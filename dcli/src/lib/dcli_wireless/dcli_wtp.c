#ifdef _D_WCPSS_
#include <string.h>
#include <zebra.h>
#include <dbus/dbus.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <unistd.h>
#include "command.h"
#include "vtysh/vtysh.h"
#include "memory.h"
#include "../dcli_main.h"
#include "wcpss/waw.h"
#include "wcpss/wid/WID.h"
#include "wid_ac.h"
#include "wid_wtp.h"
#include "dcli_wtp.h"
#include "bsd_bsd.h"
#include "dbus/wcpss/dcli_wid_wtp.h"
#include "bsd/bsdpub.h"

#include "dbus/asd/ASDDbusDef1.h"

#include "dbus/wcpss/ACDbusDef1.h"
#include "memory.h"

#include "sysdef/npd_sysdef.h"
#include <dirent.h>

//#define DCLI_GROUP 1

#define TRACE_STR "Tracing via batch ping with vary size packets"
#define BTRACE_STR "Bandwidth tracing via batch ping with vary size packets"
#define TRACE_WTP_STR "Tracing wtp via batch ping with vary size packets\n"
#define BTRACE_WTP_STR "Bandwidth tracing wtp via batch ping with vary size packets\n"

/*
 *	trace script file name 
 *	call as follows:
 *		. TRACE_SCRIPT_NAME OPTIONS TARGET_ID TARGET_IP
 *		where
 *			TRACE_SCRIPT_NAME - the script file name define here
 *			OPTIONS - script command line options which are mandatory , supported options are
 *				'-h' - with header message given , usually given out in the 1st call
 *				'-i'  - this is an option which ignored by the script
 *				'-t' - with tail message given, usually given out in the last call
 *				"-ht" - this option means only one item call with both header and tail infomation
 *			TARGET_ID - target identifier along with TARGET_IP
 *			TARGET_IP - target ip address to ping
 */
#define TRACE_SCRIPT_NAME "/usr/bin/trace_wtp.sh"

/*
 *	bandwidth trace script file name 
 *	call as follows:
 *		. BTRACE_SCRIPT_NAME OPTIONS FLAG TARGET_IP
 *		where
 *			BTRACE_SCRIPT_NAME - the script file name define here
 *			OPTIONS - script command line options which are mandatory , supported options are
 *				'-h' - with header message given , usually given out in the 1st call
 *				'-i'  - this is an option which ignored by the script
 *				'-t' - with tail message given, usually given out in the last call
 *				"-ht" - this option means only one item call with both header and tail infomation
 *			FLAG - traffic type options which are mandatory, supported options are
 *				't' - traffic test with TCP packet type
 *				'u' -traffic test with UDP packet type
 *				'b' - traffic test with both TCP and UDP packet type, which TCP traffic test first
 *			TARGET_IP - target ip address to ping
 */
#define BTRACE_SCRIPT_NAME "/usr/bin/btrace_wtp.sh"

extern int boot_flag;

/**********************************************************************************
 *  dcli_wtp_trace_script_exec
 *
 *	DESCRIPTION:
 * 		This function calls wtp trace scripts reside on file system
 *
 *	INPUT:
 *		ipAddr - ip address in ascii format which probably along with L4 port #
 *		id - identifier in ascii format which is along with ip address
 *		flag - flag indicate this is the first/middle/last call, which has the follow value:
 *			'F' or 'f' - this is the first call during the call sequence
 *			'M' or 'm' - this is the middle call during the call sequence
 *			'L' or 'l' - this is the last call during the call sequence
 *			'A' or 'a' - this option means only one item call with both header and tail infomation
 *	
 *	OUTPUT:
 *		NULL
 *
 * 	RETURN:
 *		NULL
 *		
 **********************************************************************************/
void ReInitDbusConnection(DBusConnection **dcli_dbus_connection,int slot_id,int distributFag){
	//DBusConnection *dcli_dbus_connection = NULL;
	if((distributFag)&&(dbus_connection_dcli[slot_id])&&(NULL != dbus_connection_dcli[slot_id]->dcli_dbus_connection))
	{
		*dcli_dbus_connection = dbus_connection_dcli[slot_id]->dcli_dbus_connection;
	}else{
		//*dcli_dbus_connection = dcli_dbus_connection_local;
		vty_out(vty,"the slot %d has not connected\n", slot_id);
	}
}

void dcli_wtp_trace_script_exec
(
	char * ipAddr,
	unsigned int id,
	unsigned char flag
)
{
	char command[128] = {0};

	if(!ipAddr) return;

	/* convert flag to command option */
	switch(flag) {
		default:
			return;
		case 'F':
		case 'f':
			sprintf(command,"%s -h %d %s", TRACE_SCRIPT_NAME, id, ipAddr);
			break;
		case 'M':
		case 'm':
			sprintf(command,"%s -i %d %s", TRACE_SCRIPT_NAME, id, ipAddr);
			break;
		case 'L':
		case 'l':
			sprintf(command,"%s -t %d %s", TRACE_SCRIPT_NAME, id, ipAddr);
			break;
		case 'A':
		case 'a':
			sprintf(command,"%s -ht %d %s", TRACE_SCRIPT_NAME, id, ipAddr);
			break;	
	}

	system(command);
	return;
}

/**********************************************************************************
 *  dcli_wtp_trace_script_exec
 *
 *	DESCRIPTION:
 * 		This function calls wtp trace scripts reside on file system
 *
 *	INPUT:
 *		ipAddr - ip address in ascii format which probably along with L4 port #
 *		sflag - flag indicate this is the first/middle/last call, which has the follow value:
 *			'F' or 'f' - this is the first call during the call sequence
 *			'M' or 'm' - this is the middle call during the call sequence
 *			'L' or 'l' - this is the last call during the call sequence
 *			'A' or 'a' - this option means only one item call with both header and tail infomation
 *		tflag - flag indicates traffic type, which has the follow value:
 *			'T' or 't' - traffic type TCP
 *			'U' or 'u' - traffic type UDP
 *			'B' or 'b' - traffic type both TCP and UDP
 *	
 *	OUTPUT:
 *		NULL
 *
 * 	RETURN:
 *		NULL
 *		
 **********************************************************************************/
void dcli_wtp_btrace_script_exec
(
	char * ipAddr,
	unsigned char sflag,
	unsigned char tflag
)
{
	char command[128] = {0};
	char indicator = 0;

	if(!ipAddr) return;

	/* convert tflag to command option */
	switch(tflag) {
		default:
			return;
		case 'T':
		case 't':
			indicator = 't';
			break;
		case 'U':
		case 'u':
			indicator = 'u';
			break;
		case 'B':
		case 'b':
			indicator = 'b';			
			break;
	}
	
	/* convert sflag to command option */
	switch(sflag) {
		default:
			return;
		case 'F':
		case 'f':
			sprintf(command,"%s -h %c %s", BTRACE_SCRIPT_NAME, indicator, ipAddr);
			break;
		case 'M':
		case 'm':
			sprintf(command,"%s -i %c %s", BTRACE_SCRIPT_NAME, indicator, ipAddr);
			break;
		case 'L':
		case 'l':
			sprintf(command,"%s -t %c %s", BTRACE_SCRIPT_NAME, indicator, ipAddr);
			break;
		case 'A':
		case 'a':
			sprintf(command,"%s -ht %c %s", BTRACE_SCRIPT_NAME, indicator, ipAddr);
			break;
	}

	system(command);
	return;
}
void DcliWReInit(){
	unsigned int count = 0,newlicensecount = 0;
	unsigned int flag = 0;
	int i=0;
	char WTP_COUNT_PATH_BASE[] = "/devinfo/maxwtpcount";
	char buf_base[DEFAULT_LEN];
	char strdir[DEFAULT_LEN];
	/*
	unsigned int count_oem = 0;
	char WTP_COUNT_PATH[] = "/devinfo/maxwtpcount";
	char buf[DEFAULT_LEN];
	memset(buf,0,DEFAULT_LEN);
	char WTP_COUNT_PATH_OEM[] = "/devinfo/maxwtpcount2";
	char buf_oem[DEFAULT_LEN];
	memset(buf_oem,0,DEFAULT_LEN);	
	if(read_ac_info(WTP_COUNT_PATH,buf) == 0){
		if(parse_int_ID(buf, &count)!=WID_DBUS_SUCCESS)
			return;
		else{
			if(count < WTP_NUM_AUTELAN)
				return;
			WTP_NUM_AUTELAN = count;
		}
	}else
		return;
	if(read_ac_info(WTP_COUNT_PATH_OEM,buf_oem) == 0){
		if(parse_int_ID(buf_oem, &count_oem)==-1)
			return WID_DBUS_ERROR;
		else{
			if(count < WTP_NUM_OEM)
				return WID_DBUS_ERROR;
			else{
				WTP_NUM_OEM = count_oem;
			}
		}
	}else
		return WID_DBUS_ERROR;	
	*/
	newlicensecount = get_dir_wild_file_count("/devinfo","maxwtpcount");
	
	
	if((newlicensecount >= glicensecount))
	{
		{
			/*xiaodawei modify, 20101029*/
			g_wtp_count = realloc(g_wtp_count,newlicensecount*(sizeof(LICENSE_TYPE *)));
			
			for(i=0; i<newlicensecount; i++)
			{
				if(i >= glicensecount){
					g_wtp_count[i] = malloc(sizeof(LICENSE_TYPE));
					g_wtp_count[i]->gmax_wtp_count = 0;
					g_wtp_count[i]->gcurrent_wtp_count = 0;
					g_wtp_count[i]->flag = 0;
				}
				memset(strdir,0,DEFAULT_LEN);
				memset(buf_base,0,DEFAULT_LEN); 
		
				if(i == 0)
				{
					if(read_ac_info(WTP_COUNT_PATH_BASE,buf_base) == 0)
					{
						if(parse_int_ID(buf_base, &count)==-1)
						{
							return WID_NEED_REBOOT;
						}
						if(count < g_wtp_count[i]->gmax_wtp_count)
						{
							return WID_NEED_REBOOT;
						}
						else
						{
							flag = g_wtp_count[i]->flag;
							if(flag!=0)
							{
								g_wtp_binding_count[flag]->gmax_wtp_count -= g_wtp_count[i]->gmax_wtp_count;
								g_wtp_count[i]->gmax_wtp_count = count;
								g_wtp_binding_count[flag]->gmax_wtp_count += g_wtp_count[i]->gmax_wtp_count;
							}
							else
							{
								g_wtp_count[i]->gmax_wtp_count = count;
							}
						}
					}
					else
					{
		
						return WID_NEED_REBOOT;
					}
		
				}
				else
				{
					sprintf(strdir,"/devinfo/maxwtpcount%d",i+1);
					if(read_ac_info(strdir,buf_base) == 0)
					{
						if(parse_int_ID(buf_base, &count)==-1)
						{
							return WID_NEED_REBOOT;
						}
						if(count < g_wtp_count[i]->gmax_wtp_count)
						{
							return WID_NEED_REBOOT;
						}
						else
						{
							flag = g_wtp_count[i]->flag;
							if(flag!=0)
							{
								g_wtp_binding_count[flag]->gmax_wtp_count -= g_wtp_count[i]->gmax_wtp_count;
								g_wtp_count[i]->gmax_wtp_count = count;
								g_wtp_binding_count[flag]->gmax_wtp_count += g_wtp_count[i]->gmax_wtp_count;
							}
							else
							{
								g_wtp_count[i]->gmax_wtp_count = count;
							}
						}
					}
					else
					{
						return WID_NEED_REBOOT;
					}
				}
		
				//vty_out(vty,"dcli################ maxwtp[%d] = %d\n",i,*gmax_wtp_count[i]);
			}
			#if 0
			WTP_NUM = 0;
			for(i=0; i<newlicensecount; i++)
			{
				WTP_NUM += g_wtp_count[i]->gmax_wtp_count;
			}
			#endif
		}
		glicensecount = newlicensecount; 
	}
#if 0
	WTP_NUM += 1;
	G_RADIO_NUM = WTP_NUM*L_RADIO_NUM;
	BSS_NUM = G_RADIO_NUM*L_BSS_NUM;
#endif
	return;
}

void DcliWInit(){
	int licensecount = 0;
	int i = 0;

	
	char WTP_COUNT_PATH_BASE[] = "/devinfo/maxwtpcount";
	char buf_base[DEFAULT_LEN];
	char strdir[DEFAULT_LEN];
	/*
	char WTP_COUNT_PATH[] = "/devinfo/maxwtpcount";
	char buf[DEFAULT_LEN];
	memset(buf,0,DEFAULT_LEN);
	char WTP_COUNT_PATH_OEM[] = "/devinfo/maxwtpcount2";
	char buf_oem[DEFAULT_LEN];
	memset(buf_oem,0,DEFAULT_LEN);	
	if(read_ac_info(WTP_COUNT_PATH,buf) == 0){
		if(parse_int_ID(buf, &WTP_NUM_AUTELAN)==-1)
			WTP_NUM_AUTELAN = WTP_DEFAULT_NUM_AUTELAN;
	}else
		WTP_NUM_AUTELAN = WTP_DEFAULT_NUM_AUTELAN;
	
	printf("WTP_NUM_AUTELAN %d\n",WTP_NUM_AUTELAN);

	if(read_ac_info(WTP_COUNT_PATH_OEM,buf_oem) == 0){
		if(parse_int_ID(buf_oem, &WTP_NUM_OEM)==-1)
			WTP_NUM_OEM = WTP_DEFAULT_NUM_OEM;
	}else
		WTP_NUM_OEM = WTP_DEFAULT_NUM_OEM;
	

	WTP_NUM = WTP_NUM_AUTELAN + WTP_NUM_OEM;
	*/
	glicensecount = get_dir_wild_file_count("/devinfo","maxwtpcount");
	/*xiaodawei add, 20101115, initialization for g_wtp_binding_count*/
	g_wtp_binding_count = malloc((glicensecount+1)*sizeof(LICENSE_TYPE *));
	for(i=0; i<glicensecount+1; i++){
		g_wtp_binding_count[i] = NULL;
	}
	if(glicensecount == 0)
	{
		/*xiaodawei modify, 20101029*/
		g_wtp_count = malloc(sizeof(LICENSE_TYPE *));
		g_wtp_count[0] = malloc(sizeof(LICENSE_TYPE));
		g_wtp_count[0]->gcurrent_wtp_count = 0;
		g_wtp_count[0]->gmax_wtp_count = WTP_DEFAULT_NUM_AUTELAN;
		g_wtp_count[0]->flag = 0;
		glicensecount = 1;
		/*WTP_NUM = WTP_DEFAULT_NUM_AUTELAN;*/
	}
	else
	{
		/*xiaodawei modify, 20101029*/
		g_wtp_count = malloc(glicensecount*(sizeof(LICENSE_TYPE *)));
		
		for(i=0; i<glicensecount; i++)
		{
			g_wtp_count[i] = malloc(sizeof(LICENSE_TYPE));
			g_wtp_count[i]->gmax_wtp_count = 0;
			g_wtp_count[i]->gcurrent_wtp_count = 0;
			g_wtp_count[i]->flag = 0;
			
			memset(strdir,0,DEFAULT_LEN);
			memset(buf_base,0,DEFAULT_LEN); 
	
			if(i == 0)
			{
				if(read_ac_info(WTP_COUNT_PATH_BASE,buf_base) == 0)
				{
					if(parse_int_ID(buf_base, &g_wtp_count[i]->gmax_wtp_count)==-1)
					g_wtp_count[i]->gmax_wtp_count = WTP_DEFAULT_NUM_AUTELAN;
				}
				else
				{
	
					g_wtp_count[i]->gmax_wtp_count = WTP_DEFAULT_NUM_AUTELAN;
				}
	
			}
			else
			{
				sprintf(strdir,"/devinfo/maxwtpcount%d",i+1);
				if(read_ac_info(strdir,buf_base) == 0)
				{
					if(parse_int_ID(buf_base, &g_wtp_count[i]->gmax_wtp_count)==-1)
					g_wtp_count[i]->gmax_wtp_count = WTP_DEFAULT_NUM_OEM;
				}
				else
				{
					g_wtp_count[i]->gmax_wtp_count = WTP_DEFAULT_NUM_OEM;
				}
			}
	
			//vty_out(vty,"dcli################ maxwtp[%d] = %d\n",i,*gmax_wtp_count[i]);
		}		
/*		for(i=0; i<glicensecount; i++)
		{
			WTP_NUM += g_wtp_count[i]->gmax_wtp_count;
		}
*/
	}
	
	WTP_NUM += 1;
	G_RADIO_NUM = WTP_NUM*L_RADIO_NUM;
	BSS_NUM = G_RADIO_NUM*L_BSS_NUM;
	return;
}

struct cmd_node wtp_node =
{
	WTP_NODE,
	"%s(config-wtp %d)# ",
	1
};
struct cmd_node hansi_wtp_node =
{
	HANSI_WTP_NODE,
	"%s(hansi-wtp %d-%d-%d)# ",
	1
};
struct cmd_node local_hansi_wtp_node =
{
	LOCAL_HANSI_WTP_NODE,
	"%s(local_hansi-wtp %d-%d-%d)# ",
	1
};

struct cmd_node wtp_node1 =
{
	WTP_NODE1,
	" ",
	1
};
int dcli_wtp_parse_wtp_list(char* ptr,int* count,int wtpId[])
{
	char* endPtr = NULL;
	int   i=0;
	endPtr = ptr;
	wtp_list_state state = dcli_wtp_check_wtpid;
	int tempid = 0;
	while(1)
	{
		switch(state)
		{
			
			case dcli_wtp_check_wtpid: 
									wtpId[i] = strtoul(endPtr,&endPtr,10);
									if(wtpId[i]>0&&wtpId[i]<WTP_NUM)
									{
										//printf("wtpId[%d] is %d.\n",i,wtpId[i]);//qiuchen add for test
										state=dcli_wtp_check_comma;
									}
									else
										state=dcli_wtp_check_fail;
									break;
		
			case dcli_wtp_check_comma: 
									if (WTP_LIST_SPLIT_COMMA== endPtr[0])
									{
										endPtr = (char*)endPtr + 1;
										state = dcli_wtp_check_wtpid;
										i++;
									}
									//qiuchen add to fix it
									else if(WTP_LIST_SPLIT_BAR == endPtr[0]){
										endPtr = (char*)endPtr + 1;
										tempid = strtoul(endPtr,&endPtr,10);
										
										if(tempid > 0 && tempid < 4096){
											if(tempid > wtpId[i]){
												while(i<(tempid-wtpId[i]+i)){
													wtpId[i+1] = wtpId[i]+1;
													i++;
 
												}
											}
											else{
												while(i<(wtpId[i]-tempid+i)){
													wtpId[i+1] = wtpId[i]-1; 
													i++; 
												}
											}
											if('\0' == endPtr[0]){
												//return 0;
												state = dcli_wtp_check_success;
												i++;
											}
											else{
												endPtr = (char*)endPtr + 1;
												state = dcli_wtp_check_wtpid;
											}
										}
										else
											state = dcli_wtp_check_fail;
									}
									else
										state = dcli_wtp_check_end;
									break;
				
		
			case dcli_wtp_check_fail:
									return -1;
									break;

			case dcli_wtp_check_end: 
									if ('\0' == endPtr[0]) 
									{
										state = dcli_wtp_check_success;
										i++;
									}
									else
										state = dcli_wtp_check_fail;
									break;
			
			case dcli_wtp_check_success: 
									*count = i;
									return 0;
									break;
			
			default: break;
		}
		
	}
		
}

int parse_wtpid_list(char* ptr,update_wtp_list **wtplist)
{
	char* endPtr = NULL;
	int   wtpid1 = 0;
	int   wtpid2 = 0;
	int   min = 0;
	int	  max = 0;
	endPtr = ptr;
	wtp_list_state state = dcli_wtp_check_wtpid;
	struct tag_wtpid *wtp_id = NULL;
	
	while(1)
	{
		switch(state)
		{
			
			case dcli_wtp_check_wtpid: 
									wtpid1 = strtoul(endPtr,&endPtr,10);
									if(wtpid1>0&&wtpid1<WTP_NUM)
									{
					            		state=dcli_wtp_check_comma;
									}
									else
										state=dcli_wtp_check_fail;
									break;
		
			case dcli_wtp_check_comma: 
				
									if(WTP_LIST_SPLIT_COMMA == endPtr[0])
									{
										endPtr = (char*)endPtr + 1;
										state = dcli_wtp_check_wtpid;
										//save wtpid1
										wtp_id = (struct tag_wtpid*)malloc(sizeof(struct tag_wtpid));
										wtp_id->wtpid = wtpid1;
										wtp_id->next = NULL;

										//insert to list
										wtp_id->next = (*wtplist)->wtpidlist;
										(*wtplist)->wtpidlist = wtp_id;
										(*wtplist)->count++;
																				
									}
									else if(WTP_LIST_SPLIT_BAR == endPtr[0])
									{
										endPtr = (char*)endPtr + 1;
										wtpid2 = strtoul(endPtr,&endPtr,10);
										if(wtpid2>0&&wtpid2<WTP_NUM)
										{
						            		//save wtpid1
											min = (wtpid2 > wtpid1)?wtpid1:wtpid2;
											max = (wtpid2 > wtpid1)?wtpid2:wtpid1;
											while(min <= max)
											{
												wtp_id = (struct tag_wtpid*)malloc(sizeof(struct tag_wtpid));
												wtp_id->wtpid = min;
												wtp_id->next = NULL;

												//insert to list
												wtp_id->next = (*wtplist)->wtpidlist;
												(*wtplist)->wtpidlist = wtp_id;
												(*wtplist)->count++;	
													
												min++;
											}
											if('\0' == endPtr[0])
											{
												return 0;
											}
											else
											{											
												endPtr = (char*)endPtr + 1;
												state=dcli_wtp_check_wtpid;
											}
										}
										else
										{
											state = dcli_wtp_check_fail;
										}
										
									}
									else
										state = dcli_wtp_check_end;
									break;
				
		
			case dcli_wtp_check_fail:
				
									return -1;
									break;

			case dcli_wtp_check_end: 
				
									if ('\0' == endPtr[0]) 
									{
										state = dcli_wtp_check_success;
									}
									else
										state = dcli_wtp_check_fail;
									break;
			
			case dcli_wtp_check_success: 
				
										//save wtpid1
										wtp_id = (struct tag_wtpid*)malloc(sizeof(struct tag_wtpid));
										wtp_id->wtpid = wtpid1;
										wtp_id->next = NULL;

										//insert to list
										wtp_id->next = (*wtplist)->wtpidlist;
										(*wtplist)->wtpidlist = wtp_id;
										(*wtplist)->count++;				
									return 0;
									break;
			
			default:

				break;
		}
		
	}
	
}

int get_dir_wild_file_count(char *dir, char *wildfile)
{
	DIR *dp = NULL;
	struct dirent *dirp;
	int wildfilecount = 0;

	dp = opendir(dir);
	if(dp == NULL)
	{
		return wildfilecount;
	}

	while((dirp = readdir(dp)) != NULL)
	{
		//printf("dirname = %s count = %d\n",dirp->d_name,wildfilecount);
		if((memcmp(dirp->d_name,wildfile,strlen(wildfile))) ==  0)
		{
			wildfilecount++;
			//printf("count = %d\n",wildfilecount);
		}
	}
	
	//printf("last count = %d\n",wildfilecount);
	closedir(dp);
	return wildfilecount;
	
}

/*zhaoruijia,translate  neighbor_channel_interference th*/

int parse_signedint_ID(char* str, int* ID)
{
    char c;
	int numFlag = 0;
	int i=0;
	int j=0;
	int ret = WID_DBUS_SUCCESS;
    if ((str[0]>='0'&&str[0]<='9')||(str[0]=='-'))
		{
	        i= strlen(str);
			if((1 == i)&&(str[0]!='-')){
                  numFlag = 1;
			 
			}
			else if((str[0]=='0')&&(str[1] != '\0')){
                 numFlag = 0;
		    }
			else{
			 
             for(j=1;j< i;j++){
			  if(str[j]<'0'||str[j]>'9'){
	              numFlag = 0;
				  break;
				}
			   numFlag = 1;
		      }
		    }
			
			if(numFlag)
				{
	               * ID = atoi(str);
				   numFlag = 0;
				   ret = WID_DBUS_SUCCESS;
			    }
			else
				{
	               ret=WID_UNKNOWN_ID;
			    }
	   }
	   else
	   {
             ret = WID_UNKNOWN_ID;
	   }

    return ret;


}



DEFUN(show_wtp_model_infor_cmd_func,
		show_wtp_model_infor_cmd,
		"show wtp_supported_model",
		"Show wtp model that wtp support\n"
)
{
	vty_out(vty,"radio model which you can config\n");
	vty_out(vty,"==============================================================================\n");
	vty_out(vty,"	model		radio number		radio type\n");
	vty_out(vty,"	2010		1			11a/b/g/n \n");
	/*vty_out(vty,"	2000		2			11a/b/g/n \n");
	//vty_out(vty,"	3000		3			11a/b/g/n \n");
	//vty_out(vty,"	4000		4			11a/b/g/n \n");*/
	vty_out(vty,"==============================================================================\n");
	return CMD_SUCCESS;
}


DEFUN(config_wtp_cmd_func,
	  config_wtp_cmd,
	  "config wtp WTPID",
	  CONFIG_STR
	  "wtp information\n"
	  "wtp id that you want to config\n"
	 )
{	int ret;
	unsigned int wtp_id = 0;
/*    wtp_id = atoi(argv[0]);*/
	DBusMessage *query, *reply;
	DBusError err;	
	ret = parse_int_ID((char*)argv[0], &wtp_id);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}	
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		vty_out(vty,"<error> wtp id should be 1 to %d\n",WTP_NUM-1);
		return CMD_SUCCESS;
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_WTP);
	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WTP);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_DBUS_ERR_RETRY;
	}
	
	if (dbus_message_get_args ( reply, &err,
					DBUS_TYPE_UINT32,&ret,
					DBUS_TYPE_INVALID)) {
		if(ret == 0){
			if(vty->node == CONFIG_NODE){
				vty->node = WTP_NODE;
				vty->index = (void *)wtp_id;				
			}else if(vty->node == HANSI_NODE){			
				vty->node = HANSI_WTP_NODE;
				vty->index_sub = (void *)wtp_id;				
			}else if(vty->node == LOCAL_HANSI_NODE){			
				vty->node = LOCAL_HANSI_WTP_NODE;
				vty->index_sub = (void *)wtp_id;				
			}
		}else if (ret == WTP_ID_NOT_EXIST){
			vty_out(vty,"<error> wtp id does not exist\n");
			dbus_message_unref(reply);
			return CMD_WARNING;
		}		
		else if(ret == WTP_ID_LARGE_THAN_MAX)
		{
			vty_out(vty,"<error> input wtp id should be 1 to %d\n",WTP_NUM-1);
			dbus_message_unref(reply);
			return CMD_WARNING;
		}
		else{
			vty_out(vty,"<error>  %d\n",ret);
			dbus_message_unref(reply);
			return CMD_WARNING;
		}
	}
	dbus_message_unref(reply);
	return CMD_SUCCESS;
}

DEFUN(create_wtp_cmd_func,
		create_wtp_cmd,
		"create wtp WTPID WTPNAME model&sn .MODEL&SN",
		"wireless server\n"
		"WTP service\n"
		"assign WTP ID \n"
		"assign WTP NAME\n"
		"WTP Model and SN like: AQ 2010 sn ASEU3 78966\n"
		"eg create wtp 1 wtp1 model&sn AQ 2010 sn ASEU3 78966 \n"
	)
{
	int ret,len,snlen;
	unsigned char isAdd;	
	unsigned int wtp_id = 0;
	char *name;
	char *model = NULL;
	char *sn = NULL;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	char *Apcodeflag = NULL;
	int	apcodeflag = 0;
	isAdd = 1;
/*	wtp_id = atoi(argv[0]);	*/	
	ret = parse_int_ID((char*)argv[0], &wtp_id);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}	
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		vty_out(vty,"<error> wtp id should be 1 to %d\n",WTP_NUM-1);
		return CMD_SUCCESS;
	}	
	len = strlen(argv[1]);
	if(len >= DEFAULT_LEN){		
		vty_out(vty,"<error> wtp name is too long,should be 1 to %d\n",DEFAULT_LEN-1);
		return CMD_SUCCESS;
	}	
	name = (char*)malloc(strlen(argv[1])+1);
	memset(name, 0, strlen(argv[1])+1);
	memcpy(name, argv[1], strlen(argv[1]));	
	
	model = WID_parse_CMD_str(&argv[2],argc-2,"sn",1);
	if(model == NULL){		
		free(name);
		vty_out(vty,"UNKNOWN COMMAND\n");		
		vty_out(vty,"COMMAND should be :create wtp 1 wtp1 model&sn AQ 2010 sn ASEU3 78966\n");
		return CMD_SUCCESS;
	}
//	str2higher(&model);
	Apcodeflag = WID_parse_CMD_str(&argv[2],argc-2,"flag",0)	;	
	
	if(Apcodeflag != NULL){		
		ret = parse_int_ID(Apcodeflag, &apcodeflag);	
		free(Apcodeflag);
		Apcodeflag = NULL;
		if(ret != WID_DBUS_SUCCESS){
			free(name);
			name = NULL;
			free(model);
			model = NULL;
			vty_out(vty,"<error> unknown flag format\n");
			return CMD_SUCCESS;
		}	
		sn = WID_parse_CMD_str(&argv[2],argc-4,"sn",0);	
	}else{
		sn = WID_parse_CMD_str(&argv[2],argc-2,"sn",0);	
	}
	if(sn == NULL){
		free(name);
		free(model);
		vty_out(vty,"UNKNOWN COMMAND\n");		
		vty_out(vty,"COMMAND should be :create wtp 1 wtp1 model&sn AQ 2010 sn ASEU3 78966\n");
		return CMD_SUCCESS;
	}
	/* book modify 2011-1-20 */
    snlen = strlen(sn);
    if(snlen >= NAS_IDENTIFIER_NAME){
        free(name);
		free(model);
		free(sn);
		vty_out(vty,"<error> wtp sn is too long,should be 1 to 127\n");
		return CMD_SUCCESS;
    }
    
	str2higher(&sn);
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_ADD_DEL_WTP);
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ADD_DEL_WTP);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
						DBUS_TYPE_BYTE,&isAdd,						
						DBUS_TYPE_STRING,&name,
						DBUS_TYPE_UINT32,&wtp_id,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_STRING,&model,
						DBUS_TYPE_UINT32,&apcodeflag,
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_DBUS_ERR_RETRY;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

		if(ret == 0)
			vty_out(vty,"WTP %d was successfully created.\n",wtp_id);
		else if(ret == WID_DBUS_ERROR)
			vty_out(vty,"<error> the model is wrong\n");
		else if(ret == WTP_ID_BE_USED)
			vty_out(vty,"<error> wtp id exist\n");
		else if(ret == WTP_OVER_MAX_NUM)
			vty_out(vty,"<error> create wtp count reach to max wtp count\n");
		else if(ret == WTP_SN_BE_USED)
			vty_out(vty,"<error> wtp sn exist\n");		
		else if(ret == WTP_ID_LARGE_THAN_MAX)
		{
			vty_out(vty,"<error> input wtp id should be 1 to %d\n",WTP_NUM-1);
		}
		else
			vty_out(vty,"<error>  %d\n",ret);
	dbus_message_unref(reply);
	free(name);
	free(model);
	free(sn);
	return CMD_SUCCESS;	
}

DEFUN(create_wtp_bymac_cmd_func,
		create_wtp_bymac_cmd,
		"create wtp WTPID WTPNAME model&mac .MODEL&MAC",
		"wireless server\n"
		"WTP service\n"
		"assign WTP ID \n"
		"assign WTP NAME\n"
		"WTP Model and SN like: AQ 2010 mac address \n"
		"eg create wtp 1 wtp1 model&sn AQ 2010 mac address \n"
	)
{
	int ret,len,snlen;
	unsigned char isAdd;	
	unsigned int wtp_id = 0;
	char *name;
	char *model = NULL;
	unsigned char *mac = NULL;
	char *Apcodeflag = NULL;
	int	apcodeflag = 0;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	
	unsigned char   macAddr[MAC_LEN];
	int op_ret;

	
	isAdd = 1;
/*	wtp_id = atoi(argv[0]);	*/	
	ret = parse_int_ID((char*)argv[0], &wtp_id);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}	
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		vty_out(vty,"<error> wtp id should be 1 to %d\n",WTP_NUM-1);
		return CMD_SUCCESS;
	}	
	len = strlen(argv[1]);
	if(len >= DEFAULT_LEN){		
		vty_out(vty,"<error> wtp name is too long,should be 1 to %d\n",DEFAULT_LEN-1);
		return CMD_SUCCESS;
	}	
	name = (char*)malloc(strlen(argv[1])+1);
	memset(name, 0, strlen(argv[1])+1);
	memcpy(name, argv[1], strlen(argv[1]));	
	
	model = WID_parse_CMD_str(&argv[2],argc-2,"mac",1);
	if(model == NULL){		
		free(name);
		name = NULL;
		vty_out(vty,"UNKNOWN COMMAND\n");		
		vty_out(vty,"COMMAND should be :create wtp 1 wtp1 model&mac AQ2010 mac address\n");
		return CMD_SUCCESS;
	}
//	str2higher(&model);
	Apcodeflag = WID_parse_CMD_str(&argv[2],argc-2,"flag",0)	;	
	
	if(Apcodeflag != NULL){		
		ret = parse_int_ID(Apcodeflag, &apcodeflag);	
		free(Apcodeflag);
		Apcodeflag = NULL;
		if(ret != WID_DBUS_SUCCESS){
			free(name);
			name = NULL;
			free(model);
			model = NULL;
			vty_out(vty,"<error> unknown flag format\n");
			return CMD_SUCCESS;
		}	
		mac = WID_parse_CMD_str(&argv[2],argc-4,"mac",0);	
	}else{
		mac = WID_parse_CMD_str(&argv[2],argc-2,"mac",0);	
	}
	
	if(mac == NULL){
		free(name);
		name = NULL;
		free(model);
		model = NULL;
		vty_out(vty,"UNKNOWN COMMAND\n");		
		vty_out(vty,"COMMAND should be :create wtp 1 wtp1 model&mac AQ2010 mac address\n");
		return CMD_SUCCESS;
	}


	memset(&macAddr,0,sizeof(macAddr));
	
	op_ret = wid_parse_mac_addr(mac,&macAddr);
	if (NPD_FAIL == op_ret) {
		free(name);
		name = NULL;
		free(model);
		model = NULL;
		free(mac);
		mac = NULL;
    	vty_out(vty,"% Bad Parameter,Unknow mac addr format!\n");
		return CMD_WARNING;
	}
   
	op_ret=is_muti_brc_mac(&macAddr);
	if(op_ret==1){
		free(name);
		name = NULL;
		free(model);
		model = NULL;
		free(mac);
		vty_out(vty,"%% Erro:input should not be broadcast or multicast mac!\n");
		return CMD_WARNING;
	}	

	/*//printf("mac:%02x:%02x:%02x:%02x:%02x:%02x\n",macAddr[0],macAddr[1],macAddr[2],macAddr[3],macAddr[4],macAddr[5]);
	////printf("mac:%s\n",mac);*/
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_ADD_DEL_WTP_BY_MAC);
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ADD_DEL_WTP_BY_MAC);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
						DBUS_TYPE_BYTE,&isAdd,						
						DBUS_TYPE_STRING,&name,
						DBUS_TYPE_UINT32,&wtp_id,
						DBUS_TYPE_BYTE,&macAddr[0],
					 	DBUS_TYPE_BYTE,&macAddr[1],
					 	DBUS_TYPE_BYTE,&macAddr[2],
					 	DBUS_TYPE_BYTE,&macAddr[3],
					 	DBUS_TYPE_BYTE,&macAddr[4],
					 	DBUS_TYPE_BYTE,&macAddr[5],
						DBUS_TYPE_STRING,&model,
						DBUS_TYPE_UINT32,&apcodeflag,
						DBUS_TYPE_UINT32,&boot_flag,
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		free(name);
		name = NULL;
		free(model);
		model = NULL;
		free(mac);
		mac = NULL;
		return CMD_DBUS_ERR_RETRY;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

		if(ret == 0)
			vty_out(vty,"WTP %d was successfully created.\n",wtp_id);
		else if(ret == WID_DBUS_ERROR)
			vty_out(vty,"<error> the model is wrong\n");
		else if(ret == WTP_ID_BE_USED)
			vty_out(vty,"<error> wtp id exist\n");
		else if(ret == WTP_OVER_MAX_NUM)
			vty_out(vty,"<error> create wtp count reach to max wtp count\n");
		else if(ret == WTP_MAC_BE_USED){
			if(boot_flag == 1){
				vty_out(vty,"<warning>WTP %d was successfully created.\n",wtp_id);
				dbus_message_unref(reply);
				free(name);
				name = NULL;
				free(model);
				model = NULL;
				free(mac);
				mac = NULL;
				return CMD_WARNING;
			}else{
				vty_out(vty,"<error> wtp mac exist\n"); 	
			}
		}
		else if(ret == WTP_ID_LARGE_THAN_MAX)
		{
			vty_out(vty,"<error> input wtp id should be 1 to %d\n",WTP_NUM-1);
		}
		else
			vty_out(vty,"<error>  %d\n",ret);
	dbus_message_unref(reply);
	
	free(name);
	name = NULL;
	free(model);
	model = NULL;
	free(mac);
	mac = NULL;

	return CMD_SUCCESS;	
}


#if 0
DEFUN(create_wtp_cmd_func,
		create_wtp_cmd,
		"create wtp WTPID WTPNAME model&sn .MODEL&SN",
		"wireless server\n"
		"WTP service\n"
		"assign WTP ID \n"
		"assign WTP NAME\n"
		"WTP Model and SN like: AQ 2010 sn ASEU3 78966\n"
		"eg create wtp 1 wtp1 model&sn AQ 2010 sn ASEU3 78966 \n"
	)
{
	int ret,len,snlen;
	unsigned char isAdd;	
	unsigned int wtp_id = 0;
	char *name;
	char *model = NULL;
	char *sn = NULL;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	isAdd = 1;
/*	wtp_id = atoi(argv[0]);	*/	
	ret = parse_int_ID((char*)argv[0], &wtp_id);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}	
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		vty_out(vty,"<error> wtp id should be 1 to %d\n",WTP_NUM-1);
		return CMD_SUCCESS;
	}	
	len = strlen(argv[1]);
	if(len >= DEFAULT_LEN){		
		vty_out(vty,"<error> wtp name is too long,should be 1 to %d\n",DEFAULT_LEN-1);
		return CMD_SUCCESS;
	}	
	name = (char*)malloc(strlen(argv[1])+1);
	memset(name, 0, strlen(argv[1])+1);
	memcpy(name, argv[1], strlen(argv[1]));	
	
	model = WID_parse_CMD_str(&argv[2],argc-2,"sn",1);
	if(model == NULL){		
		free(name);
		vty_out(vty,"UNKNOWN COMMAND\n");		
		vty_out(vty,"COMMAND should be :create wtp 1 wtp1 model&sn AQ 2010 sn ASEU3 78966\n");
		return CMD_SUCCESS;
	}
//	str2higher(&model);
	sn = WID_parse_CMD_str(&argv[2],argc-2,"sn",0)	;	
	if(sn == NULL){
		free(name);
		free(model);
		vty_out(vty,"UNKNOWN COMMAND\n");		
		vty_out(vty,"COMMAND should be :create wtp 1 wtp1 model&sn AQ 2010 sn ASEU3 78966\n");
		return CMD_SUCCESS;
	}
	str2higher(&sn);
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
	}
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_ADD_DEL_WTP);
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ADD_DEL_WTP);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
						DBUS_TYPE_BYTE,&isAdd,						
						DBUS_TYPE_STRING,&name,
						DBUS_TYPE_UINT32,&wtp_id,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_STRING,&model,
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

		if(ret == 0)
			vty_out(vty,"WTP %d was successfully created.\n",wtp_id);
		else if(ret == WID_DBUS_ERROR)
			vty_out(vty,"<error> the model is wrong\n");
		else if(ret == WTP_ID_BE_USED)
			vty_out(vty,"<error> wtp id exist\n");
		else if(ret == WTP_OVER_MAX_NUM)
			vty_out(vty,"<error> create wtp count reach to max wtp count\n");
		else if(ret == WTP_SN_BE_USED)
			vty_out(vty,"<error> wtp sn exist\n");		
		else if(ret == WTP_ID_LARGE_THAN_MAX)
		{
			vty_out(vty,"<error> input wtp id should be 1 to %d\n",WTP_NUM-1);
		}
		else
			vty_out(vty,"<error>  %d\n",ret);
	dbus_message_unref(reply);
	free(name);
	free(model);
	free(sn);
	return CMD_SUCCESS;	
}

DEFUN(create_wtp_bymac_cmd_func,
		create_wtp_bymac_cmd,
		"create wtp WTPID WTPNAME model&mac .MODEL&MAC",
		"wireless server\n"
		"WTP service\n"
		"assign WTP ID \n"
		"assign WTP NAME\n"
		"WTP Model and SN like: AQ 2010 mac address \n"
		"eg create wtp 1 wtp1 model&sn AQ 2010 mac address \n"
	)
{
	int ret,len,snlen;
	unsigned char isAdd;	
	unsigned int wtp_id = 0;
	char *name;
	char *model = NULL;
	unsigned char *mac = NULL;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	
	unsigned char   macAddr[MAC_LEN];
	int op_ret;

	
	isAdd = 1;
/*	wtp_id = atoi(argv[0]);	*/	
	ret = parse_int_ID((char*)argv[0], &wtp_id);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}	
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		vty_out(vty,"<error> wtp id should be 1 to %d\n",WTP_NUM-1);
		return CMD_SUCCESS;
	}	
	len = strlen(argv[1]);
	if(len >= DEFAULT_LEN){		
		vty_out(vty,"<error> wtp name is too long,should be 1 to %d\n",DEFAULT_LEN-1);
		return CMD_SUCCESS;
	}	
	name = (char*)malloc(strlen(argv[1])+1);
	memset(name, 0, strlen(argv[1])+1);
	memcpy(name, argv[1], strlen(argv[1]));	
	
	model = WID_parse_CMD_str(&argv[2],argc-2,"mac",1);
	if(model == NULL){		
		free(name);
		vty_out(vty,"UNKNOWN COMMAND\n");		
		vty_out(vty,"COMMAND should be :create wtp 1 wtp1 model&sn AQ 2010 mac address\n");
		return CMD_SUCCESS;
	}
//	str2higher(&model);
	mac = WID_parse_CMD_str(&argv[2],argc-2,"mac",0)	;	
	
	if(mac == NULL){
		free(name);
		free(model);
		vty_out(vty,"UNKNOWN COMMAND\n");		
		vty_out(vty,"COMMAND should be :create wtp 1 wtp1 model&sn AQ 2010 mac address\n");
		return CMD_SUCCESS;
	}


	memset(&macAddr,0,sizeof(macAddr));
	
	op_ret = parse_mac_addr(mac,&macAddr);
	if (NPD_FAIL == op_ret) {
		free(name);
		name = NULL;
		free(model);
		model = NULL;
		free(mac);
		mac = NULL;
    	vty_out(vty,"% Bad Parameter,Unknow mac addr format!\n");
		return CMD_WARNING;
	}
   
	op_ret=is_muti_brc_mac(&macAddr);
	if(op_ret==1){
		free(name);
		name = NULL;
		free(model);
		model = NULL;
		free(mac);
		vty_out(vty,"%% Erro:input should not be broadcast or multicast mac!\n");
		return CMD_WARNING;
	}	

	/*//printf("mac:%02x:%02x:%02x:%02x:%02x:%02x\n",macAddr[0],macAddr[1],macAddr[2],macAddr[3],macAddr[4],macAddr[5]);
	////printf("mac:%s\n",mac);*/
		
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
	}
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_ADD_DEL_WTP_BY_MAC);
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ADD_DEL_WTP_BY_MAC);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
						DBUS_TYPE_BYTE,&isAdd,						
						DBUS_TYPE_STRING,&name,
						DBUS_TYPE_UINT32,&wtp_id,
						DBUS_TYPE_BYTE,&macAddr[0],
					 	DBUS_TYPE_BYTE,&macAddr[1],
					 	DBUS_TYPE_BYTE,&macAddr[2],
					 	DBUS_TYPE_BYTE,&macAddr[3],
					 	DBUS_TYPE_BYTE,&macAddr[4],
					 	DBUS_TYPE_BYTE,&macAddr[5],
						DBUS_TYPE_STRING,&model,
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		free(name);
		name = NULL;
		free(model);
		model = NULL;
		free(mac);
		mac = NULL;
		return CMD_SUCCESS;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

		if(ret == 0)
			vty_out(vty,"WTP %d was successfully created.\n",wtp_id);
		else if(ret == WID_DBUS_ERROR)
			vty_out(vty,"<error> the model is wrong\n");
		else if(ret == WTP_ID_BE_USED)
			vty_out(vty,"<error> wtp id exist\n");
		else if(ret == WTP_OVER_MAX_NUM)
			vty_out(vty,"<error> create wtp count reach to max wtp count\n");
		else if(ret == WTP_MAC_BE_USED)
			vty_out(vty,"<error> wtp mac exist\n");		
		else if(ret == WTP_ID_LARGE_THAN_MAX)
		{
			vty_out(vty,"<error> input wtp id should be 1 to %d\n",WTP_NUM-1);
		}
		else
			vty_out(vty,"<error>  %d\n",ret);
	dbus_message_unref(reply);
	
	free(name);
	name = NULL;
	free(model);
	model = NULL;
	free(mac);
	mac = NULL;

	return CMD_SUCCESS;	
}
#endif

DEFUN(delete_wtp_cmd_func,
		delete_wtp_cmd,
		"delete wtp WTPID",
		"wireless server\n"
		"WTP service\n"
		"assign WTP ID \n"
	)
{
	int ret;
	unsigned char isAdd;	
	unsigned int wtp_id = 0;
	char *name;
	char *model = NULL;
	char *sn = NULL;
	int apcodeflag = 0;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	isAdd = 0;		
/*	wtp_id = atoi(argv[0]);*/	
	ret = parse_int_ID((char*)argv[0], &wtp_id);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}	

	if(wtp_id >= WTP_NUM || wtp_id == 0){
		vty_out(vty,"<error> wtp id should be 1 to %d\n",WTP_NUM-1);
		return CMD_SUCCESS;
	}
	name = (char*)malloc(1);
	memset(name, 0, 1);
	
	model = (char*)malloc(1);
	memset(model, 0, 1);

	sn = (char*)malloc(1);
	memset(sn, 0, 1);
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_ADD_DEL_WTP);
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ADD_DEL_WTP);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
						DBUS_TYPE_BYTE,&isAdd,						
						DBUS_TYPE_STRING,&name,
						DBUS_TYPE_UINT32,&wtp_id,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_STRING,&model,						
						DBUS_TYPE_UINT32,&apcodeflag,
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);

	free(name);
	name = NULL;
	free(sn);
	sn = NULL;
	free(model);
	model = NULL;
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

		if(ret == 0){
			vty_out(vty,"WTP %d was successfully deleted.\n",wtp_id);
		}
		else if(ret == WTP_ID_NOT_EXIST)
			vty_out(vty,"<error> wtp id does not exist\n");
		else if(ret == WTP_ID_BE_USED)
			vty_out(vty,"<error> wtp %d is used, please unused it first\n",wtp_id);
		else if(ret == WTP_ID_LARGE_THAN_MAX)
		{
			vty_out(vty,"<error> input wtp id should be 1 to %d\n",WTP_NUM-1);
		}
		else if(ret == RADIO_IN_EBR) //fengwenchao add 20111221 for ISSUES-850
			vty_out(vty,"<error> input wtp has some radios interface in ebr,please delete it first!\n");
		else
			vty_out(vty,"<error>  %d\n",ret);
	dbus_message_unref(reply);
	free(name);
	free(sn);
	return CMD_SUCCESS;	
}


DEFUN(show_wtp_cmd_func,
	  show_wtp_cmd,
	  "show wtp WTPID [remote] [local] [PARAMETER]",
	  CONFIG_STR
	  "WTP information\n"
	  "WTP id that you want to config\n"
	  "'remote' or 'local' hansi\n"
	  "'remote' or 'local' hansi\n"
	  "slotid-instid\n"
	 )
{	int ret,i;
	unsigned int wtp_id = 0;
	unsigned char a0,a1,a2,a3,a4,a5,num;
	unsigned char bwlannum = 0;/*20080711*/
	unsigned char wlanid[WLAN_NUM] = {0}; /*should make */
	char *name;
    char state[WTP_ARRAY_NAME_LEN];
	char quitreason[WTP_ARRAY_NAME_LEN];
	char dis[] = "disable";
	char en[] = "enable";
	char on[] = "used";
	char off[] = "unused";
	int profile = 0;
	int instRun = 0;
	int flag = 0;
	
	DCLI_WTP_API_GROUP_ONE *WTPINFO = NULL;
	ret = parse_int_ID((char*)argv[0], &wtp_id);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}	
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		vty_out(vty,"<error> wtp id should be 1 to %d\n",WTP_NUM-1);
		return CMD_SUCCESS;
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if((vty->node == CONFIG_NODE)||(vty->node == ENABLE_NODE)){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node== LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	
	if((argc == 2)||(argc == 4)){
		vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
		return CMD_SUCCESS;
	}
	if(argc == 3){
		if (!strcmp(argv[1],"remote")){
			localid = 0;
		}else if(!strcmp(argv[1],"local")){
			localid = 1;
		}else{
			vty_out(vty,"parameter should be 'remote' or 'local'\n");
			return CMD_SUCCESS;
		}
		
		if((!strcmp(argv[1],"remote"))&&(!strcmp(argv[2],"local"))){
			vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
			return CMD_SUCCESS;
		}
		
		ret = parse_slot_hansi_id((char*)argv[2],&slot_id,&profile);
		if(ret != WID_DBUS_SUCCESS){
			slot_id = HostSlotId;
			flag = 1;
			ret = parse_int_ID((char*)argv[2], &profile);
			if(ret != WID_DBUS_SUCCESS){
				if(ret == WID_ILLEGAL_INPUT){
					vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
				}
				else{
					vty_out(vty,"<error> unknown id format\n");
				}
				return CMD_WARNING;
			}	
		}
		if(distributFag == 0){
			if(slot_id != 0){
				vty_out(vty,"<error> slot id should be 0\n");
				return CMD_WARNING;
			}	
		}else if(flag == 1){
			slot_id = HostSlotId;
		}
		if(slot_id >= MAX_SLOT_NUM || slot_id < 0){
			vty_out(vty,"<error> slot id should be 1 to %d\n",MAX_SLOT_NUM-1);
			return CMD_WARNING;
		}	
		if(profile >= MAX_INSTANCE || profile == 0){
			vty_out(vty,"<error> hansi id should be 1 to %d\n",MAX_INSTANCE-1);
			return CMD_WARNING;
		}
		instRun = dcli_hmd_hansi_is_running(vty,slot_id,localid,profile);
		if (INSTANCE_NO_CREATED == instRun) {
			vty_out(vty,"<error> the instance %s %d-%d is not running\n",((localid == 1)?"local-hansi":"hansi"),slot_id,profile);
			return CMD_WARNING;
		}
		
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		if(localid == 0)
			goto hansi_parameter;
		else if(localid == 1)
			goto local_hansi_parameter; 
	}
#if 0	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SHOWWTP);
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOWWTP);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0 ){	

		WTP = (WID_WTP*)malloc(sizeof(WID_WTP));
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->wtp_triger_num));/*xm*/

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->wtp_flow_triger));/*xm*/
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->wtp_allowed_max_sta_num));/*xm*/
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->WTPID));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->WTPSN));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->WTPNAME));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->WTPModel));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->RadioCount));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->WTPStat));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->WTPIP));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->WFR_Index));	
				
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(a0));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(a1));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(a2));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(a3));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(a4));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(a5));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->CTR_ID));
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->DAT_ID));	

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->sysver));	

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->ver));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->updatepath));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->updateversion));			
	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&name);	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->isused));	
		
		/*added by weiay 20081011*/
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->quitreason));	

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(bwlannum));	

		dbus_message_iter_next(&iter);	
		dbus_message_iter_recurse(&iter,&iter_array);

		for (i = 0; i < bwlannum; i++)
		{
			DBusMessageIter iter_struct;
			dbus_message_iter_recurse(&iter_array,&iter_struct);
						
			dbus_message_iter_get_basic(&iter_struct,&wlanid[i]);
					
			dbus_message_iter_next(&iter_array);

		}
		
		/*added end*/

		dbus_message_iter_next(&iter);			
		dbus_message_iter_get_basic(&iter,&num);	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_recurse(&iter,&iter_array);
		
		for (i = 0; i < num; i++) {
			DBusMessageIter iter_struct;
			
			radio[i] = (WID_WTP_RADIO*)malloc(sizeof(WID_WTP_RADIO));
			
			dbus_message_iter_recurse(&iter_array,&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(radio[i]->Radio_L_ID));
		
			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&(radio[i]->Radio_G_ID));
		
			dbus_message_iter_next(&iter_struct);
	
			dbus_message_iter_get_basic(&iter_struct,&(radio[i]->Radio_Type));
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(radio[i]->Radio_Chan));
					
			dbus_message_iter_next(&iter_struct);
					
			dbus_message_iter_get_basic(&iter_struct,&(radio[i]->Radio_TXP));

			dbus_message_iter_next(&iter_array);
		}
	}
	
	dbus_message_unref(reply);
#endif
	if(vty->node != VIEW_NODE){
		 WTPINFO = dcli_wtp_show_api_group_one(
			index,
			FIRST,
			wtp_id,
			0,
			0,
			0,/**/
			&ret,/*num2*/
			0,
			num,
			0,
			&localid,//num6
		//	WTPINFO,
			dcli_dbus_connection,
			WID_DBUS_CONF_METHOD_SHOWWTP
			);
		//printf("##########ret is %d\n",ret);
		if(ret == -1){
			cli_syslog_info("<error> failed get reply.\n");
		}
		else if(ret == 0){
			vty_out(vty,"==============================================================================\n");
			CheckWTPState(state,WTPINFO->WTP[0]->WTPStat);
			CheckWTPQuitReason(quitreason,WTPINFO->WTP[0]->quitreason);
			vty_out(vty,"WTP NAME : %s\n",WTPINFO->WTP[0]->WTPNAME);
			vty_out(vty,"WTP ID : %d\n",WTPINFO->WTP[0]->WTPID);
			vty_out(vty,"WTP SN : %s\n",WTPINFO->WTP[0]->WTPSN);
			vty_out(vty,"WTP MODEL : %s\n",WTPINFO->WTP[0]->WTPModel);			
			vty_out(vty,"Radio Count : %d\n",WTPINFO->WTP[0]->RadioCount);
			vty_out(vty,"WTP RUN STATE : %s\n",state);	
			if(7 == WTPINFO->WTP[0]->WTPStat)
			{
				vty_out(vty,"WTP QUIT REASON : %s\n",quitreason);
			}
			vty_out(vty,"WTP STATE: %s\n",(WTPINFO->WTP[0]->isused == 1)?on:off);
			vty_out(vty,"WTP IP : %s\n",WTPINFO->WTP[0]->WTPIP);
			vty_out(vty,"WTP MAC : %02X:",WTPINFO->WTP[0]->WTPMAC[0]);
			vty_out(vty,"%02X:",WTPINFO->WTP[0]->WTPMAC[1]);
			vty_out(vty,"%02X:",WTPINFO->WTP[0]->WTPMAC[2]);
			vty_out(vty,"%02X:",WTPINFO->WTP[0]->WTPMAC[3]);
			vty_out(vty,"%02X:",WTPINFO->WTP[0]->WTPMAC[4]);
			vty_out(vty,"%02X\n",WTPINFO->WTP[0]->WTPMAC[5]);
			vty_out(vty,"WTP MAX STA NUM : %d\n",WTPINFO->WTP[0]->wtp_allowed_max_sta_num);
			vty_out(vty,"WTP NUMBER TRIGER  : %d\n",WTPINFO->WTP[0]->wtp_triger_num);
			vty_out(vty,"WTP FLOW TRIGER  : %d\n",WTPINFO->WTP[0]->wtp_flow_triger);
			vty_out(vty,"First GLOBAL RadioID : %d\n",WTPINFO->WTP[0]->WFR_Index);			
			vty_out(vty,"Control Tunnel ID : %d\n",WTPINFO->WTP[0]->CTR_ID);
			vty_out(vty,"DATA Tunnel ID: %d\n",WTPINFO->WTP[0]->DAT_ID);
			vty_out(vty,"WTP HardWare Version: %s\n",WTPINFO->WTP[0]->sysver);
			vty_out(vty,"WTP SoftWare Version: %s\n",WTPINFO->WTP[0]->ver);
			vty_out(vty,"WTP Update img: %s\n",WTPINFO->WTP[0]->updatepath);
			vty_out(vty,"WTP Update Version: %s\n",WTPINFO->WTP[0]->updateversion);
			vty_out(vty,"Apply interface: %s\n",WTPINFO->WTP[0]->apply_interface_name);
			vty_out(vty,"WTP total receive flow byte: %lld\n",WTPINFO->WTP[0]->rx_bytes);
			vty_out(vty,"WTP total traffic flow byte: %lld\n",WTPINFO->WTP[0]->tx_bytes);
			vty_out(vty,"ap apstatistics interval: %u\n",WTPINFO->WTP[0]->apstatisticsinterval);
			/*added by weiay 20080711*/
			vty_out(vty,"WTP apply wlan id: ");
			for (i = 0; i < WTPINFO->WTP[0]->apply_wlan_num; i++)
			{	//wlanid *head = NULL;
			//	if(WTPINFO->WTP->wlanid != NULL){
			//		head = WTPINFO->WTP->wlanid;
					vty_out(vty,"%d  ",WTPINFO->WTP[0]->apply_wlanid[i]);
			//		head = head->next;
			//	}
			}
			//free(WTPINFO->WTP->Wlan_Id);
		//	CW_FREE_OBJECT(WTPINFO->WTP->Wlan_Id);
			if(i == 0)
			{
				vty_out(vty,"NONE\n");
			}
			else
			{
				vty_out(vty,"\n");
			}
			/*added by weiay*/
			
			vty_out(vty,"WTP %d Radio summary\n",wtp_id);
			vty_out(vty,"==============================================================================\n");
			vty_out(vty,"RadioNum	RadioID		Channel		TX Power	Radio Type\n");
	//printf("num  is %d\n",WTPINFO->WTP[0]->radio_num);
			for(i = 0; i < WTPINFO->WTP[0]->radio_num; i++){
				if(WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Chan == 0){
						if((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_TXP == 0)||(WTPINFO->WTP[0]->WTP_Radio[i]->Radio_TXP == 100))     //fengwenchao add 20110427
						{
							vty_out(vty,"%d		%d		auto	        auto		",WTPINFO->WTP[0]->WTP_Radio[i]->Radio_L_ID,WTPINFO->WTP[0]->WTP_Radio[i]->Radio_G_ID);
						}
						else
						{
							vty_out(vty,"%d		%d		auto	        %d		",WTPINFO->WTP[0]->WTP_Radio[i]->Radio_L_ID,WTPINFO->WTP[0]->WTP_Radio[i]->Radio_G_ID,WTPINFO->WTP[0]->WTP_Radio[i]->Radio_TXP);								
						}				
	//printf("1111111122222222222222222\n");
					}
				else {
					 	if((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_TXP == 0)||(WTPINFO->WTP[0]->WTP_Radio[i]->Radio_TXP == 100))     //fengwenchao add 20110427
					 	{
							vty_out(vty,"%d		%d		%d		auto		",WTPINFO->WTP[0]->WTP_Radio[i]->Radio_L_ID,WTPINFO->WTP[0]->WTP_Radio[i]->Radio_G_ID,WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Chan);
						}
						else
						{
							vty_out(vty,"%d		%d		%d		%d		",WTPINFO->WTP[0]->WTP_Radio[i]->Radio_L_ID,WTPINFO->WTP[0]->WTP_Radio[i]->Radio_G_ID,WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Chan,WTPINFO->WTP[0]->WTP_Radio[i]->Radio_TXP);
						}							
	//printf("111111111133333333333333333333\n");
					}
				/*vty_out(vty,"%d		%d		%d		%d		",radio[i]->Radio_L_ID,radio[i]->Radio_G_ID,radio[i]->Radio_Chan,radio[i]->Radio_TXP);	*/		
	//printf("111111111114444444444444444444\n");
				vty_out(vty,"11");
				/*fengwenchao modify begin 20111109 for GM*/
				int flag_an = 0;int flag_gn = 0;
				if(((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11A) > 0)
					&&((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11N) > 0)
					&&((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11AN) > 0)
					&&(!(WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11B))
					&&(!(WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11G)))
				{
					vty_out(vty,"a/an");
				}
				else if(((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11GN) > 0)
					&&((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11N)> 0)
					&&((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11G)>0)
					&&(!(WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11B))
					&&(!(WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11A)))
				{	
					vty_out(vty,"g/gn");
				}			
				else
				{
					if((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11A) > 0)
						vty_out(vty,"a");
					if((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11B) > 0)
						vty_out(vty,"b");
					if((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11G) > 0)
						vty_out(vty,"g");		
					if((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11N) > 0)
						vty_out(vty,"n");	
				}
				/*fengwenchao modify end*/			
				vty_out(vty,"\n");
	//printf("11111111111111111111111\n");
				free(WTPINFO->WTP[0]->WTP_Radio[i]);
				WTPINFO->WTP[0]->WTP_Radio[i] = NULL ;
	//printf("22222222222222222222222221\n");
			}
			vty_out(vty,"==============================================================================\n");
			//CW_FREE_OBJECT(WTPINFO->WTP[0]->WTPMAC);
			dcli_wtp_free_fun(WID_DBUS_CONF_METHOD_SHOWWTP,WTPINFO);
		}
		else if(ret == WTP_ID_NOT_EXIST){
			vty_out(vty,"<error> wtp id does not exist\n");
		}
		else if(ret == WTP_ID_LARGE_THAN_MAX)
		{
			vty_out(vty,"<error> input wtp id should be 1 to %d\n",WTP_NUM-1);
		}
		else 
			vty_out(vty,"<error>  %d\n",ret);
		//CW_FREE_OBJECT(WTPINFO->WTP[0]);
		//CW_FREE_OBJECT(WTPINFO->WTP);
		//CW_FREE_OBJECT(WTPINFO);
	}
	
	if(vty->node == VIEW_NODE){
		//for remote hansi info
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 0;
			
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,0,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}

		hansi_parameter:
				 WTPINFO = dcli_wtp_show_api_group_one(
					profile,
					FIRST,
					wtp_id,
					0,
					0,
					0,/**/
					&ret,/*num2*/
					0,
					num,
					0,
					&localid,//num6
					dcli_dbus_connection,
					WID_DBUS_CONF_METHOD_SHOWWTP
					);
				 vty_out(vty,"==============================================================================\n");
				 vty_out(vty,"hansi %d-%d\n",slot_id,profile);
				if(ret == -1){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == 0){
					vty_out(vty,"------------------------------------------------------------------------------\n");
					CheckWTPState(state,WTPINFO->WTP[0]->WTPStat);
					CheckWTPQuitReason(quitreason,WTPINFO->WTP[0]->quitreason);
					vty_out(vty,"WTP NAME : %s\n",WTPINFO->WTP[0]->WTPNAME);
					vty_out(vty,"WTP ID : %d\n",WTPINFO->WTP[0]->WTPID);
					vty_out(vty,"WTP SN : %s\n",WTPINFO->WTP[0]->WTPSN);
					vty_out(vty,"WTP MODEL : %s\n",WTPINFO->WTP[0]->WTPModel);			
					vty_out(vty,"Radio Count : %d\n",WTPINFO->WTP[0]->RadioCount);
					vty_out(vty,"WTP RUN STATE : %s\n",state);	
					if(7 == WTPINFO->WTP[0]->WTPStat)
					{
						vty_out(vty,"WTP QUIT REASON : %s\n",quitreason);
					}
					vty_out(vty,"WTP STATE: %s\n",(WTPINFO->WTP[0]->isused == 1)?on:off);
					vty_out(vty,"WTP IP : %s\n",WTPINFO->WTP[0]->WTPIP);
					vty_out(vty,"WTP MAC : %02X:",WTPINFO->WTP[0]->WTPMAC[0]);
					vty_out(vty,"%02X:",WTPINFO->WTP[0]->WTPMAC[1]);
					vty_out(vty,"%02X:",WTPINFO->WTP[0]->WTPMAC[2]);
					vty_out(vty,"%02X:",WTPINFO->WTP[0]->WTPMAC[3]);
					vty_out(vty,"%02X:",WTPINFO->WTP[0]->WTPMAC[4]);
					vty_out(vty,"%02X\n",WTPINFO->WTP[0]->WTPMAC[5]);
					vty_out(vty,"WTP MAX STA NUM : %d\n",WTPINFO->WTP[0]->wtp_allowed_max_sta_num);
					vty_out(vty,"WTP NUMBER TRIGER	: %d\n",WTPINFO->WTP[0]->wtp_triger_num);
					vty_out(vty,"WTP FLOW TRIGER  : %d\n",WTPINFO->WTP[0]->wtp_flow_triger);
					vty_out(vty,"First GLOBAL RadioID : %d\n",WTPINFO->WTP[0]->WFR_Index);			
					vty_out(vty,"Control Tunnel ID : %d\n",WTPINFO->WTP[0]->CTR_ID);
					vty_out(vty,"DATA Tunnel ID: %d\n",WTPINFO->WTP[0]->DAT_ID);
					vty_out(vty,"WTP HardWare Version: %s\n",WTPINFO->WTP[0]->sysver);
					vty_out(vty,"WTP SoftWare Version: %s\n",WTPINFO->WTP[0]->ver);
					vty_out(vty,"WTP Update img: %s\n",WTPINFO->WTP[0]->updatepath);
					vty_out(vty,"WTP Update Version: %s\n",WTPINFO->WTP[0]->updateversion);
					vty_out(vty,"Apply interface: %s\n",WTPINFO->WTP[0]->apply_interface_name);
					vty_out(vty,"WTP total receive flow byte: %lld\n",WTPINFO->WTP[0]->rx_bytes);
					vty_out(vty,"WTP total traffic flow byte: %lld\n",WTPINFO->WTP[0]->tx_bytes);
					vty_out(vty,"ap apstatistics interval: %u\n",WTPINFO->WTP[0]->apstatisticsinterval);
					/*added by weiay 20080711*/
					vty_out(vty,"WTP apply wlan id: ");
					for (i = 0; i < WTPINFO->WTP[0]->apply_wlan_num; i++)
					{
							vty_out(vty,"%d  ",WTPINFO->WTP[0]->apply_wlanid[i]);
					}
					if(i == 0)
					{
						vty_out(vty,"NONE\n");
					}
					else
					{
						vty_out(vty,"\n");
					}
					/*added by weiay*/
					
					vty_out(vty,"WTP %d Radio summary\n",wtp_id);
					vty_out(vty,"------------------------------------------------------------------------------\n");
					vty_out(vty,"RadioNum	RadioID 	Channel 	TX Power	Radio Type\n");
					for(i = 0; i < WTPINFO->WTP[0]->radio_num; i++){
						if(WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Chan == 0){
								if((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_TXP == 0)||(WTPINFO->WTP[0]->WTP_Radio[i]->Radio_TXP == 100))	   //fengwenchao add 20110427
								{
									vty_out(vty,"%d		 %d		auto		auto		",WTPINFO->WTP[0]->WTP_Radio[i]->Radio_L_ID,WTPINFO->WTP[0]->WTP_Radio[i]->Radio_G_ID);
								}
								else
								{
									vty_out(vty,"%d	 	%d		auto		%d		",WTPINFO->WTP[0]->WTP_Radio[i]->Radio_L_ID,WTPINFO->WTP[0]->WTP_Radio[i]->Radio_G_ID,WTPINFO->WTP[0]->WTP_Radio[i]->Radio_TXP);								
								}				
							}
						else {
								if((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_TXP == 0)||(WTPINFO->WTP[0]->WTP_Radio[i]->Radio_TXP == 100))	   //fengwenchao add 20110427
								{
									vty_out(vty,"%d	 	%d		%d		auto		",WTPINFO->WTP[0]->WTP_Radio[i]->Radio_L_ID,WTPINFO->WTP[0]->WTP_Radio[i]->Radio_G_ID,WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Chan);
								}
								else
								{
									vty_out(vty,"%d	 	%d		%d		%d		",WTPINFO->WTP[0]->WTP_Radio[i]->Radio_L_ID,WTPINFO->WTP[0]->WTP_Radio[i]->Radio_G_ID,WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Chan,WTPINFO->WTP[0]->WTP_Radio[i]->Radio_TXP);
								}							
							}
						vty_out(vty,"11");
						/*fengwenchao modify begin 20111109 for GM*/
						int flag_an = 0;int flag_gn = 0;
						if(((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11A) > 0)
							&&((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11N) > 0)
							&&((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11AN) > 0)
							&&(!(WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11B))
							&&(!(WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11G)))
						{
							vty_out(vty,"a/an");
						}
						else if(((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11GN) > 0)
							&&((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11N)> 0)
							&&((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11G)>0)
							&&(!(WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11B))
							&&(!(WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11A)))
						{	
							vty_out(vty,"g/gn");
						}			
						else
						{
							if((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11A) > 0)
								vty_out(vty,"a");
							if((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11B) > 0)
								vty_out(vty,"b");
							if((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11G) > 0)
								vty_out(vty,"g");		
							if((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11N) > 0)
								vty_out(vty,"n");	
						}
						/*fengwenchao modify end*/			
						vty_out(vty,"\n");
						free(WTPINFO->WTP[0]->WTP_Radio[i]);
						WTPINFO->WTP[0]->WTP_Radio[i] = NULL ;
					}
					dcli_wtp_free_fun(WID_DBUS_CONF_METHOD_SHOWWTP,WTPINFO);
				}
				else if(ret == WTP_ID_NOT_EXIST){
					vty_out(vty,"<error> wtp id does not exist\n");
				}
				else if(ret == WTP_ID_LARGE_THAN_MAX)
				{
					vty_out(vty,"<error> input wtp id should be 1 to %d\n",WTP_NUM-1);
				}
				else 
					vty_out(vty,"<error>  %d\n",ret);
				vty_out(vty,"==============================================================================\n");
				if(argc == 3){
					return CMD_SUCCESS;
				}
			}
		}

		 //for local hansi info
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){ 		 
			 ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			 localid = 1;
			 
			 for (profile = 1; profile < MAX_INSTANCE; profile++) 
			 {
				 instRun = dcli_hmd_hansi_is_running(vty,slot_id,1,profile);
				 if (INSTANCE_NO_CREATED == instRun) {
					 continue;
				 }
				 
		local_hansi_parameter:
				 WTPINFO = dcli_wtp_show_api_group_one(
					profile,
					FIRST,
					wtp_id,
					0,
					0,
					0,/**/
					&ret,/*num2*/
					0,
					num,
					0,
					&localid,//num6
					dcli_dbus_connection,
					WID_DBUS_CONF_METHOD_SHOWWTP
					);
				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"local hansi %d-%d\n",slot_id,profile);
				if(ret == -1){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == 0){
					vty_out(vty,"------------------------------------------------------------------------------\n");
					CheckWTPState(state,WTPINFO->WTP[0]->WTPStat);
					CheckWTPQuitReason(quitreason,WTPINFO->WTP[0]->quitreason);
					vty_out(vty,"WTP NAME : %s\n",WTPINFO->WTP[0]->WTPNAME);
					vty_out(vty,"WTP ID : %d\n",WTPINFO->WTP[0]->WTPID);
					vty_out(vty,"WTP SN : %s\n",WTPINFO->WTP[0]->WTPSN);
					vty_out(vty,"WTP MODEL : %s\n",WTPINFO->WTP[0]->WTPModel);			
					vty_out(vty,"Radio Count : %d\n",WTPINFO->WTP[0]->RadioCount);
					vty_out(vty,"WTP RUN STATE : %s\n",state);	
					if(7 == WTPINFO->WTP[0]->WTPStat)
					{
						vty_out(vty,"WTP QUIT REASON : %s\n",quitreason);
					}
					vty_out(vty,"WTP STATE: %s\n",(WTPINFO->WTP[0]->isused == 1)?on:off);
					vty_out(vty,"WTP IP : %s\n",WTPINFO->WTP[0]->WTPIP);
					vty_out(vty,"WTP MAC : %02X:",WTPINFO->WTP[0]->WTPMAC[0]);
					vty_out(vty,"%02X:",WTPINFO->WTP[0]->WTPMAC[1]);
					vty_out(vty,"%02X:",WTPINFO->WTP[0]->WTPMAC[2]);
					vty_out(vty,"%02X:",WTPINFO->WTP[0]->WTPMAC[3]);
					vty_out(vty,"%02X:",WTPINFO->WTP[0]->WTPMAC[4]);
					vty_out(vty,"%02X\n",WTPINFO->WTP[0]->WTPMAC[5]);
					vty_out(vty,"WTP MAX STA NUM : %d\n",WTPINFO->WTP[0]->wtp_allowed_max_sta_num);
					vty_out(vty,"WTP NUMBER TRIGER	: %d\n",WTPINFO->WTP[0]->wtp_triger_num);
					vty_out(vty,"WTP FLOW TRIGER  : %d\n",WTPINFO->WTP[0]->wtp_flow_triger);
					vty_out(vty,"First GLOBAL RadioID : %d\n",WTPINFO->WTP[0]->WFR_Index);			
					vty_out(vty,"Control Tunnel ID : %d\n",WTPINFO->WTP[0]->CTR_ID);
					vty_out(vty,"DATA Tunnel ID: %d\n",WTPINFO->WTP[0]->DAT_ID);
					vty_out(vty,"WTP HardWare Version: %s\n",WTPINFO->WTP[0]->sysver);
					vty_out(vty,"WTP SoftWare Version: %s\n",WTPINFO->WTP[0]->ver);
					vty_out(vty,"WTP Update img: %s\n",WTPINFO->WTP[0]->updatepath);
					vty_out(vty,"WTP Update Version: %s\n",WTPINFO->WTP[0]->updateversion);
					vty_out(vty,"Apply interface: %s\n",WTPINFO->WTP[0]->apply_interface_name);
					vty_out(vty,"WTP total receive flow byte: %lld\n",WTPINFO->WTP[0]->rx_bytes);
					vty_out(vty,"WTP total traffic flow byte: %lld\n",WTPINFO->WTP[0]->tx_bytes);
					vty_out(vty,"ap apstatistics interval: %u\n",WTPINFO->WTP[0]->apstatisticsinterval);
					/*added by weiay 20080711*/
					vty_out(vty,"WTP apply wlan id: ");
					for (i = 0; i < WTPINFO->WTP[0]->apply_wlan_num; i++)
					{
							vty_out(vty,"%d  ",WTPINFO->WTP[0]->apply_wlanid[i]);
					}
					if(i == 0)
					{
						vty_out(vty,"NONE\n");
					}
					else
					{
						vty_out(vty,"\n");
					}
					/*added by weiay*/
					
					vty_out(vty,"WTP %d Radio summary\n",wtp_id);
					vty_out(vty,"------------------------------------------------------------------------------\n");
					vty_out(vty,"RadioNum	RadioID 	Channel 	TX Power	Radio Type\n");
					for(i = 0; i < WTPINFO->WTP[0]->radio_num; i++){
						if(WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Chan == 0){
								if((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_TXP == 0)||(WTPINFO->WTP[0]->WTP_Radio[i]->Radio_TXP == 100))	   //fengwenchao add 20110427
								{
									vty_out(vty,"%d	 	%d		auto		auto		",WTPINFO->WTP[0]->WTP_Radio[i]->Radio_L_ID,WTPINFO->WTP[0]->WTP_Radio[i]->Radio_G_ID);
								}
								else
								{
									vty_out(vty,"%d	 	%d		auto		%d		",WTPINFO->WTP[0]->WTP_Radio[i]->Radio_L_ID,WTPINFO->WTP[0]->WTP_Radio[i]->Radio_G_ID,WTPINFO->WTP[0]->WTP_Radio[i]->Radio_TXP);								
								}				
							}
						else {
								if((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_TXP == 0)||(WTPINFO->WTP[0]->WTP_Radio[i]->Radio_TXP == 100))	   //fengwenchao add 20110427
								{
									vty_out(vty,"%d	 	%d		%d		auto		",WTPINFO->WTP[0]->WTP_Radio[i]->Radio_L_ID,WTPINFO->WTP[0]->WTP_Radio[i]->Radio_G_ID,WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Chan);
								}
								else
								{
									vty_out(vty,"%d	 	%d		%d		%d		",WTPINFO->WTP[0]->WTP_Radio[i]->Radio_L_ID,WTPINFO->WTP[0]->WTP_Radio[i]->Radio_G_ID,WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Chan,WTPINFO->WTP[0]->WTP_Radio[i]->Radio_TXP);
								}							
							}
						vty_out(vty,"11");
						/*fengwenchao modify begin 20111109 for GM*/
						int flag_an = 0;int flag_gn = 0;
						if(((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11A) > 0)
							&&((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11N) > 0)
							&&((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11AN) > 0)
							&&(!(WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11B))
							&&(!(WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11G)))
						{
							vty_out(vty,"a/an");
						}
						else if(((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11GN) > 0)
							&&((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11N)> 0)
							&&((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11G)>0)
							&&(!(WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11B))
							&&(!(WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11A)))
						{	
							vty_out(vty,"g/gn");
						}			
						else
						{
							if((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11A) > 0)
								vty_out(vty,"a");
							if((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11B) > 0)
								vty_out(vty,"b");
							if((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11G) > 0)
								vty_out(vty,"g");		
							if((WTPINFO->WTP[0]->WTP_Radio[i]->Radio_Type&IEEE80211_11N) > 0)
								vty_out(vty,"n");	
						}
						/*fengwenchao modify end*/			
						vty_out(vty,"\n");
						free(WTPINFO->WTP[0]->WTP_Radio[i]);
						WTPINFO->WTP[0]->WTP_Radio[i] = NULL ;
					}
					dcli_wtp_free_fun(WID_DBUS_CONF_METHOD_SHOWWTP,WTPINFO);
				}
				else if(ret == WTP_ID_NOT_EXIST){
					vty_out(vty,"<error> wtp id does not exist\n");
				}
				else if(ret == WTP_ID_LARGE_THAN_MAX)
				{
					vty_out(vty,"<error> input wtp id should be 1 to %d\n",WTP_NUM-1);
				}
				else 
					vty_out(vty,"<error>  %d\n",ret);
				vty_out(vty,"==============================================================================\n");
				if(argc == 3){
					return CMD_SUCCESS;
				}
	 		}
	 	}
	}
	
	return CMD_SUCCESS;
}


DEFUN(diag_wtp_list_bywtpid_cmd_func,
	  diag_wtp_list_bywtpid_cmd,
	  "trace wtp bywtpid ID",
	  CONFIG_STR
	  "WTP information\n"
	  "WTP id that you want to trace\n"
	 )
{	
	int ret,i;
	unsigned int wtp_id = 0;
	unsigned char a0,a1,a2,a3,a4,a5,num;
	unsigned char bwlannum = 0;/*20080711*/
	unsigned char wlanid[WLAN_NUM] = {0}; /*should make */
	char *name;
    char state[WTP_ARRAY_NAME_LEN];
	char quitreason[WTP_ARRAY_NAME_LEN];
	WID_WTP *WTP;
	WID_WTP_RADIO *radio[L_RADIO_NUM];
	char dis[] = "disable";
	char en[] = "enable";
	char on[] = "used";
	char off[] = "unused";
	char sflag = 0;
/*    wtp_id = atoi(argv[0]);*/
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;
	int fd = 0;
	
	/* first check if the shell script exist */
	fd = open(TRACE_SCRIPT_NAME, O_RDONLY);
	if(fd < 0) {
		vty_out(vty, "%% Trace wtp failed due to core file missing\n");
		return CMD_WARNING;
	}
	else {
		close(fd);
	}

	
	ret = parse_int_ID((char*)argv[0], &wtp_id);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}	
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		vty_out(vty,"<error> wtp id should be 1 to %d\n",WTP_NUM-1);
		return CMD_SUCCESS;
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SHOWWTP);
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOWWTP);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0 ){	

		WTP = (WID_WTP*)malloc(sizeof(WID_WTP));
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->wtp_triger_num));/*xm*/

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->wtp_flow_triger));/*xm*/
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->wtp_allowed_max_sta_num));/*xm*/
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->WTPID));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->WTPSN));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->WTPNAME));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->WTPModel));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->RadioCount));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->WTPStat));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->WTPIP));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->WFR_Index));	

	}
	
	dbus_message_unref(reply);
	if(ret == 0){
		//add trace code
		if('\0' == WTP->WTPIP[0]) {
			vty_out(vty, "%% wtp %s No active to trace!\n",argv[0]);
		}
		else {
			
				sflag = 'A';
				dcli_wtp_trace_script_exec(WTP->WTPIP, WTP->WTPID, sflag);

				free(WTP);
				WTP = NULL;
			}
	}	
	
	
	else if(ret == WTP_ID_NOT_EXIST){
		vty_out(vty,"<error> wtp id does not exist\n");
	}
	else if(ret == WTP_ID_LARGE_THAN_MAX)
	{
		vty_out(vty,"<error> input wtp id should be 1 to %d\n",WTP_NUM-1);
	}
	else 
		vty_out(vty,"<error>  %d\n",ret);
	if(WTP){
		free(WTP);
		WTP = NULL;
	}
	return CMD_SUCCESS;
}

DEFUN(btrace_wtp_list_bywtpid_cmd_func,
	  btrace_wtp_list_bywtpid_cmd,
	  "btrace wtp bywtpid ID",
	  CONFIG_STR
	  "WTP information\n"
	  "WTP id that you want to bandwidth btrace\n"
	 )
{	
	int ret,i;
	unsigned int wtp_id = 0;
	unsigned char a0,a1,a2,a3,a4,a5,num;
	unsigned char bwlannum = 0;/*20080711*/
	unsigned char wlanid[WLAN_NUM] = {0}; /*should make */
	char *name;
    char state[WTP_ARRAY_NAME_LEN];
	char quitreason[WTP_ARRAY_NAME_LEN];
	WID_WTP *WTP;
	WID_WTP_RADIO *radio[L_RADIO_NUM];
	char dis[] = "disable";
	char en[] = "enable";
	char on[] = "used";
	char off[] = "unused";
	char sflag = 0,tflag = 0;
/*    wtp_id = atoi(argv[0]);*/
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;
	int fd = 0;
	
	/* first check if the shell script exist */
	fd = open(BTRACE_SCRIPT_NAME, O_RDONLY);
	if(fd < 0) {
		vty_out(vty, "%% Trace wtp failed due to core file missing\n");
		return CMD_WARNING;
	}
	else {
		close(fd);
	}

	
	ret = parse_int_ID((char*)argv[0], &wtp_id);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}	
	if(wtp_id >= WTP_NUM || wtp_id == 0){
		vty_out(vty,"<error> wtp id should be 1 to %d\n",WTP_NUM-1);
		return CMD_SUCCESS;
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SHOWWTP);
	
	
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOWWTP);  */
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0 ){	

		WTP = (WID_WTP*)malloc(sizeof(WID_WTP));
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->wtp_triger_num));/*xm*/

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->wtp_flow_triger));/*xm*/
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->wtp_allowed_max_sta_num));/*xm*/
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->WTPID));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->WTPSN));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->WTPNAME));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->WTPModel));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->RadioCount));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->WTPStat));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->WTPIP));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->WFR_Index));	

	}
	
	dbus_message_unref(reply);
	if(ret == 0){
		//add trace code
		if('\0' == WTP->WTPIP[0]) {
			vty_out(vty, "%% wtp %s No active to trace!\n",argv[0]);
		}
		else {
			
				sflag = 'A';
				tflag = 'B'; /* 'B' means both tcp and udp */
				dcli_wtp_btrace_script_exec(WTP->WTPIP,sflag, tflag);

				free(WTP);
				WTP = NULL;
			}
	}	
	
	
	else if(ret == WTP_ID_NOT_EXIST){
		vty_out(vty,"<error> wtp id does not exist\n");
	}
	else if(ret == WTP_ID_LARGE_THAN_MAX)
	{
		vty_out(vty,"<error> input wtp id should be 1 to %d\n",WTP_NUM-1);
	}
	else 
		vty_out(vty,"<error>  %d\n",ret);
	if(WTP){
		free(WTP);
		WTP = NULL;
	}
	return CMD_SUCCESS;
}

//fengwenchao add 20101223
DEFUN(show_wtp_config_of_all_cmd_func,
	  show_wtp_config_of_all_cmd,
	  "show wtp config of all wtp",
	  SHOW_STR
	  "Display wtps config information\n"
	  "List wtp summary\n"
	 )
{
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;	
	//int ret,i,j=0;
	int ret = 0.;
	int i = 0;
	int j = 0;
	int wtp_num = 0;
	char on[] = "used";
	char off[] = "unused";

	 


	struct WTP_CONFIG_INFORMATION *WTPconfig = NULL;
	struct WTP_CONFIG_INFORMATION *WTPconfig_show = NULL;

	if((vty->node == CONFIG_NODE)||(vty->node == ENABLE_NODE)){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	WTPconfig = show_wtp_config_all_wtp(dcli_dbus_connection,index,localid,&ret,&wtp_num);

	if((ret == 0)&&(wtp_num != 0))
	{
		vty_out(vty,"WTPNum:%-5d  \n",wtp_num);
		vty_out(vty,"========================================================================== \n");
		for(i=0;i<wtp_num;i++)
		{
			if(WTPconfig_show == NULL)
				WTPconfig_show = WTPconfig->wtp_config_list;
			else 
				WTPconfig_show = WTPconfig_show->next;

			if(WTPconfig_show == NULL)
				break;

			vty_out(vty,"WTPID:   %-5d  \n",WTPconfig_show->WTPID);	
			vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
			WTPconfig_show->wtpMacAddr[0],WTPconfig_show->wtpMacAddr[1],WTPconfig_show->wtpMacAddr[2],
			WTPconfig_show->wtpMacAddr[3],WTPconfig_show->wtpMacAddr[4],WTPconfig_show->wtpMacAddr[5]);			
			vty_out(vty,"-------------------------------------------------------------------------\n");	

			vty_out(vty,"wtpBindPort:   %-5s  \n",WTPconfig_show->wtpBindPort);	
			struct WLAN_INFO *wlan_config = NULL;
			vty_out(vty,"wtpBindWlan:   "); 

			for(j=0;j<WTPconfig_show->apply_wlan_num;j++)
			{
				if(wlan_config == NULL)
					wlan_config = WTPconfig_show->wlan_info_head;
				else
					wlan_config = wlan_config->next;
				if(wlan_config ==NULL)
					break;
			

				vty_out(vty,"WlanID:   %u  ",wlan_config->Wlanid);	
				vty_out(vty,"Wlanname:   %s  \n",wlan_config->wlanname);
				vty_out(vty,"-------------------------------------------------------------------------\n");
				if(wlan_config->intotlePkts == 0)
					vty_out(vty,"SSIDInDropRate: 0% \n");
				else
					vty_out(vty,"SSIDInDropRate: %.2f% \n",((float)wlan_config->indorpPkts/(float)wlan_config->intotlePkts)*100);
				
				if(wlan_config->outtotlePkts == 0)
					vty_out(vty,"SSIDOutDropRate: 0% \n");
				else
					vty_out(vty,"SSIDOutDropRate: %.2f% \n",((float)wlan_config->outdorpPkts/(float)wlan_config->outtotlePkts)*100);

				vty_out(vty,"SSIDDownBandWidthRate:   %d %\n",wlan_config->SSIDDownBandWidthRate);	
				vty_out(vty,"SSIDUpBandWidthRate:   %d  %\n",wlan_config->SSIDUpBandWidthRate);
				vty_out(vty,"-------------------------------------------------------------------------\n");
			}
			vty_out(vty,"wtpUsed: %s\n",(WTPconfig_show->wtpused == 1)?on:off);
			vty_out(vty,"wtpMaxStaNum: %u\n",WTPconfig_show->wtpMaxStaNum);
			vty_out(vty,"wtpLoadBalanceTrigerBaseUsr: %u\n",WTPconfig_show->wtpLoadBalanceTrigerBaseUsr);

		    vty_out(vty,"wtpLoadBalanceTrigerBaseFlow: %u\n",WTPconfig_show->wtpLoadBalanceTrigerBaseFlow);
			vty_out(vty,"-------------------------------------------------------------------------\n");			
		}
	}
	else if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == 5)
	{
			vty_out(vty,"<error>  no wtp config information.\n");
	}
	else
	{
		vty_out(vty,"<error> %d.\n",ret);
	}
	dcli_free_all_wtp_config_info(WTPconfig);
	return CMD_SUCCESS;	
}
//fengwenchao add end

DEFUN(show_wtp_list_new_cmd_func,
	  show_wtp_list_new_cmd,
	  "show wtp (list|all) [remote] [local] [PARAMETER]",
	  SHOW_STR
	  "Display wtps information\n"
	  "List wtp summary\n"
	  "List wtp summary\n"
	  "'remote' or 'local' hansi\n"
	  "'remote' or 'local' hansi\n"
	  "slotid-instid\n"
	 )
{
	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;		
	char on[] = "used";
	char off[] = "unused";
	char state[20];
	char ip[WTP_WTP_IP_LEN+1];
	unsigned int result = 0;
	WID_WTP **WTP;	
	int ret,i=0;
	int profile = 0;
	int instRun = 0;
	int flag = 0;

	DCLI_WTP_API_GROUP_ONE *WTPINFO = NULL;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if((vty->node == CONFIG_NODE)||(vty->node == ENABLE_NODE)){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	 if((argc == 2)||(argc == 4)){
		 vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
		 return CMD_SUCCESS;
	 }
	 if(argc == 3){
		 if (!strcmp(argv[1],"remote")){
			 localid = 0;
		 }else if(!strcmp(argv[1],"local")){
			 localid = 1;
		 }else{
			 vty_out(vty,"parameter should be 'remote' or 'local'\n");
			 return CMD_SUCCESS;
		 }
		 
		 if((!strcmp(argv[1],"remote"))&&(!strcmp(argv[2],"local"))){
			 vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
			 return CMD_SUCCESS;
		 }
		 
		 ret = parse_slot_hansi_id((char*)argv[2],&slot_id,&profile);
		 if(ret != WID_DBUS_SUCCESS){
			 slot_id = HostSlotId;
			 flag = 1;
			 ret = parse_int_ID((char*)argv[2], &profile);
			 if(ret != WID_DBUS_SUCCESS){
				 if(ret == WID_ILLEGAL_INPUT){
					 vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
				 }
				 else{
					 vty_out(vty,"<error> unknown id format\n");
				 }
				 return CMD_WARNING;
			 }	 
		 }
		 if(distributFag == 0){
			 if(slot_id != 0){
				 vty_out(vty,"<error> slot id should be 0\n");
				 return CMD_WARNING;
			 }	 
		 }else if(flag == 1){
			 slot_id = HostSlotId;
		 }
		 if(slot_id >= MAX_SLOT_NUM || slot_id < 0){
			 vty_out(vty,"<error> slot id should be 1 to %d\n",MAX_SLOT_NUM-1);
			 return CMD_WARNING;
		 }	 
		 if(profile >= MAX_INSTANCE || profile == 0){
			 vty_out(vty,"<error> hansi id should be 1 to %d\n",MAX_INSTANCE-1);
			 return CMD_WARNING;
		 }
		 instRun = dcli_hmd_hansi_is_running(vty,slot_id,localid,profile);
		 if (INSTANCE_NO_CREATED == instRun) {
			 vty_out(vty,"<error> the instance %s %d-%d is not running\n",((localid == 1)?"local-hansi":"hansi"),slot_id,profile);
			 return CMD_WARNING;
		 }
		 
		 ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		 if(localid == 0)
			 goto hansi_parameter;
		 else if(localid == 1)
			 goto local_hansi_parameter; 
	 }

	 if(vty->node != VIEW_NODE){
		 WTPINFO = dcli_wtp_show_api_group_one(
			index,
			SECOND,/*"show wtp (list|all)"*/
			0,
			0,
			0,
			0,/**/
			&ret,/*num2*/
			0,
			0,
			0,
			&localid,//num6
			dcli_dbus_connection,
			WID_DBUS_CONF_METHOD_WTPLIST_NEW
			);
	    vty_out(vty,"wtp list summary:\n");	
	    vty_out(vty,"%d WTPs Online\n",(ret == 0)?WTPINFO->TotalNum:0);
		vty_out(vty,"----------------------------------------------------------------------\n");
		vty_out(vty,"%d WTP Join state\n",(ret == 0)?WTPINFO->join_num:0);
		vty_out(vty,"%d WTP Configure state\n",(ret == 0)?WTPINFO->configure_num:0);
		vty_out(vty,"%d WTP Datacheck state\n",(ret == 0)?WTPINFO->datacheck_num:0);
		vty_out(vty,"%d WTP Run state\n",(ret == 0)?WTPINFO->run_num:0);
		vty_out(vty,"%d WTP Imagedata state\n",(ret == 0)?WTPINFO->imagedata_num:0);
		vty_out(vty,"%d WTP Bak_run state\n",(ret == 0)?WTPINFO->bak_run_num:0);
		vty_out(vty,"%d WTP Quit state\n",(ret == 0)?WTPINFO->quit_num:0);
	    vty_out(vty,"==============================================================================\n");
		vty_out(vty,"%-5s %-17s %-21s %-10s %-7s\n","WTPID","WTPMAC","WTPIP","RunState","State");
		if(ret == -1){
			cli_syslog_info("<error> failed get reply.\n");
		}
		else if(ret == 0){

				if((WTPINFO)&&(WTPINFO->WTP_INFO)&&(WTPINFO->WTP_INFO->WTP_LIST)){
					WID_WTP *head = NULL;
					head = WTPINFO->WTP_INFO->WTP_LIST;
					for (i = 0; i < WTPINFO->WTP_INFO->list_len; i++) {
						
						CheckWTPState(state,head->WTPStat);
						result = wtp_check_wtp_ip_addr(ip,head->WTPIP);
						if(result != 1)
						{
							vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-21s %-10s %-7s\n",
								head->WTPID,
								head->WTPMAC[0],head->WTPMAC[1],head->WTPMAC[2],head->WTPMAC[3],head->WTPMAC[4],head->WTPMAC[5],
								head->WTPIP,
								state,
								(head->isused == 1)?on:off);
						}
						else
						{
							vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-21s %-10s %-7s\n",
								head->WTPID,
								head->WTPMAC[0],head->WTPMAC[1],head->WTPMAC[2],head->WTPMAC[3],head->WTPMAC[4],head->WTPMAC[5],
								ip,
								state,
								(head->isused == 1)?on:off);
						}
						head = head->next;				
					
					}
				}
			dcli_wtp_free_fun(WID_DBUS_CONF_METHOD_WTPLIST_NEW,WTPINFO);
		}
	}
	vty_out(vty,"==============================================================================\n");

	if(vty->node == VIEW_NODE){
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 0;
			
			//for remote hansi info
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,0,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}

	 hansi_parameter:
				 WTPINFO = dcli_wtp_show_api_group_one(
					profile,
					SECOND,/*"show wtp (list|all)"*/
					0,
					0,
					0,
					0,/**/
					&ret,/*num2*/
					0,
					0,
					0,
					&localid,//num6
					dcli_dbus_connection,
					WID_DBUS_CONF_METHOD_WTPLIST_NEW
					);
				vty_out(vty,"wtp list summary:   hansi %d-%d\n",slot_id,profile); 
				vty_out(vty,"%d WTPs Online\n",(ret == 0)?WTPINFO->TotalNum:0);
				vty_out(vty,"----------------------------------------------------------------------\n");
				vty_out(vty,"%d WTP Join state\n",(ret == 0)?WTPINFO->join_num:0);
				vty_out(vty,"%d WTP Configure state\n",(ret == 0)?WTPINFO->configure_num:0);
				vty_out(vty,"%d WTP Datacheck state\n",(ret == 0)?WTPINFO->datacheck_num:0);
				vty_out(vty,"%d WTP Run state\n",(ret == 0)?WTPINFO->run_num:0);
				vty_out(vty,"%d WTP Imagedata state\n",(ret == 0)?WTPINFO->imagedata_num:0);
				vty_out(vty,"%d WTP Bak_run state\n",(ret == 0)?WTPINFO->bak_run_num:0);
				vty_out(vty,"%d WTP Quit state\n",(ret == 0)?WTPINFO->quit_num:0);
				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"%-5s %-17s %-21s %-10s %-7s\n","WTPID","WTPMAC","WTPIP","RunState","State");
				if(ret == -1){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == 0){
						if((WTPINFO)&&(WTPINFO->WTP_INFO)&&(WTPINFO->WTP_INFO->WTP_LIST)){
							WID_WTP *head = NULL;
							head = WTPINFO->WTP_INFO->WTP_LIST;
							for (i = 0; i < WTPINFO->WTP_INFO->list_len; i++) {
								
								CheckWTPState(state,head->WTPStat);
								result = wtp_check_wtp_ip_addr(ip,head->WTPIP);
								if(result != 1)
								{
									vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-21s %-10s %-7s\n",
										head->WTPID,
										head->WTPMAC[0],head->WTPMAC[1],head->WTPMAC[2],head->WTPMAC[3],head->WTPMAC[4],head->WTPMAC[5],
										head->WTPIP,
										state,
										(head->isused == 1)?on:off);
								}
								else
								{
									vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-21s %-10s %-7s\n",
										head->WTPID,
										head->WTPMAC[0],head->WTPMAC[1],head->WTPMAC[2],head->WTPMAC[3],head->WTPMAC[4],head->WTPMAC[5],
										ip,
										state,
										(head->isused == 1)?on:off);
								}
								head = head->next;				
							
							}
						}
					dcli_wtp_free_fun(WID_DBUS_CONF_METHOD_WTPLIST_NEW,WTPINFO);
				}
				vty_out(vty,"==============================================================================\n");
				if(argc == 3){
					return CMD_SUCCESS;
				}
			}
		}

		//for local hansi info
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 1;
			
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,1,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}

		 local_hansi_parameter:
				 WTPINFO = dcli_wtp_show_api_group_one(
					profile,
					SECOND,/*"show wtp (list|all)"*/
					0,
					0,
					0,
					0,/**/
					&ret,/*num2*/
					0,
					0,
					0,
					&localid,//num6
					dcli_dbus_connection,
					WID_DBUS_CONF_METHOD_WTPLIST_NEW
					);
				vty_out(vty,"wtp list summary:   local-hansi %d-%d\n",slot_id,profile); 
				vty_out(vty,"%d WTPs Online\n",(ret == 0)?WTPINFO->TotalNum:0);
				vty_out(vty,"----------------------------------------------------------------------\n");
				vty_out(vty,"%d WTP Join state\n",(ret == 0)?WTPINFO->join_num:0);
				vty_out(vty,"%d WTP Configure state\n",(ret == 0)?WTPINFO->configure_num:0);
				vty_out(vty,"%d WTP Datacheck state\n",(ret == 0)?WTPINFO->datacheck_num:0);
				vty_out(vty,"%d WTP Run state\n",(ret == 0)?WTPINFO->run_num:0);
				vty_out(vty,"%d WTP Imagedata state\n",(ret == 0)?WTPINFO->imagedata_num:0);
				vty_out(vty,"%d WTP Bak_run state\n",(ret == 0)?WTPINFO->bak_run_num:0);
				vty_out(vty,"%d WTP Quit state\n",(ret == 0)?WTPINFO->quit_num:0);
				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"%-5s %-17s %-21s %-10s %-7s\n","WTPID","WTPMAC","WTPIP","RunState","State");
				if(ret == -1){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == 0){
						if((WTPINFO)&&(WTPINFO->WTP_INFO)&&(WTPINFO->WTP_INFO->WTP_LIST)){
							WID_WTP *head = NULL;
							head = WTPINFO->WTP_INFO->WTP_LIST;
							for (i = 0; i < WTPINFO->WTP_INFO->list_len; i++) {
								
								CheckWTPState(state,head->WTPStat);
								result = wtp_check_wtp_ip_addr(ip,head->WTPIP);
								if(result != 1)
								{
									vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-21s %-10s %-7s\n",
										head->WTPID,
										head->WTPMAC[0],head->WTPMAC[1],head->WTPMAC[2],head->WTPMAC[3],head->WTPMAC[4],head->WTPMAC[5],
										head->WTPIP,
										state,
										(head->isused == 1)?on:off);
								}
								else
								{
									vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-21s %-10s %-7s\n",
										head->WTPID,
										head->WTPMAC[0],head->WTPMAC[1],head->WTPMAC[2],head->WTPMAC[3],head->WTPMAC[4],head->WTPMAC[5],
										ip,
										state,
										(head->isused == 1)?on:off);
								}
								head = head->next;				
							
							}
						}
					dcli_wtp_free_fun(WID_DBUS_CONF_METHOD_WTPLIST_NEW,WTPINFO);
				}
				vty_out(vty,"==============================================================================\n");
				if(argc == 3){
					return CMD_SUCCESS;
				}
			}
		}
	}
	
	return CMD_SUCCESS;
	
}

/*xiaodawei transplant from 2.0 for telecom test, 20110301*/
DEFUN(show_wtp_list_byinterface_cmd_func,
	  show_wtp_list_byinterface_cmd,
	  "show wtp list by interface",
	  SHOW_STR
	  "Display wtps information byinterface\n"
	  "List wtp summary byinterface\n"
	 )
{
	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;		
	char on[] = "used";
	char off[] = "unused";
	char state[20];
	char ip[WTP_WTP_IP_LEN+1];
	unsigned int result = 0;
	WID_WTP **WTP;	
	int ret,i=0;

	DCLI_WTP_API_GROUP_ONE *WTPINFO = NULL;
	int localid = 1;
	int slot_id = HostSlotId;
	int index;
	if((vty->node == CONFIG_NODE)||(vty->node == ENABLE_NODE)){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = (int)vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	 WTPINFO = dcli_wtp_show_api_group_one(
		index,
		TENTH,/*"show wtp list by interface"*/
		0,
		0,
		0,
		0,/**/
		&ret,/*num2*/
		0,
		0,
		0,
		&localid,//num6
		dcli_dbus_connection,
		WID_DBUS_CONF_METHOD_WTPLIST_NEW_BYINTERFACE
		);
    vty_out(vty,"wtp list summary:\n");	
    vty_out(vty,"%d WTPs Online\n",(ret == 0)?WTPINFO->TotalNum:0);
	vty_out(vty,"----------------------------------------------------------------------\n");
	vty_out(vty,"%d WTP Join state\n",(ret == 0)?WTPINFO->join_num:0);
	vty_out(vty,"%d WTP Configure state\n",(ret == 0)?WTPINFO->configure_num:0);
	vty_out(vty,"%d WTP Datacheck state\n",(ret == 0)?WTPINFO->datacheck_num:0);
	vty_out(vty,"%d WTP Run state\n",(ret == 0)?WTPINFO->run_num:0);
	vty_out(vty,"%d WTP Imagedata state\n",(ret == 0)?WTPINFO->imagedata_num:0);
	vty_out(vty,"%d WTP Bak_run state\n",(ret == 0)?WTPINFO->bak_run_num:0);
	vty_out(vty,"%d WTP Quit state\n",(ret == 0)?WTPINFO->quit_num:0);
    vty_out(vty,"==============================================================================\n");
	vty_out(vty,"%-5s %-17s %-21s %-10s %-7s\n","WTPID","WTPMAC","WTPIP","interface");
	if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
		return CMD_FAILURE;
	}
	else if(ret == 0){

			if((WTPINFO)&&(WTPINFO->WTP_INFO)&&(WTPINFO->WTP_INFO->WTP_LIST)){
				WID_WTP *head = NULL;
				head = WTPINFO->WTP_INFO->WTP_LIST;
				for (i = 0; i < WTPINFO->WTP_INFO->list_len; i++) {
					
					CheckWTPState(state,head->WTPStat);
					result = wtp_check_wtp_ip_addr(ip,head->WTPIP);
					if(result != 1)
					{
						vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-21s %s\n",
							head->WTPID,
							head->WTPMAC[0],head->WTPMAC[1],head->WTPMAC[2],head->WTPMAC[3],head->WTPMAC[4],head->WTPMAC[5],
							head->WTPIP,
							head->apply_interface_name);
						vty_out(vty,"WTPSN:%-21s   login_interfaceIP: %s\n",head->WTPSN,head->login_interfaceIP);
					}
					else
					{
						vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-21s %s\n",
							head->WTPID,
							head->WTPMAC[0],head->WTPMAC[1],head->WTPMAC[2],head->WTPMAC[3],head->WTPMAC[4],head->WTPMAC[5],
							ip,
							head->apply_interface_name);
						vty_out(vty,"WTPSN:%-21s   login_interfaceIP: %s\n",head->WTPSN,head->login_interfaceIP);
					}
					head = head->next;				
				
				}
			}
		dcli_wtp_free_fun(WID_DBUS_CONF_METHOD_WTPLIST_NEW_BYINTERFACE,WTPINFO);
	}
	vty_out(vty,"==============================================================================\n");
	/*
	vty_out(vty,"%d WTP Join state\n",(ret == 0)?WTPINFO->join_num:0);
	vty_out(vty,"%d WTP Configure state\n",(ret == 0)?WTPINFO->configure_num:0);
	vty_out(vty,"%d WTP Datacheck state\n",(ret == 0)?WTPINFO->datacheck_num:0);
	vty_out(vty,"%d WTP Run state\n",(ret == 0)?WTPINFO->run_num:0);
	vty_out(vty,"%d WTP Imagedata state\n",(ret == 0)?WTPINFO->imagedata_num:0);
	vty_out(vty,"%d WTP Bak_run state\n",(ret == 0)?WTPINFO->bak_run_num:0);
	vty_out(vty,"%d WTP Quit state\n",(ret == 0)?WTPINFO->quit_num:0);
	vty_out(vty,"----------------------------------------------------------------------\n");
	*/
	return CMD_SUCCESS;
	
}

/*END*/

DEFUN(show_wtp_model_list_func,
	  show_wtp_model_list_cmd,
	  "show wtp model list",
	  SHOW_STR
	  "Display wtps model information\n"
	  "List wtp model summary\n"
	 )
{
/*	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;	*/	
	char on[] = "used";
	char off[] = "unused";
	char state[20];
	char ip[WTP_WTP_IP_LEN+1];
	unsigned int result = 0;
//	WID_WTP **WTP;	
	int ret,i=0;
/*	unsigned int num = 0;
	unsigned int TotalNum = 0;

	unsigned int join_num = 0;
	unsigned int configure_num = 0;
	unsigned int datacheck_num = 0;
	unsigned int run_num = 0;
	unsigned int quit_num = 0;
	unsigned int imagedata_num = 0;
	unsigned int bak_run_num = 0;*/

//	WTP = malloc(WTP_NUM*(sizeof(WID_WTP *)));
	DCLI_WTP_API_GROUP_ONE *WTPINFO = NULL;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if((vty->node == CONFIG_NODE)||(vty->node == ENABLE_NODE)){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
#if 0	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST_NEW);
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST_NEW); */
	dbus_error_init(&err);
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);	
	dbus_message_unref(query);
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		free(WTP);
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0 ){
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&num);
	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_recurse(&iter,&iter_array);
		
		for (i = 0; i < num; i++) {
			DBusMessageIter iter_struct;
			
			WTP[i] = (WID_WTP*)malloc(sizeof(WID_WTP));
			WTP[i]->WTPMAC = (unsigned char *)malloc(MAC_LEN +1);
			memset(WTP[i]->WTPMAC,0,(MAC_LEN +1));
			dbus_message_iter_recurse(&iter_array,&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPID));
		
			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[0]);
			
			dbus_message_iter_next(&iter_struct);

			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[1]);
			
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[2]);
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[3]);
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[4]);
		
			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[5]);	
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPIP));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPModel));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPStat));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->isused));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPNAME));

			dbus_message_iter_next(&iter_array);

			if(WTP[i]->WTPStat == 5)
			{
				TotalNum++;
			}
			switch(WTP[i]->WTPStat)
			{	
				case 2	:	join_num++;
							break;
				case 3	:	configure_num++;
							break;
				case 4	:	datacheck_num++;
							break;
				case 5	:	run_num++;
							break;	
				case 7	:	quit_num++;
							break;
				case 8	:	imagedata_num++;
							break;
				case 9	:	bak_run_num++;
							break;
				default	:	break;
			}
		}
	}
	
	dbus_message_unref(reply);
#endif
	 WTPINFO = dcli_wtp_show_api_group_one(
		index,
		SECOND,/*"show wtp model list"*/
		0,
		0,
		0,
		0,/**/
		&ret,/*num2*/
		0,
		0,
		0,
		&localid,//num6
	//	WTPINFO,
		dcli_dbus_connection,
		WID_DBUS_CONF_METHOD_WTPLIST_NEW
		);
	//printf("##########ret is %d\n",ret);
    vty_out(vty,"wtp list summary:\n");	
    vty_out(vty,"%d WTPs Online\n",(ret == 0)?WTPINFO->TotalNum:0);
	vty_out(vty,"----------------------------------------------------------------------\n");
	vty_out(vty,"%d WTP Join state\n",(ret == 0)?WTPINFO->join_num:0);
	vty_out(vty,"%d WTP Configure state\n",(ret == 0)?WTPINFO->configure_num:0);
	vty_out(vty,"%d WTP Datacheck state\n",(ret == 0)?WTPINFO->datacheck_num:0);
	vty_out(vty,"%d WTP Run state\n",(ret == 0)?WTPINFO->run_num:0);
	vty_out(vty,"%d WTP Imagedata state\n",(ret == 0)?WTPINFO->imagedata_num:0);
	vty_out(vty,"%d WTP Bak_run state\n",(ret == 0)?WTPINFO->bak_run_num:0);
	vty_out(vty,"%d WTP Quit state\n",(ret == 0)?WTPINFO->quit_num:0);
    vty_out(vty,"==============================================================================\n");
	vty_out(vty,"%-5s %-17s %-21s %-10s %-7s\n","WTPID","WTPMAC","WTPIP","RunState","Model");   //fengwenchao change State to Model  20110516
	if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == 0){
			if((WTPINFO)&&(WTPINFO->WTP_INFO)&&(WTPINFO->WTP_INFO->WTP_LIST)){
				WID_WTP *head = NULL;
				head = WTPINFO->WTP_INFO->WTP_LIST;
				for (i = 0; i < WTPINFO->WTP_INFO->list_len; i++) {
					
					CheckWTPState(state,head->WTPStat);
					result = wtp_check_wtp_ip_addr(ip,head->WTPIP);
					if(result != 1)
					{
						vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-21s %-10s %-34s\n",
							head->WTPID,
							head->WTPMAC[0],head->WTPMAC[1],head->WTPMAC[2],head->WTPMAC[3],head->WTPMAC[4],head->WTPMAC[5],
							head->WTPIP,
							state,
							head->WTPModel);
					}
					else
					{
						vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-21s %-10s %-34s\n",
							head->WTPID,
							head->WTPMAC[0],head->WTPMAC[1],head->WTPMAC[2],head->WTPMAC[3],head->WTPMAC[4],head->WTPMAC[5],
							ip,
							state,
							head->WTPModel);
					}
				//	CW_FREE_OBJECT(head->WTPMAC);
					head = head->next;				
				
				}
			}
		//	CW_FREE_OBJECT(WTPINFO->WTP_INFO->WTP_LIST);
		dcli_wtp_free_fun(WID_DBUS_CONF_METHOD_WTPLIST_NEW,WTPINFO);
	}
	vty_out(vty,"==============================================================================\n");
	/*
	vty_out(vty,"%d WTP Join state\n",(ret == 0)?WTPINFO->join_num:0);
	vty_out(vty,"%d WTP Configure state\n",(ret == 0)?WTPINFO->configure_num:0);
	vty_out(vty,"%d WTP Datacheck state\n",(ret == 0)?WTPINFO->datacheck_num:0);
	vty_out(vty,"%d WTP Run state\n",(ret == 0)?WTPINFO->run_num:0);
	vty_out(vty,"%d WTP Imagedata state\n",(ret == 0)?WTPINFO->imagedata_num:0);
	vty_out(vty,"%d WTP Bak_run state\n",(ret == 0)?WTPINFO->bak_run_num:0);
	vty_out(vty,"%d WTP Quit state\n",(ret == 0)?WTPINFO->quit_num:0);
	vty_out(vty,"----------------------------------------------------------------------\n");
	*/
//	CW_FREE_OBJECT(WTPINFO->WTP_INFO);
//	CW_FREE_OBJECT(WTPINFO);
	return CMD_SUCCESS;
	
}

DEFUN(show_wtp_list_cmd_func,
	  show_wtp_list_cmd,
	  "show wtp (list|all) by sn",
	  SHOW_STR
	  "Display wtps information\n"
	  "List wtp summary\n"
	  "by sn display sn\n"
	  "by sn display sn\n"
	 )
{
	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;		
	char on[] = "used";
	char off[] = "unused";
	char state[20];
//	WID_WTP **WTP;	
	int ret,i=0;
/*	unsigned int num = 0;
	unsigned int TotalNum = 0;

	unsigned int join_num = 0;
	unsigned int configure_num = 0;
	unsigned int datacheck_num = 0;
	unsigned int run_num = 0;
	unsigned int quit_num = 0;
	unsigned int imagedata_num = 0;
	unsigned int bak_run_num = 0;
	
	WTP = malloc(WTP_NUM*(sizeof(WID_WTP *)));*/
	DCLI_WTP_API_GROUP_ONE *WTPINFO = NULL;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if((vty->node == CONFIG_NODE)||(vty->node == ENABLE_NODE)){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
#if 0	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST);

	
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST);*/
	dbus_error_init(&err);
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);	
	dbus_message_unref(query);
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		free(WTP);
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0 ){
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&num);
	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_recurse(&iter,&iter_array);
		
		for (i = 0; i < num; i++) {
			DBusMessageIter iter_struct;
			
			WTP[i] = (WID_WTP*)malloc(sizeof(WID_WTP));
			
			dbus_message_iter_recurse(&iter_array,&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPID));
		
			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPSN));
		
			dbus_message_iter_next(&iter_struct);

			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPNAME));
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPModel));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->RadioCount));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WFR_Index));

			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPStat));
			if(WTP[i]->WTPStat == 5)
				TotalNum++;
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->CTR_ID));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->DAT_ID));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->isused));

			dbus_message_iter_next(&iter_array);

			switch(WTP[i]->WTPStat)
			{	
				case 2	:	join_num++;
							break;
				case 3	:	configure_num++;
							break;
				case 4	:	datacheck_num++;
							break;
				case 5	:	run_num++;
							break;	
				case 7	:	quit_num++;
							break;
				case 8	:	imagedata_num++;
							break;
				case 9	:	bak_run_num++;
							break;
				default	:	break;
			}
		}
	}
	
	dbus_message_unref(reply);
#endif	
	 WTPINFO = dcli_wtp_show_api_group_one(
		index,
		THIRD,/*"show wtp (list|all) by sn"*/
		0,
		0,
		0,
		0,/**/
		&ret,/*num2*/
		0,
		0,
		0,
		&localid,//num6
	//	WTPINFO,
		dcli_dbus_connection,
		WID_DBUS_CONF_METHOD_WTPLIST
		);
	//printf("##########ret is %d\n",ret);
    vty_out(vty,"wtp list summary:\n");	
    vty_out(vty,"%d WTPs Online\n",(ret != 0)?0:WTPINFO->TotalNum);
	vty_out(vty,"----------------------------------------------------------------------\n");
	vty_out(vty,"%d WTP Join state\n",(ret != 0)?0:WTPINFO->join_num);
	vty_out(vty,"%d WTP Configure state\n",(ret != 0)?0:WTPINFO->configure_num);
	vty_out(vty,"%d WTP Datacheck state\n",(ret != 0)?0:WTPINFO->datacheck_num);
	vty_out(vty,"%d WTP Run state\n",(ret != 0)?0:WTPINFO->run_num);
	vty_out(vty,"%d WTP Imagedata state\n",(ret != 0)?0:WTPINFO->imagedata_num);
	vty_out(vty,"%d WTP Bak_run state\n",(ret != 0)?0:WTPINFO->bak_run_num);
	vty_out(vty,"%d WTP Quit state\n",(ret != 0)?0:WTPINFO->quit_num);
    vty_out(vty,"==============================================================================\n");
	vty_out(vty,"%-5s %-20s %-20s %-7s %-5s %-10s %-7s\n","WTPID","WTPName","SN","RaCount","RID","RunState","State");
	if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == 0){
		if((WTPINFO)&&(WTPINFO->WTP_INFO)&&(WTPINFO->WTP_INFO->WTP_LIST)){
			WID_WTP *head = NULL;
			head = WTPINFO->WTP_INFO->WTP_LIST;
			for (i = 0; i < WTPINFO->WTP_INFO->list_len; i++) {
				
				CheckWTPState(state,head->WTPStat);
				vty_out(vty,"%-5d %-20s %-20s %-7d %-5d %-10s %-7s\n",head->WTPID,head->WTPNAME,head->WTPSN,
					head->RadioCount,head->WFR_Index,state,(head->isused == 1)?on:off);
			//	CW_FREE_OBJECT(head->WTPMAC);
				head = head->next;				
			
			}
			}
	//	CW_FREE_OBJECT(WTPINFO->WTP_INFO->WTP_LIST);
	dcli_wtp_free_fun(WID_DBUS_CONF_METHOD_WTPLIST,WTPINFO);
	}
	/*	for (i = 0; i < num; i++) {	
			CheckWTPState(state,WTP[i]->WTPStat);
			vty_out(vty,"%-5d %-20s %-20s %-7d %-5d %-10s %-7s\n",WTP[i]->WTPID,WTP[i]->WTPNAME,WTP[i]->WTPSN,
				WTP[i]->RadioCount,WTP[i]->WFR_Index,state,(WTP[i]->isused == 1)?on:off);
			
			free(WTP[i]);
		}*/
	vty_out(vty,"==============================================================================\n");
	/*
	vty_out(vty,"%d WTP Join state\n",(ret != 0)?0:WTPINFO->join_num);
	vty_out(vty,"%d WTP Configure state\n",(ret != 0)?0:WTPINFO->configure_num);
	vty_out(vty,"%d WTP Datacheck state\n",(ret != 0)?0:WTPINFO->datacheck_num);
	vty_out(vty,"%d WTP Run state\n",(ret != 0)?0:WTPINFO->run_num);
	vty_out(vty,"%d WTP Imagedata state\n",(ret != 0)?0:WTPINFO->imagedata_num);
	vty_out(vty,"%d WTP Bak_run state\n",(ret != 0)?0:WTPINFO->bak_run_num);
	vty_out(vty,"%d WTP Quit state\n",(ret != 0)?0:WTPINFO->quit_num);
	vty_out(vty,"----------------------------------------------------------------------\n");
	*/
//	CW_FREE_OBJECT(WTPINFO->WTP_INFO);
//	CW_FREE_OBJECT(WTPINFO);
	return CMD_SUCCESS;
	
}

DEFUN(show_wtp_list_by_mac_cmd_func,
	  show_wtp_list_by_mac_cmd,
	  "show wtp (list|all) by mac",
	  SHOW_STR
	  "Display wtps information\n"
	  "List wtp summary\n"
	  "by mac display mac\n"
	  "by mac display mac\n"
	 )
{
/*	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;	*/	
	char on[] = "used";
	char off[] = "unused";
	char state[20];
	WID_WTP **WTP;	
	int ret,i=0;
/*	unsigned int num = 0;
	unsigned int TotalNum = 0;

	unsigned int join_num = 0;
	unsigned int configure_num = 0;
	unsigned int datacheck_num = 0;
	unsigned int run_num = 0;
	unsigned int quit_num = 0;
	unsigned int imagedata_num = 0;
	unsigned int bak_run_num = 0;
	
	WTP = malloc(WTP_NUM*(sizeof(WID_WTP *)));*/
	DCLI_WTP_API_GROUP_ONE *WTPINFO = NULL;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
#if 0	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST_BYMAC);

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST_BYMAC);*/
	dbus_error_init(&err);
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);	
	dbus_message_unref(query);
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		free(WTP);
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0 ){
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&num);
	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_recurse(&iter,&iter_array);
		
		for (i = 0; i < num; i++) {
			DBusMessageIter iter_struct;
			
			WTP[i] = (WID_WTP*)malloc(sizeof(WID_WTP));
			WTP[i]->WTPMAC = (unsigned char *)malloc(MAC_LEN +1);
			memset(WTP[i]->WTPMAC,0,(MAC_LEN +1));
			dbus_message_iter_recurse(&iter_array,&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPID));
		
			
			dbus_message_iter_next(&iter_struct);	
			
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPMAC[0]));	
			dbus_message_iter_next(&iter_struct);	
			
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPMAC[1]));				
			dbus_message_iter_next(&iter_struct);	
			
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPMAC[2]));		
			dbus_message_iter_next(&iter_struct);

			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPMAC[3]));	
			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPMAC[4]));	
			dbus_message_iter_next(&iter_struct);	
			
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPMAC[5]));	
			dbus_message_iter_next(&iter_struct);	

			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPNAME));
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPModel));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->RadioCount));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WFR_Index));

			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPStat));
			if(WTP[i]->WTPStat == 5)
				TotalNum++;
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->CTR_ID));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->DAT_ID));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->isused));

			dbus_message_iter_next(&iter_array);

			switch(WTP[i]->WTPStat)
			{	
				case 2	:	join_num++;
							break;
				case 3	:	configure_num++;
							break;
				case 4	:	datacheck_num++;
							break;
				case 5	:	run_num++;
							break;	
				case 7	:	quit_num++;
							break;
				case 8	:	imagedata_num++;
							break;
				case 9	:	bak_run_num++;
							break;
				default	:	break;
			}
		}
	}
	
	dbus_message_unref(reply);
#endif
	 WTPINFO = dcli_wtp_show_api_group_one(
		index,
		FOURTH,/*"show wtp (list|all) by mac"*/
		0,
		0,
		0,
		0,/**/
		&ret,/*num2*/
		0,
		0,
		0,
		&localid,//num6
	//	WTPINFO,
		dcli_dbus_connection,
		WID_DBUS_CONF_METHOD_WTPLIST_BYMAC
		);
    vty_out(vty,"wtp list summary:\n");	
    vty_out(vty,"%d WTPs Online\n",(ret != 0)?0:WTPINFO->TotalNum);
	vty_out(vty,"----------------------------------------------------------------------\n");
	vty_out(vty,"%d WTP Join state\n",(ret != 0)?0:WTPINFO->join_num);
	vty_out(vty,"%d WTP Configure state\n",(ret != 0)?0:WTPINFO->configure_num);
	vty_out(vty,"%d WTP Datacheck state\n",(ret != 0)?0:WTPINFO->datacheck_num);
	vty_out(vty,"%d WTP Run state\n",(ret != 0)?0:WTPINFO->run_num);
	vty_out(vty,"%d WTP Imagedata state\n",(ret != 0)?0:WTPINFO->imagedata_num);
	vty_out(vty,"%d WTP Bak_run state\n",(ret != 0)?0:WTPINFO->bak_run_num);
	vty_out(vty,"%d WTP Quit state\n",(ret != 0)?0:WTPINFO->quit_num);
    vty_out(vty,"==============================================================================\n");
	vty_out(vty,"%-5s %-20s %-17s %-7s %-5s %-10s %-7s\n","WTPID","WTPName","MAC","RaCount","RID","RunState","State");
	if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == 0){
		if((WTPINFO)&&(WTPINFO->WTP_INFO)&&(WTPINFO->WTP_INFO->WTP_LIST)){
			WID_WTP *head = NULL;
			head = WTPINFO->WTP_INFO->WTP_LIST;
			for (i = 0; i < WTPINFO->WTP_INFO->list_len; i++) {
				
				CheckWTPState(state,head->WTPStat);
				vty_out(vty,"%-5d %-20s %02X:%02X:%02X:%02X:%02X:%02X %-7d %-5d %-10s %-7s\n",head->WTPID,head->WTPNAME,head->WTPMAC[0],\
					head->WTPMAC[1],head->WTPMAC[2],head->WTPMAC[3],head->WTPMAC[4],head->WTPMAC[5],\
					head->RadioCount,head->WFR_Index,state,(head->isused == 1)?on:off);
				CW_FREE_OBJECT(head->WTPMAC);
				head = head->next;				
			
			}
			}
	//	CW_FREE_OBJECT(WTPINFO->WTP_INFO->WTP_LIST);
		dcli_wtp_free_fun(WID_DBUS_CONF_METHOD_WTPLIST_BYMAC,WTPINFO);
	}
	/*	for (i = 0; i < num; i++) {	
			CheckWTPState(state,WTP[i]->WTPStat);
			vty_out(vty,"%-5d %-20s %02X:%02X:%02X:%02X:%02X:%02X %-7d %-5d %-10s %-7s\n",WTP[i]->WTPID,WTP[i]->WTPNAME,WTP[i]->WTPMAC[0],\
				WTP[i]->WTPMAC[1],WTP[i]->WTPMAC[2],WTP[i]->WTPMAC[3],WTP[i]->WTPMAC[4],WTP[i]->WTPMAC[5],\
				WTP[i]->RadioCount,WTP[i]->WFR_Index,state,(WTP[i]->isused == 1)?on:off);
			
			free(WTP[i]->WTPMAC);
			WTP[i]->WTPMAC = NULL;
			free(WTP[i]);
			WTP[i] = NULL;
	}*/
	vty_out(vty,"==============================================================================\n");
	/*
	vty_out(vty,"%d WTP Join state\n",(ret != 0)?0:WTPINFO->join_num);
	vty_out(vty,"%d WTP Configure state\n",(ret != 0)?0:WTPINFO->configure_num);
	vty_out(vty,"%d WTP Datacheck state\n",(ret != 0)?0:WTPINFO->datacheck_num);
	vty_out(vty,"%d WTP Run state\n",(ret != 0)?0:WTPINFO->run_num);
	vty_out(vty,"%d WTP Imagedata state\n",(ret != 0)?0:WTPINFO->imagedata_num);
	vty_out(vty,"%d WTP Bak_run state\n",(ret != 0)?0:WTPINFO->bak_run_num);
	vty_out(vty,"%d WTP Quit state\n",(ret != 0)?0:WTPINFO->quit_num);
	vty_out(vty,"----------------------------------------------------------------------\n");
	*/
//	CW_FREE_OBJECT(WTPINFO->WTP_INFO);
//	CW_FREE_OBJECT(WTPINFO);
	return CMD_SUCCESS;
	
}

//fengwenchao add 20110226 for requirments-144
DEFUN(show_wtp_list_by_model_func,
	  show_wtp_list_by_model_cmd,
	  "show wtp list by model MODEL",
	  SHOW_STR
	  "Display wtps information\n"
	  "List wtp by model\n"
	 )
{
	char on[] = "used";
	char off[] = "unused";
	char state[20];
	//char ip[WTP_WTP_IP_LEN+1];
	//unsigned int result = 0;
	int ret = 0;
	int i=0;
	int retmodel = 0;
	int j = 0;
	char* Input_model = NULL;
	int Input_model_num = 0;
	int wtp_model_type = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;

	struct WTP_MODEL_VERSION **WTP_MODEL = NULL;
	
	//printf("argv[0]= %s \n",argv[0]);
	if(argv[0] == NULL)
	{
		ret = -1;
	}
	//printf("ret =  %d \n",ret);

	if(ret != 0)
		{
		vty_out(vty,"<error> input error\n");
		return CMD_SUCCESS;			
		}

	Input_model = malloc(strlen(argv[0])+1);
	memset(Input_model,0,strlen(argv[0])+1);
	memcpy(Input_model,argv[0],strlen(argv[0]));
	//printf("Input_model = %s  \n",Input_model);
	DCLI_WTP_API_GROUP_ONE *WTPINFO = NULL;
	
	
	if(vty->node == CONFIG_NODE)
		{
			index = 0;
		}
	else if(vty->node == HANSI_NODE)
		{
			index = vty->index;
			localid = vty->local;
			slot_id = vty->slotindex;
		}
	else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	WTPINFO = dcli_wtp_show_api_group_one(
	   index,
	   ELEVENTH,
	   0,
	   0,
	   0,
	   0,/**/
	   &ret,/*num2*/
	   0,
	   0,
	   0,
	   &localid,//num6
	 //  WTPINFO,
	   dcli_dbus_connection,
	   WID_DBUS_CONF_METHOD_SHOWWTP_BYMODEL
	   );
	//printf("ret = %d   \n",ret);
    vty_out(vty,"wtp list summary:\n");	
	vty_out(vty,"Total WTP num :  %d\n",(ret != 0)?0:WTPINFO->num);
    vty_out(vty,"%d WTPs Online\n",(ret != 0)?0:WTPINFO->TotalNum);
    vty_out(vty,"==============================================================================\n");
	vty_out(vty,"%-5s %-17s %-10s %-7s %-7s %-7s %-7s %-7s\n","WTPID","WTPMAC","WTPMODEL","APCODE","SOFTVERSION","CODEVER","RunState","State");
	if(ret == -1)
		{
			cli_syslog_info("<error> failed get reply.\n");
		}
	else if(ret == 0)
		{
			if((WTPINFO)&&(WTPINFO->WTP)&&(WTPINFO->WTP_M_V))
				{
					WID_WTP **head = NULL;
					//WID_WTP *wtpstate = NULL;
					//wtpstate = WTPINFO->WTP_INFO->WTP_LIST;
					WTP_MODEL =  WTPINFO->WTP_M_V;
					head = WTPINFO->WTP;

					//printf("WTPINFO->num = %d \n",WTPINFO->num);
					for (i = 0; i < WTPINFO->num; i++)
					{	
						//	printf("head->WTPModel = %s \n",head[i]->WTPModel);
						if(!strcmp(Input_model,head[i]->WTPModel))
							{
								CheckWTPState(state,head[i]->WTPStat);									
								vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-10s %-10s %-7s %-10s %-10s %-10s\n",
										head[i]->WTPID,
										head[i]->WTPMAC[0],head[i]->WTPMAC[1],head[i]->WTPMAC[2],head[i]->WTPMAC[3],head[i]->WTPMAC[4],head[i]->WTPMAC[5],
										head[i]->WTPModel,
										head[i]->APCode,
										head[i]->ver,
										head[i]->codever,
										state,
										(head[i]->isused == 1)?on:off);
								Input_model_num++;
							}
						else
							{
								//printf("wo kao~~~~bu shi ba!~~~ou~~~NO~~~~\n");
							}
						//wtpstate = wtpstate->next;																																																							
										
					}

					if(Input_model_num == 0)
						{
							vty_out(vty,"There is no model same with inputing\n");							
						}
					
					vty_out(vty,"==============================================================================\n");
					
					for(i = 0; i < WTPINFO->wtp_model_type; i++)
					{
						//vty_out(vty,"\n");
						vty_out(vty,"MODEL : %s  num :  %d\n",WTP_MODEL[i]->wtp_model,WTP_MODEL[i]->wtp_model_num);
						/*for(j = 0; j < WTP_MODEL[i]->wtpid_flag; j++)
						{
							vty_out(vty,"(WTPID : %d \n)",WTP_MODEL[i]->wtpid_group[j]);
						}*/
					}					
				}
			else
				{
					//printf("ou ~~~~~NO~~~NO~~~NO~~~NO!\n");
				}
			dcli_wtp_free_fun(WID_DBUS_CONF_METHOD_SHOWWTP_BYMODEL,WTPINFO);

		}
	vty_out(vty,"==============================================================================\n");
	CW_FREE_OBJECT(Input_model);
	return CMD_SUCCESS;	
}
//fengwenchao add end

//fengwenchao add 20110226 for requirments-144
DEFUN(show_wtp_list_by_version_func,
	  show_wtp_list_by_version_cmd,
	  "show wtp list by version VERSION",
	  SHOW_STR
	  "Display wtps information\n"
	  "List wtp by version\n"
	 )
{
	char on[] = "used";
	char off[] = "unused";
	char state[20];

	int ret = 0;
	int i=0;
	int retmodel = 0;
	int j = 0;

	char* Input_version = NULL;
	int Input_version_num = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;

	struct WTP_MODEL_VERSION **WTP_VERSION = NULL;
	
	if(argv[0] == NULL)
	{
		ret = -1;
	}

	if(ret != 0)
		{
		vty_out(vty,"<error> input error\n");
		return CMD_SUCCESS;			
		}

	Input_version = malloc(strlen(argv[0])+1);
	memset(Input_version,0,strlen(argv[0])+1);
	memcpy(Input_version,argv[0],strlen(argv[0]));
	
	DCLI_WTP_API_GROUP_ONE *WTPINFO = NULL;
	
	
	if(vty->node == CONFIG_NODE)
		{
			index = 0;
		}
	else if(vty->node == HANSI_NODE)
		{
			index = vty->index;
			localid = vty->local;
			slot_id = vty->slotindex;
		}
	else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	WTPINFO = dcli_wtp_show_api_group_one(
	   index,
	   TWELFTH,
	   0,
	   0,
	   0,
	   0,/**/
	   &ret,/*num2*/
	   0,
	   0,
	   0,
	   &localid,//num6
	 //  WTPINFO,
	   dcli_dbus_connection,
	   WID_DBUS_CONF_METHOD_SHOWWTP_BYVERSION  
	   );
	//printf("ret = %d   \n",ret);
    vty_out(vty,"wtp list summary:\n");	
	vty_out(vty,"Total WTP num :  %d\n",(ret != 0)?0:WTPINFO->num);
    vty_out(vty,"%d WTPs Online\n",(ret != 0)?0:WTPINFO->TotalNum);
    vty_out(vty,"==============================================================================\n");
	vty_out(vty,"%-5s %-17s %-10s %-7s %-7s %-7s %-7s %-7s\n","WTPID","WTPMAC","WTPMODEL","APCODE","SOFTVERSION","CODEVER","RunState","State");
	if(ret == -1)
		{
			cli_syslog_info("<error> failed get reply.\n");
		}
	else if(ret == 0)
		{
			if((WTPINFO)&&(WTPINFO->WTP)&&(WTPINFO->WTP_M_V))
				{

					WID_WTP **head = NULL;

					WTP_VERSION =  WTPINFO->WTP_M_V;
					head = WTPINFO->WTP;

					for (i = 0; i < WTPINFO->num; i++)
					{	
						if(!strcmp(Input_version,head[i]->codever))
							{		
								CheckWTPState(state,head[i]->WTPStat);	
								vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-10s %-10s %-7s %-10s %-10s %-10s\n",
										head[i]->WTPID,
										head[i]->WTPMAC[0],head[i]->WTPMAC[1],head[i]->WTPMAC[2],head[i]->WTPMAC[3],head[i]->WTPMAC[4],head[i]->WTPMAC[5],
										head[i]->WTPModel,
										head[i]->APCode,
										head[i]->ver,
										head[i]->codever,
										state,
										(head[i]->isused == 1)?on:off);
								Input_version_num++;
							}																																																															
					}

					if(Input_version_num == 0)
						{
							vty_out(vty,"There is no model same with inputing\n");							
						}
					
					vty_out(vty,"==============================================================================\n");
					//printf("WTPINFO->wtp_version_type =  %d \n",WTPINFO->wtp_version_type);
					for(i = 0; i < WTPINFO->wtp_version_type; i++)
					{
						vty_out(vty,"MODEL : %s  num :  %d\n",WTP_VERSION[i]->wtp_version,WTP_VERSION[i]->wtp_version_num);
					}					
				}
			else
				{
					//printf("ou ~~~~~NO~~~NO~~~NO~~~NO!\n");
				}
			dcli_wtp_free_fun(WID_DBUS_CONF_METHOD_SHOWWTP_BYVERSION,WTPINFO);

		}
	vty_out(vty,"==============================================================================\n");
	CW_FREE_OBJECT(Input_version);
	return CMD_SUCCESS;	
}
//fengwenchao add end

DEFUN(show_wtp_list_by_state_func,
	  show_wtp_list_by_state_cmd,
	  "show wtp list by state (join|configure|datacheck|run|quit|imagedata|bak_run) [remote] [local] [PARAMETER]",
	  SHOW_STR
	  "Display wtps information\n"
	  "List wtp by state\n"
	  "by wtp state\n"
	  "by wtp state\n"
	  "choose state include join|configure|datacheck|run|quit|imagedata|bak_run\n"
	  "configure state\n"
	  "datacheck state\n"
	  "run state\n"
	  "quit state\n"
	  "imagedata state\n"
	  "bak_run state\n"
	  "'remote' or 'local' hansi\n"
	  "'remote' or 'local' hansi\n"
	  "slotid-instid\n"
	 )
{
/*	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;		*/
	char on[] = "used";
	char off[] = "unused";
	char state[20];
	char ip[WTP_WTP_IP_LEN+1];
	unsigned int result = 0;
//	WID_WTP **WTP;	
	int ret,i=0;
//	unsigned int num = 0;
//	unsigned int TotalNum = 0;

	int profile = 0;
	int instRun = 0;
	int flag = 0;
	unsigned char inputstate = 0;

	//parameter check start
	if (!strcmp(argv[0],"join"))
	{
		inputstate = 2;	
	}		
	else if (!strcmp(argv[0],"configure"))
	{
		inputstate = 3;
	}
	else if (!strcmp(argv[0],"datacheck"))
	{
		inputstate = 4;
	}
	else if (!strcmp(argv[0],"run"))
	{
		inputstate = 5;
	}
	else if (!strcmp(argv[0],"quit"))
	{
		inputstate = 7;
	}	
	else if (!strcmp(argv[0],"imagedata"))
	{
		inputstate = 8;
	}
	else if (!strcmp(argv[0],"bak_run"))
	{
		inputstate = 9;
	}		
	else
	{
		vty_out(vty,"<error> input patameter should only be join|configure|datacheck|run|quit|imagedata|bak_run\n");
		return CMD_SUCCESS;
	}


	
	//parameter check end

	
//	WTP = malloc(WTP_NUM*(sizeof(WID_WTP *)));
	DCLI_WTP_API_GROUP_ONE *WTPINFO = NULL;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	if((argc == 2)||(argc == 4)){
		vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
		return CMD_SUCCESS;
	}
	if(argc == 3){
		if (!strcmp(argv[1],"remote")){
			localid = 0;
		}else if(!strcmp(argv[1],"local")){
			localid = 1;
		}else{
			vty_out(vty,"parameter should be 'remote' or 'local'\n");
			return CMD_SUCCESS;
		}
		
		if((!strcmp(argv[1],"remote"))&&(!strcmp(argv[2],"local"))){
			vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
			return CMD_SUCCESS;
		}
		
		ret = parse_slot_hansi_id((char*)argv[2],&slot_id,&profile);
		if(ret != WID_DBUS_SUCCESS){
			slot_id = HostSlotId;
			flag = 1;
			ret = parse_int_ID((char*)argv[2], &profile);
			if(ret != WID_DBUS_SUCCESS){
				if(ret == WID_ILLEGAL_INPUT){
					vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
				}
				else{
					vty_out(vty,"<error> unknown id format\n");
				}
				return CMD_WARNING;
			}	
		}
		if(distributFag == 0){
			if(slot_id != 0){
				vty_out(vty,"<error> slot id should be 0\n");
				return CMD_WARNING;
			}	
		}else if(flag == 1){
			slot_id = HostSlotId;
		}
		if(slot_id >= MAX_SLOT_NUM || slot_id < 0){
			vty_out(vty,"<error> slot id should be 1 to %d\n",MAX_SLOT_NUM-1);
			return CMD_WARNING;
		}	
		if(profile >= MAX_INSTANCE || profile == 0){
			vty_out(vty,"<error> hansi id should be 1 to %d\n",MAX_INSTANCE-1);
			return CMD_WARNING;
		}
		instRun = dcli_hmd_hansi_is_running(vty,slot_id,localid,profile);
		if (INSTANCE_NO_CREATED == instRun) {
			vty_out(vty,"<error> the instance %s %d-%d is not running\n",((localid == 1)?"local-hansi":"hansi"),slot_id,profile);
			return CMD_WARNING;
		}
		
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		if(localid == 0)
			goto hansi_parameter;
		else if(localid == 1)
			goto local_hansi_parameter; 
	}
#if 0	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST_NEW);
	
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST_NEW);*/
	dbus_error_init(&err);
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);	
	dbus_message_unref(query);
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		free(WTP);
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0 ){
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&num);
	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_recurse(&iter,&iter_array);
		
		for (i = 0; i < num; i++) {
			DBusMessageIter iter_struct;
			
			WTP[i] = (WID_WTP*)malloc(sizeof(WID_WTP));
			WTP[i]->WTPMAC = (unsigned char *)malloc(MAC_LEN +1);
			memset(WTP[i]->WTPMAC,0,(MAC_LEN +1));
			dbus_message_iter_recurse(&iter_array,&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPID));
		
			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[0]);
			
			dbus_message_iter_next(&iter_struct);

			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[1]);
			
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[2]);
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[3]);
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[4]);
		
			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[5]);	
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPIP));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPModel));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPStat));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->isused));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPNAME));

			dbus_message_iter_next(&iter_array);

			if(WTP[i]->WTPStat == 5)
			{
				TotalNum++;
			}
		}
	}
	
	dbus_message_unref(reply);
#endif	
	if(vty->node != VIEW_NODE){
		WTPINFO = dcli_wtp_show_api_group_one(
		   index,
		   SECOND,/*"show wtp list by state (join|configure|datacheck|run|quit|imagedata|bak_run)"*/
		   0,
		   0,
		   0,
		   0,/**/
		   &ret,/*num2*/
		   0,
		   0,
		   0,
		   &localid,//num6
		 //  WTPINFO,
		   dcli_dbus_connection,
		   WID_DBUS_CONF_METHOD_WTPLIST_NEW
		   );
	    vty_out(vty,"wtp list summary:\n");	
	    vty_out(vty,"%d WTPs Online\n",(ret != 0)?0:WTPINFO->TotalNum);
	    vty_out(vty,"==============================================================================\n");
		vty_out(vty,"%-5s %-17s %-21s %-10s %-7s\n","WTPID","WTPMAC","WTPIP","RunState","State");
		if(ret == -1){
			cli_syslog_info("<error> failed get reply.\n");
		}
		else if(ret == 0){
			if((WTPINFO)&&(WTPINFO->WTP_INFO)&&(WTPINFO->WTP_INFO->WTP_LIST)){
				WID_WTP *head = NULL;
				head = WTPINFO->WTP_INFO->WTP_LIST;
				for (i = 0; i < WTPINFO->num; i++) {	
					//added filter method
					if(inputstate == head->WTPStat)
					{
						CheckWTPState(state,head->WTPStat);
						result = wtp_check_wtp_ip_addr(ip,head->WTPIP);
						if(result != 1)
						{
							vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-21s %-10s %-7s\n",
								head->WTPID,
								head->WTPMAC[0],head->WTPMAC[1],head->WTPMAC[2],head->WTPMAC[3],head->WTPMAC[4],head->WTPMAC[5],
								head->WTPIP,
								state,
								(head->isused == 1)?on:off);
						}
						else
						{
							vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-21s %-10s %-7s\n",
								head->WTPID,
								head->WTPMAC[0],head->WTPMAC[1],head->WTPMAC[2],head->WTPMAC[3],head->WTPMAC[4],head->WTPMAC[5],
								ip,
								state,
								(head->isused == 1)?on:off);
						}
					}
					//CW_FREE_OBJECT(head->WTPMAC);
					head = head->next;				
				//	free(WTP[i]->WTPMAC);
				//	WTP[i]->WTPMAC = NULL;
				//	free(WTP[i]);
				//	WTP[i] = NULL;
				}
			}
		//	CW_FREE_OBJECT(WTPINFO->WTP_INFO->WTP_LIST);
		dcli_wtp_free_fun(WID_DBUS_CONF_METHOD_WTPLIST_NEW,WTPINFO);
		}
		vty_out(vty,"==============================================================================\n");
	//	CW_FREE_OBJECT(WTPINFO->WTP_INFO);
	//	CW_FREE_OBJECT(WTPINFO);
	}
	
	if(vty->node == VIEW_NODE){
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 0;
			
			//for remote hansi info
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,0,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}

	 hansi_parameter:
			WTPINFO = dcli_wtp_show_api_group_one(
				   profile,
				   SECOND,/*"show wtp list by state (join|configure|datacheck|run|quit|imagedata|bak_run)"*/
				   0,
				   0,
				   0,
				   0,/**/
				   &ret,/*num2*/
				   0,
				   0,
				   0,
				   &localid,//num6
				   dcli_dbus_connection,
				   WID_DBUS_CONF_METHOD_WTPLIST_NEW
				   );
				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"hansi %d-%d\n",slot_id,profile);
				vty_out(vty,"-----------------------------------------------------------------------------\n");
				vty_out(vty,"wtp list summary:\n"); 
				vty_out(vty,"%d WTPs Online\n",(ret != 0)?0:WTPINFO->TotalNum);
				vty_out(vty,"=========================================================================\n");
				vty_out(vty,"%-5s %-17s %-21s %-10s %-7s\n","WTPID","WTPMAC","WTPIP","RunState","State");
				if(ret == -1){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == 0){
					if((WTPINFO)&&(WTPINFO->WTP_INFO)&&(WTPINFO->WTP_INFO->WTP_LIST)){
						WID_WTP *head = NULL;
						head = WTPINFO->WTP_INFO->WTP_LIST;
						for (i = 0; i < WTPINFO->num; i++) {	
							//added filter method
							if(inputstate == head->WTPStat)
							{
								CheckWTPState(state,head->WTPStat);
								result = wtp_check_wtp_ip_addr(ip,head->WTPIP);
								if(result != 1)
								{
									vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-21s %-10s %-7s\n",
										head->WTPID,
										head->WTPMAC[0],head->WTPMAC[1],head->WTPMAC[2],head->WTPMAC[3],head->WTPMAC[4],head->WTPMAC[5],
										head->WTPIP,
										state,
										(head->isused == 1)?on:off);
								}
								else
								{
									vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-21s %-10s %-7s\n",
										head->WTPID,
										head->WTPMAC[0],head->WTPMAC[1],head->WTPMAC[2],head->WTPMAC[3],head->WTPMAC[4],head->WTPMAC[5],
										ip,
										state,
										(head->isused == 1)?on:off);
								}
							}
							head = head->next;				
						}
					}
				dcli_wtp_free_fun(WID_DBUS_CONF_METHOD_WTPLIST_NEW,WTPINFO);
				}
				vty_out(vty,"==============================================================================\n");
				if(argc == 3){
					return CMD_SUCCESS;
				}
			}
		}

	//for local hansi info
	for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		localid = 1;
		
		for (profile = 1; profile < MAX_INSTANCE; profile++) 
		{
			instRun = dcli_hmd_hansi_is_running(vty,slot_id,1,profile);
			if (INSTANCE_NO_CREATED == instRun) {
				continue;
			}
	
	 local_hansi_parameter:
			WTPINFO = dcli_wtp_show_api_group_one(
				   profile,
				   SECOND,/*"show wtp list by state (join|configure|datacheck|run|quit|imagedata|bak_run)"*/
				   0,
				   0,
				   0,
				   0,/**/
				   &ret,/*num2*/
				   0,
				   0,
				   0,
				   &localid,//num6
				   dcli_dbus_connection,
				   WID_DBUS_CONF_METHOD_WTPLIST_NEW
				   );
				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"local hansi %d-%d\n",slot_id,profile);
				vty_out(vty,"-----------------------------------------------------------------------------\n");
				vty_out(vty,"wtp list summary:\n"); 
				vty_out(vty,"%d WTPs Online\n",(ret != 0)?0:WTPINFO->TotalNum);
				vty_out(vty,"=========================================================================\n");
				vty_out(vty,"%-5s %-17s %-21s %-10s %-7s\n","WTPID","WTPMAC","WTPIP","RunState","State");
				if(ret == -1){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == 0){
					if((WTPINFO)&&(WTPINFO->WTP_INFO)&&(WTPINFO->WTP_INFO->WTP_LIST)){
						WID_WTP *head = NULL;
						head = WTPINFO->WTP_INFO->WTP_LIST;
						for (i = 0; i < WTPINFO->num; i++) {	
							//added filter method
							if(inputstate == head->WTPStat)
							{
								CheckWTPState(state,head->WTPStat);
								result = wtp_check_wtp_ip_addr(ip,head->WTPIP);
								if(result != 1)
								{
									vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-21s %-10s %-7s\n",
										head->WTPID,
										head->WTPMAC[0],head->WTPMAC[1],head->WTPMAC[2],head->WTPMAC[3],head->WTPMAC[4],head->WTPMAC[5],
										head->WTPIP,
										state,
										(head->isused == 1)?on:off);
								}
								else
								{
									vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-21s %-10s %-7s\n",
										head->WTPID,
										head->WTPMAC[0],head->WTPMAC[1],head->WTPMAC[2],head->WTPMAC[3],head->WTPMAC[4],head->WTPMAC[5],
										ip,
										state,
										(head->isused == 1)?on:off);
								}
							}
							head = head->next;				
						}
					}
				dcli_wtp_free_fun(WID_DBUS_CONF_METHOD_WTPLIST_NEW,WTPINFO);
				}
				vty_out(vty,"==============================================================================\n");
				if(argc == 3){
					return CMD_SUCCESS;
				}
			}
		}
	}
	return CMD_SUCCESS;
	
}

DEFUN(show_wtp_list_by_ip_func,
	  show_wtp_list_by_ip_cmd,
	  "show wtp list by ip IP mask [MASk]",
	  SHOW_STR
	  "Display wtps information\n"
	  "List wtp by ip\n"
		"ip address\n"
		"ip address like 192.168.8.11\n"
		"subnet mask\n"
		"subnet mask like 255.255.0.0\n"
	 )
{
/*	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;	*/	
	char on[] = "used";
	char off[] = "unused";
	char state[20];
	char ip[WTP_WTP_IP_LEN+1];
	unsigned int result = 0;
//	WID_WTP **WTP;	
	int ret,ret1,i=0;
//	unsigned int num = 0;
//	unsigned int TotalNum = 0;

	unsigned long ipaddr = 0;
	unsigned long mask = 0;
	char apip[WID_SYSTEM_CMD_LENTH];
	char *delim=":";
	char *papip = NULL;
	char general_mask[] = "255.255.255.255";    //fengwenchao add 20110621


	//parameter check start
	
	ret = WID_Check_IP_Format((char*)argv[0]);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown ip format\n");
		return CMD_SUCCESS;
	}
	
	ipaddr = dcli_ip2ulong((char*)argv[0]);

	if(2 == argc)
	{
		ret1 = WID_Check_Mask_Format((char*)argv[1]);
		if(ret1 != WID_DBUS_SUCCESS){
			vty_out(vty,"<error> unknown mask format\n");
			return CMD_SUCCESS;
		}
		if(check_mask_Legal((char*)argv[1]))
		{
			vty_out(vty,"<error>mask is not legal format\n");
			return CMD_SUCCESS;		
		}
		mask = dcli_ip2ulong((char*)argv[1]);
	}
	else
	{
		mask = dcli_ip2ulong((char*)general_mask);
	}	
	//parameter check end

	
	//WTP = malloc(WTP_NUM*(sizeof(WID_WTP *)));
	DCLI_WTP_API_GROUP_ONE *WTPINFO = NULL;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
#if 0	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST_NEW);
	
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST_NEW);*/
	
	dbus_error_init(&err);
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);	
	dbus_message_unref(query);
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		free(WTP);
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0 ){
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&num);
	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_recurse(&iter,&iter_array);
		
		for (i = 0; i < num; i++) {
			DBusMessageIter iter_struct;
			
			WTP[i] = (WID_WTP*)malloc(sizeof(WID_WTP));
			WTP[i]->WTPMAC = (unsigned char *)malloc(MAC_LEN +1);
			memset(WTP[i]->WTPMAC,0,(MAC_LEN +1));
			dbus_message_iter_recurse(&iter_array,&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPID));
		
			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[0]);
			
			dbus_message_iter_next(&iter_struct);

			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[1]);
			
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[2]);
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[3]);
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[4]);
		
			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[5]);	
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPIP));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPModel));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPStat));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->isused));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPNAME));

			dbus_message_iter_next(&iter_array);

			if(WTP[i]->WTPStat == 5)
			{
				TotalNum++;
			}
		}
	}
	
	dbus_message_unref(reply);
#endif	
	WTPINFO = dcli_wtp_show_api_group_one(
	   index,
	   SECOND,/*"show wtp list by ip IP mask MASk"*/
	   0,
	   0,
	   0,
	   0,/**/
	   &ret,/*num2*/
	   0,
	   0,
	   0,
	   &localid,//num6
	 //  WTPINFO,
	   dcli_dbus_connection,
	   WID_DBUS_CONF_METHOD_WTPLIST_NEW
	   );
    vty_out(vty,"wtp list summary:\n");	
    vty_out(vty,"%d WTPs Online\n",(ret != 0)?0:WTPINFO->TotalNum);
    vty_out(vty,"==============================================================================\n");
	vty_out(vty,"%-5s %-17s %-21s %-10s %-7s\n","WTPID","WTPMAC","WTPIP","RunState","State");
	if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == 0){
		if((WTPINFO)&&(WTPINFO->WTP_INFO)&&(WTPINFO->WTP_INFO->WTP_LIST)){
			WID_WTP *head = NULL;
			head = WTPINFO->WTP_INFO->WTP_LIST;
			for (i = 0; i < WTPINFO->num; i++) {	
					CheckWTPState(state,head->WTPStat);
					result = wtp_check_wtp_ip_addr(ip,head->WTPIP);
					if(result != 1)
					{
						memset(apip,0,WID_SYSTEM_CMD_LENTH);
						papip = NULL;

						strcpy(apip,head->WTPIP);
						papip = strtok(apip,delim);
						
						if(1 == check_ip_with_mask(ipaddr,mask,papip))
						{
							vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-21s %-10s %-7s\n",
							head->WTPID,
							head->WTPMAC[0],head->WTPMAC[1],head->WTPMAC[2],head->WTPMAC[3],head->WTPMAC[4],head->WTPMAC[5],
							head->WTPIP,
							state,
							(head->isused == 1)?on:off);
						}
					}
				
			//	CW_FREE_OBJECT(head->WTPMAC);
				head = head->next;
			}
		}
	//	CW_FREE_OBJECT(WTPINFO->WTP_INFO->WTP_LIST);
		dcli_wtp_free_fun(WID_DBUS_CONF_METHOD_WTPLIST_NEW,WTPINFO);
	}
	vty_out(vty,"==============================================================================\n");
//	CW_FREE_OBJECT(WTPINFO->WTP_INFO);
//	CW_FREE_OBJECT(WTPINFO);
	return CMD_SUCCESS;
	
}

DEFUN(show_wtp_list_by_macex_func,
	  show_wtp_list_by_macex_cmd,
	  "show wtp list by mac MAC mask [MASk]",
	  SHOW_STR
	  "Display wtps information\n"
	  "List wtp by mac\n"
		"mac address\n"
		"mac address like 00:1F:64:E0:01:90\n"
		"mac mask\n"
		"mac mask like 00:00:00:00:00:FF\n"
	 )
{
/*	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;		*/
	char on[] = "used";
	char off[] = "unused";
	char state[20];
	char ip[WTP_WTP_IP_LEN+1];
	unsigned int result = 0;
	WID_WTP **WTP;	
	int ret,ret1,i=0;
//	unsigned int num = 0;
//	unsigned int TotalNum = 0;

	char general_mask[] = "FF:FF:FF:FF:FF:FF";    //fengwenchao add 20110621
	WIDMACADDR  macaddr;
	WIDMACADDR  macmask;

	//parameter check start

	ret = wid_parse_mac_addr((char *)argv[0],&macaddr);
	if (CMD_FAILURE == ret) {
		vty_out(vty,"<error> Unknown mac addr format.\n");
		return CMD_FAILURE;
	}
	if(2 == argc)
	{
		ret = wid_parse_mac_addr((char *)argv[1],&macmask);
		if (CMD_FAILURE == ret) {
			vty_out(vty,"<error> Unknown macmask addr format.\n");
			return CMD_FAILURE;
		}
	}
	else
	{
		ret = wid_parse_mac_addr((char *)general_mask,&macmask);
	}
	
	//parameter check end

	
	//WTP = malloc(WTP_NUM*(sizeof(WID_WTP *)));
	DCLI_WTP_API_GROUP_ONE *WTPINFO = NULL;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
#if 0
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST_NEW);
	
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST_NEW);*/
	dbus_error_init(&err);
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);	
	dbus_message_unref(query);
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		free(WTP);
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0 ){
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&num);
	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_recurse(&iter,&iter_array);
		
		for (i = 0; i < num; i++) {
			DBusMessageIter iter_struct;
			
			WTP[i] = (WID_WTP*)malloc(sizeof(WID_WTP));
			WTP[i]->WTPMAC = (unsigned char *)malloc(MAC_LEN +1);
			memset(WTP[i]->WTPMAC,0,(MAC_LEN +1));
			dbus_message_iter_recurse(&iter_array,&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPID));
		
			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[0]);
			
			dbus_message_iter_next(&iter_struct);

			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[1]);
			
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[2]);
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[3]);
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[4]);
		
			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[5]);	
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPIP));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPModel));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPStat));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->isused));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPNAME));

			dbus_message_iter_next(&iter_array);

			if(WTP[i]->WTPStat == 5)
			{
				TotalNum++;
			}
		}
	}
	
	dbus_message_unref(reply);
#endif
	WTPINFO = dcli_wtp_show_api_group_one(
	   index,
	   SECOND,/*"show wtp list by mac MAC mask MASk"*/
	   0,
	   0,
	   0,
	   0,/**/
	   &ret,/*num2*/
	   0,
	   0,
	   0,
	   &localid,//num6
	//   WTPINFO,
	   dcli_dbus_connection,
	   WID_DBUS_CONF_METHOD_WTPLIST_NEW
	   );
    vty_out(vty,"wtp list summary:\n");	
    vty_out(vty,"%d WTPs Online\n",(ret != 0)?0:WTPINFO->TotalNum);
    vty_out(vty,"==============================================================================\n");
	vty_out(vty,"%-5s %-17s %-21s %-10s %-7s\n","WTPID","WTPMAC","WTPIP","RunState","State");
	if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == 0){
		if((WTPINFO)&&(WTPINFO->WTP_INFO)&&(WTPINFO->WTP_INFO->WTP_LIST)){
			WID_WTP *head = NULL;
			head = WTPINFO->WTP_INFO->WTP_LIST;
			for (i = 0; i < WTPINFO->num; i++) {	
				if(1 == check_mac_with_mask(&macaddr,&macmask,head->WTPMAC))
				{
					CheckWTPState(state,head->WTPStat);
					result = wtp_check_wtp_ip_addr(ip,head->WTPIP);
					if(result != 1)
					{
						vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-21s %-10s %-7s\n",
						head->WTPID,
						head->WTPMAC[0],head->WTPMAC[1],head->WTPMAC[2],head->WTPMAC[3],head->WTPMAC[4],head->WTPMAC[5],
						head->WTPIP,
						state,
						(head->isused == 1)?on:off);

					}
					else
					{
						vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-21s %-10s %-7s\n",
							head->WTPID,
							head->WTPMAC[0],head->WTPMAC[1],head->WTPMAC[2],head->WTPMAC[3],head->WTPMAC[4],head->WTPMAC[5],
							ip,
							state,
							(head->isused == 1)?on:off);
					}
				}
				
			//	CW_FREE_OBJECT(head->WTPMAC);
				head = head->next;				
			}
		}
		//CW_FREE_OBJECT(WTPINFO->WTP_INFO->WTP_LIST);
		dcli_wtp_free_fun(WID_DBUS_CONF_METHOD_WTPLIST_NEW,WTPINFO);
	}
	vty_out(vty,"==============================================================================\n");
//	CW_FREE_OBJECT(WTPINFO->WTP_INFO);
//	CW_FREE_OBJECT(WTPINFO);
	return CMD_SUCCESS;
	
}


DEFUN(diag_wtp_list_cmd_func,
	  diag_wtp_list_cmd,
	  "trace wtp (list|all)",
	  TRACE_STR
	  TRACE_WTP_STR
	  "Tracing all avialable wtps\n"
	  "Tracing all avialable wtps\n"
)
{
	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter  iter;
	DBusMessageIter  iter_array;		
	WID_WTP **WTP = NULL, *wtpNode = NULL;	
	int ret = 0, i = 0, fd = 0;
	char sflag = 0;
	unsigned int num = 0, test_num = 0;

	/* first check if the shell script exist */
	fd = open(TRACE_SCRIPT_NAME, O_RDONLY);
	if(fd < 0) {
		vty_out(vty, "%% Trace wtp failed due to core file missing\n");
		return CMD_WARNING;
	}
	else {
		close(fd);
	}

	WTP = malloc(WTP_NUM*(sizeof(WID_WTP *)));
	if(!WTP) {
		vty_out(vty, "%% Memory allocation error\r\n");
		return CMD_WARNING;
	}

	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST_NEW);
	
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST_NEW);*/
	dbus_error_init(&err);
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);	
	dbus_message_unref(query);
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		free(WTP);
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0 ){
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&num);
	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_recurse(&iter,&iter_array);
		for (i = 0; i < num; i++) {
			DBusMessageIter iter_struct;
			wtpNode = (WID_WTP*)malloc(sizeof(WID_WTP));
			if(!wtpNode) {
				vty_out(vty, "%% Memory allocation error when get wtp # %d\n",i);
				free(WTP);
				return CMD_WARNING;
			}
			memset(wtpNode, 0, sizeof(WID_WTP));
			wtpNode->WTPMAC = (unsigned char *)malloc(MAC_LEN +1);
			if(NULL == wtpNode->WTPMAC) {
				vty_out(vty, "%% Memory allocation error when get wtp # %d mac\n",i);
				free(wtpNode);
				free(WTP);
				return CMD_WARNING;
			}
			memset(wtpNode->WTPMAC,0,(MAC_LEN +1));
			dbus_message_iter_recurse(&iter_array,&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(wtpNode->WTPID));
		
			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&wtpNode->WTPMAC[0]);
			
			dbus_message_iter_next(&iter_struct);

			dbus_message_iter_get_basic(&iter_struct,&wtpNode->WTPMAC[1]);
			
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&wtpNode->WTPMAC[2]);
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&wtpNode->WTPMAC[3]);
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&wtpNode->WTPMAC[4]);
		
			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&wtpNode->WTPMAC[5]);	
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(wtpNode->WTPIP));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(wtpNode->WTPModel));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(wtpNode->WTPStat));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(wtpNode->isused));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPNAME));

			dbus_message_iter_next(&iter_array);
			if('\0' == wtpNode->WTPIP[0]) {

				free(wtpNode->WTPMAC);
				wtpNode->WTPMAC = NULL;
				free(wtpNode);
				wtpNode = NULL;
				
			}
			else {
				WTP[test_num] = wtpNode;
				test_num++;
			}
		}
	}
	
	dbus_message_unref(reply);
	
	if(ret == 0) {
		if(0 == test_num) {
			vty_out(vty, "%% No active wtp to trace!\n");
		}
		else {
			for (i = 0; i < test_num; i++) {
				sflag = (1 == test_num )? 'A': \
						((i == (test_num - 1)) ? 'L' : (i ? 'M' : 'F'));
				dcli_wtp_trace_script_exec(WTP[i]->WTPIP, WTP[i]->WTPID, sflag);
				free(WTP[i]->WTPMAC);
				WTP[i]->WTPMAC = NULL;
				free(WTP[i]);
				WTP[i] = NULL;
			}
		}
	}
	
	free(WTP);
	WTP = NULL;

	return CMD_SUCCESS;	
}


DEFUN(diag_wtp_list_bywlanid_cmd_func,
	  diag_wtp_list_bywlanid_cmd,
	  "trace wtp bywlanid ID",
	  TRACE_STR
	  TRACE_WTP_STR
	  "Tracing avialable wtps who binding wlan id\n"
	  "Tracing all avialable wtps who binding wlan id\n"
)
{
	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter  iter;
	DBusMessageIter  iter_array;		
	WID_WTP **WTP = NULL, *wtpNode = NULL;	
	int ret = 0, i = 0, fd = 0;
	char sflag = 0;
	unsigned int num = 0, test_num = 0;
	int wlanid = 0;
	ret = parse_int_ID((char*)argv[0], &wlanid);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}	
	if(wlanid >= WLAN_NUM || wlanid == 0){
		vty_out(vty,"<error> wlan id should be 1 to %d\n",WLAN_NUM-1);
		return CMD_SUCCESS;
	}

	/* first check if the shell script exist */
	fd = open(TRACE_SCRIPT_NAME, O_RDONLY);
	if(fd < 0) {
		vty_out(vty, "%% Trace wtp failed due to core file missing\n");
		return CMD_WARNING;
	}
	else {
		close(fd);
	}

	WTP = malloc(WTP_NUM*(sizeof(WID_WTP *)));
	if(!WTP) {
		vty_out(vty, "%% Memory allocation error\r\n");
		return CMD_WARNING;
	}

	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST_BYWLANID);
	
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST_BYWLANID);*/
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wlanid,
							 DBUS_TYPE_INVALID);	
	
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);	
	dbus_message_unref(query);
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		free(WTP);
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0 ){
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&num);
	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_recurse(&iter,&iter_array);
		for (i = 0; i < num; i++) {
			DBusMessageIter iter_struct;
			wtpNode = (WID_WTP*)malloc(sizeof(WID_WTP));
			if(!wtpNode) {
				vty_out(vty, "%% Memory allocation error when get wtp # %d\n",i);
				free(WTP);
				return CMD_WARNING;
			}
			memset(wtpNode, 0, sizeof(WID_WTP));
			wtpNode->WTPMAC = (unsigned char *)malloc(MAC_LEN +1);
			if(NULL == wtpNode->WTPMAC) {
				vty_out(vty, "%% Memory allocation error when get wtp # %d mac\n",i);
				free(wtpNode);
				free(WTP);
				return CMD_WARNING;
			}
			memset(wtpNode->WTPMAC,0,(MAC_LEN +1));
			dbus_message_iter_recurse(&iter_array,&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(wtpNode->WTPID));
		
			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&wtpNode->WTPMAC[0]);
			
			dbus_message_iter_next(&iter_struct);

			dbus_message_iter_get_basic(&iter_struct,&wtpNode->WTPMAC[1]);
			
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&wtpNode->WTPMAC[2]);
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&wtpNode->WTPMAC[3]);
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&wtpNode->WTPMAC[4]);
		
			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&wtpNode->WTPMAC[5]);	
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(wtpNode->WTPIP));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(wtpNode->WTPModel));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(wtpNode->WTPStat));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(wtpNode->isused));

			dbus_message_iter_next(&iter_array);
			if('\0' == wtpNode->WTPIP[0]) {

				free(wtpNode->WTPMAC);
				wtpNode->WTPMAC = NULL;
				free(wtpNode);
				wtpNode = NULL;
				
			}
			else {
				WTP[test_num] = wtpNode;
				test_num++;
			}
		}
	}
	else if (ret == WLAN_ID_NOT_EXIST)
	{
		vty_out(vty,"<error> wlan id does not exist\n");
	}
	
	dbus_message_unref(reply);
	
	if(ret == 0) {
		if(0 == test_num) {
			vty_out(vty, "%% No active wtp to trace!\n");
		}
		else {
			for (i = 0; i < test_num; i++) {
				sflag = (1 == test_num )? 'A': \
						((i == (test_num - 1)) ? 'L' : (i ? 'M' : 'F'));

				dcli_wtp_trace_script_exec(WTP[i]->WTPIP, WTP[i]->WTPID, sflag);
				free(WTP[i]->WTPMAC);
				WTP[i]->WTPMAC = NULL;
				free(WTP[i]);
				WTP[i] = NULL;
			}
		}
	}
	
	free(WTP);
	WTP = NULL;

	return CMD_SUCCESS;	
}

DEFUN(btrace_wtp_list_bywlanid_cmd_func,
	  btrace_wtp_list_bywlanid_cmd,
	  "btrace wtp bywlanid ID",
	  TRACE_STR
	  TRACE_WTP_STR
	  "Bandwidth tracing avialable wtps who binding wlan id\n"
	  "Bandwidth tracing all avialable wtps who binding wlan id\n"
)
{
	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter  iter;
	DBusMessageIter  iter_array;		
	WID_WTP **WTP = NULL, *wtpNode = NULL;	
	int ret = 0, i = 0, fd = 0;
	char sflag = 0,tflag = 0;
	unsigned int num = 0, test_num = 0;
	int wlanid = 0;
	ret = parse_int_ID((char*)argv[0], &wlanid);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}	
	if(wlanid >= WLAN_NUM || wlanid == 0){
		vty_out(vty,"<error> wlan id should be 1 to %d\n",WLAN_NUM-1);
		return CMD_SUCCESS;
	}

	/* first check if the shell script exist */
	fd = open(BTRACE_SCRIPT_NAME, O_RDONLY);
	if(fd < 0) {
		vty_out(vty, "%% Bandwidth trace wtp failed due to core file missing\n");
		return CMD_WARNING;
	}
	else {
		close(fd);
	}

	WTP = malloc(WTP_NUM*(sizeof(WID_WTP *)));
	if(!WTP) {
		vty_out(vty, "%% Memory allocation error\r\n");
		return CMD_WARNING;
	}

	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST_BYWLANID);
	
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST_BYWLANID);*/
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wlanid,
							 DBUS_TYPE_INVALID);	
	
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);	
	dbus_message_unref(query);
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		free(WTP);
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0 ){
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&num);
	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_recurse(&iter,&iter_array);
		for (i = 0; i < num; i++) {
			DBusMessageIter iter_struct;
			wtpNode = (WID_WTP*)malloc(sizeof(WID_WTP));
			if(!wtpNode) {
				vty_out(vty, "%% Memory allocation error when get wtp # %d\n",i);
				free(WTP);
				return CMD_WARNING;
			}
			memset(wtpNode, 0, sizeof(WID_WTP));
			wtpNode->WTPMAC = (unsigned char *)malloc(MAC_LEN +1);
			if(NULL == wtpNode->WTPMAC) {
				vty_out(vty, "%% Memory allocation error when get wtp # %d mac\n",i);
				free(wtpNode);
				free(WTP);
				return CMD_WARNING;
			}
			memset(wtpNode->WTPMAC,0,(MAC_LEN +1));
			dbus_message_iter_recurse(&iter_array,&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(wtpNode->WTPID));
		
			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&wtpNode->WTPMAC[0]);
			
			dbus_message_iter_next(&iter_struct);

			dbus_message_iter_get_basic(&iter_struct,&wtpNode->WTPMAC[1]);
			
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&wtpNode->WTPMAC[2]);
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&wtpNode->WTPMAC[3]);
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&wtpNode->WTPMAC[4]);
		
			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&wtpNode->WTPMAC[5]);	
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(wtpNode->WTPIP));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(wtpNode->WTPModel));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(wtpNode->WTPStat));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(wtpNode->isused));

			dbus_message_iter_next(&iter_array);
			if('\0' == wtpNode->WTPIP[0]) {

				free(wtpNode->WTPMAC);
				wtpNode->WTPMAC = NULL;
				free(wtpNode);
				wtpNode = NULL;
				
			}
			else {
				WTP[test_num] = wtpNode;
				test_num++;
			}
		}
	}
	else if (ret == WLAN_ID_NOT_EXIST)
	{
		vty_out(vty,"<error> wlan id does not exist\n");
	}
	
	dbus_message_unref(reply);
	
	if(ret == 0) {
		if(0 == test_num) {
			vty_out(vty, "%% No active wtp to trace!\n");
		}
		else {
			for (i = 0; i < test_num; i++) {
				sflag = (1 == test_num )? 'A': \
						((i == (test_num - 1)) ? 'L' : (i ? 'M' : 'F'));

				tflag = 'B'; /* 'B' means both tcp and udp */
				dcli_wtp_btrace_script_exec(WTP[i]->WTPIP,sflag, tflag);

				free(WTP[i]->WTPMAC);
				WTP[i]->WTPMAC = NULL;
				free(WTP[i]);
				WTP[i] = NULL;
			}
		}
	}
	
	free(WTP);
	WTP = NULL;

	return CMD_SUCCESS;	
}


DEFUN(btrace_wtp_list_cmd_func,
	  btrace_wtp_list_cmd,
	  "btrace wtp (list|all)",
	  BTRACE_STR
	  BTRACE_WTP_STR
	  "Bandwidth tracing all avialable wtps\n"
	  "Bandwidth tracing all avialable wtps\n"
)
{
	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter  iter;
	DBusMessageIter  iter_array;		
	WID_WTP **WTP = NULL, *wtpNode = NULL;	
	int ret = 0, i = 0, fd = 0;
	char sflag = 0, tflag = 0;
	unsigned int num = 0, test_num = 0;

	/* first check if the shell script exist */
	fd = open(BTRACE_SCRIPT_NAME, O_RDONLY);
	if(fd < 0) {
		vty_out(vty, "%% Bandwidth trace wtp failed due to core file missing\n");
		return CMD_WARNING;
	}
	else {
		close(fd);
	}

	WTP = malloc(WTP_NUM*(sizeof(WID_WTP *)));
	if(!WTP) {
		vty_out(vty, "%% Memory allocation error\r\n");
		return CMD_WARNING;
	}

	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST_NEW);
	
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST_NEW);*/
	
	dbus_error_init(&err);
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);	
	dbus_message_unref(query);
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		free(WTP);
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0 ){
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&num);
	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_recurse(&iter,&iter_array);
		for (i = 0; i < num; i++) {
			DBusMessageIter iter_struct;
			wtpNode = (WID_WTP*)malloc(sizeof(WID_WTP));
			if(!wtpNode) {
				vty_out(vty, "%% Memory allocation error when get wtp # %d\n",i);
				free(WTP);
				return CMD_WARNING;
			}
			memset(wtpNode, 0, sizeof(WID_WTP));
			wtpNode->WTPMAC = (unsigned char *)malloc(MAC_LEN +1);
			if(NULL == wtpNode->WTPMAC) {
				vty_out(vty, "%% Memory allocation error when get wtp # %d mac\n",i);
				free(wtpNode);
				free(WTP);
				return CMD_WARNING;
			}
			memset(wtpNode->WTPMAC,0,(MAC_LEN +1));
			dbus_message_iter_recurse(&iter_array,&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(wtpNode->WTPID));
		
			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&wtpNode->WTPMAC[0]);
			
			dbus_message_iter_next(&iter_struct);

			dbus_message_iter_get_basic(&iter_struct,&wtpNode->WTPMAC[1]);
			
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&wtpNode->WTPMAC[2]);
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&wtpNode->WTPMAC[3]);
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&wtpNode->WTPMAC[4]);
		
			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&wtpNode->WTPMAC[5]);	
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(wtpNode->WTPIP));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(wtpNode->WTPModel));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(wtpNode->WTPStat));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(wtpNode->isused));

			dbus_message_iter_next(&iter_struct);
		
			//dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPNAME));
			dbus_message_iter_get_basic(&iter_struct,&(wtpNode->WTPNAME));  //fengwenchao modify for AXSSZFI-742,20120203

			dbus_message_iter_next(&iter_array);
			if('\0' == wtpNode->WTPIP[0]) {

				free(wtpNode->WTPMAC);
				wtpNode->WTPMAC = NULL;
				free(wtpNode);
				wtpNode = NULL;
				
			}
			else {
				WTP[test_num] = wtpNode;
				test_num++;
			}
		}
	}
	
	dbus_message_unref(reply);
	
	if(ret == 0) {
		if(0 == test_num) {
			vty_out(vty, "%% No active wtp to do bandwidth trace!\n");
		}
		else {
			for (i = 0; i < test_num; i++) {
				//sflag = (i == (test_num - 1)) ? 'L' : (i ? 'M' : 'F');
				sflag = (1 == test_num )? 'A': \
				((i == (test_num - 1)) ? 'L' : (i ? 'M' : 'F'));
				
				tflag = 'B'; /* 'B' means both tcp and udp */
				dcli_wtp_btrace_script_exec(WTP[i]->WTPIP,sflag, tflag);
				free(WTP[i]->WTPMAC);
				WTP[i]->WTPMAC = NULL;
				free(WTP[i]);
				WTP[i] = NULL;
			}
		}
	}
	
	free(WTP);
	WTP = NULL;

	return CMD_SUCCESS;	
}

DEFUN(show_ap_version_cmd_func,
	  show_ap_version_cmd,
	  "show version",
	  SHOW_STR
	  "Display the ap version of the ac support\n"
	 )
{
/*	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;	*/	

	int i=0,ret=0,num=0;
	DCLI_WTP_API_GROUP_ONE *WTPINFO = NULL;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
#if 0	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_ACVERSION);
	
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ACVERSION); */
	
	dbus_error_init(&err);	
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) 
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	char *apmodel = NULL;
	char *versionname = NULL;
	char *versionpath = NULL;
	unsigned char radionum;
	unsigned char bssnum;
	
	vty_out(vty,"AC support version list summary\n");
    vty_out(vty,"==============================================================================\n");
	vty_out(vty,"%-30s %-10s %-24s %-6s %-6s\n","Model","Version","Version_Path","RadNum","BssNum");
	if(ret == 0 ){
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&num);
	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_recurse(&iter,&iter_array);

		
		for (i = 0; i < num; i++) {
			DBusMessageIter iter_struct;
			
			dbus_message_iter_recurse(&iter_array,&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(apmodel));	
			
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(versionname));
		
			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&(versionpath));
			
			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&(radionum));	

			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&(bssnum));	
			
			dbus_message_iter_next(&iter_array);
			vty_out(vty,"%-30s %-10s %-24s %-6d %-6d\n",apmodel,versionname,versionpath,radionum,bssnum);
		}
	}
	vty_out(vty,"==============================================================================\n");
	dbus_message_unref(reply);	
#endif
	WTPINFO = dcli_wtp_show_api_group_one(
	   index,
	   FIFTH,/*"show wtp (list|all)"*/
	   0,
	   0,
	   0,
	   0,/**/
	   &ret,/*num2*/
	   0,
	   0,
	   0,
	   &localid,//num6
	//   WTPINFO,
	   dcli_dbus_connection,
	   WID_DBUS_CONF_METHOD_ACVERSION
	   );
	vty_out(vty,"AC support version list summary\n");
    vty_out(vty,"==============================================================================\n");
	vty_out(vty,"%-30s %-10s %-24s %-6s %-6s\n","Model","Version","Version_Path","RadNum","BssNum");
	if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == 0){
		if((WTPINFO)&&(WTPINFO->AP_VERSION)){
			for (i = 0; i < WTPINFO->num; i++) {
				vty_out(vty,"%-30s %-10s %-24s %-6d %-6d\n",WTPINFO->AP_VERSION[i]->apmodel,WTPINFO->AP_VERSION[i]->versionname,WTPINFO->AP_VERSION[i]->versionpath,WTPINFO->AP_VERSION[i]->radionum,WTPINFO->AP_VERSION[i]->bssnum);
				//CW_FREE_OBJECT(WTPINFO->AP_VERSION[i]);
			}
		}	
		dcli_wtp_free_fun(WID_DBUS_CONF_METHOD_ACVERSION,WTPINFO);
	}
	vty_out(vty,"==============================================================================\n");
	//CW_FREE_OBJECT(WTPINFO->AP_VERSION);
	//CW_FREE_OBJECT(WTPINFO);
	return CMD_SUCCESS;

}
/*
#if _GROUP_POLICY
DEFUN(wtp_apply_interface_cmd_func,
		wtp_apply_interface_cmd,
		"wtp apply interface IFNAME",
		"wtp apply interface\n"
		"wtp binding information\n"
		"wtp binding interafce\n"
		"assign Interface name\n"
		)
{
	int ret;
	int ret6;
	unsigned int id;
	char *ifname;
	int insize = 0;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int type = 0;// 0 wtp;1 group
	unsigned int i = 0;
	unsigned int num = 0;
	unsigned int *wtp_list = NULL;	
	unsigned int *wtpid = 0;
	insize = strlen(argv[0]);
	
	if(insize > 16)
	{
		vty_out(vty,"<error> the length of input parameter %s is %d ,excel the limit of 16\n",argv[0],insize);
		return CMD_SUCCESS;	
	}
	
	//wtp_id = (unsigned int)vty->index;
	
	ifname = (char*)malloc(strlen(argv[0])+1);
	memset(ifname, 0, strlen(argv[0])+1);
	memcpy(ifname, argv[0], strlen(argv[0]));	

	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (int)vty->index;
		type = 1;
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
	}
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_IFNAME);
		
	dbus_error_init(&err);

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&type,
						DBUS_TYPE_UINT32,&id,
						DBUS_TYPE_STRING,&ifname,						 
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		if(ifname)
		{
			free(ifname);
			ifname = NULL;
		}
		return CMD_SUCCESS;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&ret6);
	if(type == 1){
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&num);
		wtp_list = (unsigned int *)malloc(num*(sizeof(unsigned int)));
		for(i = 0; i < num; i++){
			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&wtpid);
			wtp_list[i] = wtpid;				
		}
	}

	if((ret == 0)&&(ret6 == 0)){
		vty_out(vty,"IPV4: wtp %d bind interface %s successfully.\n",id,ifname);
		vty_out(vty,"IPV6: wtp %d bind interface %s successfully.\n",id,ifname);
		if(type == 1 && num != 0){
			vty_out(vty,"wtp:");				
			for(i = 0; i < num; i++){
				vty_out(vty,"%d ",wtp_list[i]);		
			}
			vty_out(vty,"failed\n");		
		}
	}
	else if(ret == 0){
		vty_out(vty,"IPV4: wtp %d bind interface %s successfully.\n",id,ifname);
		if(ret6 != 0) 
			vty_out(vty,"<warnning>IPV6: wtp binding ipv6 addr fail.\n");
	}
	else if(ret6 == 0){
		if(ret == INTERFACE_NOT_EXIST) 
			vty_out(vty,"<warnning>IPV4: interface %s does not exist\n",ifname);
		else if(ret == APPLY_IF_FAIL)
			vty_out(vty,"<warnning>IPV4: apply interface %s failed\n",ifname);
		else if(ret == WID_BINDING_WLAN)
			vty_out(vty,"<warnning>IPV4: if you want to change binding interface, please delete binding wlan id first\n");
		vty_out(vty,"IPV6: wtp %d bind interface %s successfully.\n",id,ifname);
	}
	else{			
		if(ret == INTERFACE_NOT_EXIST) 
			vty_out(vty,"<error>IPV4: interface %s does not exist\n",ifname);
		else if(ret == APPLY_IF_FAIL)
			vty_out(vty,"<error>IPV4: apply interface %s failed\n",ifname);
		else if(ret == WID_BINDING_WLAN)
			vty_out(vty,"<error>IPV4: if you want to change binding interface, please delete binding wlan id first\n");
		else vty_out(vty,"<error>IPV4:wtp binding ipv4 fail.errno is %d\n",ret);
		vty_out(vty,"<error>IPV6:wtp binding ipv6 addr fail.errno is %d\n",ret6);
	}
	
	dbus_message_unref(reply);
	free(ifname);
	ifname = NULL;
	return CMD_SUCCESS;	

}*/
#if _GROUP_POLICY
DEFUN(wtp_apply_interface_cmd_func,
		wtp_apply_interface_cmd,
		"wtp apply interface IFNAME",
		"wtp apply interface\n"
		"wtp binding information\n"
		"wtp binding interafce\n"
		"assign Interface name\n"
		)
{
	int i = 0;
	int ret = 0;
	int ret6 = 0;
	int count =0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	int insize = 0;
	unsigned int id= 0;
	unsigned int type = 0;
	unsigned char wlan_id = 0;
	
	char *ifname = NULL;
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;

	insize = strlen(argv[0]);
	if(insize > 16)
	{
		vty_out(vty,"<error> the length of input parameter %s is %d ,excel the limit of 16\n",argv[0],insize);
		return CMD_SUCCESS; 
	}
	
	//wtp_id = (unsigned int)vty->index;
	
	ifname = (char*)malloc(strlen(argv[0])+1);
	memset(ifname, 0, strlen(argv[0])+1);
	memcpy(ifname, argv[0], strlen(argv[0]));	

	if(vty->node == WTP_NODE){
		index = 0;			
		id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (int)vty->index;
		type = 1;
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	WtpList_Head = wtp_apply_interface_cmd_wtp_apply_interface(index,localid,dcli_dbus_connection,type,id,&ifname,&count,&ret,&ret6);

	if((ret == 0)&&(ret6 == 0)){
		vty_out(vty,"IPV4: wtp %d bind interface %s successfully.\n",id,ifname);
		vty_out(vty,"IPV6: wtp %d bind interface %s successfully.\n",id,ifname);
		if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL)){
			vty_out(vty,"wtp ");					
			for(i=0; i<count; i++){
				
				vty_out(vty," 555.\n");
				if(Wtp_Show_Node == NULL)
					Wtp_Show_Node = WtpList_Head->WtpList_list;
				else 
					Wtp_Show_Node = Wtp_Show_Node->next;

				if(Wtp_Show_Node == NULL)
					break;
				
				vty_out(vty,"%d \n",Wtp_Show_Node->WtpId);					
			}
			
			vty_out(vty," failed.\n");
		}
	}
	
	else if(ret == 0){
		vty_out(vty,"IPV4: wtp %d bind interface %s successfully.\n",id,ifname);
		if(ret6 != 0) 
			vty_out(vty,"<warnning>IPV6: wtp binding ipv6 addr fail.\n");
	}
	else if(ret6 == 0){
		if(ret == INTERFACE_NOT_EXIST) 
			vty_out(vty,"<warnning>IPV4: interface %s does not exist\n",ifname);
		else if(ret == APPLY_IF_FAIL)
			vty_out(vty,"<warnning>IPV4: apply interface %s failed\n",ifname);
		else if(ret == WID_BINDING_WLAN)
			vty_out(vty,"<warnning>IPV4: if you want to change binding interface, please delete binding wlan id first\n");
		vty_out(vty,"IPV6: wtp %d bind interface %s successfully.\n",id,ifname);
	}
	else{			
		if(ret == INTERFACE_NOT_EXIST) 
			vty_out(vty,"<error>IPV4: interface %s does not exist\n",ifname);
		else if(ret == APPLY_IF_FAIL)
			vty_out(vty,"<error>IPV4: apply interface %s failed\n",ifname);
		else if(ret == WID_BINDING_WLAN)
			vty_out(vty,"<error>IPV4: if you want to change binding interface, please delete binding wlan id first\n");
		
		else if (ret == WID_INTERFACE_NOT_BE_LOCAL_BOARD){
			vty_out(vty,"<error> %s is no local interface, permission denial\n",ifname);
		}
		else {vty_out(vty,"<error>IPV4:wtp binding ipv4 fail.errno is %d\n",ret);
		vty_out(vty,"<error>IPV6:wtp binding ipv6 addr fail.errno is %d\n",ret6);}
	}
	
	if(ifname!= NULL){
		free(ifname);
		ifname = NULL;
	}
	if(WtpList_Head != NULL){
		dcli_free_WtpList(WtpList_Head);
	}
	
	return CMD_SUCCESS; 
}

#else
DEFUN(wtp_apply_interface_cmd_func,
		wtp_apply_interface_cmd,
		"wtp apply interface IFNAME",
		"wtp apply interface\n"
		"wtp binding information\n"
		"wtp binding interafce\n"
		"assign Interface name\n"
		)
{
	int ret;
	int ret6;
	unsigned int wtp_id;
	char *ifname;
	int insize = 0;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

	/*make robust code*/
	insize = strlen(argv[0]);
	if(insize > 16)
	{
		vty_out(vty,"<error> the length of input parameter %s is %d ,excel the limit of 16\n",argv[0],insize);
		return CMD_SUCCESS;	
	}
	
	//wtp_id = (unsigned int)vty->index;
	
	ifname = (char*)malloc(strlen(argv[0])+1);
	memset(ifname, 0, strlen(argv[0])+1);
	memcpy(ifname, argv[0], strlen(argv[0]));	
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_IFNAME);
		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_IFNAME);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,					
						DBUS_TYPE_UINT32,&wtp_id,
						DBUS_TYPE_STRING,&ifname,						 
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		if(ifname)
		{
			free(ifname);
			ifname = NULL;
		}
		return CMD_SUCCESS;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&ret6);


		if((ret == 0)&&(ret6 == 0)){
			vty_out(vty,"IPV4: wtp %d bind interface %s successfully.\n",wtp_id,ifname);
			vty_out(vty,"IPV6: wtp %d bind interface %s successfully.\n",wtp_id,ifname);
		}
		else if(ret == 0){
			vty_out(vty,"IPV4: wtp %d bind interface %s successfully.\n",wtp_id,ifname);
			if(ret6 != 0) 
				vty_out(vty,"<warnning>IPV6: wtp binding ipv6 addr fail.\n");
		}
		else if(ret6 == 0){
			if(ret == INTERFACE_NOT_EXIST) 
				vty_out(vty,"<warnning>IPV4: interface %s does not exist\n",ifname);
			else if(ret == APPLY_IF_FAIL)
				vty_out(vty,"<warnning>IPV4: apply interface %s failed\n",ifname);
			else if(ret == WID_BINDING_WLAN)
				vty_out(vty,"<warnning>IPV4: if you want to change binding interface, please delete binding wlan id first\n");
			else if(ret == WTP_BE_USING)   /*fengwenchao add 20110810*/
				vty_out(vty,"<warnning>IPV4: if you want to change binding interface, please unused wtp  first\n");
			else if(ret == IF_BINDING_FLAG){
				vty_out(vty,"<error>IPV4: interface %s has be binded in other hansi.\n",ifname);
			}
			vty_out(vty,"IPV6: wtp %d bind interface %s successfully.\n",wtp_id,ifname);
		}
		else{			
			if(ret == INTERFACE_NOT_EXIST) 
				vty_out(vty,"<error>IPV4: interface %s does not exist\n",ifname);
			else if(ret == APPLY_IF_FAIL)
				vty_out(vty,"<error>IPV4: apply interface %s failed\n",ifname);
			else if(ret == WID_BINDING_WLAN)
				vty_out(vty,"<error>IPV4: if you want to change binding interface, please delete binding wlan id first\n");	
			else if(ret == IF_BINDING_FLAG){
				vty_out(vty,"<error>IPV4: interface %s has be binded in other hansi.\n",ifname);
			}
			else if (ret == WID_INTERFACE_NOT_BE_LOCAL_BOARD){
				vty_out(vty,"<error> %s is no local interface, permission denial\n",ifname);
			}
			else if(ret == WTP_BE_USING)  /*wcl modify for AUTELAN-2814*/
				{
				vty_out(vty,"<warnning>IPV4: if you want to change binding interface, please unused wtp  first\n");
				}
			else {
				vty_out(vty,"<error>IPV4:wtp binding ipv4 fail.errno is %d\n",ret);
				}
			if(ret6 == WTP_BE_USING)
				{
			vty_out(vty,"<warnning>IPV6: if you want to change binding interface, please unused wtp  first\n");
				}
			else if(ret6 == APPLY_IF_FAIL)
				{	
			vty_out(vty,"<error>IPV6: apply interface %s failed\n",ifname);
			}
			else 
				{
			vty_out(vty,"<error>IPV6:wtp binding ipv6 addr fail.errno is %d\n",ret6);
				}/*wcl modify for AUTELAN-2814*/
		}
	
	/*	else if((ret == WTP_ID_NOT_EXIST)||(ret6 == WTP_ID_NOT_EXIST))
			vty_out(vty,"<error> wtp id does not exist\n");
		else if((ret == WTP_BE_USING)||(ret6 == WTP_BE_USING))
			vty_out(vty,"<error> wtp is using\n");
		else if((ret == INTERFACE_NOT_EXIST)&&(ret6 == 0))
			vty_out(vty,"<warnning>wtp bingding ipv6 addr success,but bingding ipv4 addr fail\n");		
		else if((ret == APPLY_IF_FAIL)&&(ret6 == 0))			
			vty_out(vty,"<warnning>wtp bingding ipv6 addr success,but bingding ipv4 addr fail\n");
		else if(ret == WID_BINDING_WLAN)
			vty_out(vty,"<error> if you want to change binding interface, please delete binding wlan id first\n");
		else if((ret == 0)&&(ret6 != 0)){
			vty_out(vty,"<warnning> wtp bingding ipv4 addr success,but bingding ipv6 addr fail\n");
		     }
		else if((ret != 0)&&(ret6 == 0)){
			vty_out(vty,"<warnning> wtp bingding ipv6 addr success,but bingding ipv4 addr fail\n");
		     }	
		else if((ret != 0)&&(ret6 != 0)){
			vty_out(vty,"<error> wtp bingding ipv6 addr fail,but bingding ipv4 addr fail\n");
		     }			
	    else
			vty_out(vty,"<error>  %d\n",ret); */
	dbus_message_unref(reply);
	free(ifname);
	ifname = NULL;
	return CMD_SUCCESS;	

}
#endif

/*add terminal wtp binding special wlan weiay 200805604*/
DEFUN(wtp_apply_ipv6interface_cmd_func,
		wtp_apply_ipv6interface_cmd,
		"wtp apply ipv6interface IFNAME",
		"wtp apply ipv6interface\n"
		"wtp binding ipv6 information\n"
		"wtp binding ipv6 interafce\n"
		"assign ipv6 Interface name\n"
		)
{
	int ret;
	unsigned int wtp_id;
	char *ifname;
	int insize = 0;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

	/*make robust code*/
	insize = strlen(argv[0]);
	if(insize > 16)
	{
		vty_out(vty,"<error> the length of input parameter %s is %d ,excel the limit of 16\n",argv[0],insize);
		return CMD_SUCCESS;	
	}
	
	wtp_id = (unsigned int)vty->index;
	
	ifname = (char*)malloc(strlen(argv[0])+1);
	memset(ifname, 0, strlen(argv[0])+1);
	memcpy(ifname, argv[0], strlen(argv[0]));	
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_IFNAME_IPV6);
		
	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_IFNAME_IPV6);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,					
						DBUS_TYPE_UINT32,&wtp_id,
						DBUS_TYPE_STRING,&ifname,						 
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		if(ifname)
		{
			free(ifname);
			ifname = NULL;
		}
		return CMD_SUCCESS;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

		if(ret == 0)
			vty_out(vty,"wtp %d bind interface %s successfully.\n",wtp_id,ifname);
		else if(ret == WTP_ID_NOT_EXIST)
			vty_out(vty,"<error> wtp id does not exist\n");
		else if(ret == WTP_BE_USING)
			vty_out(vty,"<error> wtp is using\n");
		else if(ret == INTERFACE_NOT_EXIST)
			vty_out(vty,"<error> interface %s does not exist\n",ifname);		
		else if(ret == APPLY_IF_FAIL)
			vty_out(vty,"<error> apply interface %s failed\n",ifname);
		else if(ret == WID_BINDING_WLAN)
			vty_out(vty,"<error> if you want to change binding interface, please delete binding wlan id first\n");
		else if(ret == BINDING_IPV6_ADDRE_RROR){
			vty_out(vty,"<error> wtp bingding ipv6 addr error make sure interface have ipv6 address\n");
		     }
	    else
			vty_out(vty,"<error>  %d\n",ret);
	dbus_message_unref(reply);
	free(ifname);
	ifname = NULL;
	return CMD_SUCCESS;	

}

//#if _GROUP_POLICY
/*add by nl for group ap set 2010-09-03 */
/*
DEFUN(wtp_apply_wlan_cmd_func,
		wtp_apply_wlan_cmd,
		"wtp apply wlan ID",
		"wtp apply wlan id\n"
		"wtp binding information\n" 
		"assign wlan id <1-15>\n"
		)
{
	int ret;
	unsigned int id;
	unsigned char wlan_id;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int type = 0;//0 wtp  1 group 
	
	ret = parse_char_ID((char*)argv[0], &wlan_id);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}	
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		vty_out(vty,"<error> wlan id should be 1 to %d\n",WLAN_NUM-1);
		return CMD_SUCCESS;
	}
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	
	if(vty->node == WTP_NODE){
		index = 0;			
		id = (int)vty->index;
		type = 0;
	}
	else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
	}
	else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (int)vty->index;
		type = 1;
		vty_out(vty,"*******type = 1*** AP_GROUP_WTP_NODE*****\n");
	}
	else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
	}
	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_WLANID);
		
	dbus_error_init(&err);

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&type,
						DBUS_TYPE_UINT32,&id,
						DBUS_TYPE_BYTE,&wlan_id,						 
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	int count =0;
	int *wtp_list = NULL;
	int wtpid = 0;
	int i = 0;
	
	if(type == 1){
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&count);
		if(count != 0){
			(wtp_list) = (unsigned int *)malloc(count*(sizeof(unsigned int)));
		}
		for(i=0; i < count; i++){
			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&wtpid);
			(wtp_list)[i] = wtpid;
		}
	}
	if(ret == WID_DBUS_SUCCESS){
		vty_out(vty,"wtp binding wlan successfully.\n");
		if(count != 0){
			vty_out(vty,"wtp ");					
			for(i=0; i<count; i++){
				vty_out(vty,"%d \n",wtp_list[i]);					
			}
			vty_out(vty," failed.\n");
			if(wtp_list!= NULL){
				free(wtp_list);
				wtp_list = NULL;
			}
		}
	}
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else if(ret == WTP_ID_BE_USED)
		vty_out(vty,"<error> wtp is in use, you should unused it first\n");
	else if(ret == WLAN_ID_NOT_EXIST)
		vty_out(vty,"<error> binding wlan does not exist \n");
	else if(ret == Wlan_IF_NOT_BE_BINDED)
		vty_out(vty,"<error> wlan does not bind interface\n");
	else if(ret == WTP_IF_NOT_BE_BINDED)
		vty_out(vty,"<error> wtp does not bind interface\n");
	else if(ret == WTP_WLAN_BINDING_NOT_MATCH)
		vty_out(vty,"<error> wlan and wtp bind interface did not match \n");
	else if(ret == WTP_CLEAR_BINDING_WLAN_SUCCESS)
		vty_out(vty,"clear wtp binding wlan list successfully\n");
	else if(ret == WLAN_BE_ENABLE)
		vty_out(vty,"<error> wlan is enable,you should disable it first\n");
	else if(ret == WTP_OVER_MAX_BSS_NUM)
		vty_out(vty,"<error> wtp over max bss count\n");
	else if(ret == WTP_WEP_NUM_OVER)
		vty_out(vty,"<error> wtp over max wep wlan count or wep index conflict\n");	
	else
		vty_out(vty,"<error>  %d\n",ret);
	
	dbus_message_unref(reply);

	return CMD_SUCCESS;	
}
*/

/*add by nl for group ap set 2010-09-03 */

#if _GROUP_POLICY
DEFUN(wtp_apply_wlan_cmd_func,
		wtp_apply_wlan_cmd,
		"wtp apply wlan ID",
		"wtp apply wlan id\n"
		"wtp binding information\n" 
		"assign wlan id <1-15>\n"
		)
{
	int i = 0;
	int ret = 0;
	int count =0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int id= 0;
	unsigned int type = 0;
	unsigned char wlan_id = 0;
	
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	ret = parse_char_ID((char*)argv[0], &wlan_id);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}	
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		vty_out(vty,"<error> wlan id should be 1 to %d\n",WLAN_NUM-1);
		return CMD_SUCCESS;
	}

	
	if(vty->node == WTP_NODE){
		index = 0;			
		id = (int)vty->index;
		type = 0;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (int)vty->index;
		type = 1;
		vty_out(vty,"*******type = 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	WtpList_Head = wtp_apply_wlan_cmd_wtp_apply_wlan_id(index,localid,dcli_dbus_connection,type,id,wlan_id,&count,&ret);
	
	if(ret == 0){
		vty_out(vty,"wtp apply wlan  %s successfully.\n",argv[0]);
		if((count != 0)&&(type == 1)&&(WtpList_Head!= NULL)){
			vty_out(vty,"wtp ");					
			for(i=0; i<count; i++){
				if(Wtp_Show_Node == NULL)
					Wtp_Show_Node = WtpList_Head->WtpList_list;
				else 
					Wtp_Show_Node = Wtp_Show_Node->next;

				if(Wtp_Show_Node == NULL)
					break;
				
				vty_out(vty,"%d \n",Wtp_Show_Node->WtpId);					
			}
			
			vty_out(vty," failed.\n");
			//dcli_free_WtpList(WtpList_Head);
		}
	}
	
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else if(ret == WTP_ID_BE_USED)
		vty_out(vty,"<error> wtp is in use, you should unused it first\n");
	else if(ret == WLAN_ID_NOT_EXIST)
		vty_out(vty,"<error> binding wlan does not exist \n");
	else if(ret == Wlan_IF_NOT_BE_BINDED)
		vty_out(vty,"<error> wlan does not bind interface\n");
	else if(ret == WTP_IF_NOT_BE_BINDED)
		vty_out(vty,"<error> wtp does not bind interface\n");
	else if(ret == WTP_WLAN_BINDING_NOT_MATCH)
		vty_out(vty,"<error> wlan and wtp bind interface did not match \n");
	else if(ret == WTP_CLEAR_BINDING_WLAN_SUCCESS)
		vty_out(vty,"clear wtp binding wlan list successfully\n");
	else if(ret == WLAN_BE_ENABLE)
		vty_out(vty,"<error> wlan is enable,you should disable it first\n");
	else if(ret == WTP_OVER_MAX_BSS_NUM)
		vty_out(vty,"<error> wtp over max bss count\n");
	else if(ret == WTP_WEP_NUM_OVER)
		vty_out(vty,"<error> wtp over max wep wlan count or wep index conflict\n");
	else if(ret == SECURITYINDEX_IS_SAME)
		vty_out(vty,"<error> wep conflict, wtp binding wlan securityindex is same with others\n");	
	else
		vty_out(vty,"<error>  %d\n",ret);

	if(WtpList_Head!=NULL){
		dcli_free_WtpList(WtpList_Head);
	}

	return CMD_SUCCESS;	
}

#else
/*add terminal wtp binding special wlan weiay 200805604*/
DEFUN(wtp_apply_wlan_cmd_func,
		wtp_apply_wlan_cmd,
		"wtp apply wlan ID",
		"wtp apply wlan id\n"
		"wtp binding information\n" 
		"assign wlan id <1-15>\n"
		)
{
	int ret;
	unsigned int wtp_id;
	unsigned char wlan_id;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	
	//wtp_id = (unsigned int)vty->index;	

	
	ret = parse_char_ID((char*)argv[0], &wlan_id);
	if(ret != WID_DBUS_SUCCESS){
            if(ret == WID_ILLEGAL_INPUT){
            	vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
            }
			else{
		vty_out(vty,"<error> unknown id format\n");
			}
		return CMD_SUCCESS;
	}	
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		vty_out(vty,"<error> wlan id should be 1 to %d\n",WLAN_NUM-1);
		return CMD_SUCCESS;
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_WLANID);
		
		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_WLANID);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,					
						DBUS_TYPE_UINT32,&wtp_id,
						DBUS_TYPE_BYTE,&wlan_id,						 
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

		if(ret == 0)
			vty_out(vty,"wtp %d binding wlan %d successfully.\n",wtp_id,wlan_id);
		else if(ret == WTP_ID_NOT_EXIST)
			vty_out(vty,"<error> wtp id does not exist\n");
		else if(ret == WTP_ID_BE_USED)
			vty_out(vty,"<error> wtp is in use, you should unused it first\n");
		else if(ret == WLAN_ID_NOT_EXIST)
			vty_out(vty,"<error> binding wlan does not exist \n");
		else if(ret == Wlan_IF_NOT_BE_BINDED)
			vty_out(vty,"<error> wlan does not bind interface\n");
		else if(ret == WTP_IF_NOT_BE_BINDED)
			vty_out(vty,"<error> wtp does not bind interface\n");
		else if(ret == WTP_WLAN_BINDING_NOT_MATCH)
			vty_out(vty,"<error> wlan and wtp bind interface did not match \n");
		else if(ret == WTP_CLEAR_BINDING_WLAN_SUCCESS)
			vty_out(vty,"clear wtp binding wlan list successfully\n");
		else if(ret == WLAN_BE_ENABLE)
			vty_out(vty,"<error> wlan is enable,you should disable it first\n");
		else if(ret == WTP_OVER_MAX_BSS_NUM)
			vty_out(vty,"<error> wtp over max bss count\n");
		else if(ret == WTP_WEP_NUM_OVER)
			vty_out(vty,"<error> wtp over max wep wlan count or wep index conflict\n");
		else if(ret == SECURITYINDEX_IS_SAME)
			vty_out(vty,"<error> wep conflict, wtp binding wlan securityindex is same with others\n");
		else
			vty_out(vty,"<error>  %d\n",ret);
	dbus_message_unref(reply);

	return CMD_SUCCESS;	

}
#endif
/*
#if _GROUP_POLICY
DEFUN(config_wtp_service_cmd_func,
	  config_wtp_service_cmd,
	  "wtp (used|unused)",
	  SERVICE_STR
	  "WTP config\n"
	  "wtp service used/unused\n"
	 )
{	

	int ret;
	unsigned int id;
	unsigned int stat;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int type = 0;//0 wtp  1 group 
	
	str2lower(&argv[0]);
	
	if (!strcmp(argv[0],"used"))
	{
		stat = 0;	
	}		
	else if (!strcmp(argv[0],"unused"))
	{
		stat = 1;
	}
	else
	{
		vty_out(vty,"<error> input patameter should only be 'used' or 'unused'\n");
		return CMD_SUCCESS;
	}

	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (int)vty->index;
		type = 1;
		vty_out(vty,"*******type = 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
	}

	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_WTP_USED);
		
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&type,
						DBUS_TYPE_UINT32,&id,
						DBUS_TYPE_UINT32,&stat,						 
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	int count =0;
	int *wtp_list = NULL;
	int wtpid = 0;
	int i = 0;
	
	if(type == 1){
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&count);
		if(count != 0){
			(wtp_list) = (unsigned int *)malloc(count*(sizeof(unsigned int)));
		}
		for(i=0; i < count; i++){
			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&wtpid);
			(wtp_list)[i] = wtpid;
		}
	}
	if(ret == 0){
		vty_out(vty,"wtp %s successfully.\n",argv[0]);
		if(count != 0){
			vty_out(vty,"wtp ");					
			for(i=0; i<count; i++){
				vty_out(vty,"%d \n",wtp_list[i]);					
			}
			vty_out(vty," failed.\n");
			free(wtp_list);
		}
	}
	
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else if(ret == INTERFACE_NOT_BE_BINDED)
		vty_out(vty,"<error> you should apply interface first\n");
	else if(ret == WTP_IS_NOT_BINDING_WLAN_ID)
		vty_out(vty,"<error> you should apply wlan first\n");	
	else if(ret == L3_INTERFACE_ERROR)
		vty_out(vty,"<error> map layer3 interace failed\n");
	else if(ret == IF_POLICY_CONFLICT)
		vty_out(vty,"<error> bss interface policy conflict\n");
	else
		vty_out(vty,"<error>  %d\n",ret);
	dbus_message_unref(reply);

	return CMD_SUCCESS;	
}*/

#if _GROUP_POLICY
DEFUN(config_wtp_service_cmd_func,
	  config_wtp_service_cmd,
	  "wtp (used|unused)",
	  SERVICE_STR
	  "WTP config\n"
	  "wtp service used/unused\n"
	 )
{	
	
	int i = 0;
	int ret = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int id = 0;
	unsigned int stat = 0;
	unsigned int type = 0;
	
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	//vty_out(vty,"##### _GROUP_POLICY #### \n");

	str2lower(&argv[0]);
	
	if (!strcmp(argv[0],"used"))
	{
		stat = 0;	
	}		
	else if (!strcmp(argv[0],"unused"))
	{
		stat = 1;
	}
	else
	{
		vty_out(vty,"<error> input patameter should only be 'used' or 'unused'\n");
		return CMD_SUCCESS;
	}

	if(vty->node == WTP_NODE){
		index = 0;			
		id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (int)vty->index;
		type = 1;
		vty_out(vty,"*******type = 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	WtpList_Head = config_wtp_service_cmd_wtp_used(index,localid,dcli_dbus_connection,type,id,stat,&count,&ret);

	if(ret == 0){
		vty_out(vty,"wtp %s successfully.\n",argv[0]);
		if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL)){
			vty_out(vty,"wtp ");					
			for(i=0; i<count; i++){
				if(Wtp_Show_Node == NULL)
					Wtp_Show_Node = WtpList_Head->WtpList_list;
				else 
					Wtp_Show_Node = Wtp_Show_Node->next;

				if(Wtp_Show_Node == NULL)
					break;
				
				vty_out(vty,"%d \n",Wtp_Show_Node->WtpId);					
			}
			
			vty_out(vty," failed.\n");
			dcli_free_WtpList(WtpList_Head);
		}
	}
	
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else if(ret == INTERFACE_NOT_BE_BINDED)
		vty_out(vty,"<error> you should apply interface first\n");
	else if(ret == WTP_IS_NOT_BINDING_WLAN_ID)
		vty_out(vty,"<error> you should apply wlan first\n");	
	else if(ret == L3_INTERFACE_ERROR)
		vty_out(vty,"<error> map layer3 interace failed\n");
	else if(ret == IF_POLICY_CONFLICT)
		vty_out(vty,"<error> bss interface policy conflict\n");
	else
		vty_out(vty,"<error>  %d\n",ret);

	return CMD_SUCCESS; 
}

#else
/*added by weiay 20080623*/
DEFUN(config_wtp_service_cmd_func,
	  config_wtp_service_cmd,
	  "wtp (used|unused)",
	  SERVICE_STR
	  "WTP config\n"
	  "wtp service used/unused\n"
	 )
{	
	int ret;
	unsigned int wtp_id;
	unsigned int stat;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	
	//wtp_id = (unsigned int)vty->index;	
	
	str2lower(&argv[0]);
	
	if (!strcmp(argv[0],"used"))
	{
		stat = 0;	
	}		
	else if (!strcmp(argv[0],"unused"))
	{
		stat = 1;
	}
	else
	{
		vty_out(vty,"<error> input patameter should only be 'used' or 'unused'\n");
		return CMD_SUCCESS;
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_WTP_USED);
		
		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_WTP_USED);*/
	
	dbus_error_init(&err);

	dbus_message_append_args(query,					
						DBUS_TYPE_UINT32,&wtp_id,
						DBUS_TYPE_UINT32,&stat,						 
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		vty_out(vty,"wtp %s successfully.\n",argv[0]);
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else if(ret == INTERFACE_NOT_BE_BINDED)
		vty_out(vty,"<error> you should apply interface first\n");
	else if(ret == WTP_IS_NOT_BINDING_WLAN_ID)
		vty_out(vty,"<error> you should apply wlan first\n");	
	else if(ret == L3_INTERFACE_ERROR)
		vty_out(vty,"<error> map layer3 interace failed\n");
	else if(ret == IF_POLICY_CONFLICT)
		vty_out(vty,"<error> bss interface policy conflict\n");
	else
		vty_out(vty,"<error>  %d\n",ret);
	dbus_message_unref(reply);

	return CMD_SUCCESS;	
}
/*added end
//added by weiay 20080701*/
#endif
DEFUN(wtp_delete_wlan_cmd_func,
		wtp_delete_wlan_cmd,
		"wtp delete wlan WLANID",
		"wtp delete wlan id\n"
		"wtp delete wlan operate\n" 
		"wtp binding wlan id\n" 
		"delete wlan id <1-15>\n"
		)

{
	int ret;
	unsigned int wtp_id;
	unsigned char wlan_id;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	
//	wtp_id = (unsigned int)vty->index;	
/*	wlan_id = (atoi(argv[0]));*/
	if (!strcmp(argv[0],"all")||!strcmp(argv[0],"ALL")||!strcmp(argv[0],"All"))
	{
		wlan_id = 0;	
	}	
	else
	{	
		ret = parse_char_ID((char*)argv[0], &wlan_id);
		if(ret != WID_DBUS_SUCCESS){
            if(ret == WID_ILLEGAL_INPUT){
            	vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
            }
			else{
			vty_out(vty,"<error> unknown id format\n");
			}
			return CMD_SUCCESS;
		}	
		if(wlan_id >= WLAN_NUM || wlan_id == 0){
			vty_out(vty,"<error> wlan id should be 1 to %d\n",WLAN_NUM-1);
			return CMD_SUCCESS;
		}
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_DELETE_WLAN_ID);
		
		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_DELETE_WLAN_ID);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,					
						DBUS_TYPE_UINT32,&wtp_id,
						DBUS_TYPE_BYTE,&wlan_id,						 
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

		if(ret == 0)
			vty_out(vty,"wtp %d delete wlan %d successfully.\n",wtp_id,wlan_id);
		else if(ret == WTP_ID_NOT_EXIST)
			vty_out(vty,"<error> wtp id does not exist\n");
		else if(ret == WTP_ID_BE_USED)
			vty_out(vty,"<error> wtp is used, you should unused it first\n");
		else if(ret == WLAN_ID_NOT_EXIST)
			vty_out(vty,"<error> binding wlan does not exist \n");
		else if(ret == Wlan_IF_NOT_BE_BINDED)
			vty_out(vty,"<error> wlan does not bind interface\n");
		else if(ret == WTP_IF_NOT_BE_BINDED)
			vty_out(vty,"<error> wtp does not bind interface\n");
		else if(ret == WTP_WLAN_BINDING_NOT_MATCH)
			vty_out(vty,"<error> wlan and wtp bind interface does not match \n");
		else if(ret == WTP_CLEAR_BINDING_WLAN_SUCCESS)
			vty_out(vty,"clear wtp binding wlan list successfully\n");
		else if(ret == WLAN_BE_ENABLE)
			vty_out(vty,"<error> wlan is enable,you should disable it first\n");
		else if(ret == BSS_BE_ENABLE)
			vty_out(vty,"<error> bss is enable\n");		
		else if(ret == 	INTERFACE_NOT_BE_BINDED)
			vty_out(vty,"<error> wtp does not bind this wlan\n");
		else if(ret == RADIO_IN_EBR){
			vty_out(vty,"<error> wtp interface is in ebr,please delete it from ebr first"); /*wcl add for AUTELAN-2789*/
			}
		else
			vty_out(vty,"<error>  %d\n",ret);
	dbus_message_unref(reply);

	return CMD_SUCCESS;	


}
#if _GROUP_POLICY
DEFUN(wtp_disable_wlan_cmd_func,
		wtp_disable_wlan_cmd,
		"wtp disable wlan WLANID",
		"wtp disable wlan id\n"
		"wtp disable wlan operate\n" 
		"wtp disable wlan id\n" 
		"disable wlan id <1-15>\n"
		)
{
	int i = 0;
	int ret = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned char wlan_id = 0;
	
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	//wtp_id = (unsigned int)vty->index;	
	ret = parse_char_ID((char*)argv[0], &wlan_id);

	if(ret != WID_DBUS_SUCCESS){
            if(ret == WID_ILLEGAL_INPUT){
            	vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
            }
			else{
				vty_out(vty,"<error> unknown id format\n");
			}
		return CMD_SUCCESS;
	}	
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		vty_out(vty,"<error> wlan id should be 1 to %d\n",WLAN_NUM-1);
		return CMD_SUCCESS;
	}
	
	if(vty->node == WTP_NODE){
		index = 0;			
		id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (int)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	WtpList_Head = wtp_disable_wlan_cmd_wtp_disable_wlan(index, localid, dcli_dbus_connection, type, id, wlan_id, &count, &ret);

	if(type == 1){
		if(ret == 0){
			vty_out(vty,"group %d wtp disable wlan %d successfully.\n",id,wlan_id );
			if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL)){
				vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d \n",Wtp_Show_Node->WtpId);					
				}
				
				vty_out(vty," failed.\n");
				dcli_free_WtpList(WtpList_Head);
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
		 	vty_out(vty,"<error> group id does not exist\n");
	}
	else if (type == 0){
		if(ret == 0)
			vty_out(vty,"wtp %d disable wlan %d was successfully\n",id,wlan_id);
		else if(ret == WTP_ID_NOT_EXIST)
			vty_out(vty,"<error> wtp id does not exist\n");
		else if(ret == WLAN_ID_NOT_EXIST)
			vty_out(vty,"<error> binding wlan does not exist \n");
		else if(ret ==	INTERFACE_NOT_BE_BINDED)
			vty_out(vty,"<error> wtp does not bind this wlan\n");
		else if(ret ==	WTP_WLAN_BINDING_NOT_MATCH)
			vty_out(vty,"<error> wtp bind wlan id does not match\n");
		else
			vty_out(vty,"<error>  %d\n",ret);
	}
	return CMD_SUCCESS; 

}
#else

DEFUN(wtp_disable_wlan_cmd_func,
		wtp_disable_wlan_cmd,
		"wtp disable wlan WLANID",
		"wtp disable wlan id\n"
		"wtp disable wlan operate\n" 
		"wtp disable wlan id\n" 
		"disable wlan id <1-15>\n"
		)
{
	int ret;
	unsigned int wtp_id;
	unsigned char wlan_id;
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;
	
	//wtp_id = (unsigned int)vty->index;	
	ret = parse_char_ID((char*)argv[0], &wlan_id);
	
	if(ret != WID_DBUS_SUCCESS){
            if(ret == WID_ILLEGAL_INPUT){
            	vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
            }
			else{
		vty_out(vty,"<error> unknown id format\n");
			}
		return CMD_SUCCESS;
	}	
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		vty_out(vty,"<error> wlan id should be 1 to %d\n",WLAN_NUM-1);
		return CMD_SUCCESS;
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_DISABLE_WLAN_ID);
		
		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_DISABLE_WLAN_ID);*/
	dbus_error_init(&err);

	dbus_message_append_args(query, 				
						DBUS_TYPE_UINT32,&wtp_id,
						DBUS_TYPE_BYTE,&wlan_id,						 
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

		if(ret == 0)
			vty_out(vty,"wtp %d disable wlan %d was successfully\n",wtp_id,wlan_id);
		else if(ret == WTP_ID_NOT_EXIST)
			vty_out(vty,"<error> wtp id does not exist\n");
		else if(ret == WLAN_ID_NOT_EXIST)
			vty_out(vty,"<error> binding wlan does not exist \n");
		else if(ret ==	INTERFACE_NOT_BE_BINDED)
			vty_out(vty,"<error> wtp does not bind this wlan\n");
		else if(ret ==	WTP_WLAN_BINDING_NOT_MATCH)
			vty_out(vty,"<error> wtp bind wlan id does not match\n");
		else
			vty_out(vty,"<error>  %d\n",ret);
	dbus_message_unref(reply);

	return CMD_SUCCESS; 

}
#endif
#if _GROUP_POLICY
DEFUN(wtp_enable_wlan_cmd_func,
		wtp_enable_wlan_cmd,
		"wtp enable wlan WLANID",
		"wtp enable wlan id\n"
		"wtp enable wlan operate\n" 
		"wtp enable wlan id\n" 
		"enable wlan id <1-15>\n"
		)
{
	int i = 0;
	int ret = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned char wlan_id = 0;
	
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	ret = parse_char_ID((char*)argv[0], &wlan_id);

	if(ret != WID_DBUS_SUCCESS){
            if(ret == WID_ILLEGAL_INPUT){
            	vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
            }
			else{
				vty_out(vty,"<error> unknown id format\n");
			}
		return CMD_SUCCESS;
	}	
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		vty_out(vty,"<error> wlan id should be 1 to %d\n",WLAN_NUM-1);
		return CMD_SUCCESS;
	}
	
	if(vty->node == WTP_NODE){
		index = 0;			
		id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (int)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	WtpList_Head = wtp_enable_wlan_cmd_wtp_enable_wlan(index, localid, dcli_dbus_connection, type, id, wlan_id, &count, &ret);

	if(0 ==type){
		if(ret == 0)
			vty_out(vty,"wtp %d enable wlan %d successfully\n",id,wlan_id);
		else if(ret == WTP_ID_NOT_EXIST)
			vty_out(vty,"<error> wtp id does not exist\n");
		else if(ret == WLAN_ID_NOT_EXIST)
			vty_out(vty,"<error> binding wlan does not exist\n");
		else if(ret ==	INTERFACE_NOT_BE_BINDED)
			vty_out(vty,"<error> wtp does not bind this wlan\n");
		else if(ret ==	WTP_NOT_IN_RUN_STATE)
			vty_out(vty,"<error> wtp is not in run state\n");	
		else if(ret ==	WTP_WLAN_BINDING_NOT_MATCH)
			vty_out(vty,"<error> wtp bind wlan does not match\n");	
		else if(ret ==	WLAN_BE_DISABLE)
			vty_out(vty,"<error> wlan %d is disable\n",wlan_id);	
		else if(ret == L3_INTERFACE_ERROR)
			vty_out(vty,"<error> you map layer3 interace error\n");	
		else if(ret == IF_POLICY_CONFLICT)
			vty_out(vty,"<error> bss interface policy conflict\n");
		else if(ret == WTP_WEP_NUM_OVER)
				vty_out(vty,"<error> wtp over max wep wlan count or wep index conflict\n");
		else
			vty_out(vty,"<error>  %d\n",ret);
	}

	else if(type == 1){
		if(ret == 0){
			vty_out(vty,"group %d wtp enable wlan %d successfully.\n",id,wlan_id );
			if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL)){
				vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d \n",Wtp_Show_Node->WtpId);					
				}
				
				vty_out(vty," failed.\n");
				dcli_free_WtpList(WtpList_Head);
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
		 	vty_out(vty,"<error> group id does not exist\n");
	}

	return CMD_SUCCESS; 

}


#else
DEFUN(wtp_enable_wlan_cmd_func,
		wtp_enable_wlan_cmd,
		"wtp enable wlan WLANID",
		"wtp enable wlan id\n"
		"wtp enable wlan operate\n" 
		"wtp enable wlan id\n" 
		"enable wlan id <1-15>\n"
		)
{
	int ret;
	unsigned int wtp_id;
	unsigned char wlan_id;
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;
	
	//wtp_id = (unsigned int)vty->index;	
	ret = parse_char_ID((char*)argv[0], &wlan_id);
	
	if(ret != WID_DBUS_SUCCESS){
            if(ret == WID_ILLEGAL_INPUT){
            	vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
            }
			else{
		vty_out(vty,"<error> unknown id format\n");
			}
		return CMD_SUCCESS;
	}	
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		vty_out(vty,"<error> wlan id should be 1 to %d\n",WLAN_NUM-1);
		return CMD_SUCCESS;
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_ENABLE_WLAN_ID);
		
		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_ENABLE_WLAN_ID);*/
	dbus_error_init(&err);

	dbus_message_append_args(query, 				
						DBUS_TYPE_UINT32,&wtp_id,
						DBUS_TYPE_BYTE,&wlan_id,						 
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		vty_out(vty,"wtp %d enable wlan %d successfully\n",wtp_id,wlan_id);
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else if(ret == WLAN_ID_NOT_EXIST)
		vty_out(vty,"<error> binding wlan does not exist\n");
	else if(ret ==	INTERFACE_NOT_BE_BINDED)
		vty_out(vty,"<error> wtp does not bind this wlan\n");
	else if(ret ==	WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp is not in run state\n");	
	else if(ret ==	WTP_WLAN_BINDING_NOT_MATCH)
		vty_out(vty,"<error> wtp bind wlan does not match\n");	
	else if(ret ==	WLAN_BE_DISABLE)
		vty_out(vty,"<error> wlan %d is disable\n",wlan_id);	
	else if(ret == L3_INTERFACE_ERROR)
		vty_out(vty,"<error> you map layer3 interace error\n");	
	else if(ret == IF_POLICY_CONFLICT)
		vty_out(vty,"<error> bss interface policy conflict\n");
	else if(ret == WTP_WEP_NUM_OVER)
			vty_out(vty,"<error> wtp over max wep wlan count or wep index conflict\n");
	else
		vty_out(vty,"<error>  %d\n",ret);
	dbus_message_unref(reply);

return CMD_SUCCESS; 

}
#endif
DEFUN(wtp_show_wlan_cmd_func,
		wtp_show_wlan_cmd,
		"wtp show wlan (list|all)",
		"wtp show wlan list\n"
		"wtp show wlan operate\n" 
		"wtp binding wlan id list\n" 
		"show wlan id list\n"
		)


{
	
	return CMD_SUCCESS; 

}

/*************************************************************************/
/*xm 08/08/29*/
DEFUN(	wtp_set_ap_model_version_path_cmd_func,
			wtp_set_ap_model_version_path_cmd,
			"set ap img-path PATH radio <1-4> bss <1-8> based .MODEL&VERSION",
			"set ap version name\n" 
			"version name value\n"
			"set ap version path\n"
			"version path value\n"
			"radio count\n"
			"radio count value\n"
			"bss count\n"
			"bss count value\n"
			"model and version like: AQ 2010 version V 1.1.1\n"
			"set ap img path AW1.1.9.img radio 1 bss 8 based AQ 2010 version V 1.1.1\n"
	 )
{
	int ret;
	DBusMessage *query, *reply;	
	DBusMessageIter  iter;
	DBusError err;

	char *buf_model;/*Suggestion:not out of range of 7*/
	char *buf_version;/*[256];Suggestion:not out of range of 25*/
	char *buf_path;/*[256];Suggestion:not out of range of 25*/

	unsigned char radiocount;
	unsigned char bsscount;
	
	buf_model = WID_parse_CMD_str(&argv[3],argc-3,"version",1);	
	if(buf_model == NULL){		
		vty_out(vty,"UNKNOWN COMMAND\n");
		vty_out(vty,"COMMAND should be :set ap img path AW1.1.9.img radio 1 bss 8 based AQ 2010 version V 1.1.1\n");
		return CMD_SUCCESS;
	}
	str2higher(&buf_model);
	buf_version = WID_parse_CMD_str(&argv[3],argc-3,"version",0);
	if(buf_version == NULL){		
		free(buf_model);
		vty_out(vty,"UNKNOWN COMMAND\n");		
		vty_out(vty,"COMMAND should be :set ap img path AW1.1.9.img radio 1 bss 8 based AQ 2010 version V 1.1.1\n");
		return CMD_SUCCESS;
	}
	buf_path = (char*)malloc(strlen(argv[0])+1);
	memset(buf_path, 0, strlen(argv[0])+1);
	memcpy(buf_path, argv[0], strlen(argv[0]));	

	radiocount = atoi(argv[1]);
	bsscount = atoi(argv[2]);
	
	dbus_error_init(&err);
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_VERSION_PATH);
	
	
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_VERSION_PATH);*/
	
	dbus_message_append_args(query,
						DBUS_TYPE_STRING,&buf_model,
						DBUS_TYPE_STRING,&buf_version,
						DBUS_TYPE_STRING,&buf_path,
						DBUS_TYPE_BYTE,&radiocount,
						DBUS_TYPE_BYTE,&bsscount,
						DBUS_TYPE_INVALID);
	
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);

	dbus_message_unref(query);

	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		free(buf_model);
		free(buf_path);
		free(buf_version);
		return CMD_SUCCESS;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		vty_out(vty,"wireless-control set ap model<%s> version<%s> image path<%s> successfully\n",buf_model,buf_version,buf_path);
	else if(ret ==WID_NO_SURPORT_MODEL)
		vty_out(vty,"<error> wireless-control does not surport model %s\n",buf_model);
	else
		vty_out(vty,"<error>  %d\n",ret);
	
	dbus_message_unref(reply);	
	
	free(buf_model);

	free(buf_path);
	free(buf_version);
	return CMD_SUCCESS; 

}

DEFUN(delete_model_cmd_func,
		delete_model_cmd,
		"delete ap model MODEl",
		"delete ap config\n" 
		"delete ap config\n"
		"moded type\n"
		"assign model type \n"
	)
{
	int ret;
	DBusMessage *query, *reply;	
	DBusMessageIter  iter;
	DBusError err;

	char *buf_model;

	
	buf_model = (char*)malloc(strlen(argv[0])+1);
	memset(buf_model, 0, strlen(argv[0])+1);
	memcpy(buf_model, argv[0], strlen(argv[0]));	
	
	dbus_error_init(&err);

	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_DELETE_AP_MODEL);

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_DELETE_AP_MODEL);*/
	
	dbus_message_append_args(query,
						DBUS_TYPE_STRING,&buf_model,
						DBUS_TYPE_INVALID);
	
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);

	dbus_message_unref(query);

	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		free(buf_model);
		return CMD_SUCCESS;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		vty_out(vty,"wireless-control delete ap model<%s> successfully\n",buf_model);
	else if(ret ==WID_NO_SURPORT_MODEL)
		vty_out(vty,"<error>  model:%s does not exist or the model is system default model\n",buf_model);
	else
		vty_out(vty,"<error>  %d\n",ret);
	
	dbus_message_unref(reply);	
	
	free(buf_model);

	return CMD_SUCCESS; 

}
DEFUN(set_ap_connect_check_cmd_func,
	  set_ap_connect_check_cmd,
	  "set ap checktimer ECHOTIMER",     
	  "set ap checktimer\n"
	  "set ap checktimer\n" 
	  "set ap checktimer\n"
	  "<3-30>\n"     					
	 )
{
	int ret;
	DBusMessage *query, *reply;	
	DBusMessageIter  iter;
	DBusError err;
	unsigned int wtpid = 0;  //fengwenchao modify 20111215 for AXSSZFI-645
	dbus_error_init(&err);
	
	int checktimer = 10;
	if((vty->node == CONFIG_NODE)||(vty->node == ENABLE_NODE))
	{
		wtpid = 0;
	}else if(vty->node == WTP_NODE)
	{
		wtpid = (unsigned int)vty->index;
	}
	ret = parse_int_ID((char*)argv[0], &checktimer);
	if(ret != WID_DBUS_SUCCESS)
	{
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}	
	//echotimer = atoi(argv[0]);
	if((checktimer < 3)||(checktimer > 30))
	{
		vty_out(vty,"<error> input checktimer should be 3~30.\n");
		return CMD_SUCCESS;
	}
	
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_AP_CHECKTIMER);

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_AP_TIMER);*/
	
	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpid,
						DBUS_TYPE_UINT32,&checktimer,
						DBUS_TYPE_INVALID);
	
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);

	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		vty_out(vty,"wid set ap check timer %d successfully\n",checktimer);
	else
		vty_out(vty,"<error>  %d\n",ret);
	
	dbus_message_unref(reply);	

	return CMD_SUCCESS; 

}

DEFUN(set_ap_echotimer_cmd_func,
	  set_ap_echotimer_cmd,
	  "set ap echotimer ECHOTIMER",     //fengwenchao change <3-30> to ECHOTIMER 20110412
	  "set ap echotimer\n"
	  "set ap echotimer\n" 
	  "set ap echotimer\n"
	  "<3-30>\n"     					//fengwenchao modify 20110412
	 )
{
	int ret;
	DBusMessage *query, *reply;	
	DBusMessageIter  iter;
	DBusError err;
	unsigned int wtpid =0; //fengwenchao modify 20111215 for AXSSZFI-645
	dbus_error_init(&err);
	
	int echotimer = 10;
	if((vty->node == CONFIG_NODE)||(vty->node == ENABLE_NODE))
	{
		wtpid = 0;
	}else if(vty->node == WTP_NODE)
	{
		wtpid = (unsigned int)vty->index;
	}
	/*fengwenchao modify 20110412*/
	ret = parse_int_ID((char*)argv[0], &echotimer);
	if(ret != WID_DBUS_SUCCESS)
	{
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}	
	//echotimer = atoi(argv[0]);
	if((echotimer < 3)||(echotimer > 30))
	{
		vty_out(vty,"<error> input echotimer should be 3~30.\n");
		return CMD_SUCCESS;
	}
	/*fengwenchao modify end*/	
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];

	if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_AP_TIMER);

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_AP_TIMER);*/
	
	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpid,
						DBUS_TYPE_UINT32,&echotimer,
						DBUS_TYPE_INVALID);
	
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);

	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		vty_out(vty,"wid set ap echo timer %d successfully\n",echotimer);
	else
		vty_out(vty,"<error>  %d\n",ret);
	
	dbus_message_unref(reply);	

	return CMD_SUCCESS; 

}

DEFUN(set_ap_cpu_collect_time_cmd_func,
	  set_ap_cpu_collect_time_cmd,
	  "set ap cpu_collect_time COLLECTTIME",	//fengwenchao change <5-900> to COLLECTTIME 20110412	/*xiaodawei change 1-86400 to 5-900, modify for StatWindowTime, 20101203*/
	  "set ap cpu_collect_time\n"
	  "set ap cpu_collect_time\n" 
	  "set ap cpu_collect_time\n"
	  "<5-900>\n"                           //fengwenchao modify 20110412
	 )
{
	int ret;
	DBusMessage *query, *reply;	
	DBusMessageIter  iter;
	DBusError err;
	unsigned int wtpid;
	dbus_error_init(&err);
	
	int collect_time = 300;
	if((vty->node == CONFIG_NODE)||(vty->node == ENABLE_NODE)||(vty->node == HANSI_NODE))
	{
		wtpid = 0;
		printf("wtpid in hansi  %d\n",wtpid);
	}
	else if(vty->node == WTP_NODE)
	{
		wtpid = (unsigned int)vty->index;
		printf("wtpid %d\n",wtpid);
	}
	else if(vty->node ==  HANSI_WTP_NODE)
	{
		wtpid = (unsigned int)vty->index_sub;
		printf("wtpid in hansi wtp %d\n",wtpid);
	}
	/*fengwenchao modify 20110412*/
	ret = parse_int_ID((char*)argv[0], &collect_time);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}	
	//collect_time = atoi(argv[0]);
	if((collect_time < 5)||(collect_time > 900))
	{
		vty_out(vty,"<error> input collect time should be 5~900.\n");
		return CMD_SUCCESS;
	}
	/*fengwenchao modify end*/
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	
	if((vty->node == HANSI_NODE)||(vty->node == HANSI_WTP_NODE)){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if((vty->node == LOCAL_HANSI_NODE)||(vty->node == LOCAL_HANSI_WTP_NODE)){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else{
		index = 0 ;
	}
	
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_AP_COLLECT_TIME);
	
	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpid,
						DBUS_TYPE_UINT32,&collect_time,
						DBUS_TYPE_INVALID);
	
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);

	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		vty_out(vty,"wid set ap collect_time timer %d successfully\n",collect_time);
	else
		vty_out(vty,"<error>  %d\n",ret);
	
	dbus_message_unref(reply);	

	return CMD_SUCCESS; 

}


DEFUN(show_ap_echotimer_cmd_func,
	  show_ap_echotimer_cmd,
	  "show ap echotimer",
	  "show ap echotimer\n" 
	  "show ap echotimer\n"
	  "show echotimer value\n"
	 )

{
/*	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;*/

	int ret=0;
	DCLI_WTP_API_GROUP_THREE *WTPINFO = NULL;
//	CW_CREATE_OBJECT_ERR(WTPINFO, DCLI_WTP_API_GROUP_THREE, return NULL;);	
//	WTPINFO->echotimer = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
#if 0	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_ECHOTIMER);

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ECHOTIMER);*/
	
	dbus_error_init(&err);	
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) 
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	int echotimer = 10;
 
    vty_out(vty,"================================\n");
	vty_out(vty,"%-15s","AP_ECHO_TIMER:");
	if(ret == 0 ){
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&echotimer);
		vty_out(vty,"%d seconds\n",echotimer);
		vty_out(vty,"================================\n");
	}
	
	dbus_message_unref(reply);	
#endif	
	 WTPINFO = dcli_wtp_show_api_group_three(
		index,
		FIRST,/*"show ap echotimer"*/
		0,
		0,
		0,
		&ret,/**/
		0,/*num2*/
		0,
		0,
		0,
		&localid,//num6
	//	WTPINFO,
		dcli_dbus_connection,
		WID_DBUS_CONF_METHOD_ECHOTIMER
		);
	//printf("##########ret is %d\n",ret);
	if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == 0){		
		vty_out(vty,"echotimer  %d seconds\n",WTPINFO->echotimer);
		vty_out(vty,"checktimer %d seconds\n",WTPINFO->checktimer);
		vty_out(vty,"================================\n");
		dcli_wtp_free_fun_three(WID_DBUS_CONF_METHOD_ECHOTIMER,WTPINFO);
	}
//	CW_FREE_OBJECT(WTPINFO);
	return CMD_SUCCESS;

}


DEFUN (download_ap_image_func,
	   download_ap_image_cmd,
	   "download ap URL USERNAME PASSWORD",
	   "Download ap IMG\n"
	   "Download ap IMG\n"
	   "The ap img file location&name\n"
	   "User name\n"
	   "Password\n")
{
	char cmd[WTP_COMMAND_LEN];
	char cpycmd[WTP_COMMAND_LEN];
	char* filename=strrchr(argv[0],'/');

	if((filename == NULL) || ((strcasestr(filename,".img") == NULL)&&(strcasestr(filename,".bin") == NULL)&&(strcasestr(filename,".tar.bz2") == NULL)))
	{
		vty_out(vty, "error download file name, file must be ap img file\n");
		return CMD_SUCCESS;
	}
	
	int ret = 0;
	int quitreason = 0;
	char *httpStr = NULL, *ftpStr = NULL;
	
	char ipaddr[32] = {0};
	char if_name[32]= {0};
	int send_slot = 0;
	ret = get_ipaddr_and_slot_by_url(argv[0],ipaddr,if_name,&send_slot);/*zhaocg add for pfm*/
	if(ret != 0)
	{
		vty_out(vty,"The URL is wrong,please check it\n");
		return CMD_WARNING;
	}

	if(filename)
	{
		memset(cmd,0,WTP_COMMAND_LEN);
		sprintf(cmd,"down_ap_img.sh %s %s %s %s \n",argv[0],argv[1],argv[2],filename+1);

		vty_out(vty,"downloading .................\n");
		/* book add, 2011-11-18 */
		if(pfm_download_config(0,send_slot,ipaddr,if_name) != 0)         //set download to all ports
		{
			vty_out(vty,"config_pfm_failed");
			return CMD_WARNING;
		}
		ret = system(cmd);
		if(pfm_download_config(1,send_slot,ipaddr,if_name) != 0)         //set function back
		{
			vty_out(vty,"config_pfm_failed");
			return CMD_WARNING;
		}
	}
	else
	{
		vty_out(vty,"<error> the url is wrong\n");
	}
	
	if(ret != 0)
	{	
		vty_out(vty,"<error> download fail\n");
		return CMD_SUCCESS;
	}
	
	if(filename)
	{
		vty_out(vty,"finish download to memory, now is copying to storage card\n");
		vty_out(vty,"please don't power off, if you power off download file may be damage\n");
		vty_out(vty,"copying .................\n");
		
		// copy file to storage card
		memset(cpycmd,0,WTP_COMMAND_LEN);
		sprintf(cpycmd,"sor.sh cp /wtp/%s 180\n",filename+1);
		ret = system(cpycmd);
		quitreason = WEXITSTATUS(ret);
			
		if(quitreason == 0)
		{	
			vty_out(vty,"write to storage card success\n");
		}
		else if(quitreason == 1)
		{	
			vty_out(vty,"wrong parameter,Usage: sor.sh OPCMD OPFILENAME TIMEOUT\n");
		}
		else if(quitreason == 2)
		{	
			vty_out(vty,"SAD proccess no start,please start /usr/bin/sad.sh\n");
		}
		else if(quitreason == 3)
		{	
			vty_out(vty,"SAD proccess is busy,please try later\n");
		}
		else if(quitreason == 4)
		{	
			vty_out(vty,"storage operation request timeout,please try later\n");
		}
		else if(quitreason == 5)
		{	
			vty_out(vty,"storage card space is not enough\n");
		}
		else
		{
			vty_out(vty,"error %d unkown reason\n",quitreason);
		}
	}

    /* zhangshu add, 2012-8-6 */
	if(quitreason == 0) {
        /* sync to other boards */
    	int board_count = 0;
    	int ID[MAX_SLOT_NUM] = {0};
    	int i = 0;
    	char src_path[PATH_LEN] = {0};
        char des_path[PATH_LEN] = {0};
        char res_md5[PATH_LEN] = {0};
        sprintf(src_path, "/mnt/wtp%s", filename);
        sprintf(des_path, "/mnt/wtp%s", filename);
    	/* print md5 */
        sor_md5img(vty, src_path);
    	vty_out(vty,"Start synchronizing, please wait...\n");
        board_count = dcli_bsd_get_slot_ids(dcli_dbus_connection,ID,BSD_TYPE_WTP);
        //printf("count = %d\n",board_count);
        for(i = 0; i < board_count; i++) {
            memset(res_md5, 0, PATH_LEN);
            vty_out(vty,"Synchronize to slot_%d...\n",ID[i]);
            ret = dcli_bsd_copy_file_to_board(dcli_dbus_connection,ID[i],src_path,des_path,0,BSD_TYPE_WTP, res_md5);
            vty_out(vty,"File md5 value on dest board is %s\n", (char*)res_md5);
            if(ret == 0)
                vty_out(vty,"successful.\n");
            else if(ret == -2)
                vty_out(vty,"over time.\n");
            else if(ret == 1)
                vty_out(vty,"not enough memery on slot_%d",ID[i]);
            else
                vty_out(vty,"failed.\n");
        }	
	}
	/* book add end */
	
	return CMD_SUCCESS;
}

DEFUN (download_certificate_image_func,
	   download_certificate_image_cmd,
	   "download certificate URL USERNAME PASSWORD",
	   "Download wipi certificate\n"
	   "Download wipi certificate\n"
	   "The wipi certificate file location&name\n"
	   "User name\n"
	   "Password\n")
{
	char cmd[WTP_COMMAND_LEN];
	char cpycmd[WTP_COMMAND_LEN];
	char* filename=strrchr(argv[0],'/');

	if((filename == NULL) || (strcasestr(filename,".cer") == NULL))
	{
		vty_out(vty, "error download file name, file must be wipi certificate file\n");
		return CMD_SUCCESS;
	}
		
	int ret = 0;
	int quitreason = 0;
	char *httpStr = NULL, *ftpStr = NULL;
	char ipaddr[32] = {0};
	char if_name[32]= {0};
	int send_slot = 0;
	ret = get_ipaddr_and_slot_by_url(argv[0],ipaddr,if_name,&send_slot);/*zhaocg add for pfm*/
	if(ret != 0)
	{
		vty_out(vty,"The URL is wrong,please check it\n");
		return CMD_WARNING;
	}

	if(filename)
	{
		memset(cmd,0,WTP_COMMAND_LEN);
		sprintf(cmd,"down_ap_img.sh %s %s %s %s \n",argv[0],argv[1],argv[2],filename+1);

		vty_out(vty,"downloading .................\n");
		/* book add, 2011-11-18 */
		if(pfm_download_config(0,send_slot,ipaddr,if_name) != 0)         //set download to all ports
		{
			vty_out(vty,"config_pfm_failed");
			return CMD_WARNING;
		}
		ret = system(cmd);
		if(pfm_download_config(1,send_slot,ipaddr,if_name) != 0)         //set download to all ports
		{
			vty_out(vty,"config_pfm_failed");
			return CMD_WARNING;
		}
	}
	else
	{
		vty_out(vty,"<error> the url is wrong\n");
	}
	
	if(ret != 0)
	{	
		vty_out(vty,"<error> download fail\n");
		return CMD_SUCCESS;
	}

	
	if(filename)
	{	
		vty_out(vty,"finish download to memory, now is copying to storage card\n");
		vty_out(vty,"please don't power off, if you power off download file may be damage\n");
		vty_out(vty,"copying .................\n");
		
		// copy file to storage card
		memset(cpycmd,0,WTP_COMMAND_LEN);
		sprintf(cpycmd,"sor.sh cp /wtp/%s 180\n",filename+1);
		ret = system(cpycmd);	
		quitreason = WEXITSTATUS(ret);
			
		if(quitreason == 0)
		{	
			vty_out(vty,"write to storage card success\n");
		}
		else if(quitreason == 1)
		{	
			vty_out(vty,"wrong parameter,Usage: sor.sh OPCMD OPFILENAME TIMEOUT\n");
		}
		else if(quitreason == 2)
		{	
			vty_out(vty,"SAD proccess no start,please start /usr/bin/sad.sh\n");
		}
		else if(quitreason == 3)
		{	
			vty_out(vty,"SAD proccess is busy,please try later\n");
		}
		else if(quitreason == 4)
		{	
			vty_out(vty,"storage operation request timeout,please try later\n");
		}
		else if(quitreason == 5)
		{	
			vty_out(vty,"storage card space is not enough\n");
		}
		else
		{
			vty_out(vty,"error %d unkown reason\n",quitreason);
		}

		
	}

    /* zhangshu add, 2012-8-6 */
	if(quitreason == 0) {
	    /* print md5 */
	    char src_path[PATH_LEN] = {0};
        char des_path[PATH_LEN] = {0};
        char res_md5[PATH_LEN] = {0};
        sprintf(src_path, "/mnt/wtp%s", filename);
        sprintf(des_path, "/mnt/wtp%s", filename);
        sor_md5img(vty, src_path);
        /* sync to other boards */
    	int board_count = 0;
    	int ID[MAX_SLOT_NUM] = {0};
    	int i = 0;
    	vty_out(vty,"Start synchronizing, please wait...\n");
        board_count = dcli_bsd_get_slot_ids(dcli_dbus_connection,ID,BSD_TYPE_WTP);
        //printf("count = %d\n",board_count);
        for(i = 0; i < board_count; i++) {
            memset(res_md5, 0, PATH_LEN);
            vty_out(vty,"Synchronize to slot_%d...\n",ID[i]);
            ret = dcli_bsd_copy_file_to_board(dcli_dbus_connection,ID[i],src_path,des_path,0,BSD_TYPE_WTP, res_md5);
            vty_out(vty,"File md5 value on dest board is %s\n", (char*)res_md5);
            if(ret == 0)
                vty_out(vty,"successful.\n");
            else if(ret == -2)
                vty_out(vty,"over time.\n");
            else if(ret == 1)
                vty_out(vty,"not enough memery on slot_%d",ID[i]);
            else
                vty_out(vty,"failed.\n");
        }	
	}
	/* book add end */
	
	return CMD_SUCCESS;
}



DEFUN (check_download_ap_image_func,
	   check_download_ap_image_cmd,
	   "check ap_img_file FILENAME",
	   "Check Download ap file\n"
	   "File name\n"
	   )
{
	char cmd[WTP_COMMAND_LEN];	
	char* name=strrchr(argv[0],'.');
	if((name==NULL)||((strcmp(name,".img")!=0)&&(strcmp(name,".IMG")!=0)&&(strcmp(name,".bin")!=0)&&(strcmp(name,".BIN")!=0))){
		vty_out(vty,"unknown certifiation name.\n");		
		return CMD_SUCCESS;
	}
	memset(cmd,0,WTP_COMMAND_LEN);
	sprintf(cmd,"cd /mnt/wtp/ \n ls -lt |grep %s\n",argv[0]);
	system(cmd);
	return CMD_SUCCESS;
}

DEFUN (check_download_wapi_cert_func,
	   check_download_wapi_cert_cmd,
	   "check wapi_cert_file FILENAME",
	   "Check wapi cert file\n"
	   "File name\n"
	   )
{
	char cmd[WTP_COMMAND_LEN];
	char* name=strrchr(argv[0],'.');
	if((name==NULL)||(strcmp(name,".cer")!=0)){
		vty_out(vty,"unknown certifiation name.\n");		
		return CMD_SUCCESS;
	}
	memset(cmd,0,WTP_COMMAND_LEN);
	sprintf(cmd,"cd /mnt/wtp/ \n ls -lt |grep %s\n",argv[0]);
	system(cmd);
	return CMD_SUCCESS;
}


DEFUN (uplink_detect_cmd_func,
	   uplink_detect_cmd,
	   "uplink IPADDR WLANID (enable|disable)",
	   "uplink ip addr wlan id \n"
	   "ip address\n"
	   "wlan id\n"
	   "enable or disable\n")
{
	int ret;
	FILE *fp;
	unsigned char state = 0;
	char path[] = "/var/run/uplink_detect";
	char newpath[128] = {0};
	ret = WID_Check_IP_Format((char*)argv[0]);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown ip format\n");
		return CMD_SUCCESS;
	}
	char * addr = (char*)malloc(strlen(argv[0])+1);
	memset(addr, 0, strlen(argv[0])+1);
	memcpy(addr, argv[0], strlen(argv[0]));
	
	if(!strcmp(argv[2],"enable"))
	{
		state = 1;
	}else if(!strcmp(argv[2],"disable")){
		state = 0;
	}else{
		vty_out(vty,"<error> unknown format,just be enable or disable\n");
		return CMD_SUCCESS;
	}

	unsigned char wlan_id = 0;

	ret = parse_char_ID((char*)argv[1], &wlan_id);
	
	if(ret != WID_DBUS_SUCCESS){
            if(ret == WID_ILLEGAL_INPUT){
            	vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
            }
			else{
			    vty_out(vty,"<error> unknown id format\n");
			}
			if(addr){
				free(addr);
				addr = NULL;
			}
		return CMD_SUCCESS;
	}	
	if(wlan_id >= WLAN_NUM || wlan_id == 0){
		vty_out(vty,"<error> wlan id should be 1 to %d\n",WLAN_NUM-1);
		if(addr){
			free(addr);
			addr = NULL;
		}
		return CMD_SUCCESS;
	}


	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_CHECK_WLANID);



/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_CHECK_WLANID);*/
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&wlan_id,
							 DBUS_TYPE_STRING,&addr,
							 DBUS_TYPE_BYTE,&state,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		
		if(addr){
			free(addr);
			addr = NULL;
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == -1)
	{
		vty_out(vty,"<error> wlan id %s noexist\n",argv[1]);
		return CMD_SUCCESS;
		if(addr){
			free(addr);
			addr = NULL;
		}
	}


	char cmd[WTP_COMMAND_LEN];
	memset(cmd,0,WTP_COMMAND_LEN);

	char cmd1[WTP_COMMAND_LEN];
	memset(cmd1,0,WTP_COMMAND_LEN);

	sprintf(newpath,"%s%d-%d-%d-%d",path,localid, slot_id,index,wlan_id);
	sprintf(cmd1,"sudo chmod 777 %s",newpath);

	int status = 1;
	if(!strcmp(argv[2],"disable"))
	{
		sprintf(cmd,"echo 0 > %s",newpath);
	}
	else
	{
		fp = fopen(newpath,"w");

		if(fp != NULL)
		{    
			fchmod(fp,777);
			fclose(fp);
		}		
		
		//sprintf(cmd,"sudo uplink_detect.sh %s %s &",argv[0],argv[1]);
		sprintf(cmd,"sudo uplink_detect.sh %s %s %d %d %d&",argv[0],argv[1],index,slot_id,localid);
		

	}

	/*//printf("cmd:%s \n",cmd);*/
	
	system(cmd1);

	system(cmd);
	if(addr != NULL){
		free(addr);
		addr = NULL;
	}
	dbus_message_unref(reply);	
	return CMD_SUCCESS;
}

#if _GROUP_POLICY
/*xm add 08/12/03*/
DEFUN(wtp_max_sta_cmd_func,
		wtp_max_sta_cmd,
		"set wtp max sta num NUM",
		"wtp set max sta num\n"
		"max num of sta \n" 
		"value should be <0-64>\n"
		)
{

	
	unsigned int id = 0;
	unsigned int wtp_max_sta=0;
	unsigned int stanum;
	int i = 0;
	int ret = 0;
	int ret1 = 0;
	int count = 0;
	int finalnum = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int type = 0;
	
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;

	ret = parse_int_ID((char*)argv[0], &wtp_max_sta);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown NUM format\n");
		return CMD_SUCCESS;
	}	
	/*fengwenchao add 20110504*/
	if((wtp_max_sta < 0)||(wtp_max_sta > 64))
	{
		vty_out(vty,"<error> input num should be 0-64\n");
		return CMD_SUCCESS;
	}
	/*fengwenchao add end*/

	
	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	WtpList_Head = wtp_max_sta_cmd_set_wtp_max_sta_num(index,localid, dcli_dbus_connection,type,id,wtp_max_sta,&stanum,&count,
		&finalnum,&ret,&ret1);

	if(type == 0)
		{	
			if((ret == 0)&&(ret1 == 0))
				vty_out(vty,"wtp %d set max sta num %d successfully\n",id,wtp_max_sta);
			else if(ret == WTP_ID_NOT_EXIST)
				vty_out(vty,"<error> wtp id does not exist\n");
			else if(ret1 == -1)
				vty_out(vty,"<error> %d sta(s) has accessed before you set max sta num %d\n",stanum,wtp_max_sta);
			else
				vty_out(vty,"<error>  %d\n",ret);
		}

	else if(type == 1){
		if((ret == 0)&&(ret1 == 0))
			{
				vty_out(vty,"group %d wtp set max sta num %d successfully\n",id,wtp_max_sta);
				if(( finalnum!= 0)&&(type == 1)&&(WtpList_Head!=NULL)){
					vty_out(vty,"wtp ");
					//vty_out(vty,"finalnum = %d \n",finalnum);
					for(i=0; i<finalnum; i++)
						{
							/*if(Wtp_Show_Node == NULL)
								Wtp_Show_Node = WtpList_Head->WtpList_list;
							else 
								Wtp_Show_Node = Wtp_Show_Node->next;

							if(Wtp_Show_Node == NULL)
							break;*/
							vty_out(vty,"%d \n",WtpList_Head[i].WtpId);
							//vty_out(vty,"%d \n",Wtp_Show_Node->WtpId);	
							/*if(Wtp_Show_Node->FailReason == 'f')
								{
									vty_out(vty,"<error> %d sta(s) has accessed before you set max sta num %d\n",Wtp_Show_Node->WtpStaNum,wtp_max_sta);
								}
							else
								{
									vty_out(vty,"fail\n");
								}*/
							 if(WtpList_Head[i].FailReason == 'f')
								{
									vty_out(vty,"<error> %d sta(s) has accessed before you set max sta num %d\n",WtpList_Head[i].WtpStaNum,wtp_max_sta);
								}
							else
								{
									vty_out(vty,"fail\n");
								}
						}
				
					if(WtpList_Head != NULL)
						{
							free(WtpList_Head);
							WtpList_Head == NULL;
						}
					//dcli_free_WtpList(WtpList_Head);
				}
			}
		else if (ret == GROUP_ID_NOT_EXIST)
		 	vty_out(vty,"<error> group id does not exist\n");
	}


	
	return CMD_SUCCESS;

}

#else
/*xm add 08/12/03*/
DEFUN(wtp_max_sta_cmd_func,
		wtp_max_sta_cmd,
		"set wtp max sta num NUM",
		"wtp set max sta num\n"
		"max num of sta \n" 
		"value should be <0-32767>\n"
		)
{

	int ret;
	unsigned int wtp_id = 0;
	unsigned int wtp_max_sta=0;
	unsigned int type=3;
	unsigned int stanum;
	unsigned int radioid = 0;   //fengwenchao add 20110512
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;

	
	dbus_error_init(&err);

	//wtp_id = (unsigned int)vty->index;
	
	//wtp_max_sta=atoi(argv[0]);
	ret = parse_int_ID((char*)argv[0], &wtp_max_sta);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown NUM format\n");
		return CMD_SUCCESS;
	}	
	/*fengwenchao add 20110504*/
	if(/*(wtp_max_sta < 0)||*/(wtp_max_sta > 32767))
	{
		vty_out(vty,"<error> input num should be 0-32767\n");
		return CMD_SUCCESS;
	}
	/*fengwenchao add end*/

	/*compare max_sta_num  with  current sta num*/
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,ASD_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,ASD_DBUS_STA_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,ASD_DBUS_STA_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,ASD_DBUS_STA_METHOD_GET_STA_INFO);
		
/*	query = dbus_message_new_method_call(ASD_DBUS_BUSNAME,ASD_DBUS_STA_OBJPATH,\
						ASD_DBUS_STA_INTERFACE,ASD_DBUS_STA_METHOD_GET_STA_INFO);*/
	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&type,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_UINT32,&radioid,    //fengwenchao add 20110512
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
		
	dbus_message_unref(query);
		
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&stanum);
	dbus_message_unref(reply);

	if(stanum==-1){
		vty_out(vty,"<error> wtp not exist.\n");
		return CMD_SUCCESS;
	}
	
	if(wtp_max_sta< stanum){
		vty_out(vty,"<error> %d sta(s) has accessed before you set max sta num %d  \n",stanum,wtp_max_sta);
		return CMD_SUCCESS;
	}


/*	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
	}*/
		memset(BUSNAME,0,PATH_LEN);
		memset(OBJPATH,0,PATH_LEN);
		memset(INTERFACE,0,PATH_LEN);

	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_MAX_STA);
		


/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_MAX_STA);*/


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_UINT32,&wtp_max_sta,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		vty_out(vty,"wtp %d set max sta num %d successfully\n",wtp_id,wtp_max_sta);
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else if(ret == WID_DBUS_ERROR)
		vty_out(vty,"<error> operation fail .\n");
	else
		vty_out(vty,"<error>  %d\n",ret);

	
	dbus_message_unref(reply);
	return CMD_SUCCESS;



}
#endif
#if _GROUP_POLICY
DEFUN(wtp_triger_num_cmd_func,
		wtp_triger_num_cmd,
		"set wtp number triger  TRIGER",  //fengwenchao change <1-64> to TRIGER 20110412
		"wtp set triger num\n"
		"triger balance fuction\n" 
		"triger balance fuction\n"
		"triger balance fuction\n"
		"<1-64>\n"						  //fengwenchao modify 20110412
		)
{

	int i = 0;
	int ret = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned int triger=0;
	unsigned char wlan_id = 0;
	
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;

	/*fengwenchao modify 20110412*/
	ret = parse_int_ID((char*)argv[0], &triger);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}
	//triger=atoi(argv[0]);
	if((triger < 1)||(triger > 64))
	{
		vty_out(vty,"<error> input triger num should be 1~64.\n");
		return CMD_SUCCESS;
	}
	/*fengwenchao modify end*/

	if(vty->node == WTP_NODE){
		index = 0;			
		id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (int)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	WtpList_Head = wtp_triger_num_cmd_set_wtp_number_triger(index, localid, dcli_dbus_connection, type, id, triger, &count, &ret);

	if(type ==0){
		if(ret == 0)
			vty_out(vty,"wtp %d set wtp number triger  %d successfully\n",id,triger);
		else if(ret == WTP_ID_NOT_EXIST)
			vty_out(vty,"<error> wtp id does not exist\n");
		else if(ret == WID_DBUS_ERROR)
			vty_out(vty,"<error> operation fail .\n");
		else if(ret == APPLY_IF_FAIL)
			vty_out(vty,"<error> number triger must be little than max sta num .\n");
		else
			vty_out(vty,"<error>  %d\n",ret);
		
	}	
	else if(type == 1){
		if(ret == 0){
			vty_out(vty,"group %d set wtp number triger %d successfully.\n",id,triger );
			if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL)){
				vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d \n",Wtp_Show_Node->WtpId);					
				}
				
				vty_out(vty," failed.\n");
				dcli_free_WtpList(WtpList_Head);
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
		 	vty_out(vty,"<error> group id does not exist\n");
	}

	return CMD_SUCCESS;

}
#else
DEFUN(wtp_triger_num_cmd_func,
		wtp_triger_num_cmd,
		"set wtp number triger	TRIGER",  //fengwenchao change <1-64> to TRIGER 20110412
		"wtp set triger num\n"
		"triger balance fuction\n" 
		"triger balance fuction\n"
		"triger balance fuction\n"
		"<1-64>\n"						  //fengwenchao modify 20110412
		)
{

	int ret;
	unsigned int wtp_id = 0;
	unsigned int triger=0;
	
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;

	
	dbus_error_init(&err);


	//wtp_id = (unsigned int)vty->index;
	/*fengwenchao modify 20110412*/
	ret = parse_int_ID((char*)argv[0], &triger);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}
	//triger=atoi(argv[0]);
	if((triger < 1)||(triger > 64))
	{
		vty_out(vty,"<error> input triger num should be 1~64.\n");
		return CMD_SUCCESS;
	}
	/*fengwenchao modify end*/
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_TRIGER);
		


/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_TRIGER);*/


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_UINT32,&triger,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		vty_out(vty,"wtp %d set wtp number triger  %d successfully\n",wtp_id,triger);
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else if(ret == WID_DBUS_ERROR)
		vty_out(vty,"<error> operation fail .\n");
	else if(ret == APPLY_IF_FAIL)
		vty_out(vty,"<error> number triger must be little than max sta num .\n");
	else
		vty_out(vty,"<error>  %d\n",ret);
	
	dbus_message_unref(reply);
	return CMD_SUCCESS;

}
#endif

#if _GROUP_POLICY
/*xm add 09/02/05 /////////////////////////////////////////////////////*/
DEFUN(wtp_flow_triger_cmd_func,
		wtp_flow_triger_cmd,
		"set wtp flow triger  FLOWTRIGER",  //fengwenchao change <0-1024> to FLOWTRIGER 20110412
		"wtp set flow triger\n"
		"triger balance fuction\n" 
		"triger balance fuction\n"		  
		"triger balance fuction\n"
		"<0-1024>\n"					  //fengwenchao modify 20110412
		)
{

	int i = 0;
	int ret = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned int triger=0;
	unsigned char wlan_id = 0;
	
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;

	/*fengwenchao modify 20110412*/
	ret = parse_int_ID((char*)argv[0], &triger);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}
	//triger=atoi(argv[0]);
	if((triger < 0)||(triger > 1024))
	{
		vty_out(vty,"<error> input flow triger should be 0~1024.\n");
		return CMD_SUCCESS;
	}
	/*fengwenchao modify end*/

	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (int)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	WtpList_Head = wtp_triger_num_cmd_set_wtp_flow_triger(index, localid, dcli_dbus_connection, type, id, triger, &count, &ret);

	/*if(ret == 0)
		vty_out(vty,"wtp %d set wtp flow triger  %d successfully\n",id,triger);
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else if(ret == WID_DBUS_ERROR)
		vty_out(vty,"<error> operation fail .\n");
	else if(ret == APPLY_IF_FAIL)
		vty_out(vty,"<error> flow triger must be <0-1024> .\n");
	else
		vty_out(vty,"<error>  %d\n",ret);*/
	
	if(type ==0){
		if(ret == 0)
			vty_out(vty,"wtp %d set wtp flow triger  %d successfully\n",id,triger);
		else if(ret == WTP_ID_NOT_EXIST)
			vty_out(vty,"<error> wtp id does not exist\n");
		else if(ret == WID_DBUS_ERROR)
			vty_out(vty,"<error> operation fail .\n");
		else if(ret == APPLY_IF_FAIL)
			vty_out(vty,"<error> flow triger must be <0-1024> .\n");
		else
			vty_out(vty,"<error>  %d\n",ret);		
	}
	
	else if(type == 1){
		if(ret == 0){
			vty_out(vty,"group %d set wtp flow triger %d successfully.\n",id,triger );
			if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL)){
				vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;					
					vty_out(vty,"%d \n",Wtp_Show_Node->WtpId);					
				}				
				vty_out(vty," failed.\n");
				dcli_free_WtpList(WtpList_Head);
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
		 	vty_out(vty,"<error> group id does not exist\n");
	}
	return CMD_SUCCESS;
}
#else
/*xm add 09/02/05 /////////////////////////////////////////////////////*/
DEFUN(wtp_flow_triger_cmd_func,
		wtp_flow_triger_cmd,
		"set wtp flow triger  FLOWTRIGER",	//fengwenchao change <0-1024> to FLOWTRIGER 20110412
		"wtp set flow triger\n"
		"triger balance fuction\n" 
		"triger balance fuction\n"		  
		"triger balance fuction\n"
		"<0-1024>\n"					  //fengwenchao modify 20110412
		)
{

	int ret;
	unsigned int wtp_id = 0;
	unsigned int triger=0;
	
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;

	
	dbus_error_init(&err);


	//wtp_id = (unsigned int)vty->index;
	/*fengwenchao modify 20110412*/
	ret = parse_int_ID((char*)argv[0], &triger);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}
	//triger=atoi(argv[0]);
	if(/*(triger < 0)||*/(triger > 1024))
	{
		vty_out(vty,"<error> input flow triger should be 0~1024.\n");
		return CMD_SUCCESS;
	}
	/*fengwenchao modify end*/
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_FLOW_TRIGER);
		

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_FLOW_TRIGER);*/


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_UINT32,&triger,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		vty_out(vty,"wtp %d set wtp flow triger  %d successfully\n",wtp_id,triger);
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else if(ret == WID_DBUS_ERROR)
		vty_out(vty,"<error> operation fail .\n");
	else if(ret == APPLY_IF_FAIL)
		vty_out(vty,"<error> flow triger must be <0-1024> .\n");
	else
		vty_out(vty,"<error>  %d\n",ret);
	
	dbus_message_unref(reply);
	return CMD_SUCCESS;

}
#endif
#if _GROUP_POLICY
DEFUN(set_ap_max_throughout_func,
	  set_ap_max_throughout_cmd,
	  "set ap max throughout PARAMETER",
	  "wireless-control config\n"
	  "ap config\n"
	  "max throughout\n"
	  "max throughout\n"
	  "ap max throughout Mb/s \n"
	 )
{
	int i = 0;
	int ret = 0;
	int ret1 = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned char wlan_id = 0;
    unsigned char bandwidth = 0;
	
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (int)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ret1 = parse_char_ID((char*)argv[0], &bandwidth);

	if(ret1 != WID_DBUS_SUCCESS){
        if(ret1 == WID_ILLEGAL_INPUT){
        	vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
        }
		else{
		vty_out(vty,"<error> unknown id format\n");
		}
		return CMD_SUCCESS;
	}	
	
	if(bandwidth > 108 || bandwidth == 0){
		vty_out(vty,"<error> ap max throughout should be 1 to 108\n");
		return CMD_SUCCESS;
	}
	
	WtpList_Head = set_ap_max_throughout_cmd_set_ap_max_throught(index, localid, dcli_dbus_connection, type, id, bandwidth, &count, &ret);
	
	if(type == 0){
		if(ret == 0){
			vty_out(vty,"set ap max throughout %s successfully\n",argv[0]);
		}
		else if(ret == WTP_ID_NOT_EXIST)
			vty_out(vty,"<error> wtp id does not exist\n");
		
		else{
			vty_out(vty,"<error>  %d\n",ret);
		}
	}

	else if(type == 1){
		if(ret == 0){
			vty_out(vty,"group %d set ap max throughout %d successfully.\n",id,bandwidth );
			if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL)){
				vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d \n",Wtp_Show_Node->WtpId);					
				}
				
				vty_out(vty," failed.\n");
				dcli_free_WtpList(WtpList_Head);
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
		 	vty_out(vty,"<error> group id does not exist\n");
	}
	
	return CMD_SUCCESS;			
}
#else
DEFUN(set_ap_max_throughout_func,
	  set_ap_max_throughout_cmd,
	  "set ap max throughout PARAMETER",
	  "wireless-control config\n"
	  "ap config\n"
	  "max throughout\n"
	  "max throughout\n"
	  "ap max throughout Mb/s \n"
	 )
{
	int ret,ret1;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

    unsigned char bandwidth = 0;
	unsigned int wtp_id = 0;
//	wtp_id = (unsigned int)vty->index;
	
	ret1 = parse_char_ID((char*)argv[0], &bandwidth);
	if(ret1 != WID_DBUS_SUCCESS){
            if(ret1 == WID_ILLEGAL_INPUT){
            	vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
            }
			else{
			vty_out(vty,"<error> unknown id format\n");
			}
			return CMD_SUCCESS;
	}	
	if(bandwidth > 108 || bandwidth == 0){
		vty_out(vty,"<error> ap max throughout should be 1 to 108\n");
		return CMD_SUCCESS;
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_AP_MAX_THROUGHOUT);
		
	
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_AP_MAX_THROUGHOUT);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,	
							 DBUS_TYPE_BYTE,&bandwidth,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"set ap max throughout %s successfully\n",argv[0]);
	}
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	
	return CMD_SUCCESS;			
}
#endif

#if _GROUP_POLICY

DEFUN(tcpdump_ap_extension_command_func,
	  tcpdump_ap_extension_command_cmd,
	  "tcpdump .COMMAND",
	  "tcpdump\n"
	  
	 )
{
	char* buc=" -c 10";
	char *p;
    char* command=NULL;
	char* command1=NULL;
	int i = 0;
	int ret = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int id = 0;
	unsigned int type = 0; 
	
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	if (argc > 0)
	{
    	command = WID_parse_ap_extension_command(argv, argc);
									
 	}
	else
	{
    	command = NULL;
	}
	if(!command) 
	{
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}

	/*
		if(strlen(command) > 128)
	{
		if(command)
		{
			free(command);
			command = NULL;
		}
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}
	*/
    if(vty->node == WTP_NODE){
		index = 0;			
		id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	command1=(char*)malloc(strlen(command)+4);

	p=strstr(command,"-c");

	if(!p)
		{
			command=(char*)realloc(command,256);
			strcat(command,buc);
		}
	else
		{	
			if((*(p+2)==' ')&&(*(p+3)>='1'&&*(p+3)<='9'))
				{
		
				}
			else{
					command1 = insert_ten_tcpdump_command(command,command1,' ','1','0');
					/*if(command){
						free(command);
						command = NULL;
						}*/CW_FREE_OBJECT(command);
					command=command1;
				} 
		}
	WtpList_Head = tcpdump_ap_extension_command_cmd_tcpdump(index,localid,dcli_dbus_connection,type,id,command,&count,&ret);

	if(type==0)
		{
			if(ret == 0)
			{
				vty_out(vty,"tcpdump command successfully\n");
			}
			else if(ret == WTP_ID_NOT_EXIST)
				vty_out(vty,"<error> wtp id does not exist\n");
			else if(ret == WID_ILLEGAL_INPUT)
				vty_out(vty,"<error>tcpdump command too long \n");
			else
			{
				vty_out(vty,"<error>  %d\n",ret);
			}
		}
	if(type==1)
  		{
			if(ret == 0){
			vty_out(vty,"group %d tcpdump command successfully\n",id);
			if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL)){
				vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d \n",Wtp_Show_Node->WtpId);					
				}
				
				vty_out(vty," failed.\n");
				dcli_free_WtpList(WtpList_Head);
				}
			}
  		else if (ret == GROUP_ID_NOT_EXIST)
		 	vty_out(vty,"<error> group id does not exist\n");
	  	}

	return CMD_SUCCESS;	
				
}

#else
DEFUN(tcpdump_ap_extension_command_func,
	  tcpdump_ap_extension_command_cmd,
	  "tcpdump .COMMAND",
	  "tcpdump\n"
	  
	 )
{
    int ret;
	//int havec;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	char* buc=" -c 10";
	char *p;
    char* command=NULL;
	char* command1=NULL;
	unsigned int wtp_id = 0;

	if (argc > 0)
	{
    	command = WID_parse_ap_extension_command(argv, argc);
									
 	}
	else
	{
    	command = NULL;
	}
	if(!command) 
	{
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}

	/*
		if(strlen(command) > 128)
	{
		if(command)
		{
			free(command);
			command = NULL;
		}
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}
	*/
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
    if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	command1=(char*)malloc(strlen(command)+4);

	p=strstr(command,"-c");

	if(!p)
		{
			//havec=0;
			command=(char*)realloc(command,256);
			strcat(command,buc);
		}
	else
		{	//printf("%s\n",p); 
			if((*(p+2)==' ')&&(*(p+3)>='1'&&*(p+3)<='9'))
				{
					//havec=1;
				}
			else{
					command1 = insert_ten_tcpdump_command(command,command1,' ','1','0');
					/*if(command){
						free(command);
						command = NULL;
						}*/CW_FREE_OBJECT(command);
					command=command1;
				} 
		}

	//vty_out(vty,"command=%s\n",command);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_TCPDUMP_AP_EXTENSION_COMMAND);

	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
						     DBUS_TYPE_STRING,&command,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	dbus_message_unref(query);
	if(command1)
	{
		free(command1);
		command1 = NULL;
	}
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	
	if(ret == 0)
	{
		vty_out(vty,"tcpdump command successfully\n");
	}
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else if(ret == WID_ILLEGAL_INPUT)
		vty_out(vty,"<error>tcpdump command too long \n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}


	dbus_message_unref(reply);

	
	return CMD_SUCCESS;			
}
#endif
#if _GROUP_POLICY

DEFUN(set_ap_extension_command_func,
	  set_ap_extension_command_cmd,
	  "set ap extension command .COMMAND",
	  "wireless-control config\n"
	  "ap config\n"
	  "extension command\n"
	  "extension command\n"
	  "command send to ap\n"
	 )
{
	int i = 0;
	int ret = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int id = 0;
	unsigned int type = 0; 
	
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;

    unsigned char* command = NULL;
	
	if (argc > 0)
	{
    	command = WID_parse_ap_extension_command(argv, argc);
 	}
	else
	{
    	command = NULL;
	}
	if(!command) 
	{
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}
	if(strlen(command) > 512)
	{
		if(command)
		{
			free(command);
			command = NULL;
		}
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}
	if(vty->node == WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	WtpList_Head = set_ap_extension_command_cmd_set_ap_extension_command(index,localid,dcli_dbus_connection,type,id,
		command,&count,&ret);

	if(type==0)
		{
			if(ret == 0)
			{
				vty_out(vty,"set ap extension command %s successfully\n",argv[0]);
			}
			else if(ret == WTP_ID_NOT_EXIST)
				vty_out(vty,"<error> wtp id does not exist\n");
			else
			{
				vty_out(vty,"<error>  %d\n",ret);
			}
		
		}
	if(type==1)
  		{
			if(ret == 0){
			vty_out(vty,"group %d set ap extension command %s successfully\n",id,argv[0]);
			if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL)){
				vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d \n",Wtp_Show_Node->WtpId);					
				}
				
				vty_out(vty," failed.\n");
				dcli_free_WtpList(WtpList_Head);
				}
			}
  		else if (ret == GROUP_ID_NOT_EXIST)
		 	vty_out(vty,"<error> group id does not exist\n");
	  	}

	return CMD_SUCCESS;			
}

#else
DEFUN(set_ap_extension_command_func,
	  set_ap_extension_command_cmd,
	  "set ap extension command .COMMAND",
	  "wireless-control config\n"
	  "ap config\n"
	  "extension command\n"
	  "extension command\n"
	  "command send to ap\n"
	 )
{
	int ret,ret1;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

    unsigned char* command;
	unsigned int wtp_id = 0;
//	wtp_id = (unsigned int)vty->index;
	
	/*command = (char*)malloc(strlen(argv[0])+1);
	//memset(command, 0, strlen(argv[0])+1);
	//memcpy(command, argv[0], strlen(argv[0]));*/
	
	if (argc > 0)
	{
    	command = WID_parse_ap_extension_command(argv, argc);
 	}
	else
	{
    	command = NULL;
	}
	if(!command) 
	{
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}
	if(strlen(command) > 128)
	{
		if(command)
		{
			free(command);
			command = NULL;
		}
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_AP_EXTENSION_COMMAND);
		

	
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_AP_EXTENSION_COMMAND);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_STRING,&command,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	dbus_message_unref(query);
	if(command)
	{
		free(command);
		command = NULL;
	}
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"set ap extension command %s successfully\n",argv[0]);
	}
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	
	return CMD_SUCCESS;			
}

#define LONGITUDE_LATITUDE_MAX_LEN 16

/*
 *ret:0 for success;1 for incorrect format; 2 for out of range
 *
 *
 */
int parse_longitude_latitude(char *str, unsigned char **temp) {
	*temp = malloc(LONGITUDE_LATITUDE_MAX_LEN);
	if (!(*temp))
		return 1;
	memset(*temp, '\0', LONGITUDE_LATITUDE_MAX_LEN);
	strncpy(*temp, str, (strlen(str) >= LONGITUDE_LATITUDE_MAX_LEN) ? LONGITUDE_LATITUDE_MAX_LEN-1 : strlen(str)+1);
	return 0;
	
}

DEFUN(set_ap_longitude_latitude_func,
	  set_ap_longitude_latitude_cmd,
	  "set ap longitude LONGITUDE latitude LATITUDE",
	  "wireless-control config\n"
	  "ap config\n"
	  "extension command\n"
	  "extension command\n"
	  "command send to ap\n"
	 )
{
	int ret,ret1;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

    unsigned char *longitude, *latitude;
	unsigned int wtp_id = 0;

	if (argc < 2) {
 		vty_out(vty, "parameter not enough\n");
		return CMD_FAILURE;
	}
	// TODO: some where need to  be changed

	vty_out(vty, "argv[0]=%s len=%d\n", argv[0], strlen(argv[0]));
	ret = parse_longitude_latitude(argv[0], &longitude);
	if(ret == 1) {
		vty_out(vty,"parse parameter longitude format failed.format as:\n");
		return CMD_FAILURE;
	} else if (ret == 2) {

	} else {
		
	}

	vty_out(vty, "argv[1]=%s len=%d\n", argv[1], strlen(argv[1]));
	ret = parse_longitude_latitude(argv[1], &latitude);
	if (ret) {
		free(longitude);
		vty_out(vty, "parse parameter latitude failed\n");
		return CMD_FAILURE;
	}

	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		vty_out(vty, "wtp node\n");
		index = 0;			
		wtp_id = (int)vty->index;
	} else if(vty->node == HANSI_NODE){
		vty_out(vty, "hansi node\n");
		index = vty->index;
		wtp_id = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	} else if(vty->node == HANSI_WTP_NODE){
		vty_out(vty, "hansi wtp node\n");
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		vty_out(vty, "local hansi wtp node\n");
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	} else {
		vty_out(vty, "command not support at this node\n");
		return CMD_FAILURE;
	}
	vty_out(vty, "22222222222\n");
	vty_out(vty, "argv[0]=%s argv[1]=%s\n", argv[0], argv[1]);
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	vty_out(vty, "BUSNAME %s\n", BUSNAME);
	vty_out(vty, "OBJPATH %s\n", OBJPATH);
	vty_out(vty, "INTERFACE %s\n", INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_AP_LONGITUDE_LATITUDE_COMMAND);
	vty_out(vty, "333333333333\n");
	dbus_error_init(&err);
	vty_out(vty, "444444444\n");
	vty_out(vty, "wtp_id=%d longitude=%s latitude=%s\n", wtp_id, longitude, latitude);
	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_STRING, &longitude,
							 DBUS_TYPE_STRING, &latitude,
							 DBUS_TYPE_INVALID);
	vty_out(vty, "77777777777\n");
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	vty_out(vty, "555555555\n");
	dbus_message_unref(query);

	free(longitude);
	free(latitude);
	vty_out(vty, "66666666666\n");
	if (NULL == reply)
	{
		vty_out(vty, "<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	vty_out(vty, "8888888888\n");
	dbus_message_iter_init(reply,&iter);
	vty_out(vty, "99999999\n");
	dbus_message_iter_get_basic(&iter,&ret);
	vty_out(vty, "0000000000000000\n");
	if(ret == 0)
	{
		//vty_out(vty,"set ap longitude %s and latitude %s successfully\n",argv[0], argv[1]);
		vty_out(vty,"set ap longitude  and latitude  successfully\n");
	}
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
	vty_out(vty, "qqqqqqqqqqqqqqq\n");	
	dbus_message_unref(reply);

	
	return CMD_SUCCESS;			
}

#endif

DEFUN(set_ap_option60_parameter_func,
	  set_ap_option60_parameter_cmd,
	  "set ap option60 parameter .PARAMETER",
	  "wireless-control config\n"
	  "ap config\n"
	  "option60 parameter\n"
	  "option60 parameter\n"
	  "paramter send to ap\n"
	 )
{
	int ret,ret1;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

    unsigned char* parameter;
	unsigned int wtp_id = 0;
	if (argc > 0)
	{
    		parameter= WID_parse_ap_option60_parameter(argv, argc);
 	}
	else
	{
    	parameter = NULL;
	}
	if(!parameter) 
	{
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}
	if(strlen(parameter) > 512)
	{
		if(parameter)
		{
			free(parameter);
			parameter= NULL;
		}
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_AP_OPTION60_PARAMETER);
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_STRING,&parameter,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	dbus_message_unref(query);
	if(parameter)
	{
		free(parameter);
		parameter = NULL;
	}
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"set ap option60 parameter %s successfully\n",argv[0]);
	}
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	
	return CMD_SUCCESS;			
}


DEFUN(set_ap_ipaddr_command_func,
	  set_ap_ipaddr_command_cmd,
	  "set ap ip address IP mask MASK gateway GATEWAY",
	  "wireless-control config\n"
	  "ap config\n"
	  "ip address\n"
	  "ip address\n"
	  "ip address like 192.168.8.11\n"
	  "subnet mask\n"
	  "subnet mask like 8 16 24\n"
	  "gateway address\n"
	  "gateway address like 192.168.8.1\n"
	 )
{
	int ret,ret1,ret2;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

    unsigned int ip;
	unsigned char mask;
	unsigned int gateway;
	unsigned int wtp_id = 0;
	unsigned char myipBuf[WTP_IP_BUFF_LEN] = {0};	
	unsigned char *myipPtr = myipBuf;

	
//	wtp_id = (unsigned int)vty->index;
	
	ret = WID_Check_IP_Format((char*)argv[0]);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown ip format\n");
		return CMD_SUCCESS;
	}
	
	ip = dcli_ip2ulong((char*)argv[0]);
	ret = ip_long2str(ip,&myipPtr);

	/*//printf("ipstr:%s ipint:%d ipintstr:%s\n",argv[0],ip,myipPtr);*/

	ret1 = parse_char_ID((char*)argv[1], &mask);
	if(ret1 != WID_DBUS_SUCCESS){
            if(ret1 == WID_ILLEGAL_INPUT){
            	vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
            }
			else{
		vty_out(vty,"<error> unknown id format\n");
			}
		return CMD_SUCCESS;
	}
	if(mask != 8 && mask != 16 &&mask !=24){
		vty_out(vty,"<error> unknown mask parameters\n");
		return CMD_SUCCESS;
	}
	/*//printf("2\n");*/

	ret2 = WID_Check_IP_Format((char*)argv[2]);
	if(ret2 != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown ip format\n");
		return CMD_SUCCESS;
	}
	
	gateway = dcli_ip2ulong((char*)argv[2]);
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_AP_IP_GATEWAY);
		

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_AP_IP_GATEWAY);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_UINT32,&ip,
							 DBUS_TYPE_BYTE,&mask,
							 DBUS_TYPE_UINT32,&gateway,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"set ap ip %s gateway %s successfully\n",argv[0],argv[1]);
	}
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	
	return CMD_SUCCESS;			
}
DEFUN(show_wtp_runtime_cmd_func,
	  show_wtp_runtime_cmd,
	  "show wtp runtime",
	  SHOW_STR
	  "wtp information\n"
	  "wtp runtime\n"
	 )
{	
	
/*	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;*/
	unsigned int WTPID = 0;
	//unsigned int ElectrifyRegisterCircle = 0;
	int ret = WID_DBUS_SUCCESS;
	//WTPID = (unsigned int)vty->index;

	DCLI_WTP_API_GROUP_THREE *WTPINFO = NULL;
/*	CW_CREATE_OBJECT_ERR(WTPINFO, DCLI_WTP_API_GROUP_THREE, return NULL;);	
	WTPINFO->ElectrifyRegisterCircle = 0;
	WTPINFO->addtime = 0;
	WTPINFO->starttime = 0;
	WTPINFO->imagadata_time = 0;
	WTPINFO->config_update_time = 0;*/
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
#if 0	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WID_WTP_RUNTIME);
		

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WID_WTP_RUNTIME);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0){
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(addtime));	

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(ElectrifyRegisterCircle));

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(imagadata_time));

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(config_update_time));
	}	
	dbus_message_unref(reply);
#endif
	 WTPINFO = dcli_wtp_show_api_group_three(
		index,
		SECOND,/*"show wtp runtime"*/
		WTPID,
		0,
		0,
		&ret,/**/
		0,/*num2*/
		0,
		0,
		0,
		&localid,//num6
	//	WTPINFO,
		dcli_dbus_connection,
		WID_DBUS_CONF_METHOD_SHOW_WID_WTP_RUNTIME
		);
	//printf("##########ret is %d\n",ret);
	if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == 0){		
		vty_out(vty,"==============================================================================\n");
		vty_out(vty,"WTPID: %d\n",WTPID);
		if(WTPINFO->addtime == 0)
		{
			vty_out(vty,"Access Time:	Not Accessed\n");
			vty_out(vty,"Run Time:	NONE\n");
		}
		else
		{
			vty_out(vty,"Access Time:	%s",ctime(&WTPINFO->addtime));
			time_t now,online_time;
			time(&now);
			online_time = now - (WTPINFO->addtime);
			int hour,min,sec;
			hour=online_time/3600;
			min=(online_time-hour*3600)/60;
			sec=(online_time-hour*3600)%60;
			vty_out(vty,"Run Time:	%02d:%02d:%02d\n",hour,min,sec);
		}
		
		if(WTPINFO->ElectrifyRegisterCircle == 0)
		{
			vty_out(vty,"ElectrifyRegisterCircle Time:	Not Accessed\n");
			vty_out(vty,"Start Time:	NONE\n");
		}
		else
		{
			WTPINFO->starttime = WTPINFO->addtime - WTPINFO->ElectrifyRegisterCircle;
			time_t now,online_time;
			time(&now);
			online_time=now-(WTPINFO->starttime);
			int hour,min,sec;
			hour=online_time/3600;
			min=(online_time-hour*3600)/60;
			sec=(online_time-hour*3600)%60;
			vty_out(vty,"Start Time:	%s",ctime(&WTPINFO->starttime));
			vty_out(vty,"Start Time:	%02d:%02d:%02d\n",hour,min,sec);
		}
		if(WTPINFO->imagadata_time == 0)
		{
			vty_out(vty,"Imagadata Time:	No imagadata\n");
		}
		else
		{
			vty_out(vty,"Imagadata Time:	%s",ctime(&WTPINFO->imagadata_time));
		}
		if(WTPINFO->config_update_time == 0)
		{
			vty_out(vty,"Config update Time:	No configuration update\n");
		}
		else
		{
			vty_out(vty,"Config update Time:	%s",ctime(&WTPINFO->config_update_time));
		}
		if(WTPINFO->quittime == 0){
			vty_out(vty,"Quit Time:	NULL\n");
		}else{
			vty_out(vty,"Quit Time:	%s",ctime(&WTPINFO->quittime));
		}
		vty_out(vty,"Check times:	%d\n",WTPINFO->checktimes);
		vty_out(vty,"==============================================================================\n");

		dcli_wtp_free_fun_three(WID_DBUS_CONF_METHOD_SHOW_WID_WTP_RUNTIME,WTPINFO);
	}
	else if (ret == WTP_ID_NOT_EXIST)
	vty_out(vty,"<error> wtp id does not exist\n");
	return CMD_SUCCESS;
}

#if _GROUP_POLICY
DEFUN(set_wtp_location_cmd_func,
	  set_wtp_location_cmd,
	  "set wtp location LOCATION",
	  CONFIG_STR
	  "wtp information\n"
	  "wtp location\n"
	  "wtp location name length <1-15>\n"
	 )
{	
	int i = 0;
	int ret = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	int policy = 0;
	unsigned int id = 0;
	unsigned int type = 0; 
	
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	char *location = NULL;
	int len = 0;

	len = strlen(argv[0]);
	if(len > 15){		
		vty_out(vty,"<error> wtp location is too long,should be 1 to 15\n");
		return CMD_SUCCESS;
	}
	
	location = (char*)malloc(strlen(argv[0])+1);
	memset(location, 0, strlen(argv[0])+1);
	memcpy(location, argv[0], strlen(argv[0]));

	if(vty->node == WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	WtpList_Head = set_wtp_location_cmd_set_wtp_location(index,localid,dcli_dbus_connection,type,id,location,
		&count,&ret);

	if(type==0)
		{
			if(ret == 0)
			{		
				vty_out(vty,"set wtp location %s successfully\n",argv[0]);
			}
			else if (ret == WTP_ID_NOT_EXIST)
				vty_out(vty,"<error> wtp id does not exist\n");
		}
	if(type==1)
  		{
			if(ret == 0){
			vty_out(vty,"group %d set wtp location %s successfully\n",id,argv[0]);
			if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL)){
				vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d \n",Wtp_Show_Node->WtpId);					
				}
				
				vty_out(vty," failed.\n");
				dcli_free_WtpList(WtpList_Head);
				}
			}
  		else if (ret == GROUP_ID_NOT_EXIST)
		 	vty_out(vty,"<error> group id does not exist\n");
	  	}
	free(location);
	location = NULL;
	return CMD_SUCCESS;
}

#else
DEFUN(set_wtp_location_cmd_func,
	  set_wtp_location_cmd,
	  "set wtp location LOCATION",
	  CONFIG_STR
	  "wtp information\n"
	  "wtp location\n"
	  "wtp location name length <1-15>\n"
	 )
{	
	
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;
	unsigned int WTPID;
	int ret = WID_DBUS_SUCCESS;
	char *location = NULL;
	int len = 0;
	//WTPID = (unsigned int)vty->index;

	len = strlen(argv[0]);
	if(len > 15){		
		vty_out(vty,"<error> wtp location is too long,should be 1 to 15\n");
		return CMD_SUCCESS;
	}
	
	location = (char*)malloc(strlen(argv[0])+1);
	memset(location, 0, strlen(argv[0])+1);
	memcpy(location, argv[0], strlen(argv[0]));


	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_WTP_LOCATION);
		

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_WTP_LOCATION);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_STRING,&location,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		if(location)
		{
			free(location);
			location = NULL;
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
		
	dbus_message_unref(reply);
	if(ret == 0)
	{		
		vty_out(vty,"set wtp location %s successfully\n",argv[0]);
	}
	else if (ret == WTP_ID_NOT_EXIST)
	vty_out(vty,"<error> wtp id does not exist\n");
	free(location);
	location = NULL;
	return CMD_SUCCESS;
}
#endif
DEFUN(show_wtp_location_cmd_func,
	  show_wtp_location_cmd,
	  "show wtp location",
	  SHOW_STR
	  "wtp information\n"
	  "wtp location\n"
	 )
{	
	
/*	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;*/
	unsigned int WTPID = 0;
	int ret = WID_DBUS_SUCCESS;
	//WTPID = (unsigned int)vty->index;
	//char *location;
	DCLI_WTP_API_GROUP_THREE *WTPINFO = NULL;
//	CW_CREATE_OBJECT_ERR(WTPINFO, DCLI_WTP_API_GROUP_THREE, return NULL;);	
//	WTPINFO->wtp_location = NULL;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
#if 0	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WID_WTP_LOCATION);
		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WID_WTP_LOCATION);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}

	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0)
	{	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&location);
	
	}
	
	dbus_message_unref(reply);
#endif
	 WTPINFO = dcli_wtp_show_api_group_three(
		index,
		THIRD,/*"show wtp location"*/
		WTPID,
		0,
		0,
		&ret,/**/
		0,/*num2*/
		0,
		0,
		0,
		&localid,//num6
	//	WTPINFO,
		dcli_dbus_connection,
		WID_DBUS_CONF_METHOD_SHOW_WID_WTP_LOCATION
		);
	//printf("##########ret is %d\n",ret);
	if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == 0){		
		vty_out(vty,"==============================================================================\n");
		vty_out(vty,"WTPID:	%d\n",WTPID);
		vty_out(vty,"Location:	%s\n",WTPINFO->wtp_location);
		vty_out(vty,"==============================================================================\n");
		dcli_wtp_free_fun_three(WID_DBUS_CONF_METHOD_SHOW_WID_WTP_LOCATION,WTPINFO);
	}
	else if (ret == WID_WTP_LOCATION_NOT_SET)
	vty_out(vty,"<error> wtp does not set location\n");
	else if (ret == WTP_ID_NOT_EXIST)
	vty_out(vty,"<error> wtp id does not exist\n");
//	CW_FREE_OBJECT(WTPINFO);
	return CMD_SUCCESS;
}
#if _GROUP_POLICY
DEFUN(set_ap_channel_disturb_trap_func,
	  set_ap_channel_disturb_trap_cmd,
	  "channel disturb trap (enable|disable)",
	  "ap channel disturb trap config\n"
	  "ap channel disturb trap config\n"
	  "ap channel disturb trap config\n"
	  "ap channel disturb trap enable|disable\n"
	 )
{
	  
	int i = 0;
	int ret = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	int policy = 0;
	unsigned int id = 0;
	unsigned int type = 0; 
	
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;
  

	
	if (!strcmp(argv[0],"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[0],"disable"))
	{
		policy = 0;	
	}
	else
	{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	} 
	if(vty->node == WTP_NODE){
		index = 0;			
		id= (unsigned)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
 
	WtpList_Head = set_ap_channel_disturb_trap_cmd_channel_disturb_trap(index,localid,dcli_dbus_connection,type,id,
		policy,&count,&ret);
 
	if(type==0)
		{
			if(ret == 0)
			{
				vty_out(vty," set ap channel disturb trap %s successfully\n",argv[0]);
			}				
			else
			{
				vty_out(vty,"<error>  %d\n",ret);
			} 
		}

	 if(type==1)
  		{
			if(ret == 0){
			vty_out(vty,"group %d set ap channel disturb trap %s successfully\n",id,argv[0]);
			if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL)){
				vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d \n",Wtp_Show_Node->WtpId);					
				}
				
				vty_out(vty," failed.\n");
				dcli_free_WtpList(WtpList_Head);
				}
			}
  		else if (ret == GROUP_ID_NOT_EXIST)
		 	vty_out(vty,"<error> group id does not exist\n");
	  	}
	return CMD_SUCCESS;			
}

#else
DEFUN(set_ap_channel_disturb_trap_func,
	  set_ap_channel_disturb_trap_cmd,
	  "channel disturb trap (enable|disable)",
	  "ap channel disturb trap config\n"
	  "ap channel disturb trap config\n"
	  "ap channel disturb trap config\n"
	  "ap channel disturb trap enable|disable\n"
	 )
{
	
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID;
	int ret = WID_DBUS_SUCCESS;
	//WTPID = (unsigned int)vty->index;
    int policy = 0;

	
	if (!strcmp(argv[0],"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[0],"disable"))
	{
		policy = 0;	
	}
	else
	{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_AP_CHANNEL_DISTURB_TRAP);
		

	
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_AP_CHANNEL_DISTURB_TRAP);*/
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty," set ap channel disturb trap %s successfully\n",argv[0]);
	}				
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	
	return CMD_SUCCESS;			
}
#endif
#if _GROUP_POLICY
DEFUN(set_wtp_netid_cmd_func,
	  set_wtp_netid_cmd,
	  "set wtp netid NETID",
	  CONFIG_STR
	  "wtp information\n"
	  "wtp netid\n"
	  "wtp netid name length <1-32>\n"
	 )
{	

	int i = 0;
	int ret = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	char *netid = NULL;
	int len = 0;

	len = strlen(argv[0]);
	if(len > 32){		
		vty_out(vty,"<error> wtp location is too long,should be 1 to 32\n");
		return CMD_SUCCESS;
	}
	
	netid = (char*)malloc(strlen(argv[0])+1);
	memset(netid, 0, strlen(argv[0])+1);
	memcpy(netid, argv[0], strlen(argv[0]));
	
	if(vty->node == WTP_NODE){
		index = 0;			
		id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	WtpList_Head = set_wtp_netid_cmd_set_wtp_netid(index,localid,dcli_dbus_connection,type,id,netid,&count,&ret);
	
if(type==0)
{
	if(ret == 0)
	{		
		vty_out(vty,"set wtp netid %s successfully\n",argv[0]);
	}
	else if (ret == WTP_ID_NOT_EXIST)
	vty_out(vty,"<error> wtp id does not exist\n");
}

  if(type==1)
  {
		if(ret == 0){
			vty_out(vty,"group %d set wtp netid %s successfully\n",id,argv[0]);
			if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL)){
				vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d \n",Wtp_Show_Node->WtpId);					
				}
				
				vty_out(vty," failed.\n");
				dcli_free_WtpList(WtpList_Head);
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
		 	vty_out(vty,"<error> group id does not exist\n");
  }

	free(netid);
	netid = NULL;
	return CMD_SUCCESS;
}

#else
DEFUN(set_wtp_netid_cmd_func,
	  set_wtp_netid_cmd,
	  "set wtp netid NETID",
	  CONFIG_STR
	  "wtp information\n"
	  "wtp netid\n"
	  "wtp netid name length <1-32>\n"
	 )
{	
	
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;
	unsigned int WTPID;
	int ret = WID_DBUS_SUCCESS;
	char *netid = NULL;
	int len = 0;
	//WTPID = (unsigned int)vty->index;

	len = strlen(argv[0]);
	if(len > 32){		
		vty_out(vty,"<error> wtp location is too long,should be 1 to 32\n");
		return CMD_SUCCESS;
	}
	
	netid = (char*)malloc(strlen(argv[0])+1);
	memset(netid, 0, strlen(argv[0])+1);
	memcpy(netid, argv[0], strlen(argv[0]));
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_WTP_NETID);
		

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_WTP_NETID);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_STRING,&netid,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		if(netid)
		{
			free(netid);
			netid = NULL;
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
		
	dbus_message_unref(reply);
	if(ret == 0)
	{		
		vty_out(vty,"set wtp netid %s successfully\n",argv[0]);
	}
	else if (ret == WTP_ID_NOT_EXIST)
	vty_out(vty,"<error> wtp id does not exist\n");
	free(netid);
	netid = NULL;
	return CMD_SUCCESS;
}
#endif
DEFUN(show_wtp_netid_cmd_func,
	  show_wtp_netid_cmd,
	  "show wtp netid",
	  SHOW_STR
	  "wtp information\n"
	  "wtp netid\n"
	 )
{	
	
/*	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;*/
	unsigned int WTPID;
	int ret = WID_DBUS_SUCCESS;
	//WTPID = (unsigned int)vty->index;
	char *netid;
	DCLI_WTP_API_GROUP_THREE *WTPINFO = NULL;
//	CW_CREATE_OBJECT_ERR(WTPINFO, DCLI_WTP_API_GROUP_THREE, return NULL;);	
//	WTPINFO->netid = NULL;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
#if 0	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WID_WTP_NETID);
		

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WID_WTP_NETID);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}

	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0)
	{	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&netid);
	
	}
	
	dbus_message_unref(reply);
#endif
	 WTPINFO = dcli_wtp_show_api_group_three(
		index,
		FOURTH,/*"show wtp netid"*/
		WTPID,
		0,
		0,
		&ret,/**/
		0,/*num2*/
		0,
		0,
		0,
		&localid,
	//	WTPINFO,
		dcli_dbus_connection,
		WID_DBUS_CONF_METHOD_SHOW_WID_WTP_NETID
		);
	if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == 0){		
		vty_out(vty,"==============================================================================\n");
		vty_out(vty,"WTPID:	%d\n",WTPID);
		vty_out(vty,"NETID:	%s\n",WTPINFO->netid);
		vty_out(vty,"==============================================================================\n");
		dcli_wtp_free_fun_three(WID_DBUS_CONF_METHOD_SHOW_WID_WTP_NETID,WTPINFO);
	}
	else if (ret == WID_WTP_LOCATION_NOT_SET)
	vty_out(vty,"<error> wtp does not set netid\n");
	else if (ret == WTP_ID_NOT_EXIST)
	vty_out(vty,"<error> wtp id does not exist\n");
//	CW_FREE_OBJECT(WTPINFO);
	return CMD_SUCCESS;
}
/*
DEFUN(show_wtp_extension_information_func,
	  show_wtp_extension_information_cmd,
	  "show wtp extension information",
	  SHOW_STR
	  "wtp information\n"
	  "wtp information\n"
	  "wtp information\n"
	 )
{	
	
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;
	unsigned int WTPID;
	int ret = WID_DBUS_SUCCESS;
	WTPID = (unsigned int)vty->index;
	int i = 0;
	wid_wifi_info info;
	info.cpu = 0;
	info.tx_mgmt = 0;
	info.rx_mgmt = 0;
	info.tx_packets = 0;
	info.tx_errors = 0;
	info.tx_retry = 0;
	info.eth_count = 0;
	info.ath_count = 0;
	for(i=0;i<AP_ETH_IF_NUM;i++)
	{
		info.eth_updown_time[i] = 0;
	}
	for(i=0;i<AP_ATH_IF_NUM;i++)
	{
		info.ath_updown_time[i] = 0;
	}
	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_AP_SHOW_WTP_EXTENSION_INFOMATION);
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}

	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0)
	{	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.cpu);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_mgmt);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.rx_mgmt);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_packets);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_errors);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_retry);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.eth_count);

		for(i=0;i<AP_ETH_IF_NUM;i++)
		{
			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&info.eth_updown_time[i]);
		}

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.ath_count);

		for(i=0;i<AP_ATH_IF_NUM;i++)
		{
			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&info.ath_updown_time[i]);
		}
	}
	
	dbus_message_unref(reply);
	if(ret == 0){		
		vty_out(vty,"==============================================================================\n");
		vty_out(vty,"WTP extension infomation\n");
		vty_out(vty,"WTPID:	%d\n",WTPID);
		vty_out(vty,"cpu:	%0.2f %\n",info.cpu/100.00);
		vty_out(vty,"tx_mgmt:	%d\n",info.tx_mgmt);
		vty_out(vty,"rx_mgmt:	%d\n",info.rx_mgmt);
		vty_out(vty,"total_mgmt:	%d\n",info.rx_mgmt+info.tx_mgmt);
		vty_out(vty,"tx_packets:	%d\n",info.tx_packets);
		vty_out(vty,"tx_errors:	%d\n",info.tx_errors);
		vty_out(vty,"tx_retry:	%d\n",info.tx_retry);
		vty_out(vty,"eth_count:	%d\n",info.eth_count);
		for(i=0;i<AP_ETH_IF_NUM;i++)
		{
			if(info.eth_updown_time[i] != 0)
			{
				vty_out(vty,"eth%d updown time:	%d\n",i,info.eth_updown_time[i]);
			}
		}
		vty_out(vty,"ath_count:	%d\n",info.ath_count);
		for(i=0;i<AP_ATH_IF_NUM;i++)
		{
			if(info.ath_updown_time[i] != 0)
			{
				vty_out(vty,"ath%d updown time:	%d\n",i+1,info.ath_updown_time[i]);
			}
		}
		vty_out(vty,"==============================================================================\n");
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
	vty_out(vty,"<error> wtp is not in run state\n");
	else if (ret == WTP_ID_NOT_EXIST)
	vty_out(vty,"<error> wtp id does not exist\n");
	else if (ret == SWITCH_IS_DISABLE)
		vty_out(vty,"<error> wtp extension info report switch disable\n");
	return CMD_SUCCESS;
}*/
DEFUN(show_wtp_sample_throughput_information_func,
	  show_wtp_sample_throughput_information_cmd,
	  "show wtp sample throughput information",
	  SHOW_STR
	  "wtp information\n"
	  "wtp sample information\n"
	  "wtp sample throughput information\n"
	  "wtp sample throughput information\n"
	 )
{	
	
/*	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;*/
	unsigned int WTPID;
	unsigned char time;
	int ret = WID_DBUS_SUCCESS;
	//WTPID = (unsigned int)vty->index;
	int i = 0;
	//wid_sample_rate_info info = {0,0,0,0,0,0};

	DCLI_WTP_API_GROUP_TWO *INFO = NULL;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
#if 0	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WID_WTP_SAMPLE_THROUGHPUT_INFO);
		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WID_WTP_SAMPLE_THROUGHPUT_INFO);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}

	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0)
	{	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&time);
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.past_uplink_throughput);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.past_downlink_throughput);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.current_uplink_throughput);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.current_downlink_throughput);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.uplink_rate);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.downlink_rate);

		
	}
	/*ap send info is BYTE,show will be bit*/
	dbus_message_unref(reply);
#endif
	INFO = dcli_wtp_show_api_group_two(
	   index,
	   FIRST,/*"show wtp sample throughput information"*/
	   WTPID,
	   0,
	   0,
	   &ret,/**/
	   0,/*num2*/
	   0,
	   0,
	   0,
	   &localid,
	//   INFO,
	   dcli_dbus_connection,
	   WID_DBUS_CONF_METHOD_SHOW_WID_WTP_SAMPLE_THROUGHPUT_INFO
	   );
	if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == 0){		
		vty_out(vty,"==============================================================================\n");
		vty_out(vty,"WTP sample throughput infomation\n");
		vty_out(vty,"sample time:	%d\n",(INFO->WTP[0]->wid_sample_throughput.time));
		/* protect 0 value*/
		if(INFO->WTP[0]->wid_sample_throughput.uplink_rate <= 2)
		{
			INFO->WTP[0]->wid_sample_throughput.uplink_rate = 2;
		}
		if(INFO->WTP[0]->wid_sample_throughput.downlink_rate <= 2)
		{
			INFO->WTP[0]->wid_sample_throughput.downlink_rate = 2;
		}
		vty_out(vty,"past_uplink_throughput:	%d KB\n",INFO->WTP[0]->wid_sample_throughput.past_uplink_throughput);
		vty_out(vty,"past_downlink_throughput:	%d KB\n",INFO->WTP[0]->wid_sample_throughput.past_downlink_throughput);
		vty_out(vty,"current_uplink_throughput:	%d KB\n",INFO->WTP[0]->wid_sample_throughput.current_uplink_throughput);
		vty_out(vty,"current_downlink_throughput:	%d KB\n",INFO->WTP[0]->wid_sample_throughput.current_downlink_throughput);
		vty_out(vty,"uplink_throughput:	%d KB\n",INFO->WTP[0]->wid_sample_throughput.uplink_rate);
		vty_out(vty,"downlink_throughput:	%d KB\n",INFO->WTP[0]->wid_sample_throughput.downlink_rate);
		vty_out(vty,"uplink_rate:	%d kbps\n",((INFO->WTP[0]->wid_sample_throughput.uplink_rate)/(INFO->WTP[0]->wid_sample_throughput.time))*8);
		vty_out(vty,"downlink_rate:	%d kbps\n",((INFO->WTP[0]->wid_sample_throughput.downlink_rate)/(INFO->WTP[0]->wid_sample_throughput.time))*8);
		vty_out(vty,"==============================================================================\n");

		dcli_wtp_free_fun_two(WID_DBUS_CONF_METHOD_SHOW_WID_WTP_SAMPLE_THROUGHPUT_INFO,INFO);
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
	vty_out(vty,"<error> wtp is not in run state\n");
	else if (ret == WTP_ID_NOT_EXIST)
	vty_out(vty,"<error> wtp id does not exist\n");
	else if (ret == SAMPLE_THROUGHPUT_NOT_ENABLE)
	vty_out(vty,"<error> sample switch disable,enable it first\n");

//	CW_FREE_OBJECT(INFO->WTP[0]);
//	CW_FREE_OBJECT(INFO->WTP);
//	CW_FREE_OBJECT(INFO);
	return CMD_SUCCESS;
}

#if _GROUP_POLICY

DEFUN(set_wtp_wtpname_cmd_func,
	  set_wtp_wtpname_cmd,
	  "set wtp name NAME",
	  CONFIG_STR
	  "wtp information\n"
	  "wtp name\n"
	  "wtp name length <1-255>\n"
	 )
{	

	char *name = NULL;
	int len = 0;
	int i = 0;
	int ret = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;

	//DBusConnection *dbus_connection = dcli_dbus_connection;
	len = strlen(argv[0]);

	if(len >= DEFAULT_LEN){		
		vty_out(vty,"<error> wtp name is too long,should be 1 to %d\n",DEFAULT_LEN-1);
		return CMD_SUCCESS;
	}	

	
	name = (char*)malloc(strlen(argv[0])+1);
	memset(name, 0, strlen(argv[0])+1);
	memcpy(name, argv[0], strlen(argv[0]));
	
	if(vty->node == WTP_NODE){
		index = 0;			
		id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	WtpList_Head = set_wtp_wtpname_cmd_set_wtp_name(index,localid,dcli_dbus_connection,type,id,name,&count,&ret);

	if(type==0)
		{
			if(ret == 0)
				{		
					vty_out(vty,"set wtp name %s successfully\n",argv[0]);
				}
			else if (ret == WTP_ID_NOT_EXIST)
					vty_out(vty,"<error> wtp id does not exist\n");
		}

	
	if(type==1)
		{
			if(ret == 0)
			{
				vty_out(vty,"group %d set wtp name %s successfully\n",id,argv[0]);
				if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL))
				{
					vty_out(vty,"wtp ");					
					for(i=0; i<count; i++)
					{
						if(Wtp_Show_Node == NULL)
							Wtp_Show_Node = WtpList_Head->WtpList_list;
						else 
							Wtp_Show_Node = Wtp_Show_Node->next;
	
						if(Wtp_Show_Node == NULL)
							break;
						
						vty_out(vty,"%d ",Wtp_Show_Node->WtpId);
						vty_out(vty,"%c",Wtp_Show_Node->FailReason);
					}	
					
					vty_out(vty," failed.\n");
					dcli_free_WtpList(WtpList_Head);
				}
			}
			else if (ret == GROUP_ID_NOT_EXIST)
		 	vty_out(vty,"<error> group id does not exist\n");
		}

	free(name);
	name = NULL;
	return CMD_SUCCESS;
}

#else
DEFUN(set_wtp_wtpname_cmd_func,
	  set_wtp_wtpname_cmd,
	  "set wtp name NAME",
	  CONFIG_STR
	  "wtp information\n"
	  "wtp name\n"
	  "wtp name length <1-255>\n"
	 )
{	
	
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;
	unsigned int WTPID = 0;
	int ret = WID_DBUS_SUCCESS;
	char *name = NULL;
	int len = 0;
	//WTPID = (unsigned int)vty->index;

	len = strlen(argv[0]);

	if(len >= DEFAULT_LEN){		
		vty_out(vty,"<error> wtp name is too long,should be 1 to %d\n",DEFAULT_LEN-1);
		return CMD_SUCCESS;
	}	

	
	name = (char*)malloc(strlen(argv[0])+1);
	memset(name, 0, strlen(argv[0])+1);
	memcpy(name, argv[0], strlen(argv[0]));
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTPNAME);
		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTPNAME);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_STRING,&name,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		if(name)
		{
			free(name);
			name = NULL;
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
		
	dbus_message_unref(reply);
	if(ret == 0)
	{		
		vty_out(vty,"set wtp name %s successfully\n",argv[0]);
	}
	else if (ret == WTP_ID_NOT_EXIST)
	vty_out(vty,"<error> wtp id does not exist\n");
	free(name);
	name = NULL;
	return CMD_SUCCESS;
}
#endif
#if _GROUP_POLICY

DEFUN(set_ap_extension_infomation_enable_func,
	  set_ap_extension_infomation_enable_cmd,
	  "set ap extension infomation switch (enable|disable)",
	  CONFIG_STR
	  "wtp config\n"
	  "wtp extension information\n"
	  "wtp extension information\n"
	  "wtp extension information switch\n"
	  "enable|disable\n"
	 )
{
    int policy = 0;
	int i = 0;
	int ret = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;

	//DBusConnection *dbus_connection = dcli_dbus_connection;
	if (!strcmp(argv[0],"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[0],"disable"))
	{
		policy = 0;	
	}
	else
	{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}
	
	if(vty->node == WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	
	WtpList_Head = set_ap_extension_infomation_enable_cmd_set_ap_extension_infomation_switch(index,localid,dcli_dbus_connection,type,
		id,policy,&count,&ret);

	if(type==0)
		{
			if(ret == 0)
			{
				vty_out(vty," set wtp %d extension infomation switch %s successfully\n",id,argv[0]);
			}
			else if (ret == WTP_ID_NOT_EXIST)
				vty_out(vty,"<error> wtp id does not exist\n");
			else if (ret == WTP_NOT_IN_RUN_STATE)
				vty_out(vty,"<error> wtp id does not run\n");
			else
			{
				vty_out(vty,"<error>  %d\n",ret);
			}
		}

	if(type==1)
		{
			if(ret == 0)
			{
				vty_out(vty,"group %d set wtp extension infomation switch %s successfully\n",id,argv[0]);
				if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL))
				{
					vty_out(vty,"wtp ");					
					for(i=0; i<count; i++)
					{
						if(Wtp_Show_Node == NULL)
							Wtp_Show_Node = WtpList_Head->WtpList_list;
						else 
							Wtp_Show_Node = Wtp_Show_Node->next;
	
						if(Wtp_Show_Node == NULL)
							break;
						
						vty_out(vty,"%d ",Wtp_Show_Node->WtpId);
						vty_out(vty,"%c",Wtp_Show_Node->FailReason);
					}	
					
					vty_out(vty," failed.\n");
					dcli_free_WtpList(WtpList_Head);
				}
			}
			else if (ret == GROUP_ID_NOT_EXIST)
		 	vty_out(vty,"<error> group id does not exist\n");
		}

	
	return CMD_SUCCESS;			
}

#else
DEFUN(set_ap_extension_infomation_enable_func,
	  set_ap_extension_infomation_enable_cmd,
	  "set ap extension infomation switch (enable|disable)",
	  CONFIG_STR
	  "wtp config\n"
	  "wtp extension information\n"
	  "wtp extension information\n"
	  "wtp extension information switch\n"
	  "enable|disable\n"
	 )
{
	int ret;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID = 0;
    int policy = 0;
	//WTPID = (unsigned int)vty->index;
	
	if (!strcmp(argv[0],"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[0],"disable"))
	{
		policy = 0;	
	}
	else
	{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_EXTENSION_INFOMATION_SWITCH);
		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_EXTENSION_INFOMATION_SWITCH);*/
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty," set wtp %d extension infomation switch %s successfully\n",WTPID,argv[0]);
	}
	else if (ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else if (ret == WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp id does not run\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	
	return CMD_SUCCESS;			
}
#endif
#if _GROUP_POLICY

/* zhangshu add for set Terminal Disturb Info Report switch, 2010-10-08 */
DEFUN(set_ap_terminal_distrub_infomation_switch_func,
	  set_ap_terminal_distrub_infomation_switch_cmd,
	  "set ap terminal distrub infomation switch (enable|disable)",
	  CONFIG_STR
	  "wtp config\n"
	  "wtp terminal distrub infomation\n"
	  "wtp terminal distrub infomation\n"
	  "wtp terminal distrub infomation\n"
	  "wtp terminal distrub infomation\n"
	  "wtp terminal distrub infomation switch\n"
	  "enable|disable\n"
	 )
{

    int policy = 0;
	int i = 0;
	int ret = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	if (!strcmp(argv[0],"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[0],"disable"))
	{
		policy = 0;	
	}
	else
	{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}

	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	WtpList_Head = set_ap_terminal_distrub_infomation_switch_cmd_set_ap_switch(index,localid,dcli_dbus_connection,type,id,
		policy,&count,&ret);

	if(type==0)
		{
			if(ret == 0)
			{
				vty_out(vty," set wtp %d terminal distrub infomation switch %s successfully\n",id,argv[0]);
			}
			else if (ret == WTP_ID_NOT_EXIST)
			{
				vty_out(vty,"<error> wtp id does not exist\n");
			}
			else if (ret == WTP_NOT_IN_RUN_STATE)
			{
				vty_out(vty,"<error> wtp id does not run\n");
			}
			else
			{
				vty_out(vty,"<error>  %d\n",ret);
			}
	
		}
	
		if(type==1)
		{
			if(ret == 0)
			{
				vty_out(vty,"group %d set wtp terminal distrub infomation switch %s successfully\n",id,argv[0]);
				if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL))
				{
					vty_out(vty,"wtp ");					
					for(i=0; i<count; i++)
					{
						if(Wtp_Show_Node == NULL)
							Wtp_Show_Node = WtpList_Head->WtpList_list;
						else 
							Wtp_Show_Node = Wtp_Show_Node->next;
	
						if(Wtp_Show_Node == NULL)
							break;
						
						vty_out(vty,"%d ",Wtp_Show_Node->WtpId);
						vty_out(vty,"%c",Wtp_Show_Node->FailReason);
					}	
					
					vty_out(vty," failed.\n");
					dcli_free_WtpList(WtpList_Head);
				}
			}
			else if (ret == GROUP_ID_NOT_EXIST)
		 	vty_out(vty,"<error> group id does not exist\n");
			}
	return CMD_SUCCESS;			
}

#else
/* zhangshu add for set Terminal Disturb Info Report switch, 2010-10-08 */
DEFUN(set_ap_terminal_distrub_infomation_switch_func,
	  set_ap_terminal_distrub_infomation_switch_cmd,
	  "set ap terminal distrub infomation switch (enable|disable)",
	  CONFIG_STR
	  "wtp config\n"
	  "wtp terminal distrub infomation\n"
	  "wtp terminal distrub infomation\n"
	  "wtp terminal distrub infomation\n"
	  "wtp terminal distrub infomation\n"
	  "wtp terminal distrub infomation switch\n"
	  "enable|disable\n"
	 )
{
	int ret;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID = 0;
    int policy = 0;
	
	if (!strcmp(argv[0],"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[0],"disable"))
	{
		policy = 0;	
	}
	else
	{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}

	//WTPID = (unsigned int)vty->index;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);

	query = dbus_message_new_method_call(BUSNAME,OBJPATH,\
						INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_TERMINAL_DISTRUB_INFOMATION_SWITCH);
						
	dbus_error_init(&err);
	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty," set wtp %d terminal distrub infomation switch %s successfully\n",WTPID,argv[0]);
	}
	else if (ret == WTP_ID_NOT_EXIST)
	{
		vty_out(vty,"<error> wtp id does not exist\n");
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
	{
		vty_out(vty,"<error> wtp id does not run\n");
	}
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);
	return CMD_SUCCESS;			
}
#endif
#if _GROUP_POLICY
/* zhangshu add for set Terminal Disturb Info Report interval, 2010-10-08 */
DEFUN(set_ap_terminal_distrub_infomation_pkt_func,
	  set_ap_terminal_distrub_infomation_pkt_cmd,
	  "set ap terminal distrub infomation reportpkt REPORTPKT",  //fengwenchao change <0-50000> to REPORTPKT 20110412
	  CONFIG_STR
	  "wtp config\n"
	  "wtp terminal distrub infomation\n"
	  "wtp terminal distrub infomation\n"
	  "wtp terminal distrub infomation\n"
	  "wtp terminal distrub infomation\n"
	  "<0-50000> wtp terminal distrub infomation reportpkt\n"  //fengwenchao modify 20110412
	  "0-50000\n"
	 )
{
	int i = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	int pkt = 0;
	int ret = WID_DBUS_SUCCESS;
	unsigned int type = 0;
	unsigned int id = 0;
	
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;

	/*fengwenchao modify 20110412*/
	ret = parse_int_ID((char*)argv[0], &pkt);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}
	//pkt = atoi(argv[0]);
	/*fengwenchao modify end*/
	
	if(pkt > 50000 || pkt < 0){
		vty_out(vty,"<error> ap terminal distrub infomation reportpkt error\n");
		return CMD_SUCCESS;
	}

	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	WtpList_Head = set_ap_terminal_distrub_infomation_pkt_cmd_set_ap_terminal_distrub_infomation_reportpkt(index,localid,dcli_dbus_connection,
		type,id,pkt,&count,&ret);
	if(type==0)
		{
			if(ret == 0)
			{
				vty_out(vty," set wtp %d terminal distrub infomation pkt %s successfully\n",id,argv[0]);
			}
			else if (ret == WTP_ID_NOT_EXIST)
			{
				vty_out(vty,"<error> wtp id does not exist\n");
			}
			else if (ret == WTP_NOT_IN_RUN_STATE)
			{
				vty_out(vty,"<error> wtp id does not run\n");
			}
			else
			{
				vty_out(vty,"<error>  %d\n",ret);
			}
		
		}
	if(type==1)
		{
			if(ret == 0)
			{
				vty_out(vty,"group %d set wtp terminal distrub infomation sta_num %s successfully\n",id,argv[0]);
				if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL))
				{
					vty_out(vty,"wtp ");					
					for(i=0; i<count; i++)
					{
						if(Wtp_Show_Node == NULL)
							Wtp_Show_Node = WtpList_Head->WtpList_list;
						else 
							Wtp_Show_Node = Wtp_Show_Node->next;
	
						if(Wtp_Show_Node == NULL)
							break;
						
						vty_out(vty,"%d ",Wtp_Show_Node->WtpId);
						vty_out(vty,"%c",Wtp_Show_Node->FailReason);
					}	
					
					vty_out(vty," failed.\n");
					dcli_free_WtpList(WtpList_Head);
				}
			}
			else if (ret == GROUP_ID_NOT_EXIST)
		 	vty_out(vty,"<error> group id does not exist\n");
		}
	return CMD_SUCCESS;			
}

#else
/* zhangshu add for set Terminal Disturb Info Report interval, 2010-10-08 */
DEFUN(set_ap_terminal_distrub_infomation_pkt_func,
	  set_ap_terminal_distrub_infomation_pkt_cmd,
	  "set ap terminal distrub infomation reportpkt REPORTPKT",  //fengwenchao change <0-50000> to REPORTPKT 20110412
	  CONFIG_STR
	  "wtp config\n"
	  "wtp terminal distrub infomation\n"
	  "wtp terminal distrub infomation\n"
	  "wtp terminal distrub infomation\n"
	  "wtp terminal distrub infomation\n"
	  "<0-50000> wtp terminal distrub infomation reportpkt\n"  //fengwenchao modify 20110412
	  "0-50000\n"
	 )
{
	int ret;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID = 0;
    int pkt = 0;
	
	/*fengwenchao modify 20110412*/
	ret = parse_int_ID((char*)argv[0], &pkt);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}
	//pkt = atoi(argv[0]);
	/*fengwenchao modify end*/
	
	if(pkt > 50000 || pkt < 0){
		vty_out(vty,"<error> ap terminal distrub infomation reportpkt error\n");
		return CMD_SUCCESS;
	}

	//WTPID = (unsigned int)vty->index;
	int localid = 1;
	int slot_id = HostSlotId;
    int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,\
						INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_TERMINAL_DISTRUB_INFOMATION_PKT);
						
	dbus_error_init(&err);
	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_UINT32,&pkt,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty," set wtp %d terminal distrub infomation pkt %s successfully\n",WTPID,argv[0]);
	}
	else if (ret == WTP_ID_NOT_EXIST)
	{
		vty_out(vty,"<error> wtp id does not exist\n");
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
	{
		vty_out(vty,"<error> wtp id does not run\n");
	}
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);
	return CMD_SUCCESS;			
}
#endif
#if _GROUP_POLICY

/* zhangshu add for set Terminal Disturb Info Report sta num, 2010-10-08 */
DEFUN(set_ap_terminal_distrub_infomation_sta_num_func,
	  set_ap_terminal_distrub_infomation_sta_num_cmd,
	  "set ap terminal distrub infomation sta_num STANUM",   //fengwenchao change <1-50000> to STANUM 20110412
	  CONFIG_STR
	  "wtp config\n"
	  "wtp terminal distrub infomation\n"
	  "wtp terminal distrub infomation\n"
	  "wtp terminal distrub infomation\n"
	  "wtp terminal distrub infomation\n"
	  "<1-50000> wtp terminal distrub infomation sta_num\n"	//fengwenchao modify 20110412	  "<1-50000> wtp terminal distrub infomation sta_num\n"   //fengwenchao modify 20110412
	  "1-50000\n"
	 )
{
	int i = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	int ret = WID_DBUS_SUCCESS;
	unsigned int type = 0;
	unsigned int id = 0;
	unsigned int sta_num = 0;
	

	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;
    	
	/*fengwenchao modify 20110412*/
	ret = parse_int_ID((char*)argv[0], &sta_num);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}
	//sta_num = atoi(argv[0]);
	/*fengwenchao modify end*/
	
	if(sta_num > 50000 || sta_num <= 0){
		vty_out(vty,"<error> ap terminal distrub infomation report sta_num error\n");
		return CMD_SUCCESS;
	}

	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	WtpList_Head = set_ap_terminal_distrub_infomation_sta_num_cmd_sta_num(index,localid,dcli_dbus_connection,type,id,sta_num,
		&count,&ret);

if(type==0)
{
	if(ret == 0)
	{
		vty_out(vty," set wtp %d terminal distrub infomation sta_num %s successfully\n",id,argv[0]);
	}
	else if (ret == WTP_ID_NOT_EXIST)
	{
		vty_out(vty,"<error> wtp id does not exist\n");
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
	{
		vty_out(vty,"<error> wtp id does not run\n");
	}
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
}
if(type==1)
{
	if(ret == 0)
	{
		vty_out(vty,"group %d set wtp terminal distrub infomation sta_num %s successfully\n",id,argv[0]);
		if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL))
			{
				vty_out(vty,"wtp ");					
				for(i=0; i<count; i++)
				{
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;
	
					if(Wtp_Show_Node == NULL)
						break;
						
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);
					vty_out(vty,"%c",Wtp_Show_Node->FailReason);
				}	
					
				vty_out(vty," failed.\n");
				dcli_free_WtpList(WtpList_Head);
			}
		}
	else if (ret == GROUP_ID_NOT_EXIST)
		 vty_out(vty,"<error> group id does not exist\n");
}

		
	return CMD_SUCCESS;			
}

#else
/* zhangshu add for set Terminal Disturb Info Report sta num, 2010-10-08 */
DEFUN(set_ap_terminal_distrub_infomation_sta_num_func,
	  set_ap_terminal_distrub_infomation_sta_num_cmd,
	  "set ap terminal distrub infomation sta_num STANUM",   //fengwenchao change <1-50000> to STANUM 20110412
	  CONFIG_STR
	  "wtp config\n"
	  "wtp terminal distrub infomation\n"
	  "wtp terminal distrub infomation\n"
	  "wtp terminal distrub infomation\n"
	  "wtp terminal distrub infomation\n"
	  "<1-50000> wtp terminal distrub infomation sta_num\n"	//fengwenchao modify 20110412
	  "1-50000\n"
	 )
{
	int ret;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID = 0;
    int sta_num = 0;
	
	/*fengwenchao modify 20110412*/
	ret = parse_int_ID((char*)argv[0], &sta_num);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}
	//sta_num = atoi(argv[0]);
	/*fengwenchao modify end*/
	
	if(sta_num > 50000 || sta_num <= 0){
		vty_out(vty,"<error> ap terminal distrub infomation report sta_num error\n");
		return CMD_SUCCESS;
	}

	//WTPID = (unsigned int)vty->index;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);

	query = dbus_message_new_method_call(BUSNAME,OBJPATH,\
						INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_TERMINAL_DISTRUB_INFOMATION_STA_NUM);
						
	dbus_error_init(&err);
	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_UINT32,&sta_num,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty," set wtp %d terminal distrub infomation sta_num %s successfully\n",WTPID,argv[0]);
	}
	else if (ret == WTP_ID_NOT_EXIST)
	{
		vty_out(vty,"<error> wtp id does not exist\n");
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
	{
		vty_out(vty,"<error> wtp id does not run\n");
	}
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);
	return CMD_SUCCESS;			
}
/* ---zhangshu add for terminal distrub infomation END---, 2010-10-08 */
#endif
#if _GROUP_POLICY

DEFUN(set_ap_extension_infomation_reportinterval_cmd_func,
	  set_ap_extension_infomation_reportinterval_cmd,
	  "set ap extension infomation reportinterval PARAMETER",
	  "wireless-control config\n"
	  "ap extension infomation\n"
	  "ap extension infomation\n"
	  "ap extension infomation\n"
	  "ap extension infomation reportinterval\n"
	  "ap extension infomation reportinterval s \n"
	 )
{
	int i = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int type = 0;
	unsigned int id = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret1 =WID_DBUS_SUCCESS; 
    unsigned int interval = 0;

	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;

	
	ret1 = parse_int_ID((char*)argv[0], &interval);
	if(ret1 != WID_DBUS_SUCCESS){
            if(ret1 == WID_ILLEGAL_INPUT){
            	vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
            }
			else{
			vty_out(vty,"<error> unknown id format\n");
			}
			return CMD_SUCCESS;
	}	
	if(interval > 600 || interval == 0){
		vty_out(vty,"<error> ap extension infomation reportinterval error\n");
		return CMD_SUCCESS;
	}	
	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	WtpList_Head=set_ap_extension_infomation_reportinterval_cmd_set_ap_extension_infomation_reportinterval(
		index,localid,dcli_dbus_connection,type,id,interval,&count,&ret);
if(type==0)
{
	if(ret == 0)
		{
			vty_out(vty,"set ap extension infomation reportinterval %s successfully\n",argv[0]);
		}
	else if(ret == WTP_NOT_IN_RUN_STATE)
			vty_out(vty,"<error> wtp is not in run state\n");
	else if(ret == WTP_ID_NOT_EXIST)
			vty_out(vty,"<error> wtp id does not exist\n");
	else
		{
		vty_out(vty,"<error>  %d\n",ret);
		}
}
if(type==1)
{
	if(ret == 0)
		{
			vty_out(vty,"set ap extension infomation reportinterval %s successfully\n",argv[0]);
			if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL))
				{
					vty_out(vty,"wtp ");					
					for(i=0; i<count; i++)
						{
							if(Wtp_Show_Node == NULL)
									Wtp_Show_Node = WtpList_Head->WtpList_list;
							else 
									Wtp_Show_Node = Wtp_Show_Node->next;

							if(Wtp_Show_Node == NULL)
									break;
					
							vty_out(vty,"%d ",Wtp_Show_Node->WtpId);
							vty_out(vty,"%c",Wtp_Show_Node->FailReason);
						}	
				
					vty_out(vty," failed.\n");
					dcli_free_WtpList(WtpList_Head);
				}
		}
	else if (ret == GROUP_ID_NOT_EXIST)
		   vty_out(vty,"<error> group id does not exist\n");
}
			
	return CMD_SUCCESS;			
}

#else

DEFUN(set_ap_unauthorized_mac_switch_cmd_func,
	  set_ap_unauthorized_mac_switch_cmd,
	  "set ap unauthorized mac switch (enable|disable)",
	  "wireless-control config\n"
	  "ap unauthorized mac\n"
	  "ap unauthorized mac\n"
	  "ap unauthorized mac\n"
	  "ap unauthorized mac report switch\n"
	  "ap unauthorized mac report switch (enable|disable) \n"
	 )
{
	int ret,ret1;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

    unsigned int interval = 0;
	unsigned int wtp_id = 0;
	unsigned int policy = 0;
	
	if (!strcmp(argv[0],"enable")){
		policy = 1;	
	} else if (!strcmp(argv[0],"disable")) {
		policy = 0;	
	} else {
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}
	
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_UNAUTHORIZED_MAC_REPORT_SWITCH);
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,	
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"set ap unauthorized mac report switch %s successfully\n", argv[0]);
	} else if (ret == WTP_NOT_IN_RUN_STATE) {
		vty_out(vty,"<error> wtp is not in run state\n");
	} else if(ret == WTP_ID_NOT_EXIST) {
		vty_out(vty,"<error> wtp id does not exist\n");
	} else {
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	return CMD_SUCCESS;			
}

DEFUN(set_ap_unauthorized_mac_reportinterval_cmd_func,
	  set_ap_unauthorized_mac_reportinterval_cmd,
	  "set ap unauthorized mac reportinterval PARAMETER",
	  "wireless-control config\n"
	  "ap unauthorized mac\n"
	  "ap unauthorized mac\n"
	  "ap unauthorized mac\n"
	  "ap unauthorized mac reportinterval\n"
	  "ap unauthorized mac reportinterval s \n"
	 )
{
	int ret,ret1;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

    unsigned int interval = 0;
	unsigned int wtp_id = 0;

	if (argc < 1) {
		vty_out(vty, "parameter time interval is need\n");
		return CMD_FAILURE;
	}
	
	ret1 = parse_int_ID((char*)argv[0], &interval);
	if(ret1 != WID_DBUS_SUCCESS){
            if(ret1 == WID_ILLEGAL_INPUT){
            	vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
            }
			else{
			vty_out(vty,"<error> unknown id format\n");
			}
			return CMD_SUCCESS;
	}
	
	if(interval > 32767 || interval == 0){   /*fengwenchao change 600 to 32767*/
		vty_out(vty,"the time interval should be between 1 and 32766\n");
		return CMD_FAILURE;
	}
	
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_UNAUTHORIZED_MAC_REPORTINTERVAL);
		
		
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,	
							 DBUS_TYPE_UINT32,&interval,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"set ap unauthorized mac reportinterval %s successfully\n",argv[0]);
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp is not in run state\n");
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	
	return CMD_SUCCESS;			
}


DEFUN(set_ap_configure_error_switch_cmd_func,
	  set_ap_configure_error_switch_cmd,
	  "set ap configure file error switch (enable|disable)",
	  "wireless-control config\n"
	  "ap configure file error\n"
	  "ap configure file error\n"
	  "ap configure file error\n"
	  "ap configure file error report switch\n"
	  "ap configure file error report switch (enable|disable) \n"
	 )
{
	int ret,ret1;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

    unsigned int interval = 0;
	unsigned int wtp_id = 0;
	unsigned int policy = 0;
	
	if (!strcmp(argv[0],"enable")){
		policy = 1;	
	} else if (!strcmp(argv[0],"disable")) {
		policy = 0;	
	} else {
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}
	
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_CONFIGURE_ERR_REPORTSWITCH);
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,	
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"set ap configure file error report switch %s successfully\n", argv[0]);
	} else if (ret == WTP_NOT_IN_RUN_STATE) {
		vty_out(vty,"<error> wtp is not in run state\n");
	} else if(ret == WTP_ID_NOT_EXIST) {
		vty_out(vty,"<error> wtp id does not exist\n");
	} else {
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	return CMD_SUCCESS;			
}

DEFUN(set_ap_configure_error_reportinterval_cmd_func,
	  set_ap_confiugre_error_reportinterval_cmd,
	  "set ap configure file error reportinterval PARAMETER",
	  "wireless-control config\n"
	  "ap configure file error\n"
	  "ap configure file error\n"
	  "ap configure file error\n"
	  "ap configure file error reportinterval\n"
	  "ap configure file error reportinterval s \n"
	 )
{
	int ret,ret1;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

    unsigned int interval = 0;
	unsigned int wtp_id = 0;

	if (argc < 1) {
		vty_out(vty, "parameter time interval is need\n");
		return CMD_FAILURE;
	}
	
	ret1 = parse_int_ID((char*)argv[0], &interval);
	if(ret1 != WID_DBUS_SUCCESS){
            if(ret1 == WID_ILLEGAL_INPUT){
            	vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
            }
			else{
			vty_out(vty,"<error> unknown id format\n");
			}
			return CMD_SUCCESS;
	}
	
	if(interval > 32767 || interval == 0){   /*fengwenchao change 600 to 32767*/
		vty_out(vty,"the time interval should be between 1 and 32766\n");
		return CMD_FAILURE;
	}
	
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_CONFIGURE_ERR_REPORTINTERVAL);
		
		
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,	
							 DBUS_TYPE_UINT32,&interval,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"set ap configure file error reportinterval %s successfully\n",argv[0]);
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp is not in run state\n");
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	
	return CMD_SUCCESS;			
}

DEFUN(set_ap_online_sta_full_switch_cmd_func,
	  set_ap_online_sta_full_switch_cmd,
	  "set ap online sta full switch (enable|disable)",
	  "wireless-control config\n"
	  "ap onlie sta full\n"
	  "ap onlie sta full\n"
	  "ap onlie sta full\n"
	  "ap onlie sta full report switch\n"
	  "ap onlie sta full report switch (enable|disable) \n"
	 )
{
	int ret,ret1;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

    unsigned int interval = 0;
	unsigned int wtp_id = 0;
	unsigned int policy = 0;
	
	if (!strcmp(argv[0],"enable")){
		policy = 1;	
	} else if (!strcmp(argv[0],"disable")) {
		policy = 0;	
	} else {
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}
	
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_ONLINE_STA_FULL_REPORTE_SWITCH);
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,	
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"set ap onlie sta full report switch %s successfully\n", argv[0]);
	} else if (ret == WTP_NOT_IN_RUN_STATE) {
		vty_out(vty,"<error> wtp is not in run state\n");
	} else if(ret == WTP_ID_NOT_EXIST) {
		vty_out(vty,"<error> wtp id does not exist\n");
	} else {
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	return CMD_SUCCESS;			
}

DEFUN(set_ap_online_sta_full_reportinterval_cmd_func,
	  set_ap_online_sta_full_reportinterval_cmd,
	  "set ap online sta full reportinterval PARAMETER",
	  "wireless-control config\n"
	  "ap online sta full\n"
	  "ap online sta full\n"
	  "ap online sta full\n"
	  "ap online sta full reportinterval\n"
	  "ap online sta full reportinterval s \n"
	 )
{
	int ret,ret1;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

    unsigned int interval = 0;
	unsigned int wtp_id = 0;

	if (argc < 1) {
		vty_out(vty, "parameter time interval is need\n");
		return CMD_FAILURE;
	}
	
	ret1 = parse_int_ID((char*)argv[0], &interval);
	if(ret1 != WID_DBUS_SUCCESS){
            if(ret1 == WID_ILLEGAL_INPUT){
            	vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
            }
			else{
			vty_out(vty,"<error> unknown id format\n");
			}
			return CMD_SUCCESS;
	}
	
	if(interval > 32767 || interval == 0){   /*fengwenchao change 600 to 32767*/
		vty_out(vty,"the time interval should be between 1 and 32766\n");
		return CMD_FAILURE;
	}
	
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_ONLINE_STA_FULL_REPORTEINTERVAL);
		
		
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,	
							 DBUS_TYPE_UINT32,&interval,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"set ap online sta full reportinterval %s successfully\n",argv[0]);
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp is not in run state\n");
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	
	return CMD_SUCCESS;			
}

DEFUN(set_rx_tx_flow_overflow_cmd_func,
	  trap_rx_tx_flow_overflow_cmd,
	  "set ap sta flow (rx|tx) overflow trap switch (enable|disable)",
	  "wireless-control config\n"
	  "ap sta flow (rx|tx) overflow \n"
	  "ap sta flow (rx|tx) overflow \n"
	  "ap sta flow (rx|tx) overflow \n"
	  "ap sta flow (rx|tx) overflow  report switch\n"
	  "ap sta flow (rx|tx) overflow  report switch (enable|disable) \n"
	 )
{
	int ret,ret1;

	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;

	unsigned int interval = 0;
	unsigned int wtp_id = 0;
	unsigned int policy = 0;
	unsigned int is_rx_tx = 0;
	
	if (!strcmp(argv[0],"rx")){
		is_rx_tx = 1;	
	} else if (!strcmp(argv[0],"tx")) {
		is_rx_tx = 0;	
	} else {
		vty_out(vty,"<error> input patameter only with 'rx' or 'tx'\n");
		return CMD_SUCCESS;
	}
	
	if (!strcmp(argv[1],"enable")){
		policy = 1; 
	} else if (!strcmp(argv[1],"disable")) {
		policy = 0; 
	} else {
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}
	
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_STA_FLOW_RX_TX_OVERLFOW_TRAP_SWITCH);
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_UINT32,&is_rx_tx,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"set ap flow %s overflow report switch %s successfully\n", argv[0], argv[1]);
	} else if (ret == WTP_NOT_IN_RUN_STATE) {
		vty_out(vty,"<error> wtp is not in run state\n");
	} else if(ret == WTP_ID_NOT_EXIST) {
		vty_out(vty,"<error> wtp id does not exist\n");
	} else {
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	return CMD_SUCCESS; 		
}


DEFUN(set_ap_sta_flow_rx_tx_overflow_threshold_cmd_func,
	  set_ap_sta_flow_rx_tx_overflow_threshold_cmd,
	  "set ap sta flow (rx|tx) overflow threshold PARAMETER",
	  "wireless-control config\n"
	  "ap sta flow (rx|tx) threshold\n"
	  "ap sta flow (rx|tx) threshold\n"
	  "ap sta flow (rx|tx) threshold\n"
	  "ap sta flow (rx|tx) threshold \n"
	  "ap sta flow (rx|tx) threshold  kB \n"
	 )
{
	int ret,ret1;

	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;

	unsigned int interval = 0;
	unsigned int wtp_id = 0;
	unsigned int is_rx_tx = 0;
	if (argc < 2) {
		vty_out(vty, "parameter time interval is need\n");
		return CMD_FAILURE;
	}

	if (!strcmp(argv[0],"rx")){
		is_rx_tx = 1;	
	} else if (!strcmp(argv[0],"tx")) {
		is_rx_tx = 0;	
	} else {
		vty_out(vty,"<error> input patameter only with 'rx' or 'tx'\n");
		return CMD_SUCCESS;
	}
	
	ret1 = parse_int_ID((char*)argv[1], &interval);
	if(ret1 != WID_DBUS_SUCCESS){
		if(ret1 == WID_ILLEGAL_INPUT){
			vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
		}
		else{
		vty_out(vty,"<error> unknown id format\n");
		}
		return CMD_SUCCESS;
	}
	
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_STA_FLOW_RX_TX_OVERLFOW_THRESHOLD);
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_UINT32,&is_rx_tx,
							 DBUS_TYPE_UINT32,&interval,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"set ap sta flow %s overflow reportinterval %s successfully\n",argv[0], argv[1]);
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp is not in run state\n");
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	
	return CMD_SUCCESS; 		
}



DEFUN(set_ap_sta_flow_rx_tx_overflow_switch_cmd_func,
	  set_ap_sta_flow_rx_tx_overflow_switch_cmd,
	  "set ap sta flow (rx|tx) overflow report switch (enable|disable)",
	  "wireless-control config\n"
	  "ap sta flow (rx|tx) overflow \n"
	  "ap sta flow (rx|tx) overflow \n"
	  "ap sta flow (rx|tx) overflow \n"
	  "ap sta flow (rx|tx) overflow  report switch\n"
	  "ap sta flow (rx|tx) overflow  report switch (enable|disable) \n"
	 )
{
	int ret,ret1;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

    unsigned int interval = 0;
	unsigned int wtp_id = 0;
	unsigned int policy = 0;
	unsigned int is_rx_tx = 0;
	
	if (!strcmp(argv[0],"rx")){
		is_rx_tx = 1;	
	} else if (!strcmp(argv[0],"tx")) {
		is_rx_tx = 0;	
	} else {
		vty_out(vty,"<error> input patameter only with 'rx' or 'tx'\n");
		return CMD_SUCCESS;
	}
	
	if (!strcmp(argv[1],"enable")){
		policy = 1;	
	} else if (!strcmp(argv[1],"disable")) {
		policy = 0;	
	} else {
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}
	
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_STA_FLOW_RX_TX_OVERLFOW_REPORT_SWITCH);
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_UINT32,&is_rx_tx,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"set ap flow %s overflow report switch %s successfully\n", argv[0], argv[1]);
	} else if (ret == WTP_NOT_IN_RUN_STATE) {
		vty_out(vty,"<error> wtp is not in run state\n");
	} else if(ret == WTP_ID_NOT_EXIST) {
		vty_out(vty,"<error> wtp id does not exist\n");
	} else {
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	return CMD_SUCCESS;			
}

DEFUN(set_ap_sta_flow_rx_tx_overflow_reportinterval_cmd_func,
	  set_ap_sta_flow_rx_tx_overflow_reportinterval_cmd,
	  "set ap sta flow (rx|tx) overflow report interval PARAMETER",
	  "wireless-control config\n"
	  "ap sta flow (rx|tx) overflow\n"
	  "ap sta flow (rx|tx) overflow\n"
	  "ap sta flow (rx|tx) overflow\n"
	  "ap sta flow (rx|tx) overflow reportinterval\n"
	  "ap sta flow (rx|tx) overflow reportinterval s \n"
	 )
{
	int ret,ret1;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

    unsigned int interval = 0;
	unsigned int wtp_id = 0;
	unsigned int is_rx_tx = 0;
	if (argc < 2) {
		vty_out(vty, "parameter time interval is need\n");
		return CMD_FAILURE;
	}

	if (!strcmp(argv[0],"rx")){
		is_rx_tx = 1;	
	} else if (!strcmp(argv[0],"tx")) {
		is_rx_tx = 0;	
	} else {
		vty_out(vty,"<error> input patameter only with 'rx' or 'tx'\n");
		return CMD_SUCCESS;
	}
	
	ret1 = parse_int_ID((char*)argv[1], &interval);
	if(ret1 != WID_DBUS_SUCCESS){
            if(ret1 == WID_ILLEGAL_INPUT){
            	vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
            }
			else{
			vty_out(vty,"<error> unknown id format\n");
			}
			return CMD_SUCCESS;
	}
	
	if(interval > 32767 || interval == 0){
		vty_out(vty,"the time interval should be between 1 and 32766\n");
		return CMD_FAILURE;
	}
	
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_STA_FLOW_RX_TX_OVERLFOW_REPORTINTERVAL);
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_UINT32,&is_rx_tx,
							 DBUS_TYPE_UINT32,&interval,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"set ap sta flow %s overflow reportinterval %s successfully\n",argv[0], argv[1]);
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp is not in run state\n");
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	
	return CMD_SUCCESS;			
}


DEFUN(set_ap_extension_infomation_reportinterval_cmd_func,
	  set_ap_extension_infomation_reportinterval_cmd,
	  "set ap extension infomation reportinterval PARAMETER",
	  "wireless-control config\n"
	  "ap extension infomation\n"
	  "ap extension infomation\n"
	  "ap extension infomation\n"
	  "ap extension infomation reportinterval\n"
	  "ap extension infomation reportinterval s \n"
	 )
{
	int ret,ret1;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

    unsigned int interval = 0;
	unsigned int wtp_id = 0;
	//wtp_id = (unsigned int)vty->index;
	
	ret1 = parse_int_ID((char*)argv[0], &interval);
	if(ret1 != WID_DBUS_SUCCESS){
            if(ret1 == WID_ILLEGAL_INPUT){
            	vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
            }
			else{
			vty_out(vty,"<error> unknown id format\n");
			}
			return CMD_SUCCESS;
	}	
	if(interval > 32767 || interval == 0){   /*fengwenchao change 600 to 32767*/
		vty_out(vty,"<error> ap extension infomation reportinterval error\n");
		return CMD_SUCCESS;
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_EXTENSION_INFOMATION_REPORTINTERVAL);
		
	
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_EXTENSION_INFOMATION_REPORTINTERVAL);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,	
							 DBUS_TYPE_UINT32,&interval,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"set ap extension infomation reportinterval %s successfully\n",argv[0]);
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp is not in run state\n");
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	
	return CMD_SUCCESS;			
}
#endif
DEFUN(set_ap_moment_infomation_enable_func,
	  set_ap_moment_infomation_enable_cmd,
	  "set ap moment_collect infomation_switch (enable|disable)",
	  CONFIG_STR
	  "set ap moment_collect infomation_switch\n"
	  "set ap moment_collect infomation_switch\n"
	  "set ap moment_collect infomation_switch\n"
	  "enable|disable\n"
	 )
{
	int ret;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID = 0;
    int policy = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	
	if (!strcmp(argv[0],"enable")){
		policy = 1;	
	}
	else if (!strcmp(argv[0],"disable")){
		policy = 0;	
	}
	else{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}
	/*for applying hansi node by nl  */
	/*================================================= */
	if(vty->node == CONFIG_NODE)
	{
		index = 0;
		WTPID = 0;
		//printf("wtpid in hansi  %d\n",WTPID);
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		WTPID = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		WTPID = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	else if(vty->node == WTP_NODE)
	{
		index = 0;
		WTPID = (unsigned int)vty->index;
		printf("wtpid %d\n",WTPID);
	}
	else if(vty->node ==  HANSI_WTP_NODE)
	{
		index = vty->index;
		WTPID = (unsigned int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
		printf("wtpid in hansi wtp %d\n",WTPID);
	}else if(vty->node ==  LOCAL_HANSI_WTP_NODE)
	{
		index = vty->index;
		WTPID = (unsigned int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);

	query = dbus_message_new_method_call(BUSNAME,OBJPATH,\
						INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_MOMENT_INFOMATION_SWITCH);
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply){
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)){
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0){
		vty_out(vty," set wtp %d moment infomation switch %s successfully\n",WTPID,argv[0]);
	}
	else if (ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist.\n");
	else if (ret == WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp id does not run.\n");
	else if (ret == VALUE_IS_NONEED_TO_CHANGE)
		vty_out(vty,"<error> The switch is already %s. \n",(policy==1)? "enable":"disable");
	else{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);
	
	return CMD_SUCCESS;			
}

DEFUN(set_ap_moment_infomation_reportinterval_cmd_func,
	  set_ap_moment_infomation_reportinterval_cmd,
	  "set ap moment_collect infomation_reportinterval INTERVAL",	//fengwenchao change <2-5> to INTERVAL  20110412 /*xiaodawei change 3-600 to 2-5*/
	  "set ap moment_collect infomation_reportinterval\n"
	  "set ap moment_collect infomation_reportinterval\n"
	  "set ap moment_collect infomation_reportinterval\n"
	  "set ap moment_collect infomation_reportinterval\n"    
	  "<2-32767>\n"                                                      //fengwenchao modify 20110412
	 )
{
	int ret;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
    unsigned int interval = 0;
	
	/*fengwenchao modify 20110412*/
	ret = parse_int_ID((char*)argv[0], &interval);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}	
	//interval = atoi(argv[0]);
	/*fengwenchao modify end*/
	
	if(interval > 32767 || interval < 2){   /*fengwenchao change 5 to 32767*/
		vty_out(vty,"<error> ap moment infomation reportinterval error\n");
		return CMD_SUCCESS;
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	
	/*================================================= */
	if(vty->node == CONFIG_NODE){
		index = 0;			
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	/*====================================================*/
	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,\
						INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_MOMENT_INFOMATION_REPORTINTERVAL);
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&interval,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply){
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)){
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0){
		vty_out(vty,"set ap moment infomation reportinterval %s successfully\n",argv[0]);
	}
	else if(ret == VALUE_IS_NONEED_TO_CHANGE)
		vty_out(vty,"<error> The value is no need to change.\n");
	else{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);
	
	return CMD_SUCCESS;			
}

DEFUN(set_ap_sample_infomation_reportinterval_cmd_func,
	  set_ap_sample_infomation_reportinterval_cmd,
	  "set ap sample infomation_reportinterval INTERVAL",	//fengwenchao change <2-900> to INTERVAL 20110412	/*xiaodawei change 3-3600 to 2-900, modify for sample time, 20101210*/
	  "set ap sample infomation_reportinterval\n"
	  "set ap sample infomation_reportinterval\n"
	  "set ap sample infomation_reportinterval\n"
	  "set ap sample infomation_reportinterval\n"
	  "<2-32767>\n"                                           //fengwenchao modify 20110412
	 )
{
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	int ret;
    unsigned int interval = 0;
	
	unsigned int wtp_id = 0;

	/*fengwenchao modify 20110412*/
	ret = parse_int_ID((char*)argv[0], &interval);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}	
	//interval = atoi(argv[0]);
	/*fengwenchao modify end*/
	
	if(interval > 32767 || interval < 2){  /*fengwenchao change 900 to 32767*/
		vty_out(vty,"<error> ap sample infomation reportinterval error\n");
		return CMD_SUCCESS;
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	
	/*================================================= */
	if(vty->node == CONFIG_NODE){
		index = 0;			
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	/*====================================================*/
	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,\
						INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_SAMPLE_INFOMATION_REPORTINTERVAL);
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&interval,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply){
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)){
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0){
		vty_out(vty,"set ap sample infomation reportinterval %d successfully\n",interval);
	}
	else if(ret == VALUE_IS_NONEED_TO_CHANGE)
		vty_out(vty,"<error> The value is no need to change.\n");
	else{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);
	
	return CMD_SUCCESS;			
}

DEFUN(set_ap_routine_infomation_reportinterval_cmd_func,
	  set_ap_routine_infomation_reportinterval_cmd,
	  "set ap routine_collect infomation_reportinterval INTERVAL",	//fengwenchao change <10-120> to INTERVAL 20110412  /*xiaodawei change 5-3600 to 10-120, modify for normal collect cycle, 20101210*/
	  "wireless-control config\n"
	  "set ap routine_collect infomation_reportinterval\n"
	  "set ap routine_collect infomation_reportinterval\n"
	  "set ap routine_collect infomation_reportinterval\n"
	  "<10-32767>\n"                                                  //fengwenchao add 20110412 
	 )
{
	int ret;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
    unsigned int interval = 0;

	/*fengwenchao modify 20110412*/
	ret = parse_int_ID((char*)argv[0], &interval);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}	
	//interval = atoi(argv[0]);
	/*fengwenchao modify end*/
	
	if(interval > 32767 || interval < 10){   /*fengwenchao change 120 to 32767*/
		vty_out(vty,"<error> ap routine infomation reportinterval error\n");
		return CMD_SUCCESS;
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
		
	/*================================================= */
	if(vty->node == CONFIG_NODE){
		index = 0;			
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	/*====================================================*/
	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,\
						INTERFACE,WID_DBUS_WTP_METHOD_SHOW_WTP_ROUTINE_INFOMATION_REPORTINTERVAL);
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&interval,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply){
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)){
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0){
		vty_out(vty,"set ap routine infomation reportinterval %d successfully\n",interval);
	}
	else if(ret == VALUE_IS_NONEED_TO_CHANGE)
		vty_out(vty,"<error> The value is no need to change.\n");
	else{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);
	
	return CMD_SUCCESS;			
}

DEFUN(show_ap_moment_information_reportinterval_cmd_func,
	  show_ap_moment_information_reportinterval_cmd,
	  "show ap moment_information ",
	  SHOW_STR
	  "show ap moment_information \n"
	 "show ap moment_information \n"
	 )
{

	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;

	int ret=0;
	unsigned int moment_report_value = 0;
	unsigned int routine_report_value = 0;
	unsigned char moment_report_switch = 0;
	int collect_time = 3500;
	unsigned int sample_time = 5;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	
	/*================================================= */
	if(vty->node == CONFIG_NODE){
		index = 0;			
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	/*====================================================*/
	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,\
						INTERFACE,WID_DBUS_WTP_METHOD_SHOW_WTP_MOMENT_INFOMATION_REPORTINTERVAL);
	
	dbus_error_init(&err);	
	
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);

	if (NULL == reply){
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0 ){
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(moment_report_value));	

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(routine_report_value));	

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(moment_report_switch));	

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(collect_time));	

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(sample_time));	

		vty_out(vty,"==============================================================================\n");
		vty_out(vty,"moment_report_value: %d\n",moment_report_value);
		vty_out(vty,"routine_report_value: %d\n",routine_report_value);
		vty_out(vty,"moment_report_switch: %s\n",moment_report_switch == 1 ?"enable":"disable");
		vty_out(vty,"collect_time: %d\n",collect_time);
		vty_out(vty,"sample_time: %d\n",sample_time);
 		vty_out(vty,"==============================================================================\n");
	}
	
	else{
		vty_out(vty,"<error>  %d\n",ret);
	}

	dbus_message_unref(reply);	

	return CMD_SUCCESS;
}

DEFUN(show_wtp_wlan_vlan_information_func,
	  show_wtp_wlan_vlan_information_cmd,
	  "show wtp wlan vlan information",
	  SHOW_STR
	  "wtp information\n"
	  "wtp wlan vlan information\n"
	  "wtp wlan vlan information\n"
	  "wtp wlan vlan information\n"
	 )
{	
	
/*	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;*/
	unsigned int WTPID = 0;
	int num = 0;
	int ret = WID_DBUS_SUCCESS;
	//WTPID = (unsigned int)vty->index;
	int i = 0;
//	struct wtp_wlan_vlan_info info[WTP_WLAN_VLAN_LEN];
	DCLI_WTP_API_GROUP_THREE *WTPINFO = NULL;
//	CW_CREATE_OBJECT_ERR(WTPINFO, DCLI_WTP_API_GROUP_THREE, return NULL;);	
//	WTPINFO->WLAN = NULL;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
#if 0	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WID_WTP_WLAN_VLAN_INFO);
		
		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WID_WTP_WLAN_VLAN_INFO);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}

	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0)
	{	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&num);

		for(i=0;i<num;i++)
		{
			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&info[i].wlanid);

			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&info[i].vlanid);

			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&info[i].priority);

		}
	}
	dbus_message_unref(reply);
#endif
	 WTPINFO = dcli_wtp_show_api_group_three(
		index,
		FIFTH,/*show wtp wlan vlan information*/
		WTPID,
		0,
		0,
		&ret,/**/
		0,/*num2*/
		0,
		0,
		0,
		&localid,//num6
	//	WTPINFO,
		dcli_dbus_connection,
		WID_DBUS_CONF_METHOD_SHOW_WID_WTP_WLAN_VLAN_INFO
		);
	//printf("##########ret is %d,num is %d\n",ret,num);
	if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == 0){		
		vty_out(vty,"==============================================================================\n");
		vty_out(vty,"WTP %d wlan vlan infomation\n",WTPID);
		vty_out(vty,"------------------------------------------------------------------------------\n");
		vty_out(vty,"WlanID	VlanID	Priority\n");
		for(i=0;i<WTPINFO->wlan_num;i++)
		{
			vty_out(vty,"%6d	%6d	%8d\n",WTPINFO->WLAN[i]->WlanID,WTPINFO->WLAN[i]->vlanid,WTPINFO->WLAN[i]->wlan_1p_priority);
			//CW_FREE_OBJECT(WTPINFO->WLAN[i]);
		}
		vty_out(vty,"==============================================================================\n");
		//CW_FREE_OBJECT(WTPINFO->WLAN);
		dcli_wtp_free_fun_three(WID_DBUS_CONF_METHOD_SHOW_WID_WTP_WLAN_VLAN_INFO,WTPINFO);
	}
	else if (ret == WTP_ID_NOT_EXIST)
	vty_out(vty,"<error> wtp id does not exist\n");
	//CW_FREE_OBJECT(WTPINFO);
	return CMD_SUCCESS;
}
/*
DEFUN(show_wtp_extension_information_v2_func,
	  show_wtp_extension_information_v2_cmd,
	  "show wtp tm extension information",
	  SHOW_STR
	  "V2\n"
	  "wtp information\n"
	  "wtp information\n"
	  "wtp information\n"
	 )
{	
	
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;
	unsigned int WTPID;
	int ret = WID_DBUS_SUCCESS;
	WTPID = (unsigned int)vty->index;
	int i = 0;
	wid_wifi_info info;
	char en[] = "enable";
	char dis[] = "disable";
	char st[] = "static";
	char dh[] = "dhcp";
	{
		info.reportswitch = 0;
		info.reportinterval = 0;
		info.cpu = 0;
		info.tx_mgmt = 0;
		info.rx_mgmt = 0;
		info.tx_packets = 0;
		info.tx_errors = 0;
		info.tx_retry = 0;
		info.ipmode = 0;
		info.memoryall = 0;
		info.memoryuse = 0;
		info.flashall = 0;
		info.flashempty = 0;
		info.wifi_snr = 0;
		info.eth_count = 0;
		info.ath_count = 0;
		memset(info.eth_updown_time,0,AP_ETH_IF_NUM);
		memset(info.ath_updown_time,0,AP_ATH_IF_NUM);
	}
	for(i=0;i<AP_ETH_IF_NUM;i++)
	{
		info.eth_updown_time[i] = 0;
	}
	for(i=0;i<AP_ATH_IF_NUM;i++)
	{
		info.ath_updown_time[i] = 0;
	}
	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_AP_SHOW_WTP_EXTENSION_INFOMATION_V2);
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}

	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0)
	{	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.cpu);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_mgmt);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.rx_mgmt);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_packets);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_errors);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_retry);

		//add something diff from v1
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.reportswitch);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.reportinterval);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.ipmode);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.memoryall);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.memoryuse);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.flashall);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.flashempty);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.wifi_snr);
		//end
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.eth_count);

		for(i=0;i<AP_ETH_IF_NUM;i++)
		{
			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&info.eth_updown_time[i]);
		}

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.ath_count);

		for(i=0;i<AP_ATH_IF_NUM;i++)
		{
			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&info.ath_updown_time[i]);
		}
	}
	
	dbus_message_unref(reply);
	if(ret == 0){		
		vty_out(vty,"==============================================================================\n");
		vty_out(vty,"WTP extension infomation\n");
		vty_out(vty,"WTPID:	%d\n",WTPID);
		//
		vty_out(vty,"report switch:	%s\n",(info.reportswitch == 1)?en:dis);
		vty_out(vty,"report interval:	%d s\n",info.reportinterval);
		//
		vty_out(vty,"cpu:	%0.2f %\n",info.cpu/100.00);
		//
		vty_out(vty,"IP mode:	%s\n",(info.ipmode == 1)?dh:st);
		vty_out(vty,"memory total:	%d MB\n",info.memoryall);
		vty_out(vty,"memory usage:	%d %\n",info.memoryuse);
		vty_out(vty,"flash capacity:	%d MB\n",info.flashall);
		vty_out(vty,"flash surplus capacity:	%d Kb\n",info.flashempty);
		vty_out(vty,"wifi SNR:	%d\n",info.wifi_snr);
		//
		vty_out(vty,"tx_mgmt:	%d\n",info.tx_mgmt);
		vty_out(vty,"rx_mgmt:	%d\n",info.rx_mgmt);
		vty_out(vty,"total_mgmt:	%d\n",info.rx_mgmt+info.tx_mgmt);
		vty_out(vty,"tx_packets:	%d\n",info.tx_packets);
		vty_out(vty,"tx_errors:	%d\n",info.tx_errors);
		vty_out(vty,"tx_retry:	%d\n",info.tx_retry);
		vty_out(vty,"eth_count:	%d\n",info.eth_count);
		for(i=0;i<AP_ETH_IF_NUM;i++)
		{
			if(info.eth_updown_time[i] != 0)
			{
				vty_out(vty,"eth%d updown time:	%d\n",i,info.eth_updown_time[i]);
			}
		}
		vty_out(vty,"ath_count:	%d\n",info.ath_count);
		for(i=0;i<AP_ATH_IF_NUM;i++)
		{
			if(info.ath_updown_time[i] != 0)
			{
				vty_out(vty,"ath%d updown time:	%d\n",i+1,info.ath_updown_time[i]);
			}
		}
		vty_out(vty,"==============================================================================\n");
	}
	//else if (ret == WTP_NOT_IN_RUN_STATE)
	//	vty_out(vty,"<error> wtp is not in run state\n");
	else if (ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else if (ret == SWITCH_IS_DISABLE)
		vty_out(vty,"<error> wtp extension info report switch disable\n");
	return CMD_SUCCESS;
}*/
DEFUN(show_wtp_ethernet_interface_information_func,
	  show_wtp_ethernet_interface_information_cmd,
	  "show wtp ethernet interface information",
	  SHOW_STR
	  "wtp information\n"
	  "wtp ethernet interface information\n"
	  "wtp ethernet interface information\n"
	  "wtp ethernet interface information\n"
	 )
{	
	
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;
	unsigned int WTPID;
	unsigned int model  = 0;
	unsigned char num = 0;
	int ret = WID_DBUS_SUCCESS;
	//WTPID = (unsigned int)vty->index;
	unsigned char state = 0;
	int i = 0;
	char up[] = "up";
	char down[] = "down";
	char autelan[] = "Autelan";
	char *name;
	unsigned int temp = 0;

	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WID_WTP_ETH_IF_INFO);
		
		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WID_WTP_ETH_IF_INFO);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}

	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0)
	{	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&num);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&state);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&model);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&name);
	}
	dbus_message_unref(reply);
	
	switch(model)
	{
		case 1 : temp = 37; break;/* 1110T*/
		case 2 : temp = 35; break;/* 2010*/
		case 3 : temp = 60; break;/* 2110*/
		case 4 : temp = 36; break;/* AQ1000*/
		case 5 : temp = 37; break;/* AQ1000-H*/
		case 6 : temp = 39; break;/* AQ3110-H*/
		case 7 : temp = 40; break;/* AQ3120-H*/
		default : break;
	}
	
	if(ret == 0){		
		vty_out(vty,"==============================================================================\n");
		vty_out(vty,"WTP %d ethernet interface infomation\n",WTPID);
		vty_out(vty,"ethernet interface num:	%d\n",num);
		vty_out(vty,"wtp temperature:	%d\n",temp);
		for(i=0;i<num;i++)
		{
			vty_out(vty,"ETH%d:	%7s	%15s\n",i,autelan,name);
			/*vty_out(vty,"ETH%d:	%4s\n",i,(state == 1)?up:down);*/
			if(i == 0)
			{
				vty_out(vty,"ETH%d:	%4s\n",i,(state == 1)?up:down);
			}
			else if(i ==1)
			{
				vty_out(vty,"ETH%d:	%4s\n",i,down);
			}
		}
		vty_out(vty,"==============================================================================\n");
	}
	else if (ret == WTP_ID_NOT_EXIST)
	vty_out(vty,"<error> wtp id does not exist\n");
	return CMD_SUCCESS;
}

#if _GROUP_POLICY

DEFUN(set_ap_l2_isolation_func,
	  set_ap_l2_isolation_cmd,
	  "set wlan WLANID l2 isolation (enable|disable)",   //fengwenchao change <1-15> to WLANID 20110412
	  CONFIG_STR
	  "ap wlan config\n"
	  "wlan ID <1-15>\n"
	  "ap l2 isolation config\n"
	  "ap l2 isolation config\n"
	  "ap l2 isolation enable|disable\n"
	 )
{
	
	int i = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int type = 0;
	unsigned int id = 0;
	unsigned char wlanid = 0;
	int ret = WID_DBUS_SUCCESS;
	//WTPID = (unsigned int)vty->index;
    int policy = 0;

	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;

	/*fengwenchao modify 20110412*/
	ret = parse_char_ID((char*)argv[0], &wlanid);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}	
	//wlanid = (unsigned char)atoi(argv[0]);
	if((wlanid < 1)||(wlanid > 15))
	{
		vty_out(vty,"<error> input wlanid should be 1~15.\n");
		return CMD_SUCCESS;
	}
	/*fengwenchao modify end*/	
	if (!strcmp(argv[1],"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[1],"disable"))
	{
		policy = 0;	
	}
	else
	{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}
	
	if(vty->node == WTP_NODE){
		index = 0;			
		id = (unsigned int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	WtpList_Head=set_ap_l2_isolation_cmd_set_wlan_l2_isolation(index,localid,dcli_dbus_connection,type,id,policy,wlanid,
	&count,&ret);

if(type==0)
{
		if(ret == 0)
			{
				vty_out(vty," set ap wlan %s l2 isolation %s successfully\n",argv[0],argv[1]);
			}
		else if (ret == WLAN_ID_NOT_EXIST)
			{
				vty_out(vty,"<error>  wlan %d not exist\n",wlanid);
			}
		else if (ret == WTP_IS_NOT_BINDING_WLAN_ID)
			{
				vty_out(vty,"<error>  wtp not binding wlan %d\n",wlanid);
			}
		else if (ret == WTP_NOT_IN_RUN_STATE)
				vty_out(vty,"<error> wtp id does not run\n");
		else if (ret == AP_L2_ISOLATION_ENABLE_OR_DIS_ALREADY)				/*xiaodawei add for l2 isolation enable or disable already, 20101207*/
			{
				vty_out(vty,"wlan %s l2 isolation %s already\n",argv[0],argv[1]);
			}

		else if (ret == WTP_OVER_MAX_BSS_NUM)
			{
				vty_out(vty,"<error>  binding wlan error\n");
			}
		else
			{
				vty_out(vty,"<error>  %d\n",ret);
			}
}

else if(type == 1){
		if(ret == 0){
			vty_out(vty,"set ap wlan %s l2 isolation %s successfully\n",argv[0],argv[1]);
			if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL)){
				vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
				}
				
				vty_out(vty," failed.\n");
				dcli_free_WtpList(WtpList_Head);
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
		   vty_out(vty,"<error> group id does not exist\n");
	}
	return CMD_SUCCESS;			
}

#else
DEFUN(set_ap_l2_isolation_func,
	  set_ap_l2_isolation_cmd,
	  "set wlan WLANID l2 isolation (enable|disable)",   //fengwenchao change <1-15> to WLANID 20110412
	  CONFIG_STR
	  "ap wlan config\n"
	  "wlan ID <1-15>\n"
	  "ap l2 isolation config\n"
	  "ap l2 isolation config\n"
	  "ap l2 isolation enable|disable\n"
	 )
{
	
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID = 0;
	unsigned char wlanid = 0;
	int ret = WID_DBUS_SUCCESS;
	//WTPID = (unsigned int)vty->index;
    int policy = 0;

	/*fengwenchao modify 20110412*/
	ret = parse_char_ID((char*)argv[0], &wlanid);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}	
	//wlanid = (unsigned char)atoi(argv[0]);
	if((wlanid < 1)||(wlanid > 15))
	{
		vty_out(vty,"<error> input wlanid should be 1~15.\n");
		return CMD_SUCCESS;
	}
	/*fengwenchao modify end*/	

	if (!strcmp(argv[1],"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[1],"disable"))
	{
		policy = 0;	
	}
	else
	{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SET_AP_L2_ISOLATION_ABLE);
		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SET_AP_L2_ISOLATION_ABLE);*/
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_BYTE,&wlanid,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty," set ap wlan %s l2 isolation %s successfully\n",argv[0],argv[1]);
	}
	else if (ret == WLAN_ID_NOT_EXIST)
	{
		vty_out(vty,"<error>  wlan %d not exist\n",wlanid);
	}
	else if (ret == WTP_IS_NOT_BINDING_WLAN_ID)
	{
		vty_out(vty,"<error>  wtp not binding wlan %d\n",wlanid);
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp id does not run\n");
	else if (ret == AP_L2_ISOLATION_ENABLE_OR_DIS_ALREADY)				/*xiaodawei add for l2 isolation enable or disable already, 20101207*/
	{
		vty_out(vty,"wlan %s l2 isolation %s already\n",argv[0],argv[1]);
	}
	else if (ret == WTP_OVER_MAX_BSS_NUM)
	{
		vty_out(vty,"<error>  binding wlan error\n");
	}
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	
	return CMD_SUCCESS;			
}
#endif
#if _GROUP_POLICY
DEFUN(set_ap_dos_def_func,
	  set_ap_dos_def_cmd,
	  "set ap dos def (enable|disable)",
	  CONFIG_STR
	  "ap config\n"
	  "ap dos def config\n"
	  "ap dos def config\n"
	  "ap dos def enable|disable\n"
	 )
{
	
	int i = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int type = 0;
	unsigned int id;
	int ret = WID_DBUS_SUCCESS;
	//WTPID = (unsigned int)vty->index;
    int policy = 0;

	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	
	if (!strcmp(argv[0],"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[0],"disable"))
	{
		policy = 0;	
	}
	else
	{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}
	
	if(vty->node == WTP_NODE){
		index = 0;			
		id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	
WtpList_Head = set_ap_dos_def_cmd_set_ap_dos_def(index,localid,dcli_dbus_connection,type,id,policy,
	&count,&ret);

	if(type==0)
		{	if(ret == 0)
				{
					vty_out(vty," set ap dos def %s successfully\n",argv[0]);
				}	
			else if (ret == WTP_NOT_IN_RUN_STATE)
					vty_out(vty,"<error> wtp id does not run\n");
			else
				{
					vty_out(vty,"<error>  %d\n",ret);
				}
		}	

	else if(type == 1){
		if(ret == 0){
			vty_out(vty,"group %d set ap dos def %s successfully\n",id,argv[0]);
			if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL)){
				vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
				}
				
				vty_out(vty," failed.\n");
				dcli_free_WtpList(WtpList_Head);
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
		   vty_out(vty,"<error> group id does not exist\n");
	}
	return CMD_SUCCESS;	

}

#else
DEFUN(set_ap_dos_def_func,
	  set_ap_dos_def_cmd,
	  "set ap dos def (enable|disable)",
	  CONFIG_STR
	  "ap config\n"
	  "ap dos def config\n"
	  "ap dos def config\n"
	  "ap dos def enable|disable\n"
	 )
{
	
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID;
	int ret = WID_DBUS_SUCCESS;
	//WTPID = (unsigned int)vty->index;
    int policy = 0;

	
	if (!strcmp(argv[0],"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[0],"disable"))
	{
		policy = 0;	
	}
	else
	{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SET_AP_PREVENT_DOS_ATTACK);
		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SET_AP_PREVENT_DOS_ATTACK);*/
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty," set ap dos def %s successfully\n",argv[0]);
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp id does not run\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	
	return CMD_SUCCESS;			
}
#endif
#if _GROUP_POLICY
DEFUN(set_ap_igmp_snoop_func,
	  set_ap_igmp_snoop_cmd,
	  "set ap igmp snoop (enable|disable)",
	  CONFIG_STR
	  "ap config\n"
	  "ap igmp snoop config\n"
	  "ap igmp snoop config\n"
	  "ap igmp snoop enable|disable\n"
	 )
{
	int i = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int type = 0;
	unsigned int id;
	int ret = WID_DBUS_SUCCESS;
	//WTPID = (unsigned int)vty->index;
    int policy = 0;

	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	if (!strcmp(argv[0],"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[0],"disable"))
	{
		policy = 0;	
	}
	else
	{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}
	

	if(vty->node == WTP_NODE){
		index = 0;			
		id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
 
		
	WtpList_Head= set_ap_igmp_snoop_cmd_set_ap_igmp_snoop(index,localid,dcli_dbus_connection,type,id,policy,
	&count,&ret);
	//vty_out(vty,"type= %d\n",type);
	//vty_out(vty,"id= %d\n",id);
	//vty_out(vty,"policy= %d\n",policy);
	//vty_out(vty,"count= %d\n",count);
	//vty_out(vty,"ret= %d\n",ret);
	if(type==0)
		{	if(ret == 0)
				{
					vty_out(vty," set ap igmp snoop %s successfully\n",argv[0]);
				}	
			else if (ret == WTP_NOT_IN_RUN_STATE)
					vty_out(vty,"<error> wtp id does not run\n");
			else
				{
					vty_out(vty,"<error>  %d\n",ret);
				}
		}	

	else if(type == 1){
		if(ret == 0){
			vty_out(vty,"group %d set ap igmp snoop %s successfully\n",id,argv[0]);
			if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL)){
				vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
				}
				
				vty_out(vty," failed.\n");
				dcli_free_WtpList(WtpList_Head);
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
		   vty_out(vty,"<error> group id does not exist\n");
	}
	return CMD_SUCCESS;	
}

#else
DEFUN(set_ap_igmp_snoop_func,
	  set_ap_igmp_snoop_cmd,
	  "set ap igmp snoop (enable|disable)",
	  CONFIG_STR
	  "ap config\n"
	  "ap igmp snoop config\n"
	  "ap igmp snoop config\n"
	  "ap igmp snoop enable|disable\n"
	 )
{
	
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID;
	int ret = WID_DBUS_SUCCESS;
	//WTPID = (unsigned int)vty->index;
    int policy = 0;

	
	if (!strcmp(argv[0],"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[0],"disable"))
	{
		policy = 0;	
	}
	else
	{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SET_AP_IGMP_SNOOPING);
		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SET_AP_IGMP_SNOOPING);*/
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty," set ap igmp snoop %s successfully\n",argv[0]);
	}	
	else if (ret == WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp id does not run\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	
	return CMD_SUCCESS;			
}
#endif
DEFUN(show_ap_mib_information_func,
	  show_ap_mib_information_cmd,
	  "show ap mib information",
	  SHOW_STR
	  "wtp information\n"
	  "ap_mib information\n"
	  "ap_mib information\n"
	 )
{	
	
/*	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;*/
	unsigned int WTPID = 0;
	int ret = WID_DBUS_SUCCESS;
	//WTPID = (unsigned int)vty->index;
	int i = 0;
	char en[] = "enable";
	char dis[] = "disable";
//	WID_mib_info mib_info;
	DCLI_WTP_API_GROUP_TWO *WTPINFO = NULL;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
#if 0	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SHOW_AP_MIB_INFO);
		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_AP_MIB_INFO);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}

	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0)
	{	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&mib_info.dos_def_switch);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&mib_info.igmp_snoop_switch);

		for(i=0;i<L_BSS_NUM;i++)
		{
			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&mib_info.wlan_l2isolation[i].wlanid);

			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&mib_info.wlan_l2isolation[i].l2_isolation_switch);
		}
	}
	dbus_message_unref(reply);
#endif
	 WTPINFO = dcli_wtp_show_api_group_two(
		index,
		NINTH,/*"show ap mib information"*/
		WTPID,
		0,
		0,
		&ret,/**/
		0,/*num2*/
		0,
		0,
		0,
		&localid,//num6
	//	WTPINFO,
		dcli_dbus_connection,
		WID_DBUS_CONF_METHOD_SHOW_AP_MIB_INFO
		);
//printf("##########ret is %d\n",ret);
	if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == 0){		
		vty_out(vty,"==============================================================================\n");
		vty_out(vty,"WTP %d mib infomation\n",WTPID);
		vty_out(vty,"wtp prevent dos attack switch:	%s\n",(WTPINFO->WTP[0]->mib_info.dos_def_switch == 1)?en:dis);
		vty_out(vty,"wtp IGMP snooping switch: %s\n",(WTPINFO->WTP[0]->mib_info.igmp_snoop_switch== 1)?en:dis);
		for(i=0;i<L_BSS_NUM;i++)
		{
			
			if(WTPINFO->WTP[0]->mib_info.wlan_l2isolation[i].wlanid != 0)
			{
				vty_out(vty,"wtp L2 isolation switch:	%d	%s\n",WTPINFO->WTP[0]->mib_info.wlan_l2isolation[i].wlanid,(WTPINFO->WTP[0]->mib_info.wlan_l2isolation[i].l2_isolation_switch == 1)?en:dis);
			}
			
		}
		vty_out(vty,"==============================================================================\n");

		dcli_wtp_free_fun_two(WID_DBUS_CONF_METHOD_SHOW_AP_MIB_INFO,WTPINFO);
	}
	else if (ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
//	CW_FREE_OBJECT(WTPINFO->WTP[0]);
//	CW_FREE_OBJECT(WTPINFO->WTP);
//	CW_FREE_OBJECT(WTPINFO);
	return CMD_SUCCESS;
}
DEFUN(show_wtp_extension_information_v3_func,
	  show_wtp_extension_information_v3_cmd,
	  "show wtp cmt extension information",
	  SHOW_STR
	  "V3\n"
	  "wtp extension information\n"
	  "wtp extension information\n"
	  "wtp extension information\n"
	 )
{	
	
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;
	unsigned int WTPID = 0;
	int ret = WID_DBUS_SUCCESS;
	//WTPID = (unsigned int)vty->index;
	int i = 0;
	//wid_wifi_info info;
	char en[] = "enable";
	char dis[] = "disable";
	char st[] = "static";
	char dh[] = "dhcp";
	DCLI_WTP_API_GROUP_TWO *WTPINFO = NULL;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
//	char BUSNAME[PATH_LEN];
//	char OBJPATH[PATH_LEN];
//	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
#if 0	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_AP_SHOW_WTP_EXTENSION_INFOMATION_V3);
		

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_AP_SHOW_WTP_EXTENSION_INFOMATION_V3);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}

	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0)
	{	
	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.cpu);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_mgmt);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.rx_mgmt);
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_packets);
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_errors);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_retry);

		/*add something diff from v1*/
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.reportswitch);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.reportinterval);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.ipmode);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.memoryall);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.memoryuse);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.flashall);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.flashempty);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.wifi_snr);
		/*end*/
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.eth_count);

		for(i=0;i<AP_ETH_IF_NUM;i++)
		{		
			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&info.eth_updown_time[i]);
		}

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.ath_count);

		for(i=0;i<info.ath_count;i++)
		{	
			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&info.ath_if_info[i].radioid);

			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&info.ath_if_info[i].wlanid);

			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&info.ath_if_info[i].ath_updown_times);
		}
		/*add something diff from v2*/
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.temperature);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.wifi_count);

		for(i=0;i<AP_WIFI_IF_NUM;i++)
		{		
			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&info.wifi_state[i]);
		}
	}
	
	dbus_message_unref(reply);
#endif	
	 WTPINFO = dcli_wtp_show_api_group_two(
		index,
		SECOND,/*"show wtp cmt extension information"*/
		WTPID,
		0,
		0,
		&ret,/**/
		0,/*num2*/
		0,
		0,
		0,
		&localid,//num6
	//	WTPINFO,
		dcli_dbus_connection,
		WID_DBUS_CONF_METHOD_AP_SHOW_WTP_EXTENSION_INFOMATION_V3
		);
	//printf("##########ret is %d\n",ret);
	if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == 0){		
		vty_out(vty,"==============================================================================\n");
		vty_out(vty,"WTP extension infomation\n");
		vty_out(vty,"WTPID:	%d\n",WTPID);
		
		vty_out(vty,"report switch:	%s\n",(WTPINFO->WTP[0]->wifi_extension_reportswitch == 1)?en:dis);
		vty_out(vty,"report interval:	%d s\n",WTPINFO->WTP[0]->wifi_extension_reportinterval);
		
		vty_out(vty,"cpu:	%0.2f %\n",WTPINFO->WTP[0]->wifi_extension_info.cpu/100.00);
		vty_out(vty,"temperature:	%d \n",WTPINFO->WTP[0]->wifi_extension_info.temperature);
		
		vty_out(vty,"IP mode:	%s\n",(WTPINFO->WTP[0]->wifi_extension_info.ipmode == 1)?dh:st);
		vty_out(vty,"memory total:	%d MB\n",WTPINFO->WTP[0]->wifi_extension_info.memoryall);
		vty_out(vty,"memory usage:	%d %\n",WTPINFO->WTP[0]->wifi_extension_info.memoryuse);
		vty_out(vty,"flash capacity:	%d MB\n",WTPINFO->WTP[0]->wifi_extension_info.flashall);
		vty_out(vty,"flash surplus capacity:	%d Kb\n",WTPINFO->WTP[0]->wifi_extension_info.flashempty);
		vty_out(vty,"wifi SNR:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.wifi_snr);
		
		vty_out(vty,"tx_mgmt:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.tx_mgmt);
		vty_out(vty,"rx_mgmt:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.rx_mgmt);
		vty_out(vty,"total_mgmt:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.rx_mgmt+WTPINFO->WTP[0]->wifi_extension_info.tx_mgmt);
		vty_out(vty,"tx_packets:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.tx_packets);
		vty_out(vty,"tx_errors:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.tx_errors);
		vty_out(vty,"tx_retry:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.tx_retry);
		vty_out(vty,"eth_count:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.eth_count);
		vty_out(vty,"collect_time:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.collect_time);
		
		for(i=0;i<AP_ETH_IF_NUM;i++)
		{
			if(WTPINFO->WTP[0]->wifi_extension_info.eth_updown_time[i] != 0)
			{
				vty_out(vty,"eth%d updown time:	%d\n",i,WTPINFO->WTP[0]->wifi_extension_info.eth_updown_time[i]);
			}
		}
		vty_out(vty,"ath_count:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.ath_count);
		for(i=0;i<WTPINFO->WTP[0]->wifi_extension_info.ath_count;i++)
		{
			vty_out(vty,"wifi%d ath%d updown time:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.ath_if_info[i].radioid,WTPINFO->WTP[0]->wifi_extension_info.ath_if_info[i].wlanid,WTPINFO->WTP[0]->wifi_extension_info.ath_if_info[i].ath_updown_times);
		}
		vty_out(vty,"wifi_count:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.wifi_count);
		for(i=0;i<AP_WIFI_IF_NUM;i++)
		{
			if(WTPINFO->WTP[0]->wifi_extension_info.wifi_state[i] != 0)
			{
				if(WTPINFO->WTP[0]->wifi_extension_info.wifi_state[i] == 1)
				{
					vty_out(vty,"wifi%d state:	up\n",i);
				}
				else if(WTPINFO->WTP[0]->wifi_extension_info.wifi_state[i] == 2)
				{
					vty_out(vty,"wifi%d state:	down\n",i);
				}
				else if(WTPINFO->WTP[0]->wifi_extension_info.wifi_state[i] == 3)
				{
					vty_out(vty,"wifi%d state:	error\n",i);
				}
			}
		}
		
		vty_out(vty,"rx_broadcast:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.rx_broadcast);
		vty_out(vty,"rx_unicast:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.rx_unicast);
		vty_out(vty,"rx_multicast:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.rx_multicast);
		vty_out(vty,"tx_broadcast:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.tx_broadcast);
		vty_out(vty,"tx_unicast:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.tx_unicast);
		vty_out(vty,"tx_multicast:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.tx_multicast);
		vty_out(vty,"==============================================================================\n");

		dcli_wtp_free_fun_two(WID_DBUS_CONF_METHOD_AP_SHOW_WTP_EXTENSION_INFOMATION_V3,WTPINFO);
	}
	/*else if (ret == WTP_NOT_IN_RUN_STATE)
	//	vty_out(vty,"<error> wtp is not in run state\n");*/
	else if (ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else if (ret == SWITCH_IS_DISABLE)
		vty_out(vty,"<error> wtp extension info report switch disable\n");
//	CW_FREE_OBJECT(WTPINFO);
	return CMD_SUCCESS;
}

DEFUN(show_ap_cm_statistics_func,
	  show_ap_cm_statistics_cmd,
	  "show ap cm statistics",
	  SHOW_STR
	  "ap cm statistics\n"
	  "ap cm statistics\n"
	  "ap cm statistics\n"
	 )
{	
	
/*	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;*/
	unsigned int WTPID = 0;
	int ret = WID_DBUS_SUCCESS;
	//WTPID = (unsigned int)vty->index;
	
/*	ap_cm_statistics info;

	info.cpu_average = 0;
	info.cpu_peak_value = 0;
	info.cpu_times = 0;
	info.mem_average = 0;
	info.mem_peak_value = 0;
	info.mem_times = 0;*/

	DCLI_WTP_API_GROUP_TWO *WTPINFO = NULL;
//	CW_CREATE_OBJECT_ERR(WTPINFO, DCLI_WTP_API_GROUP_TWO, return NULL;);	
//	WTPINFO->WTP = NULL;	
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
//	char BUSNAME[PATH_LEN];
//	char OBJPATH[PATH_LEN];
//	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
#if 0	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SHOW_AP_CM_STATISTICS);
		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_AP_CM_STATISTICS);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}

	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0)
	{	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.cpu_average);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.cpu_peak_value);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.cpu_times);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.mem_average);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.mem_peak_value);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.mem_times);
	}
	dbus_message_unref(reply);
#endif
	 WTPINFO = dcli_wtp_show_api_group_two(
		index,
		THIRD,/*"show ap cm statistics"*/
		WTPID,
		0,
		0,
		&ret,/**/
		0,/*num2*/
		0,
		0,
		0,
		&localid,//num6
		//WTPINFO,
		dcli_dbus_connection,
		WID_DBUS_CONF_METHOD_SHOW_AP_CM_STATISTICS
		);
	//printf("##########ret is %d\n",ret);
	if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == 0){		
		vty_out(vty,"==============================================================================\n");
		vty_out(vty,"WTP %d cpu memory usage statistics\n",WTPID);
		vty_out(vty,"cpu average:	%0.2f %\n",WTPINFO->WTP[0]->apcminfo.cpu_average/100.00);
		vty_out(vty,"cpu peak value:	%0.2f %\n",WTPINFO->WTP[0]->apcminfo.cpu_peak_value/100.00);
		vty_out(vty,"cpu times:	%d\n",WTPINFO->WTP[0]->apcminfo.cpu_times);
		vty_out(vty,"mem average:	%d %\n",WTPINFO->WTP[0]->apcminfo.mem_average);
		vty_out(vty,"mem peak value:	%d %\n",WTPINFO->WTP[0]->apcminfo.mem_peak_value);
		vty_out(vty,"mem times:	%d\n",WTPINFO->WTP[0]->apcminfo.mem_times);
		vty_out(vty,"cpu type:	%s\n",WTPINFO->WTP[0]->cpuType);
		vty_out(vty,"flash type:	%s\n",WTPINFO->WTP[0]->flashType);
		vty_out(vty,"memType type:	%s\n",WTPINFO->WTP[0]->memType);
		vty_out(vty,"==============================================================================\n");
	//	CW_FREE_OBJECT(WTPINFO->WTP[0]);		
	//	CW_FREE_OBJECT(WTPINFO->WTP);
		dcli_wtp_free_fun_two(WID_DBUS_CONF_METHOD_SHOW_AP_CM_STATISTICS,WTPINFO);
	}
	else if (ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	
//	CW_FREE_OBJECT(WTPINFO);
	return CMD_SUCCESS;
}
#if _GROUP_POLICY

DEFUN(set_ap_sta_infomation_report_enable_func,
	  set_ap_sta_infomation_report_enable_cmd,
	  "set ap sta infomation report switch (enable|disable)",
	  CONFIG_STR
	  "wtp config\n"
	  "wtp sta information\n"
	  "wtp sta information\n"
	  "wtp sta information report switch\n"
	  "wtp sta information report switch\n"
	  "wtp sta information report switch enable|disable\n"
	 )
{
	int i = 0;
	int ret = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;
    int policy = 0;
	
	if (!strcmp(argv[0],"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[0],"disable"))
	{
		policy = 0;	
	}
	else
	{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}
	
	if(vty->node == HANSI_NODE){  /*wcl modify for globle varible*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle varible*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	WtpList_Head=set_ap_sta_infomation_report_enable_cmd_set_ap_sta_infomation_report_switch(index,localid,dcli_dbus_connection,
	type,id,policy,&count,&ret);
	//printf("count = %d\n",count);
	//printf("type = %d\n",type);
	//printf("policy = %d\n",policy);
	//printf("ret = %d\n",ret);
	
	if(type==0)
		{	if(ret == 0)
			{
				vty_out(vty," set wtp %d sta infomation report switch %s successfully\n",id,argv[0]);
			}
			else if (ret == WTP_ID_NOT_EXIST)
				vty_out(vty,"<error> wtp id does not exist\n");
			else if (ret == WTP_NOT_IN_RUN_STATE)
				vty_out(vty,"<error> wtp id does not run\n");
			else
			{
				vty_out(vty,"<error>  %d\n",ret);
			}
		}	

	else if(type == 1){
		if(ret == 0){
			vty_out(vty,"group %d set wtp sta infomation report switch %s successfully\n",id,argv[0]);
			if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL)){
				vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);	
					
				}
				
				vty_out(vty," failed.\n");
				dcli_free_WtpList(WtpList_Head);
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
		   vty_out(vty,"<error> group id does not exist\n");
	}
	return CMD_SUCCESS;				
}

#else
DEFUN(set_ap_sta_infomation_report_enable_func,
	  set_ap_sta_infomation_report_enable_cmd,
	  "set ap sta infomation report switch (enable|disable)",
	  CONFIG_STR
	  "wtp config\n"
	  "wtp sta information\n"
	  "wtp sta information\n"
	  "wtp sta information report switch\n"
	  "wtp sta information report switch\n"
	  "wtp sta information report switch enable|disable\n"
	 )
{
	int ret;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID = 0;
    int policy = 0;
	/*WTPID = (unsigned int)vty->index;*//*wcl modify for globle variable*/
	
	if (!strcmp(argv[0],"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[0],"disable"))
	{
		policy = 0;	
	}
	else
	{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == HANSI_NODE){  /*wcl modify for globle varible*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle varible*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_STA_INFOMATION_SWITCH);
		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_STA_INFOMATION_SWITCH);*/
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty," set wtp %d sta infomation report switch %s successfully\n",WTPID,argv[0]);
	}
	else if (ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else if (ret == WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp id does not run\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	
	return CMD_SUCCESS;			
}
#endif
#if _GROUP_POLICY
DEFUN(set_ap_sta_infomation_reportinterval_cmd_func,
	  set_ap_sta_infomation_reportinterval_cmd,
	  "set ap sta infomation reportinterval PARAMETER",
	  "wireless-control config\n"
	  "ap sta infomation\n"
	  "ap sta infomation\n"
	  "ap sta infomation\n"
	  "ap sta infomation reportinterval\n"
	  "ap sta infomation reportinterval s \n"
	 )
{
	int i = 0;
	int ret = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;
    unsigned int interval = 0;
	
	ret = parse_int_ID((char*)argv[0], &interval);
	if(ret != WID_DBUS_SUCCESS){
            if(ret == WID_ILLEGAL_INPUT){
            	vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
            }
			else{
			vty_out(vty,"<error> unknown id format\n");
			}
			return CMD_SUCCESS;
	}	
	if(interval > 350 || interval <5){
		vty_out(vty,"<error> ap sta infomation reportinterval error\n");
		return CMD_SUCCESS;
	}
	

	if(vty->node == HANSI_NODE){  /*wcl modify for globle varible*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle varible*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
WtpList_Head=set_ap_sta_infomation_reportinterval_cmd_set_ap_sta_infomation_reportinterval(index,localid,dcli_dbus_connection,
	type,id,interval,&count,&ret);

if(type==0)
	{
		if(ret == 0)
		{
			vty_out(vty,"set ap sta infomation reportinterval %s successfully\n",argv[0]);
		}
		else if (ret == WTP_NOT_IN_RUN_STATE)
			vty_out(vty,"<error> wtp is not in run state\n");
		else if(ret == WTP_ID_NOT_EXIST)
			vty_out(vty,"<error> wtp id does not exist\n");
		else
		{
			vty_out(vty,"<error>  %d\n",ret);
		}
	}

else if(type == 1){
		if(ret == 0){
			vty_out(vty,"group %d set ap sta infomation reportinterval %s successfully.\n",id,argv[0]);
			if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL)){
				vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
				}
				
				vty_out(vty," failed.\n");
				dcli_free_WtpList(WtpList_Head);
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
		   vty_out(vty,"<error> group id does not exist\n");
	}
	return CMD_SUCCESS;			
}


#else
DEFUN(set_ap_sta_infomation_reportinterval_cmd_func,
	  set_ap_sta_infomation_reportinterval_cmd,
	  "set ap sta infomation reportinterval PARAMETER",
	  "wireless-control config\n"
	  "ap sta infomation\n"
	  "ap sta infomation\n"
	  "ap sta infomation\n"
	  "ap sta infomation reportinterval\n"
	  "ap sta infomation reportinterval : 5-32767 \n"
	 )
{
	int ret = 0;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

    unsigned int interval = 0;
	unsigned int wtp_id = 0;
	//wtp_id = (unsigned int)vty->index;
	
	ret = parse_int_ID((char*)argv[0], &interval);
	if(ret != WID_DBUS_SUCCESS){
            if(ret == WID_ILLEGAL_INPUT){
            	vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
            }
			else{
			vty_out(vty,"<error> unknown id format\n");
			}
			return CMD_SUCCESS;
	}	
	if(interval > 32767 || interval <5){				/*xiaodawei change 0-120 to 5-350, 20101210*/   /*fengwenchao change 250 to 32767  20110804*/
		vty_out(vty,"<error> ap sta infomation reportinterval error,should be 5-32767\n");
		return CMD_SUCCESS;
	}
	
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_STA_INFOMATION_REPORTINTERVAL);
		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_STA_INFOMATION_REPORTINTERVAL);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,	
							 DBUS_TYPE_UINT32,&interval,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"set ap sta infomation reportinterval %s successfully\n",argv[0]);
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp is not in run state\n");
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	
	return CMD_SUCCESS;			
}
#endif
#if _GROUP_POLICY
DEFUN(set_ap_if_info_report_enable_func,
	  set_ap_if_info_report_enable_cmd,
	  "set ap interface infomation report switch (enable|disable)",
	  CONFIG_STR
	  "wtp config\n"
	  "wtp interface information\n"
	  "wtp interface information\n"
	  "wtp interface information report switch\n"
	  "wtp interface information report switch\n"
	  "wtp interface information report switch enable|disable\n"
	 )
{
	int i = 0;
	int ret = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
    int policy = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;

	//WTPID = (unsigned int)vty->index;
	
	if (!strcmp(argv[0],"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[0],"disable"))
	{
		policy = 0;	
	}
	else
	{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}
	
	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	
	WtpList_Head = set_ap_if_info_report_enable_cmd_sep_ap_interface_information_report_switch(index, localid,
					dcli_dbus_connection, type, id , policy, &count, &ret);
		
	if(type == 0)
	{
		if(ret == 0)
		{
			vty_out(vty," set wtp %d interface infomation report switch %s successfully\n",id,argv[0]);
		}
		else if (ret == WTP_ID_NOT_EXIST)
			vty_out(vty,"<error> wtp id does not exist\n");
		else if (ret == WTP_NOT_IN_RUN_STATE)
			vty_out(vty,"<error> wtp id does not run\n");
		else
		{
			vty_out(vty,"<error>  %d\n",ret);
		}

	}

	else if(type == 1){
		if(ret == 0){
			vty_out(vty,"group %d set wtp interface infomation report switch %s successfully\n",id,argv[0]);
			if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL)){
				vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
				}
				
				vty_out(vty," failed.\n");
				dcli_free_WtpList(WtpList_Head);
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
		   vty_out(vty,"<error> group id does not exist\n");
	}
	return CMD_SUCCESS;		
}
#else

DEFUN(set_ap_if_info_report_enable_func,
	  set_ap_if_info_report_enable_cmd,
	  "set ap interface infomation report switch (enable|disable)",
	  CONFIG_STR
	  "wtp config\n"
	  "wtp interface information\n"
	  "wtp interface information\n"
	  "wtp interface information report switch\n"
	  "wtp interface information report switch\n"
	  "wtp interface information report switch enable|disable\n"
	 )
{
	int ret;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID = 0;
    int policy = 0;
	//WTPID = (unsigned int)vty->index;
	
	if (!strcmp(argv[0],"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[0],"disable"))
	{
		policy = 0;	
	}
	else
	{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_IF_INFO_SWITCH);
		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_IF_INFO_SWITCH);*/
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty," set wtp %d interface infomation report switch %s successfully\n",WTPID,argv[0]);
	}
	else if (ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else if (ret == WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp id does not run\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	
	return CMD_SUCCESS;			
}
#endif

#if _GROUP_POLICY
DEFUN(set_ap_if_info_reportinterval_cmd_func,
	  set_ap_if_info_reportinterval_cmd,
	  "set ap interface infomation reportinterval PARAMETER",
	  "wireless-control config\n"
	  "ap interface infomation\n"
	  "ap interface infomation\n"
	  "ap interface infomation\n"
	  "ap interface infomation reportinterval\n"
	  "ap interface infomation reportinterval s \n"
	 )
{
	int i = 0;
	int ret = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned char interval = 0;
	
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	ret = parse_char_ID((char*)argv[0], &interval);
	if(ret != WID_DBUS_SUCCESS){
        if(ret == WID_ILLEGAL_INPUT){
        	vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
        }
		else{
		vty_out(vty,"<error> unknown id format\n");
		}
		return CMD_SUCCESS;
	}	
	if(interval > 120 || interval == 0){
		vty_out(vty,"<error> ap sta infomation reportinterval error\n");
		return CMD_SUCCESS;
	}
	
	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	
	WtpList_Head = set_ap_if_info_report_enable_cmd_sep_ap_interface_information_report_interval(index, localid,
					dcli_dbus_connection, type, id , interval, &count, &ret);	
	
	if(type == 0)
	{
		if(ret == 0)
		{
			vty_out(vty,"set ap interface infomation reportinterval %s successfully\n",argv[0]);
		}
		else if (ret == WTP_NOT_IN_RUN_STATE)
			vty_out(vty,"<error> wtp is not in run state\n");
		else if(ret == WTP_ID_NOT_EXIST)
			vty_out(vty,"<error> wtp id does not exist\n");
		else
		{
			vty_out(vty,"<error>  %d\n",ret);
		}
	}

	else if(type == 1){
		if(ret == 0){
			vty_out(vty,"group %d set ap interface infomation reportinterval %s successfully\n",id,argv[0]);
			if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL)){
				vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
				}
				
				vty_out(vty," failed.\n");
				dcli_free_WtpList(WtpList_Head);
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
		   vty_out(vty,"<error> group id does not exist\n");
	}
	return CMD_SUCCESS;			
}
#else
DEFUN(set_ap_if_info_reportinterval_cmd_func,
	  set_ap_if_info_reportinterval_cmd,
	  "set ap interface infomation reportinterval PARAMETER",
	  "wireless-control config\n"
	  "ap interface infomation\n"
	  "ap interface infomation\n"
	  "ap interface infomation\n"
	  "ap interface infomation reportinterval\n"
	  "ap interface infomation reportinterval s \n"
	 )
{
	int ret = 0;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

    unsigned int interval = 0;
	unsigned int wtp_id = 0;
	//wtp_id = (unsigned int)vty->index;
	
	ret = parse_int_ID((char*)argv[0], &interval);
	if(ret != WID_DBUS_SUCCESS){
            if(ret == WID_ILLEGAL_INPUT){
            	vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
            }
			else{
			vty_out(vty,"<error> unknown id format\n");
			}
			return CMD_SUCCESS;
	}	
	if(interval > 32767 || interval == 0){    /*fengwenchao change 3600 to 32767*/
		vty_out(vty,"<error> ap sta infomation reportinterval error\n");
		return CMD_SUCCESS;
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_IF_INFO_REPORTINTERVAL);
		
	
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_IF_INFO_REPORTINTERVAL);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,	
							 DBUS_TYPE_UINT32,&interval,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"set ap interface infomation reportinterval %s successfully\n",argv[0]);
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp is not in run state\n");
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	
	return CMD_SUCCESS;			
}
#endif

DEFUN(show_dhcp_flooding_status_cmd_func,
		show_dhcp_flooding_status_cmd,
		"show dhcp-flooding status",
		"show dhcp flooding status"
)
{
	DCLI_WTP_API_GROUP_THREE *WTPINFO = NULL;
	int ret = WID_DBUS_SUCCESS;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == CONFIG_NODE) {
		index = 0;
	} else if(vty->node == HANSI_NODE) {
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	} else if(vty->node == LOCAL_HANSI_NODE) {
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	} else {
		return CMD_SUCCESS;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	WTPINFO = dcli_wtp_show_api_group_three(
	index,
	SIXTEENTH,/*"show dhcp-flooding status"*/
	0,
	0,
	0,
	&ret,
	0,
	0,
	0,
	0,
	&localid,
	dcli_dbus_connection,
	WID_DBUS_WTP_METHOD_SHOW_DHCP_FLOODING_STATUS_SET
	);

	if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == 0){		
		vty_out(vty,"==============================================================================\n");

		if (WTPINFO->dhcp_flooding_status) {
			vty_out(vty, "The anti-dhcp-flooding function is running now!\n");			
		}
		
		vty_out(vty, "Service\t\t\tStatus\n");
		vty_out(vty, "dhcp-flooding\t\t %s\n", WTPINFO->dhcp_flooding_status ? "enable" : "disable");

		vty_out(vty,"==============================================================================\n");
		dcli_wtp_free_fun_three(WID_DBUS_WTP_METHOD_SHOW_DHCP_FLOODING_STATUS_SET,WTPINFO);
	}
	else
		vty_out(vty,"<error>  %d\n",ret);
//	CW_FREE_OBJECT(WTPINFO);
	return CMD_SUCCESS;
}

DEFUN(set_dhcp_flooding_status_cmd_func,
	  set_dhcp_flooding_status_cmd,
	  "service dhcp-flooding (enable|disable)",
	  "set dhcp flooding enable or disable\n"
	 )
{
	int ret = 0;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

	unsigned char service_status;
	str2lower(&argv[0]);
	if (!strcmp(argv[0],"enable")||(tolower(argv[0][0]) == 'e')){
		service_status = 1;
	} else {
		service_status = 0;
	}

	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_DHCP_FLOODING_STATUS_SET);

	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_BYTE,&service_status,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"enable service dhcp-flooding successfully\n");
	}
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	
	return CMD_SUCCESS;			
}
DEFUN(show_ap_wids_set_cmd_func,
	  show_ap_wids_set_cmd,
	  "show ap wids",
	  "show wireless-control config\n"
	  "ap wids infomation\n"
	  "ap wids item config\n"
	 )
{
/*	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;*/
	unsigned int WTPID = 0;
	int ret = WID_DBUS_SUCCESS;
	/*WTPID = (unsigned int)vty->index;*/

	char on[] = "enable";
	char off[] = "disable";
	
	DCLI_WTP_API_GROUP_THREE *WTPINFO = NULL;
/*	CW_CREATE_OBJECT_ERR(WTPINFO, DCLI_WTP_API_GROUP_THREE, return NULL;);	

	WTPINFO->wids = {0};	
	WTPINFO->interval = 0;
	WTPINFO->probethreshold = 0;	
	WTPINFO->otherthreshold = 0;	
	WTPINFO->lasttime = 0;*/
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
#if 0	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SHOW_WTP_WIDS_SET);

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_WTP_METHOD_SHOW_WTP_WIDS_SET);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}

	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	
	if(ret == 0)
	{	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&wids.flooding);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&wids.sproof);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&wids.weakiv);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&interval);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&probethreshold);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&otherthreshold);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&lasttime);
	}
	dbus_message_unref(reply);
#endif
	 WTPINFO = dcli_wtp_show_api_group_three(
		index,
		SIXTH,/*"show ap wids"*/
		WTPID,
		0,
		0,
		&ret,/**/
		0,/*num2*/
		0,
		0,
		0,
		&localid,//num6
	//	WTPINFO,
		dcli_dbus_connection,
		WID_DBUS_WTP_METHOD_SHOW_WTP_WIDS_SET
		);
	//printf("##########ret is %d\n",ret);
	if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == 0){		
		vty_out(vty,"==============================================================================\n");
		vty_out(vty,"Wireless Detection Prevention System info\n");
		vty_out(vty,"flooding:%s\n",(WTPINFO->wids.flooding) == 1?on:off);
		vty_out(vty,"spoofing:%s\n",(WTPINFO->wids.sproof) == 1?on:off);
		vty_out(vty,"weakiv:%s\n",(WTPINFO->wids.weakiv) == 1?on:off);
		vty_out(vty,"interval: %d s\n",WTPINFO->interval);
		vty_out(vty,"probe threshold: %d\n",WTPINFO->probethreshold);
		vty_out(vty,"other threshold: %d\n",WTPINFO->otherthreshold);
		vty_out(vty,"last time in black: %d s\n",WTPINFO->lasttime);
		vty_out(vty,"==============================================================================\n");
		dcli_wtp_free_fun_three(WID_DBUS_WTP_METHOD_SHOW_WTP_WIDS_SET,WTPINFO);
	}
	else
		vty_out(vty,"<error>  %d\n",ret);
//	CW_FREE_OBJECT(WTPINFO);
	return CMD_SUCCESS;

}

DEFUN(set_ap_wids_set_cmd_func,
	  set_ap_wids_set_cmd,
	  "set ap wids [flooding] [spoofing] [weakiv] (enable|disable)",
	  "wireless-control config\n"
	  "ap wids infomation\n"
	  "ap wids item\n"
	  "ap wids item flooding\n"
	  "enable or disable\n"
	  "ap wids item spoofing\n"
	  "enable or disable\n"
	  "ap wids item weakiv\n"
	  "enable or disable\n"

	 )
{
	int ret = 0;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

 	unsigned char flooding = 2;
	unsigned char sproof = 2;
	unsigned char weakiv = 2;
	unsigned int wtp_id = 0;
	
	
	if(argc == 1)
	{
		if(!strncmp(argv[0],"enable",strlen(argv[0])))
		{
			flooding = 1;
			sproof = 1;
			weakiv = 1;
			
		}
		else if(!strncmp(argv[0],"disable",strlen(argv[0])))
		{
			flooding = 0;
			sproof = 0;
			weakiv = 0;
		}
		else
		{
            vty_out(vty,"%% Unknown Command!\n");
			return CMD_WARNING;
		}
	}
	else if(argc == 2)
	{
		if(!strncmp(argv[0],"flooding",strlen(argv[0])))
		{
			if(!strncmp(argv[1],"enable",strlen(argv[1])))
			{
				flooding = 1;			
			}
			else if(!strncmp(argv[1],"disable",strlen(argv[1])))
			{
				flooding = 0;
			}
			else
			{
	            vty_out(vty,"%% Unknown Command!\n");
				return CMD_WARNING;
			}
			
		}
		else if(!strncmp(argv[0],"spoofing",strlen(argv[0])))
		{
			if(!strncmp(argv[1],"enable",strlen(argv[1])))
			{
				sproof= 1;			
			}
			else if(!strncmp(argv[1],"disable",strlen(argv[1])))
			{
				sproof= 0;
			}
			else
			{
	            vty_out(vty,"%% Unknown Command!\n");
				return CMD_WARNING;
			}
			
		}
		else if(!strncmp(argv[0],"weakiv",strlen(argv[0])))
		{
			if(!strncmp(argv[1],"enable",strlen(argv[1])))
			{
				weakiv = 1;			
			}
			else if(!strncmp(argv[1],"disable",strlen(argv[1])))
			{
				weakiv= 0;
			}
			else
			{
	            vty_out(vty,"%% Unknown Command!\n");
				return CMD_WARNING;
			}
			
		}
		else
		{
            vty_out(vty,"%% Unknown Command!\n");
			return CMD_WARNING;
		}

		
	}
	else if(argc == 3)
	{
		if(!strncmp(argv[0],"flooding",strlen(argv[0])))
		{
			if(!strncmp(argv[2],"enable",strlen(argv[2])))
			{
				flooding = 1;			
			}
			else if(!strncmp(argv[2],"disable",strlen(argv[2])))
			{
				flooding= 0;
			}
			else
			{
	            vty_out(vty,"%% Unknown Command!\n");
				return CMD_WARNING;
			}

			
		}
		else if(!strncmp(argv[0],"spoofing",strlen(argv[0])))
		{
			if(!strncmp(argv[2],"enable",strlen(argv[2])))
			{
				sproof= 1;			
			}
			else if(!strncmp(argv[2],"disable",strlen(argv[2])))
			{
				sproof= 0;
			}
			else
			{
	            vty_out(vty,"%% Unknown Command!\n");
				return CMD_WARNING;
			}

			
		}
		else if(!strncmp(argv[0],"weakiv",strlen(argv[0])))
		{
			if(!strncmp(argv[2],"enable",strlen(argv[2])))
			{
				weakiv= 1;			
			}
			else if(!strncmp(argv[2],"disable",strlen(argv[2])))
			{
				weakiv= 0;
			}
			else
			{
	            vty_out(vty,"%% Unknown Command!\n");
				return CMD_WARNING;
			}

			
		}
		else
		{
            vty_out(vty,"%% Unknown Command!\n");
			return CMD_WARNING;
		}

		if(!strncmp(argv[1],"flooding",strlen(argv[1])))
		{
			if(!strncmp(argv[2],"enable",strlen(argv[2])))
			{
				flooding = 1;			
			}
			else if(!strncmp(argv[2],"disable",strlen(argv[2])))
			{
				flooding= 0;
			}
			else
			{
	            vty_out(vty,"%% Unknown Command!\n");
				return CMD_WARNING;
			}

			
		}
		else if(!strncmp(argv[1],"spoofing",strlen(argv[1])))
		{
			if(!strncmp(argv[2],"enable",strlen(argv[2])))
			{
				sproof= 1;			
			}
			else if(!strncmp(argv[2],"disable",strlen(argv[2])))
			{
				sproof= 0;
			}
			else
			{
	            vty_out(vty,"%% Unknown Command!\n");
				return CMD_WARNING;
			}

			
		}
		else if(!strncmp(argv[1],"weakiv",strlen(argv[1])))
		{
			if(!strncmp(argv[2],"enable",strlen(argv[2])))
			{
				weakiv= 1;			
			}
			else if(!strncmp(argv[2],"disable",strlen(argv[2])))
			{
				weakiv= 0;
			}
			else
			{
	            vty_out(vty,"%% Unknown Command!\n");
				return CMD_WARNING;
			}

			
		}

		else
		{
            vty_out(vty,"%% Unknown Command!\n");
			return CMD_WARNING;
		}

	}
	else if(argc == 4)
	{
		if(!strncmp(argv[0],"flooding",strlen(argv[0])))
		{
			if(!strncmp(argv[3],"enable",strlen(argv[3])))
			{
				flooding = 1;			
			}
			else if(!strncmp(argv[3],"disable",strlen(argv[3])))
			{
				flooding= 0;
			}
			else
			{
	            vty_out(vty,"%% Unknown Command!\n");
				return CMD_WARNING;
			}

			
		}
		else if(!strncmp(argv[0],"spoofing",strlen(argv[0])))
		{
			if(!strncmp(argv[3],"enable",strlen(argv[3])))
			{
				sproof= 1;			
			}
			else if(!strncmp(argv[3],"disable",strlen(argv[3])))
			{
				sproof= 0;
			}
			else
			{
				vty_out(vty,"%% Unknown Command!\n");
				return CMD_WARNING;
			}

			
		}
		else if(!strncmp(argv[0],"weakiv",strlen(argv[0])))
		{
			if(!strncmp(argv[3],"enable",strlen(argv[3])))
			{
				weakiv= 1;			
			}
			else if(!strncmp(argv[3],"disable",strlen(argv[3])))
			{
				weakiv= 0;
			}
			else
			{
				vty_out(vty,"%% Unknown Command!\n");
				return CMD_WARNING;
			}

			
		}

		else
		{
            vty_out(vty,"%% Unknown Command!\n");
			return CMD_WARNING;
		}

		if(!strncmp(argv[1],"flooding",strlen(argv[1])))
		{
			if(!strncmp(argv[3],"enable",strlen(argv[3])))
			{
				flooding = 1;			
			}
			else if(!strncmp(argv[3],"disable",strlen(argv[3])))
			{
				flooding= 0;
			}
			else
			{
				vty_out(vty,"%% Unknown Command!\n");
				return CMD_WARNING;
			}

			
		}
		else if(!strncmp(argv[1],"spoofing",strlen(argv[1])))
		{
			if(!strncmp(argv[3],"enable",strlen(argv[3])))
			{
				sproof= 1;			
			}
			else if(!strncmp(argv[3],"disable",strlen(argv[3])))
			{
				sproof= 0;
			}
			else
			{
				vty_out(vty,"%% Unknown Command!\n");
				return CMD_WARNING;
			}

			
		}
		else if(!strncmp(argv[1],"weakiv",strlen(argv[1])))
		{
			if(!strncmp(argv[3],"enable",strlen(argv[3])))
			{
				weakiv= 1;			
			}
			else if(!strncmp(argv[3],"disable",strlen(argv[3])))
			{
				weakiv= 0;
			}
			else
			{
				vty_out(vty,"%% Unknown Command!\n");
				return CMD_WARNING;
			}

			
		}
		else
		{
            vty_out(vty,"%% Unknown Command!\n");
			return CMD_WARNING;
		}

		
		if(!strncmp(argv[2],"flooding",strlen(argv[2])))
		{
			if(!strncmp(argv[3],"enable",strlen(argv[3])))
			{
				flooding = 1;			
			}
			else if(!strncmp(argv[3],"disable",strlen(argv[3])))
			{
				flooding= 0;
			}
			else
			{
				vty_out(vty,"%% Unknown Command!\n");
				return CMD_WARNING;
			}

			
		}
		else if(!strncmp(argv[2],"spoofing",strlen(argv[2])))
		{
			if(!strncmp(argv[3],"enable",strlen(argv[3])))
			{
				sproof= 1;			
			}
			else if(!strncmp(argv[3],"disable",strlen(argv[3])))
			{
				sproof= 0;
			}
			else
			{
				vty_out(vty,"%% Unknown Command!\n");
				return CMD_WARNING;
			}

			
		}
		else if(!strncmp(argv[2],"weakiv",strlen(argv[2])))
		{
			if(!strncmp(argv[3],"enable",strlen(argv[3])))
			{
				weakiv= 1;			
			}
			else if(!strncmp(argv[3],"disable",strlen(argv[3])))
			{
				weakiv= 0;
			}
			else
			{
				vty_out(vty,"%% Unknown Command!\n");
				return CMD_WARNING;
			}

			
		}
		else
		{
            vty_out(vty,"%% Unknown Command!\n");
			return CMD_WARNING;
		}


	}


	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_WIDS_SET);

	
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE, WID_DBUS_WTP_METHOD_SET_WTP_WIDS_SET);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,	
							 DBUS_TYPE_BYTE,&flooding,
							 DBUS_TYPE_BYTE,&sproof,
							 DBUS_TYPE_BYTE,&weakiv,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"set ap wids successfully\n");
	}
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	
	return CMD_SUCCESS;			
}

#if _GROUP_POLICY

DEFUN(set_ap_if_updown_func,
	  set_ap_if_updown_cmd,
	  "set ap interface (eth|wifi) ID (uplink|downlink)",
	  "AP config\n"
	  "ap interface name like wifi0/eth0\n"
	  "interface up/down\n"
	 )
{
	int i = 0;
	int ret = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int id = 0;
	unsigned int type1 = 0;
	
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;

	unsigned char type = 4;
	unsigned char policy = 2;
	unsigned char ifindex = 0;

	if (!strcmp(argv[0],"eth"))
	{
		type = 0;	
	}
	else if (!strcmp(argv[0],"wifi"))
	{
		type = 1;	
	}
	else
	{
		vty_out(vty,"<error> input interface only with 'ath' 'eth' or 'wifi'\n");
		return CMD_SUCCESS;
	}
	
	ret = wid_wtp_parse_char_ID((char*)argv[1], &ifindex);
	if(ret != WID_DBUS_SUCCESS){
			vty_out(vty,"<error> unknown id format\n");
			return CMD_SUCCESS;
	}

	if (!strcmp(argv[2],"uplink"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[2],"downlink"))
	{
		policy = 0;	
	}
	else
	{
		vty_out(vty,"<error> input interface only with 'uplink' or 'downlink'\n");
		return CMD_SUCCESS;
	}
	
	if(vty->node == WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type1 = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type1 = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type1 = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type1 = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type1 = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		
	WtpList_Head = set_ap_if_updown_cmd_set_ap_interface(index,localid,dcli_dbus_connection,type1,id,type,ifindex,policy,
		&count,&ret);

if(type1==0)
{
	
	if(ret == 0)
	{
		vty_out(vty,"set ap interface %s %s %s successfully\n",argv[0],argv[1],argv[2]);
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp is not in run state\n");
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
}

if(type1==1)
{
	if(ret == 0){
			vty_out(vty,"group %d set ap interface %s %s %s successfully\n",id,argv[0],argv[1],argv[2]);
			if((count != 0)&&(type1 == 1)&&(WtpList_Head!=NULL)){
				vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
				}
				
				vty_out(vty," failed.\n");
				dcli_free_WtpList(WtpList_Head);
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
		   vty_out(vty,"<error> group id does not exist\n");
}

	return CMD_SUCCESS;		
}

#else
DEFUN(set_ap_if_updown_func,
	  set_ap_if_updown_cmd,
	  "set ap interface (eth|wifi) ID (uplink|downlink)",
	  "AP config\n"
	  "ap interface name like wifi0/eth0\n"
	  "interface up/down\n"
	 )
{
	int ret = 0;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

	unsigned char type = 4;
	unsigned char policy = 2;
	unsigned int wtp_id = 0;
	unsigned char ifindex = 0;
	//wtp_id = (unsigned int)vty->index;

	if (!strcmp(argv[0],"eth"))
	{
		type = 0;	
	}
	else if (!strcmp(argv[0],"wifi"))
	{
		type = 1;	
	}
	else
	{
		vty_out(vty,"<error> input interface only with 'ath' 'eth' or 'wifi'\n");
		return CMD_SUCCESS;
	}
	
	ret = wid_wtp_parse_char_ID((char*)argv[1], &ifindex);
	if(ret != WID_DBUS_SUCCESS){
			vty_out(vty,"<error> unknown id format\n");
			return CMD_SUCCESS;
	}

	if (!strcmp(argv[2],"uplink"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[2],"downlink"))
	{
		policy = 0;	
	}
	else
	{
		vty_out(vty,"<error> input interface only with 'uplink' or 'downlink'\n");
		return CMD_SUCCESS;
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_INTERFACE_UPDOWN);
		
	
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_INTERFACE_UPDOWN);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,	
							 DBUS_TYPE_BYTE,&type,
							 DBUS_TYPE_BYTE,&ifindex,
							 DBUS_TYPE_BYTE,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"set ap interface %s %s %s successfully\n",argv[0],argv[1],argv[2]);
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp is not in run state\n");
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	return CMD_SUCCESS;		
}
#endif
#if _GROUP_POLICY
DEFUN(set_ap_if_eth_rate_func,
	  set_ap_if_eth_rate_cmd,
	  "set ap interface eth ETHID rate (10|100|1000)",
	  "AP config\n"
	  "ap interface name eth0 rate\n"
	  "interface rate\n"
	 )
{
	int i = 0;
	int ret = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;

	unsigned char ifindex = 0;

	unsigned int rate = 0;
	ret = wid_wtp_parse_char_ID((char*)argv[0], &ifindex);
	if(ret != WID_DBUS_SUCCESS){
			vty_out(vty,"<error> unknown id format\n");
			return CMD_SUCCESS;
	}
	ret = wid_wtp_parse_char_ID((char*)argv[1], &rate);
 
	
	if (!strcmp(argv[1],"10"))
	{
		rate = 10;	
	}
	else if (!strcmp(argv[1],"100"))
	{
		rate = 100;	
	}
	else if (!strcmp(argv[1],"1000"))
	{
		rate = 1000;	
	}	
	else
	{
		vty_out(vty,"<error> input interface only with '10' or '100' or '1000'\n");
		return CMD_SUCCESS;
	}

	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	WtpList_Head = set_ap_if_eth_rate_cmd_set_ap_interface_eth_rate(index,localid,dcli_dbus_connection,type,id,ifindex,
		rate,&count,&ret);
if(type==0)
{
	
	if(ret == 0)
	{
		vty_out(vty,"set ap interface eth%d rate %d M successfully\n",ifindex,rate);
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp is not in run state\n");
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
}

if(type==1)
{
	if(ret == 0){
			vty_out(vty,"group %d set ap interface eth%d rate %d M successfully\n",id,ifindex,rate);
			if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL)){
				vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
				}
				
				vty_out(vty," failed.\n");
				dcli_free_WtpList(WtpList_Head);
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
		   vty_out(vty,"<error> group id does not exist\n");
}

	return CMD_SUCCESS;			
}


#else
DEFUN(set_ap_if_eth_rate_func,
	  set_ap_if_eth_rate_cmd,
	  "set ap interface eth ETHID rate (10|100|1000)",
	  "AP config\n"
	  "ap interface name eth0 rate\n"
	  "interface rate\n"
	 )
{
	int ret = 0;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

	unsigned char type = 4;
	unsigned char policy = 2;
	unsigned int wtp_id = 0;
	unsigned char ifindex = 0;
	/*wtp_id = (unsigned int)vty->index;*//*wcl modify for globle variable*/
	unsigned int rate = 0;
	ret = wid_wtp_parse_char_ID((char*)argv[0], &ifindex);
	if(ret != WID_DBUS_SUCCESS){
			vty_out(vty,"<error> unknown id format\n");
			return CMD_SUCCESS;
	}
	ret = wid_wtp_parse_char_ID((char*)argv[1], &rate);

	
	if (!strcmp(argv[1],"10"))
	{
		rate = 10;	
	}
	else if (!strcmp(argv[1],"100"))
	{
		rate = 100;	
	}
	else if (!strcmp(argv[1],"1000"))
	{
		rate = 1000;	
	}	
	else
	{
		vty_out(vty,"<error> input interface only with '10' or '100' or '1000'\n");
		return CMD_SUCCESS;
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_INTERFACE_ETH_RATE);

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_INTERFACE_ETH_RATE);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,	
							 DBUS_TYPE_BYTE,&type,
							 DBUS_TYPE_BYTE,&ifindex,
							 DBUS_TYPE_UINT32,&rate,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"set ap interface eth%d rate %d M successfully\n",ifindex,rate);
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp is not in run state\n");
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else if(ret == ETH_NOT_EXIST)
		vty_out(vty,"<error> eth%d does not exist\n",ifindex);
	else 
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	return CMD_SUCCESS;		
}
#endif
//fengwenchao add 20110126 for 	XJDEV-32  from 2.0
DEFUN(set_ap_if_eth_mtu_func,
	  set_ap_if_eth_mtu_cmd,
	  "set ap interface (eth0|eth1) mtu VALUE",
	  "AP config\n"
	  "ap interface name eth0 mtu\n"
	  "interface mtu\n"
	  "set ap ethernet mtu\n"
	  "set ap ethernet mtu\n"
	  "set ap ethernet mtu\n"
	  "0~1500\n"
	 )
{
	int ret = 0;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

	unsigned char type = 4;
	unsigned char policy = 2;
	unsigned int wtp_id = 0;
	unsigned int mtu = 0;
	/*wtp_id = (unsigned int)vty->index;*//*wcl modify for globle variable*/
	unsigned int rate = 0;

	if (!strcmp(argv[0],"eth0"))
	{
		policy = 0;	
	}
	else if (!strcmp(argv[0],"eth1"))
	{
		policy = 1;	
	}
	else
	{
		vty_out(vty,"<error> input patameter only with 'eth0' or 'eth1'\n");
		return CMD_SUCCESS;
	}
	if (strlen(argv[1]) > 4)
	{
		vty_out(vty, "<error>input mtu is too large!!!\n");
		return CMD_SUCCESS;
	}
	
	ret = parse_int_ID((char*)argv[1], &mtu);
	if(ret != WID_DBUS_SUCCESS){
			vty_out(vty,"<error> unknown id format\n");
			return CMD_SUCCESS;
	}
	if (mtu > 1500)
	{
		vty_out(vty, "<error>input mtu is too large!!!\n");
		return CMD_SUCCESS;
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index;
	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = (int)vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = (int)vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ret = dcli_set_ap_eth_if_mtu(index,localid,policy,mtu,wtp_id,dcli_dbus_connection);

	if(ret == 0)
	{
		vty_out(vty,"set ap interface %s mtu %d successfully\n",argv[0],mtu);
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp is not in run state\n");
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else if(ret == ETH_NOT_EXIST)
		vty_out(vty,"<error> %s does not exist\n",argv[0]);
	else 
	{
		vty_out(vty,"<error>  %d\n",ret);
	}

	return CMD_SUCCESS;		
}
//fengwenchao add end
DEFUN(show_ap_if_info_func,
	  show_ap_if_info_cmd,
	  "show ap interface information",
	  SHOW_STR
	  "ap interface information\n"
	  "ap interface information\n"
	  "ap interface information\n"
	 )
{	
	
/*	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;*/
	unsigned int WTPID = 0;
	int i = 0;
	int j= 0;
	int ret = WID_DBUS_SUCCESS;
	char en[] = "enable";
	char dis[] = "disable";
	char eth[] = "ethernet";
	char wifi[] = "wifi";
	char state[4][6] = {"none","up","down","error"};
	//WTPID = (unsigned int)vty->index;
	
	DCLI_WTP_API_GROUP_TWO *WTPINFO = NULL;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
#if 0	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SHOW_WTP_IF_INFO);
		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SHOW_WTP_IF_INFO);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}

	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0)
	{	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.report_switch);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.report_interval);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.eth_num);

		for(i=0;i<info.eth_num;i++)
		{	
			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&info.eth[i].type);

			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&info.eth[i].ifindex);

			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&info.eth[i].state);

			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&info.eth[i].state_time);
			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&info.eth[i].eth_rate);
		}

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.wifi_num);

		for(i=0;i<info.wifi_num;i++)
		{	
			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&info.wifi[i].type);

			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&info.wifi[i].ifindex);

			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&info.wifi[i].state);

			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&info.wifi[i].state_time);
		}
	}
	dbus_message_unref(reply);
#endif
	 WTPINFO = dcli_wtp_show_api_group_two(
		index,
		TENTH,/*"show ap interface information"*/
		WTPID,
		0,
		0,
		&ret,/**/
		0,/*num2*/
		0,
		0,
		0,
		&localid,//num6
	//	WTPINFO,
		dcli_dbus_connection,
		WID_DBUS_WTP_METHOD_SHOW_WTP_IF_INFO
		);
	//printf("##########ret is %d\n",ret);
	if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == 0){		
		vty_out(vty,"==============================================================================\n");
		vty_out(vty,"WTP %d interface infomation\n",WTPID);
		vty_out(vty,"report switch:	%s\n",(WTPINFO->WTP[0]->apifinfo.report_switch == 1)?en:dis);
		vty_out(vty,"report interval:	%d\n",WTPINFO->WTP[0]->apifinfo.report_interval);
		vty_out(vty,"eth num:	%d\n",WTPINFO->WTP[0]->apifinfo.eth_num);
		for(i=0;i<WTPINFO->WTP[0]->apifinfo.eth_num;i++)
		{
			j = WTPINFO->WTP[0]->apifinfo.eth[i].state;
			vty_out(vty,"eth%d type:	%s\n",WTPINFO->WTP[0]->apifinfo.eth[i].ifindex,(WTPINFO->WTP[0]->apifinfo.eth[i].type == 0)?eth:wifi);
			vty_out(vty,"eth%d state:	%s\n",WTPINFO->WTP[0]->apifinfo.eth[i].ifindex,state[j]);
			
			time_t now,online_time;
			time(&now);
			online_time = now - (WTPINFO->WTP[0]->apifinfo.eth[i].state_time);
			int hour=0,min=0,sec=0;
			hour = online_time/3600;
			min = (online_time-hour*3600)/60;
			sec = (online_time-hour*3600)%60;
			vty_out(vty,"eth%d state time:	%02d:%02d:%02d\n",i,hour,min,sec);
			vty_out(vty,"eth%d rate :	%d M\n",i,WTPINFO->WTP[0]->apifinfo.eth[i].eth_rate);
			vty_out(vty,"eth%d mtu :	%d byte\n",i,WTPINFO->WTP[0]->apifinfo.eth[i].eth_mtu);    //fengwenchao add 20110126 for XJDEV-32 from 2.0
		}
		vty_out(vty,"wifi num:	%d\n",WTPINFO->WTP[0]->apifinfo.wifi_num);
		i = 0;
		for(i=0;i<WTPINFO->WTP[0]->apifinfo.wifi_num && i<WTPINFO->WTP[0]->RadioCount;i++)
		{
			vty_out(vty,"wifi%d type:	%s\n",WTPINFO->WTP[0]->apifinfo.wifi[i].ifindex,(WTPINFO->WTP[0]->apifinfo.wifi[i].type == 0)?eth:wifi);
			vty_out(vty,"wifi%d state:	%s\n",WTPINFO->WTP[0]->apifinfo.wifi[i].ifindex,state[(WTPINFO->WTP[0]->apifinfo.wifi[i].state)]);
			
			time_t now,online_time;
			time(&now);
			online_time = now - (WTPINFO->WTP[0]->apifinfo.wifi[i].state_time);
			
			int hour=0,min=0,sec=0;
			hour = online_time/3600;
			min = (online_time-hour*3600)/60;
			sec = (online_time-hour*3600)%60;
			vty_out(vty,"wifi%d state time:	%02d:%02d:%02d\n",i,hour,min,sec);
		}
		vty_out(vty,"==============================================================================\n");

		dcli_wtp_free_fun_two(WID_DBUS_WTP_METHOD_SHOW_WTP_IF_INFO,WTPINFO);
	}
	else if (ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else if (ret == SWITCH_IS_DISABLE)
		vty_out(vty,"<error> wtp interface infomation report switch is disable\n");
//	CW_FREE_OBJECT(WTPINFO->WTP[0]);
//	CW_FREE_OBJECT(WTPINFO->WTP);
//	CW_FREE_OBJECT(WTPINFO);
	return CMD_SUCCESS;
}
#if _GROUP_POLICY
DEFUN(get_wtp_bss_pkt_info_func,
	  get_wtp_bss_pkt_info_cmd,
	  "update wtp bss pakets infomation",
	  "update wid wsm info\n"
	  "update wtp bss pakets infomation"
	  "update wtp bss pakets infomation"
	  "update wtp bss pakets infomation"
	  "update wtp bss pakets infomation"
	 )
{
	int i = 0;
	int ret = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;


	if(vty->node == WTP_NODE){
		index = 0;			
		id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	WtpList_Head = get_wtp_bss_pkt_info_cmd_update_wtp_bss_pakets_infomation(index,localid,dcli_dbus_connection,type,id,
		&count,&ret);

if(type==0)
{
	if(ret == 0)
	{
		vty_out(vty,"update wtp bss packet infomation successfully\n");
	}
	else if(ret == WID_DBUS_ERROR)
		vty_out(vty,"<error> not expect error\n");
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
}
if(type==1)
{
	if(ret == 0)
	{
		vty_out(vty,"group %d update wtp bss packet infomation successfully\n",id);
		if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL))
		{
			vty_out(vty,"wtp ");					
			for(i=0; i<count; i++)
			{
				if(Wtp_Show_Node == NULL)
					Wtp_Show_Node = WtpList_Head->WtpList_list;
				else 
					Wtp_Show_Node = Wtp_Show_Node->next;
	
				if(Wtp_Show_Node == NULL)
					break;
						
				vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
			}
					
			vty_out(vty," failed.\n");
			dcli_free_WtpList(WtpList_Head);
		}
	}
	else if (ret == GROUP_ID_NOT_EXIST)
			 vty_out(vty,"<error> group id does not exist\n");
}
	
	return CMD_SUCCESS;			
}

#else
DEFUN(get_wtp_bss_pkt_info_func,
	  get_wtp_bss_pkt_info_cmd,
	  "update wtp bss pakets infomation",
	  "update wid wsm info\n"
	  "update wtp bss pakets infomation"
	  "update wtp bss pakets infomation"
	  "update wtp bss pakets infomation"
	  "update wtp bss pakets infomation"
	 )
{
	int ret = 0;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

	unsigned int wtp_id = 0;
	//wtp_id = (unsigned int)vty->index;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_GET_WTP_BSS_PKT_INFO);
		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_GET_WTP_BSS_PKT_INFO);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,	
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"update wtp bss packet infomation successfully\n");
	}
	else if(ret == WID_DBUS_ERROR)
		vty_out(vty,"<error> not expect error\n");
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	
	return CMD_SUCCESS;			
}
#endif
DEFUN(show_wtp_bss_pkt_info_func,
	  show_wtp_bss_pkt_info_cmd,
	  "show wtp bss pkt information",
	  SHOW_STR
	  "wtp bss pkt information\n"
	  "wtp bss pkt information\n"
	  "wtp bss pkt information\n"
	  "wtp bss pkt information\n"
	 )
{	
	
/*	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;*/
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int WTPID = 0;
	unsigned int bsscount = 0;
	
	int i = 0;
	//BSSStatistics bssinfo[L_RADIO_NUM*L_BSS_NUM];
	DCLI_WTP_API_GROUP_TWO *INFO = NULL;

	unsigned char wlanid[L_RADIO_NUM*L_BSS_NUM];
	memset(wlanid,0,L_RADIO_NUM*L_BSS_NUM);
	//WTPID = (unsigned int)vty->index;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
#if 0	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SHOW_WTP_BSS_PKT_INFO);
		

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SHOW_WTP_BSS_PKT_INFO);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}

	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0)
	{	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&bsscount);
		dbus_message_iter_next(&iter);	
		dbus_message_iter_recurse(&iter,&iter_array);
		

		for(i=0;i<bsscount;i++)
		{	
			DBusMessageIter iter_struct;
			dbus_message_iter_recurse(&iter_array,&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&bssinfo[i].BSSIndex);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&bssinfo[i].Radio_G_ID);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&bssinfo[i].rx_unicast);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&bssinfo[i].tx_unicast);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&bssinfo[i].rx_broadcast);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&bssinfo[i].tx_broadcast);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&bssinfo[i].rx_pkt_unicast);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&bssinfo[i].tx_pkt_unicast);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&bssinfo[i].rx_pkt_broadcast);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&bssinfo[i].tx_pkt_broadcast);
			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&bssinfo[i].retry);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&bssinfo[i].retry_pkt);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&bssinfo[i].err);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&wlanid[i]);

			dbus_message_iter_next(&iter_array);
		}
	}
	dbus_message_unref(reply);
#endif
//printf("555555555555555555555\n");
	INFO = dcli_wtp_show_api_group_two(
	   index,
	   FOURTH,/*"show wtp bss pkt information"*/
	   WTPID,
	   0,
	   0,
	   &ret,/**/
	   0,/*num2*/
	   0,
	   0,
	   0,
	   &localid,//num6
	//   INFO,
	   dcli_dbus_connection,
	   WID_DBUS_WTP_METHOD_SHOW_WTP_BSS_PKT_INFO
	   );
	if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == 0){		
		vty_out(vty,"==============================================================================\n");
		vty_out(vty,"WTP %d bss packet infomation\n",WTPID);
		vty_out(vty,"WTP id:	%d\n",WTPID);
		vty_out(vty,"BSS num:	%d\n",INFO->WTP[0]->WTP_Radio[0]->bss_num);
		vty_out(vty,"------------------------------------------------------------------------------\n");
		for(i=0;i<INFO->WTP[0]->WTP_Radio[0]->bss_num;i++)
		{
			vty_out(vty,"global radio id:	%d\n",INFO->WTP[0]->WTP_Radio[0]->BSS[i]->BSS_pkt_info.Radio_G_ID);
			vty_out(vty,"local radio id:	%d\n",(INFO->WTP[0]->WTP_Radio[0]->BSS[i]->Radio_G_ID)%L_RADIO_NUM);
			vty_out(vty,"bssindex:	%d\n",INFO->WTP[0]->WTP_Radio[0]->BSS[i]->BSSIndex);
			vty_out(vty,"wlanid:	%d\n",INFO->WTP[0]->WTP_Radio[0]->BSS[i]->WlanID);
			vty_out(vty,"rx_unicast:	%lld\n",INFO->WTP[0]->WTP_Radio[0]->BSS[i]->BSS_pkt_info.rx_unicast);
			vty_out(vty,"tx_unicast:	%lld\n",INFO->WTP[0]->WTP_Radio[0]->BSS[i]->BSS_pkt_info.tx_unicast);
			vty_out(vty,"rx_broadcast:	%lld\n",INFO->WTP[0]->WTP_Radio[0]->BSS[i]->BSS_pkt_info.rx_broadcast);
			vty_out(vty,"tx_broadcast:	%lld\n",INFO->WTP[0]->WTP_Radio[0]->BSS[i]->BSS_pkt_info.tx_broadcast);
			vty_out(vty,"rx_pkt_unicast:	%lld\n",INFO->WTP[0]->WTP_Radio[0]->BSS[i]->BSS_pkt_info.rx_pkt_unicast);
			vty_out(vty,"tx_pkt_unicast:	%lld\n",INFO->WTP[0]->WTP_Radio[0]->BSS[i]->BSS_pkt_info.tx_pkt_unicast);
			vty_out(vty,"rx_pkt_broadcast:	%lld\n",INFO->WTP[0]->WTP_Radio[0]->BSS[i]->BSS_pkt_info.rx_pkt_broadcast);
			vty_out(vty,"tx_pkt_broadcast:	%lld\n",INFO->WTP[0]->WTP_Radio[0]->BSS[i]->BSS_pkt_info.tx_pkt_broadcast);
			vty_out(vty,"retry:	%lld\n",INFO->WTP[0]->WTP_Radio[0]->BSS[i]->BSS_pkt_info.retry);
			vty_out(vty,"retry_pkt:	%lld\n",INFO->WTP[0]->WTP_Radio[0]->BSS[i]->BSS_pkt_info.retry_pkt);
			vty_out(vty,"err:	%lld\n",INFO->WTP[0]->WTP_Radio[0]->BSS[i]->BSS_pkt_info.err);		
			vty_out(vty,"------------------------------------------------------------------------------\n");
			//CW_FREE_OBJECT(INFO->WTP[0]->WTP_Radio[0]->BSS[i]);
		}
		vty_out(vty,"==============================================================================\n");
	//	CW_FREE_OBJECT(INFO->WTP[0]->WTP_Radio[0]->BSS);

		dcli_wtp_free_fun_two(WID_DBUS_WTP_METHOD_SHOW_WTP_BSS_PKT_INFO,INFO);
	}
	else if (ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	
//	CW_FREE_OBJECT(INFO->WTP[0]->WTP_Radio[0]);
//	CW_FREE_OBJECT(INFO->WTP[0]);
//	CW_FREE_OBJECT(INFO->WTP);
//	CW_FREE_OBJECT(INFO);
	return CMD_SUCCESS;
}
DEFUN(show_wtp_eth_pkt_info_func,
	  show_wtp_eth_pkt_info_cmd,
	  "show wtp eth pkt information",
	  SHOW_STR
	  "wtp eth pkt information\n"
	  "wtp eth pkt information\n"
	  "wtp eth pkt information\n"
	  "wtp eth pkt information\n"
	 )
{	
	
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int WTPID = 0; 
	DCLI_WTP_API_GROUP_TWO *WTPINFO = NULL;
	//WTPID = (unsigned int)vty->index;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
//	char BUSNAME[PATH_LEN];
//	char OBJPATH[PATH_LEN];
//	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
#if 0	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SHOW_WTP_ETH_PKT_INFO);
		

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SHOW_WTP_ETH_PKT_INFO);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}

	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0)
	{	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.rx_unicast);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_unicast);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.rx_broadcast);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_broadcast);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.rx_pkt_unicast);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_pkt_unicast);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.rx_pkt_broadcast);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_pkt_broadcast);
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.retry);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.retry_pkt);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.err);

	}
	dbus_message_unref(reply);
#endif
	 WTPINFO = dcli_wtp_show_api_group_two(
		index,
		FIFTH,/*"show wtp eth pkt information"*/
		WTPID,
		0,
		0,
		&ret,/**/
		0,/*num2*/
		0,
		0,
		0,
		&localid,//num6
	//	WTPINFO,
		dcli_dbus_connection,
		WID_DBUS_WTP_METHOD_SHOW_WTP_ETH_PKT_INFO
		);
	//printf("##########ret is %d\n",ret);
	if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == 0){		
		vty_out(vty,"WTP[0]->WTP_Radio[0]->BSS[0]->BSS_pkt_info.tx_unicast)  is %llu.\n",(WTPINFO->WTP[0]->WTP_Radio[0]->BSS[0]->BSS_pkt_info.tx_unicast));
		vty_out(vty,"==============================================================================\n");
		vty_out(vty,"WTP %d bss packet infomation\n",WTPID);
		vty_out(vty,"WTP id:	%d\n",WTPID);
		vty_out(vty,"------------------------------------------------------------------------------\n");
		
			vty_out(vty,"rx_unicast:	%lld\n",WTPINFO->WTP[0]->WTP_Radio[0]->BSS[0]->BSS_pkt_info.rx_unicast);
			vty_out(vty,"tx_unicast:	%lld\n",WTPINFO->WTP[0]->WTP_Radio[0]->BSS[0]->BSS_pkt_info.tx_unicast);
			vty_out(vty,"rx_broadcast:	%lld\n",WTPINFO->WTP[0]->WTP_Radio[0]->BSS[0]->BSS_pkt_info.rx_broadcast);
			vty_out(vty,"tx_broadcast:	%lld\n",WTPINFO->WTP[0]->WTP_Radio[0]->BSS[0]->BSS_pkt_info.tx_broadcast);
			vty_out(vty,"rx_pkt_unicast:	%lld\n",WTPINFO->WTP[0]->WTP_Radio[0]->BSS[0]->BSS_pkt_info.rx_pkt_unicast);
			vty_out(vty,"tx_pkt_unicast:	%lld\n",WTPINFO->WTP[0]->WTP_Radio[0]->BSS[0]->BSS_pkt_info.tx_pkt_unicast);
			vty_out(vty,"rx_pkt_broadcast:	%lld\n",WTPINFO->WTP[0]->WTP_Radio[0]->BSS[0]->BSS_pkt_info.rx_pkt_broadcast);
			vty_out(vty,"tx_pkt_broadcast:	%lld\n",WTPINFO->WTP[0]->WTP_Radio[0]->BSS[0]->BSS_pkt_info.tx_pkt_broadcast);
			vty_out(vty,"retry:	%lld\n",WTPINFO->WTP[0]->WTP_Radio[0]->BSS[0]->BSS_pkt_info.retry);
			vty_out(vty,"retry_pkt:	%lld\n",WTPINFO->WTP[0]->WTP_Radio[0]->BSS[0]->BSS_pkt_info.retry_pkt);
			vty_out(vty,"err:	%lld\n",WTPINFO->WTP[0]->WTP_Radio[0]->BSS[0]->BSS_pkt_info.err);		
			vty_out(vty,"------------------------------------------------------------------------------\n");
		
		vty_out(vty,"==============================================================================\n");
	//	CW_FREE_OBJECT(WTPINFO->WTP[0]);
	//	CW_FREE_OBJECT(WTPINFO->WTP);

		dcli_wtp_free_fun_two(WID_DBUS_WTP_METHOD_SHOW_WTP_ETH_PKT_INFO,WTPINFO);
	}
	else if (ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
//	CW_FREE_OBJECT(WTPINFO);
	return CMD_SUCCESS;
}
DEFUN(show_wtp_wifi_snr_func,
	  show_wtp_wifi_snr_cmd,
	  "show wtp wifi snr info",
	  SHOW_STR
	  "wtp wifi snr information\n"
	  "wtp wifi snr information\n"
	  "wtp wifi snr information\n"
	  "wtp wifi snr information\n"
	 )
{	
	
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int WTPID = 0;
	int i = 0;
	//WID_wtp_wifi_snr_stats info;
	DCLI_WTP_API_GROUP_TWO *WTPINFO = NULL;
//	WTPINFO->WTP->wtp_wifi_snr_stats
	//WTPID = (unsigned int)vty->index;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
#if 0	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SHOW_WTP_WIFI_SNR_INFO);
		

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SHOW_WTP_WIFI_SNR_INFO);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}

	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0)
	{	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.ifindex);
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.snr_average);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.snr_max);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.snr_min);
	}
	dbus_message_unref(reply);
#endif
	 WTPINFO = dcli_wtp_show_api_group_two(
		index,
		SIXTH,/*"show wtp wifi snr info"*/
		WTPID,
		0,
		0,
		&ret,/**/
		0,/*num2*/
		0,
		0,
		0,
		&localid,//num6
	//	WTPINFO,
		dcli_dbus_connection,
		WID_DBUS_WTP_METHOD_SHOW_WTP_WIFI_SNR_INFO
		);
	//printf("##########ret is %d\n",ret);
	if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == 0){		
		vty_out(vty,"==============================================================================\n");
		vty_out(vty,"WTP %d wifi snr infomation\n",WTPID);
		vty_out(vty,"WTP id:	%d\n",WTPID);
		
		vty_out(vty,"wifi snr average:	%d\n",WTPINFO->WTP[0]->wtp_wifi_snr_stats.snr_average);
		vty_out(vty,"wifi snr max:	%d\n",WTPINFO->WTP[0]->wtp_wifi_snr_stats.snr_max);
		if(WTPINFO->WTP[0]->wtp_wifi_snr_stats.snr_min == 100)
		{
			vty_out(vty,"wifi snr min:	0\n");
		}
		else
		{
			vty_out(vty,"wifi snr min:	%d\n",WTPINFO->WTP[0]->wtp_wifi_snr_stats.snr_min);
		}
		vty_out(vty,"==============================================================================\n");
	//	CW_FREE_OBJECT(WTPINFO->WTP[0]);
	//	CW_FREE_OBJECT(WTPINFO->WTP);

		dcli_wtp_free_fun_two(WID_DBUS_WTP_METHOD_SHOW_WTP_WIFI_SNR_INFO,WTPINFO);
	}
	else if (ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else if (ret == SWITCH_IS_DISABLE)
		vty_out(vty,"<error> wtp wifi snr report switch is disable\n");
//	CW_FREE_OBJECT(WTPINFO);
	return CMD_SUCCESS;
}
DEFUN(show_wtp_radio_pkt_info_func,
	  show_wtp_radio_pkt_info_cmd,
	  "show wtp radio pkt information",
	  SHOW_STR
	  "wtp radio pkt information\n"
	  "wtp radio pkt information\n"
	  "wtp radio pkt information\n"
	  "wtp radio pkt information\n"
	 )
{	
	
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int WTPID = 0;
	unsigned char count = 0;
	
	int i = 0;

	//BSSStatistics radioinfo[L_RADIO_NUM];
	DCLI_WTP_API_GROUP_TWO *WTPINFO = NULL;
	
	//WTPID = (unsigned int)vty->index;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
/*	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];*/
	if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
#if 0	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SHOW_WTP_RADIO_PKT_INFO);
		

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SHOW_WTP_RADIO_PKT_INFO);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}

	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0)
	{	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&count);
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_recurse(&iter,&iter_array);
		
		for(i=0;i<count;i++)
		{	
			DBusMessageIter iter_struct;
			dbus_message_iter_recurse(&iter_array,&iter_struct);
				
			dbus_message_iter_get_basic(&iter_struct,&radioinfo[i].Radio_G_ID);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&radioinfo[i].rx_unicast);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&radioinfo[i].tx_unicast);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&radioinfo[i].rx_broadcast);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&radioinfo[i].tx_broadcast);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&radioinfo[i].rx_pkt_unicast);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&radioinfo[i].tx_pkt_unicast);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&radioinfo[i].rx_pkt_broadcast);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&radioinfo[i].tx_pkt_broadcast);
			
			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&radioinfo[i].retry);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&radioinfo[i].retry_pkt);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&radioinfo[i].err);

			dbus_message_iter_next(&iter_array);
		}
	}
	dbus_message_unref(reply);
#endif
	 WTPINFO = dcli_wtp_show_api_group_two(
		index,
		SEVENTH,/*"show wtp radio pkt information"*/
		WTPID,
		0,
		0,
		&ret,/**/
		0,/*num2*/
		0,
		0,
		0,
		&localid,//num6
		//WTPINFO,
		dcli_dbus_connection,
		WID_DBUS_WTP_METHOD_SHOW_WTP_RADIO_PKT_INFO
		);
	//printf("##########ret is %d\n",ret);
	if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == 0){		
		vty_out(vty,"==============================================================================\n");
		vty_out(vty,"WTP %d radio packet infomation\n",WTPID);
		vty_out(vty,"WTP id:	%d\n",WTPID);
		vty_out(vty,"Radio num:	%d\n",WTPINFO->WTP[0]->radio_num);
		vty_out(vty,"------------------------------------------------------------------------------\n");
		for(i=0;i<WTPINFO->WTP[0]->radio_num;i++)
		{
			vty_out(vty,"global radio id:	%d\n",WTPINFO->WTP[0]->WTP_Radio[i]->BSS[0]->BSS_pkt_info.Radio_G_ID);
			vty_out(vty,"local radio id:	%d\n",(WTPINFO->WTP[0]->WTP_Radio[i]->BSS[0]->BSS_pkt_info.Radio_G_ID)%L_RADIO_NUM);
			vty_out(vty,"rx_unicast:	%lld\n",WTPINFO->WTP[0]->WTP_Radio[i]->BSS[0]->BSS_pkt_info.rx_unicast);
			vty_out(vty,"tx_unicast:	%lld\n",WTPINFO->WTP[0]->WTP_Radio[i]->BSS[0]->BSS_pkt_info.tx_unicast);
			vty_out(vty,"rx_broadcast:	%lld\n",WTPINFO->WTP[0]->WTP_Radio[i]->BSS[0]->BSS_pkt_info.rx_broadcast);
			vty_out(vty,"tx_broadcast:	%lld\n",WTPINFO->WTP[0]->WTP_Radio[i]->BSS[0]->BSS_pkt_info.tx_broadcast);
			vty_out(vty,"rx_pkt_unicast:	%lld\n",WTPINFO->WTP[0]->WTP_Radio[i]->BSS[0]->BSS_pkt_info.rx_pkt_unicast);
			vty_out(vty,"tx_pkt_unicast:	%lld\n",WTPINFO->WTP[0]->WTP_Radio[i]->BSS[0]->BSS_pkt_info.tx_pkt_unicast);
			vty_out(vty,"rx_pkt_broadcast:	%lld\n",WTPINFO->WTP[0]->WTP_Radio[i]->BSS[0]->BSS_pkt_info.rx_pkt_broadcast);
			vty_out(vty,"tx_pkt_broadcast:	%lld\n",WTPINFO->WTP[0]->WTP_Radio[i]->BSS[0]->BSS_pkt_info.tx_pkt_broadcast);
			vty_out(vty,"retry:	%lld\n",WTPINFO->WTP[0]->WTP_Radio[i]->BSS[0]->BSS_pkt_info.retry);
			vty_out(vty,"retry_pkt:	%lld\n",WTPINFO->WTP[0]->WTP_Radio[i]->BSS[0]->BSS_pkt_info.retry_pkt);
			vty_out(vty,"err:	%lld\n",WTPINFO->WTP[0]->WTP_Radio[i]->BSS[0]->BSS_pkt_info.err);		
			vty_out(vty,"------------------------------------------------------------------------------\n");
		}
		vty_out(vty,"==============================================================================\n");

		dcli_wtp_free_fun_two(WID_DBUS_WTP_METHOD_SHOW_WTP_RADIO_PKT_INFO,WTPINFO);
	}
	else if (ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
/*	int j ;
	for(j=0;j<L_RADIO_NUM;j++){
		CW_FREE_OBJECT(WTPINFO->WTP[0]->WTP_Radio[j]->BSS[0]);
		CW_FREE_OBJECT(WTPINFO->WTP[0]->WTP_Radio[j]);
	}
	CW_FREE_OBJECT(WTPINFO->WTP[0]);
	CW_FREE_OBJECT(WTPINFO->WTP);
	CW_FREE_OBJECT(WTPINFO);*/
	return CMD_SUCCESS;
}

DEFUN(show_wtp_radio_pkt_info_tunnel_func,
	  show_wtp_radio_pkt_info_tunnel_cmd,
	  "show wtp tunnel radio pkt information",
	  SHOW_STR
	  "wtp tunnel radio pkt information\n"
	  "wtp tunnel radio pkt information\n"
	  "wtp tunnel radio pkt information\n"
	  "wtp tunnel radio pkt information\n"
	 )
{	
	
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int WTPID;
	unsigned char count = 0;
	
	int i = 0;

	BSSStatistics radioinfo[L_RADIO_NUM];
	for(i=0;i<L_RADIO_NUM;i++)
	{
		radioinfo[i].Radio_G_ID = 0;
		radioinfo[i].rx_unicast = 0;
		radioinfo[i].tx_unicast = 0;
		radioinfo[i].rx_broadcast = 0;
		radioinfo[i].tx_broadcast = 0;
		radioinfo[i].rx_pkt_unicast = 0;
		radioinfo[i].tx_pkt_unicast = 0;
		radioinfo[i].rx_pkt_broadcast = 0;
		radioinfo[i].tx_pkt_broadcast = 0;
		radioinfo[i].retry = 0;
		radioinfo[i].retry_pkt = 0;
		radioinfo[i].err = 0;
	}
	
	//WTPID = (unsigned int)vty->index;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SHOW_WTP_RADIO_PKT_INFO_TUNNEL);

	/*
	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SHOW_WTP_RADIO_PKT_INFO_TUNNEL);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}

	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0)
	{	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&count);
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_recurse(&iter,&iter_array);
		
		for(i=0;i<count;i++)
		{	
			DBusMessageIter iter_struct;
			dbus_message_iter_recurse(&iter_array,&iter_struct);
				
			dbus_message_iter_get_basic(&iter_struct,&radioinfo[i].Radio_G_ID);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&radioinfo[i].rx_unicast);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&radioinfo[i].tx_unicast);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&radioinfo[i].rx_broadcast);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&radioinfo[i].tx_broadcast);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&radioinfo[i].rx_pkt_unicast);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&radioinfo[i].tx_pkt_unicast);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&radioinfo[i].rx_pkt_broadcast);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&radioinfo[i].tx_pkt_broadcast);
			
			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&radioinfo[i].retry);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&radioinfo[i].retry_pkt);

			dbus_message_iter_next(&iter_struct);	
			dbus_message_iter_get_basic(&iter_struct,&radioinfo[i].err);

			dbus_message_iter_next(&iter_array);
		}
	}
	dbus_message_unref(reply);
	if(ret == 0){		
		vty_out(vty,"==============================================================================\n");
		vty_out(vty,"WTP %d radio packet infomation\n",WTPID);
		vty_out(vty,"WTP id:	%d\n",WTPID);
		vty_out(vty,"Radio num:	%d\n",count);
		vty_out(vty,"------------------------------------------------------------------------------\n");
		for(i=0;i<count;i++)
		{
			vty_out(vty,"global radio id:	%d\n",radioinfo[i].Radio_G_ID);
			vty_out(vty,"local radio id:	%d\n",(radioinfo[i].Radio_G_ID)%L_RADIO_NUM);
			vty_out(vty,"rx_unicast:	%lld\n",radioinfo[i].rx_unicast);
			vty_out(vty,"tx_unicast:	%lld\n",radioinfo[i].tx_unicast);
			vty_out(vty,"rx_broadcast:	%lld\n",radioinfo[i].rx_broadcast);
			vty_out(vty,"tx_broadcast:	%lld\n",radioinfo[i].tx_broadcast);
			vty_out(vty,"rx_pkt_unicast:	%lld\n",radioinfo[i].rx_pkt_unicast);
			vty_out(vty,"tx_pkt_unicast:	%lld\n",radioinfo[i].tx_pkt_unicast);
			vty_out(vty,"rx_pkt_broadcast:	%lld\n",radioinfo[i].rx_pkt_broadcast);
			vty_out(vty,"tx_pkt_broadcast:	%lld\n",radioinfo[i].tx_pkt_broadcast);
			vty_out(vty,"retry:	%lld\n",radioinfo[i].retry);
			vty_out(vty,"retry_pkt:	%lld\n",radioinfo[i].retry_pkt);
			vty_out(vty,"err:	%lld\n",radioinfo[i].err);		
			vty_out(vty,"------------------------------------------------------------------------------\n");
		}
		vty_out(vty,"==============================================================================\n");
	}
	else if (ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	return CMD_SUCCESS;
}
#if _GROUP_POLICY
DEFUN(set_ac_ap_ntp_func,
	  set_ac_ap_ntp_cmd,
	  "set ap ntp (start|stop) [interval]",
	  "AP config\n"
	  "ap ntp\n"
	  "ap ntp\n"
	 )
{
	int i = 0;
	int ret = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;


	unsigned int policy = 0;
	unsigned int ntpinterval = 0;
	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	if (!strcmp(argv[0],"start"))
	{
		policy = 0;	
	}
	else if (!strcmp(argv[0],"stop"))
	{
		policy = 1;	
	}
	else
	{
		vty_out(vty,"<error> input interface only with 'start' or 'stop'\n");
		return CMD_SUCCESS;
	}
	
	if (2 == argc) {
		ntpinterval = strtoul((char *)argv[1], NULL, 10);
		/*if (ntpinterval <= 0)
		{
			vty_out(vty,"%% Invalid ntp interval: %s !", argv[1]);
			return CMD_WARNING;
		}*/
		if (ntpinterval < 60 || ntpinterval > 65535)
		{
			vty_out(vty,"%% Invalid ntp interval: %s ! interval should be 60-65535!\n", argv[1]);
			return CMD_WARNING;
		}
	}
	
	WtpList_Head = set_ac_ap_ntp_cmd_set_ap_ntp(index,localid,dcli_dbus_connection,type,id,policy,ntpinterval,&count,&ret);
if(type==0)
{
	if(ret == 0)
	{
		vty_out(vty,"set ap ntp successfully\n");
	}
/*
	else if (ret == WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp is not in run state\n");
*/
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
}
if(type==1)
{
	if(ret == 0)
	{
		vty_out(vty,"group %d set ap ntp successfully\n",id);
		if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL))
		{
			vty_out(vty,"wtp ");					
			for(i=0; i<count; i++)
			{
				if(Wtp_Show_Node == NULL)
					Wtp_Show_Node = WtpList_Head->WtpList_list;
				else 
					Wtp_Show_Node = Wtp_Show_Node->next;
	
				if(Wtp_Show_Node == NULL)
					break;
						
				vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
			}
					
			vty_out(vty," failed.\n");
			dcli_free_WtpList(WtpList_Head);
		}
	}
else if (ret == GROUP_ID_NOT_EXIST)
	vty_out(vty,"<error> group id does not exist\n");
}
		
	return CMD_SUCCESS;		
}

#else
DEFUN(set_ac_ap_ntp_func,
	  set_ac_ap_ntp_cmd,
	  "set ap ntp (start|stop) [interval]",
	  "AP config\n"
	  "ap ntp\n"
	  "ap ntp\n"
	 )
{
	int ret = 0;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

	unsigned int wtp_id = 0;
	//wtp_id = (unsigned int)vty->index;
	 unsigned int policy = 0;
	unsigned int ntpinterval = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	if (!strcmp(argv[0],"start"))
	{
		policy = 0;	
	}
	else if (!strcmp(argv[0],"stop"))
	{
		policy = 1;	
	}
	else
	{
		vty_out(vty,"<error> input interface only with 'start' or 'stop'\n");
		return CMD_SUCCESS;
	}
	
	if (2 == argc) {
		ntpinterval = strtoul((char *)argv[1], NULL, 10);
		if (ntpinterval < 60 || ntpinterval > 65535)
		{
			vty_out(vty,"%% Invalid ntp interval: %s ! interval should be 60-65535!\n", argv[1]);
			return CMD_WARNING;
		}
	}
	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_NTPCLIENT);
		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_NTPCLIENT);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
						  	 DBUS_TYPE_UINT32,&policy,
						  	 DBUS_TYPE_UINT32,&ntpinterval,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"set ap ntp successfully\n");
	}
/*
	else if (ret == WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp is not in run state\n");
*/
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	return CMD_SUCCESS;		
}
#endif
#if _GROUP_POLICY
DEFUN(set_ap_config_update_func,
	  set_ap_config_update_cmd,
	  "set ap config update from ip IP",
	  "AP config\n"
	  "AP config\n"
	  "AP config\n"
	  "AP config update\n"
	  "tftp config file from server\n"
	  "file server ip addr\n"
	  "ip addr\n"
	 )
{
	int i = 0;
	int ret = 0;
	int ret2 = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	char *ip = NULL;


	ret2 = WID_Check_IP_Format((char *)argv[0]);
	if(ret2 != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown ip format\n");
		return CMD_SUCCESS;
	}
	
	ip = (char *)malloc(strlen(argv[0])+1);  
	memset(ip, 0, strlen(argv[0])+1);
	memcpy(ip, argv[0], strlen(argv[0]));
	
	if(vty->node == WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	WtpList_Head = set_ap_config_update_cmd_set_ap_config_update_from_ip(index,localid,dcli_dbus_connection,type,id,ip,&count,&ret);
if(type==0)
{
	if(ret == 0)
	{
		vty_out(vty,"set ap config update successfully\n");
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp is not in run state\n");
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
}
if(type==1)
{
	if(ret == 0)
	{
		vty_out(vty,"group %d set ap config update successfully\n",id);
		if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL))
		{
			vty_out(vty,"wtp ");					
			for(i=0; i<count; i++)
			{
				if(Wtp_Show_Node == NULL)
					Wtp_Show_Node = WtpList_Head->WtpList_list;
				else 
					Wtp_Show_Node = Wtp_Show_Node->next;
	
				if(Wtp_Show_Node == NULL)
					break;
						
				vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
			}
					
			vty_out(vty," failed.\n");
			dcli_free_WtpList(WtpList_Head);
		}
	}
else if (ret == GROUP_ID_NOT_EXIST)
	vty_out(vty,"<error> group id does not exist\n");
}
		
	free(ip);
	ip = NULL;
	return CMD_SUCCESS;		
}

#else
DEFUN(set_ap_config_update_func,
	  set_ap_config_update_cmd,
	  "set ap config update from ip IP",
	  "AP config\n"
	  "AP config\n"
	  "AP config\n"
	  "AP config update\n"
	  "tftp config file from server\n"
	  "file server ip addr\n"
	  "ip addr\n"
	 )
{
	int ret = 0;
	char *ip;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

	unsigned int wtp_id = 0;
	//wtp_id = (unsigned int)vty->index;
	
	
	ret = WID_Check_IP_Format((char *)argv[0]);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown ip format\n");
		return CMD_SUCCESS;
	}
	
	ip = (char *)malloc(strlen(argv[0])+1);  
	memset(ip, 0, strlen(argv[0])+1);
	memcpy(ip, argv[0], strlen(argv[0]));
	
	/*//printf("ip %s %s\n",argv[0],ip);*/
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_UPDATE_WTP_CONFIG);
		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_UPDATE_WTP_CONFIG);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_STRING,&ip,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		free(ip);
		ip = NULL;
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"set ap config update successfully\n");
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp is not in run state\n");
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);
	free(ip);
	ip = NULL;
	return CMD_SUCCESS;		
}
#endif
DEFUN(show_wtp_extension_information_v4_func,
	  show_wtp_extension_information_v4_cmd,
	  "show wtp cmt extension information v4",
	  SHOW_STR
	  "V4\n"
	  "wtp extension information\n"
	  "wtp extension information\n"
	  "wtp extension information\n"
	 )
{	
	
/*	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;*/
	unsigned int WTPID = 0;
	int ret = WID_DBUS_SUCCESS;
	//WTPID = (unsigned int)vty->index;
	int i = 0;
	//wid_wifi_info info;
	char en[] = "enable";
	char dis[] = "disable";
	char st[] = "static";
	char dh[] = "dhcp";
	DCLI_WTP_API_GROUP_TWO *WTPINFO = NULL;
/*	CW_CREATE_OBJECT_ERR(WTPINFO, DCLI_WTP_API_GROUP_TWO, return NULL;);	
	WTPINFO->WTP = NULL;	
	WTPINFO->WTP = (WID_WTP*)malloc(sizeof(WID_WTP*));
	WTPINFO->WTP[0] = (WID_WTP*)malloc(sizeof(WID_WTP));
	//WTPINFO->WTP[0]->wifi_extension_info

	{
		WTPINFO->WTP[0]->wifi_extension_info.reportswitch = 0;
		WTPINFO->WTP[0]->wifi_extension_info.reportinterval = 0;
		WTPINFO->WTP[0]->wifi_extension_info.cpu = 0;
		WTPINFO->WTP[0]->wifi_extension_info.tx_mgmt = 0;
		WTPINFO->WTP[0]->wifi_extension_info.rx_mgmt = 0;
		WTPINFO->WTP[0]->wifi_extension_info.tx_packets = 0;
		WTPINFO->WTP[0]->wifi_extension_info.tx_errors = 0;
		WTPINFO->WTP[0]->wifi_extension_info.tx_retry = 0;
		WTPINFO->WTP[0]->wifi_extension_info.ipmode = 0;
		WTPINFO->WTP[0]->wifi_extension_info.memoryall = 0;
		WTPINFO->WTP[0]->wifi_extension_info.memoryuse = 0;
		WTPINFO->WTP[0]->wifi_extension_info.flashall = 0;
		WTPINFO->WTP[0]->wifi_extension_info.flashempty = 0;
		WTPINFO->WTP[0]->wifi_extension_info.wifi_snr = 0;
		WTPINFO->WTP[0]->wifi_extension_info.eth_count = 0;
		WTPINFO->WTP[0]->wifi_extension_info.ath_count = 0;
		WTPINFO->WTP[0]->wifi_extension_info.temperature = 0;
		WTPINFO->WTP[0]->wifi_extension_info.wifi_count = 0;
		WTPINFO->WTP[0]->wifi_extension_info.tx_unicast = 0;
		WTPINFO->WTP[0]->wifi_extension_info.tx_broadcast = 0;
		WTPINFO->WTP[0]->wifi_extension_info.tx_multicast = 0;
		WTPINFO->WTP[0]->wifi_extension_info.rx_unicast = 0;
		WTPINFO->WTP[0]->wifi_extension_info.rx_broadcast = 0;
		WTPINFO->WTP[0]->wifi_extension_info.rx_multicast = 0;
		WTPINFO->WTP[0]->wifi_extension_info.tx_drop = 0;
		WTPINFO->WTP[0]->wifi_extension_info.rx_drop = 0;
		WTPINFO->WTP[0]->wifi_extension_info.wpi_replay_error = 0;
		WTPINFO->WTP[0]->wifi_extension_info.wpi_decryptable_error = 0;
		WTPINFO->WTP[0]->wifi_extension_info.wpi_mic_error = 0;
		WTPINFO->WTP[0]->wifi_extension_info.disassoc_unnormal = 0;
		WTPINFO->WTP[0]->wifi_extension_info.rx_assoc_norate = 0;
		WTPINFO->WTP[0]->wifi_extension_info.rx_assoc_capmismatch = 0;
		WTPINFO->WTP[0]->wifi_extension_info.assoc_invaild = 0;
		WTPINFO->WTP[0]->wifi_extension_info.reassoc_deny = 0;
		memset(WTPINFO->WTP[0]->wifi_extension_info.wifi_state,0,AP_WIFI_IF_NUM);
		memset(WTPINFO->WTP[0]->wifi_extension_info.eth_updown_time,0,AP_ETH_IF_NUM);
		memset(WTPINFO->WTP[0]->wifi_extension_info.ath_if_info,0,sizeof(wid_ap_ath_info)*AP_ATH_IF_NUM);
	}*/
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
#if 0	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_AP_SHOW_WTP_EXTENSION_INFOMATION_V4);
		

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_AP_SHOW_WTP_EXTENSION_INFOMATION_V4);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}

	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0)
	{	
	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.cpu);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_mgmt);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.rx_mgmt);
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_packets);
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_errors);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_retry);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.reportswitch);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.reportinterval);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.ipmode);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.memoryall);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.memoryuse);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.flashall);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.flashempty);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.wifi_snr);
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.eth_count);

		for(i=0;i<AP_ETH_IF_NUM;i++)
		{		
			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&info.eth_updown_time[i]);
		}

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.ath_count);

		for(i=0;i<info.ath_count;i++)
		{	
			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&info.ath_if_info[i].radioid);

			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&info.ath_if_info[i].wlanid);

			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&info.ath_if_info[i].ath_updown_times);
		}
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.temperature);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.wifi_count);

		for(i=0;i<AP_WIFI_IF_NUM;i++)
		{		
			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&info.wifi_state[i]);
		}

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_unicast);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_broadcast);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_multicast);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.tx_drop);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.rx_unicast);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.rx_broadcast);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.rx_multicast);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.rx_drop);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.wpi_replay_error);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.wpi_decryptable_error);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.wpi_mic_error);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.disassoc_unnormal);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.rx_broadcast);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.rx_assoc_capmismatch);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.assoc_invaild);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&info.reassoc_deny);
		
	}
	
	dbus_message_unref(reply);
#endif
	 WTPINFO = dcli_wtp_show_api_group_two(
		index,
		EIGHTH,/*"show wtp cmt extension information v4"*/
		WTPID,
		0,
		0,
		&ret,/**/
		0,/*num2*/
		0,
		0,
		0,
		&localid,//num6
	//	WTPINFO,
		dcli_dbus_connection,
		WID_DBUS_CONF_METHOD_AP_SHOW_WTP_EXTENSION_INFOMATION_V4
		);
	//printf("##########ret is %d\n",ret);
	if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == 0){		
		vty_out(vty,"==============================================================================\n");
		vty_out(vty,"WTP extension infomation\n");
		vty_out(vty,"WTPID:	%d\n",WTPID);
		vty_out(vty,"report switch:	%s\n",(WTPINFO->WTP[0]->wifi_extension_reportswitch == 1)?en:dis);
		vty_out(vty,"report interval:	%d s\n",WTPINFO->WTP[0]->wifi_extension_reportinterval);
		vty_out(vty,"cpu:	%0.2f %\n",WTPINFO->WTP[0]->wifi_extension_info.cpu/100.00);
		vty_out(vty,"temperature:	%d \n",WTPINFO->WTP[0]->wifi_extension_info.temperature);
		vty_out(vty,"IP mode:	%s\n",(WTPINFO->WTP[0]->wifi_extension_info.ipmode == 1)?dh:st);
		vty_out(vty,"memory total:	%d MB\n",WTPINFO->WTP[0]->wifi_extension_info.memoryall);
		vty_out(vty,"memory usage:	%d %\n",WTPINFO->WTP[0]->wifi_extension_info.memoryuse);
		vty_out(vty,"flash capacity:	%d MB\n",WTPINFO->WTP[0]->wifi_extension_info.flashall);
		vty_out(vty,"flash surplus capacity:	%d Kb\n",WTPINFO->WTP[0]->wifi_extension_info.flashempty);
		vty_out(vty,"wifi SNR:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.wifi_snr);
		vty_out(vty,"tx_mgmt:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.tx_mgmt);
		vty_out(vty,"rx_mgmt:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.rx_mgmt);
		vty_out(vty,"total_mgmt:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.rx_mgmt+WTPINFO->WTP[0]->wifi_extension_info.tx_mgmt);
		vty_out(vty,"tx_packets:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.tx_packets);
		vty_out(vty,"tx_errors:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.tx_errors);
		vty_out(vty,"tx_retry:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.tx_retry);
		vty_out(vty,"eth_count:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.eth_count);
		for(i=0;i<AP_ETH_IF_NUM;i++)
		{
			if(WTPINFO->WTP[0]->wifi_extension_info.eth_updown_time[i] != 0)
			{
				vty_out(vty,"eth%d updown time:	%d\n",i,WTPINFO->WTP[0]->wifi_extension_info.eth_updown_time[i]);
			}
		}
		vty_out(vty,"ath_count:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.ath_count);
		for(i=0;i<WTPINFO->WTP[0]->wifi_extension_info.ath_count;i++)
		{
			vty_out(vty,"wifi%d ath%d updown time:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.ath_if_info[i].radioid,WTPINFO->WTP[0]->wifi_extension_info.ath_if_info[i].wlanid,WTPINFO->WTP[0]->wifi_extension_info.ath_if_info[i].ath_updown_times);
		}
		vty_out(vty,"wifi_count:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.wifi_count);
		for(i=0;i<AP_WIFI_IF_NUM;i++)
		{
			if(WTPINFO->WTP[0]->wifi_extension_info.wifi_state[i] != 0)
			{
				if(WTPINFO->WTP[0]->wifi_extension_info.wifi_state[i] == 1)
				{
					vty_out(vty,"wifi%d state:	up\n",i);
				}
				else if(WTPINFO->WTP[0]->wifi_extension_info.wifi_state[i] == 2)
				{
					vty_out(vty,"wifi%d state:	down\n",i);
				}
				else if(WTPINFO->WTP[0]->wifi_extension_info.wifi_state[i] == 3)
				{
					vty_out(vty,"wifi%d state:	error\n",i);
				}
			}
		}
		vty_out(vty,"------------------------------------\n");
		vty_out(vty,"ethernet infomation:\n");
		vty_out(vty,"tx_unicast:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.tx_unicast);
		vty_out(vty,"tx_broadcast:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.tx_broadcast);
		vty_out(vty,"tx_multicast:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.tx_multicast);
		vty_out(vty,"tx_drop:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.tx_drop);
		vty_out(vty,"rx_unicast:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.rx_unicast);
		vty_out(vty,"rx_broadcast:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.rx_broadcast);
		vty_out(vty,"rx_multicast:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.rx_multicast);
		vty_out(vty,"rx_drop:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.rx_drop);
		vty_out(vty,"------------------------------------\n");
		vty_out(vty,"wapi infomation:\n");
		vty_out(vty,"wpi_replay_error:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.wpi_replay_error);
		vty_out(vty,"wpi_decryptable_error:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.wpi_decryptable_error);
		vty_out(vty,"tx_multicast:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.wpi_mic_error);
		vty_out(vty,"------------------------------------\n");
		vty_out(vty,"station assoc infomation:\n");
		vty_out(vty,"disassoc_unnormal:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.disassoc_unnormal);
		vty_out(vty,"rx_assoc_norate:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.rx_assoc_norate);
		vty_out(vty,"rx_assoc_capmismatch:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.rx_assoc_capmismatch);
		vty_out(vty,"assoc_invaild:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.assoc_invaild);
		vty_out(vty,"reassoc_deny:	%d\n",WTPINFO->WTP[0]->wifi_extension_info.reassoc_deny);
		vty_out(vty,"==============================================================================\n");

		dcli_wtp_free_fun_two(WID_DBUS_CONF_METHOD_AP_SHOW_WTP_EXTENSION_INFOMATION_V4,WTPINFO);
	}
	else if (ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else if (ret == SWITCH_IS_DISABLE)
		vty_out(vty,"<error> wtp extension info report switch disable\n");

/*	CW_FREE_OBJECT(WTPINFO->WTP[0]);	
	CW_FREE_OBJECT(WTPINFO->WTP);	
	CW_FREE_OBJECT(WTPINFO);*/
	return CMD_SUCCESS;
}
DEFUN(show_wtp_max_power_base_model_func,
	  show_wtp_max_power_base_model_cmd,
	  "show wtp max power",
	  SHOW_STR
	  "wtp information\n"
	  "wtp max power\n"
	  "wtp max power\n"
	 )
{	
	
/*	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;*/
	unsigned int WTPID = 0;
	int ret = WID_DBUS_SUCCESS;
	//WTPID = (unsigned int)vty->index;
	int i = 0;
	char *model = NULL;
	unsigned int txpower = 0;
	DCLI_WTP_API_GROUP_THREE *WTPINFO = NULL;
//	CW_CREATE_OBJECT_ERR(WTPINFO, DCLI_WTP_API_GROUP_THREE, return NULL;);	
//	WTPINFO->model = NULL;
//	WTPINFO->txpower = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}	
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
#if 0	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_AP_SHOW_WTP_MAX_POWER);
		

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_AP_SHOW_WTP_MAX_POWER);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}

	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0)
	{	
	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&model);

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&txpower);

	}
	
	dbus_message_unref(reply);
#endif
	 WTPINFO = dcli_wtp_show_api_group_three(
		index,
		SEVENTH,/*"show wtp max power"*/
		WTPID,
		0,
		0,
		&ret,/**/
		0,/*num2*/
		0,
		0,
		0,
		&localid,//num6
	//	WTPINFO,
		dcli_dbus_connection,
		WID_DBUS_CONF_METHOD_AP_SHOW_WTP_MAX_POWER
		);
	//printf("##########ret is %d\n",ret);
	if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == 0){		
		vty_out(vty,"==============================================================================\n");
		vty_out(vty,"WTP max txpower\n");
		vty_out(vty,"WTPID:	%d\n",WTPID);
		vty_out(vty,"Model:	%s\n",WTPINFO->model);
		vty_out(vty,"Max txpower:	%d\n",WTPINFO->txpower);
		vty_out(vty,"Max attenuate range:	%d\n",WTPINFO->txpower);
		vty_out(vty,"==============================================================================\n");
		dcli_wtp_free_fun_three(WID_DBUS_CONF_METHOD_AP_SHOW_WTP_MAX_POWER,WTPINFO);
	}
	else if (ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else if (ret == MODEL_NO_EXIST)
		vty_out(vty,"<error> wtp model is wrong\n");
//	CW_FREE_OBJECT(WTPINFO);
	return CMD_SUCCESS;
}

#if _GROUP_POLICY
DEFUN(set_ap_reboot_func,
	  set_ap_reboot_cmd,
	  "set ap reboot",
	  "AP config\n"
	  "ap reboot\n"
	  "ap reboot\n"
	 )
{
	int i = 0;
	int ret = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;


	if(vty->node == WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	WtpList_Head = set_ap_reboot_cmd_set_ap_reboot(index,localid,dcli_dbus_connection,type,id,&count,&ret);

if(type==0)
{
	if(ret == 0)
	{
		vty_out(vty,"set ap reboot successfully\n");
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp is not in run state\n");
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
}
if(type==1)
{
		if(ret == 0){
			vty_out(vty,"group %d set ap reboot successfully\n",id);
			if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL)){
				vty_out(vty,"wtp ");					
				for(i=0; i<count; i++){
					if(Wtp_Show_Node == NULL)
						Wtp_Show_Node = WtpList_Head->WtpList_list;
					else 
						Wtp_Show_Node = Wtp_Show_Node->next;

					if(Wtp_Show_Node == NULL)
						break;
					
					vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
				}
				
				vty_out(vty," failed.\n");
				dcli_free_WtpList(WtpList_Head);
			}
		}
		else if (ret == GROUP_ID_NOT_EXIST)
		   vty_out(vty,"<error> group id does not exist\n");
}
		
	return CMD_SUCCESS;		
}

#else
DEFUN(set_ap_reboot_func,
	  set_ap_reboot_cmd,
	  "set ap reboot",
	  "AP config\n"
	  "ap reboot\n"
	  "ap reboot\n"
	 )
{
	int ret = 0;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

	unsigned int wtp_id = 0;
	//wtp_id = (unsigned int)vty->index;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_REBOOT);
		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_REBOOT);*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"set ap reboot successfully\n");
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp is not in run state\n");
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	return CMD_SUCCESS;		
}
#endif
DEFUN(set_ap_reboot_all_func,
	  set_ap_reboot_all_cmd,
	  "set ap reboot all",
	  CONFIG_STR
	  "ap reboot\n"
	  "all ap reboot\n"
	  "all ap reboot\n"
	  "all ap reboot\n"
	 )
{
	int ret = 0;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);


	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_REBOOT_ALL);

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_REBOOT_ALL);*/
	
	dbus_error_init(&err);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"set ap all reboot successfully\n");
	}	
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	return CMD_SUCCESS;		
}
DEFUN(set_ap_reboot_by_wlanid_func,
	  set_ap_reboot_by_wlanid_cmd,
	  "set ap reboot by wlan ID",
	  CONFIG_STR
	  "ap reboot\n"
	  "ap reboot by wlan ID\n"
	  "ap reboot by wlan ID\n"
	  "ap reboot by wlan ID\n"
	  "ap reboot by wlan ID\n"
	 )
{
	int ret = 0;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wlanid = 0;
	ret = parse_int_ID((char*)argv[0], &wlanid);
	if(ret != WID_DBUS_SUCCESS){
			vty_out(vty,"<error> unknown id format\n");
			return CMD_SUCCESS;
	}	
	if(wlanid >= WLAN_NUM || wlanid == 0){
		vty_out(vty,"<error> input wlan id should be 1 to %d\n",WLAN_NUM-1);
		return CMD_SUCCESS;
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_REBOOT_BY_WLANID);

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_REBOOT_BY_WLANID);*/

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wlanid,
							 DBUS_TYPE_INVALID);
	
	dbus_error_init(&err);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"set ap reboot by wlanid %d successfully\n",wlanid);
	}
	else if(ret == WLAN_ID_NOT_EXIST)
		vty_out(vty,"<error> wlan id does not exist\n");
	else if (ret == WID_WANT_TO_DELETE_WLAN)		/* Huangleilei add for ASXXZFI-1622 */
	{
		vty_out(vty, "<warning> you want to some wlan, and the operation of the wlan was not successful\n");
	}
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	return CMD_SUCCESS;		
}
DEFUN(set_ap_reboot_by_interface_func,
	  set_ap_reboot_by_interface_cmd,
	  "set ap reboot by interface IFNAME",
	  CONFIG_STR
	  "ap reboot\n"
	  "ap reboot by interface IFNAME\n"
	  "ap reboot by interface IFNAME\n"
	  "ap reboot by interface IFNAME\n"
	  "ap reboot by interface IFNAME\n"
	 )
{
	int ret = 0;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

	char *ifname;
	int insize = 0;

	insize = strlen(argv[0]);
	if(insize > 16)
	{
		vty_out(vty,"<error> the length of input parameter %s is %d ,excel the limit of 16\n",argv[0],insize);
		return CMD_SUCCESS;	
	}
	
	ifname = (char*)malloc(strlen(argv[0])+1);
	memset(ifname, 0, strlen(argv[0])+1);
	memcpy(ifname, argv[0], strlen(argv[0]));	
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_REBOOT_BY_INTERFACE);

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_REBOOT_BY_INTERFACE);*/

	dbus_message_append_args(query,
							 DBUS_TYPE_STRING,&ifname,
							 DBUS_TYPE_INVALID);
	
	dbus_error_init(&err);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	if(ifname)
	{
		free(ifname);
		ifname = NULL;
	}
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"set ap reboot by interface %s successfully\n",argv[0]);
	}
	else if(ret == APPLY_IF_FAIL)
		vty_out(vty,"<error> interface %s error\n",argv[0]);
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	return CMD_SUCCESS;		
}
DEFUN(set_ap_reboot_by_model_func,
	  set_ap_reboot_by_model_cmd,
	  "set ap reboot by model MODEL.",
	  CONFIG_STR
	  "ap reboot\n"
	  "ap reboot by model MODEL\n"
	  "ap reboot by model MODEL\n"
	  "ap reboot by model MODEL\n"
	  "ap reboot by model MODEL\n"
	 )
{
	int ret = 0;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

	unsigned char* model;
	
	if (argc > 0)
	{
    	model = WID_parse_ap_extension_command(argv, argc);
 	}
	else
	{
    	model = NULL;
	}
	if(!model) 
	{
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}
	if(strlen(model) > 80)
	{
		if(model)
		{
			free(model);
			model = NULL;
		}
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_REBOOT_BY_MODEL);

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_REBOOT_BY_MODEL);*/

	dbus_message_append_args(query,
							 DBUS_TYPE_STRING,&model,
							 DBUS_TYPE_INVALID);
	
	dbus_error_init(&err);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		if(model)
		{
			free(model);
			model = NULL;
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"set ap reboot by model %s successfully\n",model);
	}
	else if(ret == MODEL_NO_EXIST)
		vty_out(vty,"<error> model %s is not exist\n",model);
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
	if(model)
	{
		free(model);
		model = NULL;
	}	
	dbus_message_unref(reply);

	return CMD_SUCCESS;		
}
DEFUN(set_ap_reboot_by_list_func,
	  set_ap_reboot_by_list_cmd,
	  "set ap reboot by list LIST",
	  CONFIG_STR
	  "ap reboot\n"
	  "ap reboot by list LIST\n"
	  "ap reboot by list LIST\n"
	  "ap reboot by list LIST\n"
	  "ap reboot by list LIST\n"
	 )
{
	int ret = 0;
	int i = 0;
	int n,num;
	int len;
	int list[4096];
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusMessageIter iter_array;
	DBusError err;
	memset(list, 0, sizeof(list));

	len = strlen(argv[0]);
	if(len > 80)
	{
		vty_out(vty,"<error> input wtp id is too long,you should input less than 80 letters\n");
		return CMD_SUCCESS;
	}
	/*get wtp id list*/
	ret = dcli_wtp_parse_wtp_list((char*)argv[0],&n,list); 
	//qiuchen add to fix it
	if(ret != 0){
		 cli_syslog_info("parse wtp list failed\n");
	    return CMD_SUCCESS;
	} 
	/*parse if there is repeat wtpid*/
	num = dcli_wtp_remove_list_repeat(list,n);
	
	dbus_error_init(&err);
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_REBOOT_BY_LIST);

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_REBOOT_BY_LIST);*/

	
	dbus_message_iter_init_append (query, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&num);

	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);
	
	for(i = 0; i < num ; i++){			
		DBusMessageIter iter_struct;		/* Huangleilei add it by AXSSZFI-1621: dbus may be not accept more than 255 elements, as string add to it */
		dbus_message_iter_open_container(&iter_array, DBUS_TYPE_STRUCT,NULL, &iter_struct);
		dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT32, &list[i]);
		dbus_message_iter_close_container (&iter_array, &iter_struct);
	}
	
	dbus_message_iter_close_container (&iter, &iter_array);
	#if 0
	for(i = 0; i < num; i++)
	{			
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&list[i]);		
	}
	#endif

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"set ap reboot list %s successfully\n",argv[0]);
	}
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	return CMD_SUCCESS;		
}


DEFUN(	wtp_set_ap_update_config_cmd_func,
			wtp_set_ap_update_config,
			"set ap update path PATH count_onetime <1-50> based .MODEL&VERSION",
			"set version name\n" 
			"version name value\n"
			"set ap version path\n"
			"version path value\n"
			"count_onetime \n"
			"count_onetime value\n"
			"model and version like: AQ2010 version v_1.1.9\n"
			"set ap update path AW1.1.9.img AQ2010 version v_1.1.9\n"
	 )
{
	int ret;
	DBusMessage *query, *reply;	
	DBusMessageIter  iter;
	DBusError err;

	char *buf_model;
	char *buf_version;
	char *buf_path;
	int fd;

	unsigned char count_onetime;
	
	buf_model = WID_parse_CMD_str(&argv[2],argc-2,"version",1);	
	if(buf_model == NULL){		
		vty_out(vty,"UNKNOWN COMMAND\n");
		vty_out(vty,"COMMAND should be :set ap update path AW1.1.9.img based AQ2010 version v1.1.9\n");
		return CMD_SUCCESS;
	}
	str2higher(&buf_model);
	buf_version = WID_parse_CMD_str(&argv[2],argc-2,"version",0);
	if(buf_version == NULL){		
		free(buf_model);
		vty_out(vty,"UNKNOWN COMMAND\n");		
		vty_out(vty,"COMMAND should be :set ap update path AW1.1.9.img based AQ2010 version v1.1.9\n");
		return CMD_SUCCESS;
	}
	
	buf_path = (char*)malloc(strlen(argv[0])+1);
	memset(buf_path, 0, strlen(argv[0])+1);
	memcpy(buf_path, argv[0], strlen(argv[0]));	

	
	char syscmd[WID_SYSTEM_CMD_LENTH];
	memset(syscmd,0,WID_SYSTEM_CMD_LENTH);
	sprintf(syscmd,"/mnt/wtp/%s",buf_path);

	fd = open(syscmd, O_RDONLY);
	if(fd < 0)
	{
		vty_out(vty, "%% set update failed due to system cann't find file\n");
		free(buf_model);

		free(buf_path);
		free(buf_version);

		return CMD_WARNING;
	}
	else 
	{
		close(fd);
	}	

	if(strstr(buf_path,buf_version) == NULL)
	{
		vty_out(vty, "%% set update failed due to file version error\n");
		free(buf_model);

		free(buf_path);
		free(buf_version);
		return CMD_WARNING;
	}

	count_onetime = atoi(argv[1]);
	
	dbus_error_init(&err);
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_UPDATE_PATH);

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_UPDATE_PATH);*/
	
	dbus_message_append_args(query,
						DBUS_TYPE_STRING,&buf_model,
						DBUS_TYPE_STRING,&buf_version,
						DBUS_TYPE_STRING,&buf_path,
						DBUS_TYPE_BYTE,&count_onetime,
						DBUS_TYPE_INVALID);
	
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);

	dbus_message_unref(query);

	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		free(buf_model);
		free(buf_path);
		free(buf_version);
		return CMD_SUCCESS;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		vty_out(vty,"wireless-control set ap update model<%s> version<%s> image path<%s> successfully\n",buf_model,buf_version,buf_path);
	else if(ret == WID_NO_SURPORT_MODEL)
		vty_out(vty,"<error> wireless-control does not surport model %s\n",buf_model);
	else if(ret == UPDATE_PROCESS)
		vty_out(vty,"<error> update is process,please wait several minutes\n");
	else
		vty_out(vty,"<error>  %d\n",ret);
	
	dbus_message_unref(reply);	
	
	free(buf_model);

	free(buf_path);
	free(buf_version);
	return CMD_SUCCESS; 

}


DEFUN(wtp_show_ap_update_config_func,
	  wtp_show_ap_update_config,
	  "show update config",
	   "show update config information\n"
	  "show update config information\n"
	  "update config information\n"

	 )
{
/*	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;	*/	
	DCLI_WTP_API_GROUP_THREE *WTPINFO = NULL;
	DCLI_WTP_API_GROUP_THREE *phead = NULL;
/*	CW_CREATE_OBJECT_ERR(WTPINFO, DCLI_WTP_API_GROUP_THREE, return NULL;);	
	WTPINFO->model = NULL;
	WTPINFO->apcode = NULL;
	WTPINFO->versionname = NULL;
	WTPINFO->versionpath = NULL;*/

	int i=0,ret=0,num=0;
	int j=0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
#if 0	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SHOW_UPDATE_CONFIG);

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_UPDATE_CONFIG);*/

	
	dbus_error_init(&err);	
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) 
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}

	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	char *apmodel = NULL;
	char *versionname = NULL;
	char *versionpath = NULL;
	char *apcode = NULL;
	unsigned char Count_onetimeupdt;

	if(ret == 0 )
	{	

		vty_out(vty,"AC update config information\n");

	    vty_out(vty,"==============================================================================\n");
		vty_out(vty,"%-8s %-7s %-18s %-17s\n","Model","Ver_num","Ver_path","Count_onetimeupdt");

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(apmodel));	
				
		dbus_message_iter_next(&iter);
		dbus_message_iter_get_basic(&iter,&(versionname));
	
		dbus_message_iter_next(&iter);		
		dbus_message_iter_get_basic(&iter,&(versionpath));
		
		dbus_message_iter_next(&iter);		
		dbus_message_iter_get_basic(&iter,&Count_onetimeupdt);	

		
		vty_out(vty,"%-8s %-7s %-18s %-7d\n",apmodel,versionname,versionpath,Count_onetimeupdt);
		vty_out(vty,"==============================================================================\n");

		
	}
	else
	{
		vty_out(vty,"no update config information\n");
	}

	dbus_message_unref(reply);	
#endif
	 WTPINFO = dcli_wtp_show_api_group_three(
		index,
		EIGHTH,/*"show update config"*/
		0,
		0,
		0,
		&ret,/**/
		0,/*num2*/
		0,
		0,
		0,
		&localid,//num6
	//	WTPINFO,
		dcli_dbus_connection,
		WID_DBUS_CONF_METHOD_SHOW_UPDATE_CONFIG
		);
	//printf("##########ret is %d\n",ret);
	if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == 0){		

		vty_out(vty,"AC update config information\n");

	    vty_out(vty,"==============================================================================\n");
		vty_out(vty,"%-8s %-7s %-18s %-17s\n","Model","Ver_num","Ver_path","Count_onetimeupdt");
		phead = WTPINFO;
		while(phead != NULL){
			vty_out(vty,"%-8s %-7s %-18s %-7d\n",phead->model,phead->versionname,phead->versionpath,phead->Count_onetimeupdt);
			phead = phead->next;
		}
		vty_out(vty,"==============================================================================\n");

		dcli_wtp_free_ap_update_config_fun(WTPINFO);
	}
	else
	{
		vty_out(vty,"no update config information\n");
	}
//	CW_FREE_OBJECT(WTPINFO);
	return CMD_SUCCESS;

}

DEFUN(wtp_clear_ap_update_config_func,
	  wtp_clear_ap_update_config,
	  "clear update config",
	   "clear update config information\n"
	  "clear update config information\n"
	  "clear config information\n"

	 )
{
	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;		

	int i=0,ret=0,num=0;
	int j=0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_CLEAR_UPDATE_CONFIG);

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_CLEAR_UPDATE_CONFIG);*/

	
	dbus_error_init(&err);	
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) 
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}

	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0 )
	{	

		vty_out(vty,"Clear update config information success\n");
	}
	else if(ret == UPDATE_PROCESS)
	{
		vty_out(vty,"upgrade is in process,changement of configuration is not allowed now\n");
	}
	else
	{
		vty_out(vty,"no update config information\n");
	}

	dbus_message_unref(reply);	

	return CMD_SUCCESS;

}

/*mahz add for ap upgrade automatically*/
DEFUN(	bind_ap_model_with_file_config_cmd_func,
			bind_ap_model_with_file_config,
			"bind model MODEL version_file TAR_FILE together",
			"MODEL is the model of ap which is going to be upgraded\n" 
			"TAR_FILE is the file to be binded with\n"
			"model like: AQ2010\n"
			"bind model AQ2010 version_file AQ2010.tar.bz2 together\n"
	 )
{
	int ret;
	DBusMessage *query, *reply;	
	DBusMessageIter  iter;
	DBusError err;

	char *buf_model;
	char *buf_name;
	int fd;

	buf_model = (char*)malloc(strlen(argv[0])+1);
	if(buf_model == NULL){		
		vty_out(vty,"buf malloc failed\n");
		return CMD_SUCCESS;
	}
	memset(buf_model, 0, strlen(argv[0])+1);
	memcpy(buf_model, argv[0], strlen(argv[0]));
	str2higher(&buf_model);

	buf_name = (char*)malloc(strlen(argv[1])+1);
	if(buf_name == NULL){		
		vty_out(vty,"buf malloc failed\n");
		if(buf_model){
			free(buf_model);
			buf_model = NULL;
		}
		return CMD_SUCCESS;
	}
	memset(buf_name, 0, strlen(argv[1])+1);
	memcpy(buf_name, argv[1], strlen(argv[1]));

	char syscmd[WID_SYSTEM_CMD_LENTH];
	memset(syscmd,0,WID_SYSTEM_CMD_LENTH);
	sprintf(syscmd,"/mnt/wtp/%s",buf_name);

	fd = open(syscmd, O_RDONLY);
	if(fd < 0){
		vty_out(vty, "bind failed due to system cann't find file %s\n",buf_name);
		free(buf_model);
		free(buf_name);
		return CMD_WARNING;
	}
	else{
		close(fd);
	}

	dbus_error_init(&err);
	
	int index = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_BIND_MODEL_WITH_FILE);

	dbus_message_append_args(query,
						DBUS_TYPE_STRING,&buf_model,
						DBUS_TYPE_STRING,&buf_name,
						DBUS_TYPE_INVALID);
	
	vty_out(vty,"bind operation  running.......\n");
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,300000, &err);

	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		free(buf_model);
		free(buf_name);
		return CMD_SUCCESS;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		vty_out(vty,"wireless-control bind model <%s> with file <%s> successfully\n",buf_model,buf_name);
	else if(ret == MODEL_NO_EXIST)
		vty_out(vty,"<error> wireless-control does not surport model %s\n",buf_model);
	else if(ret == UPDATE_PROCESS)
		vty_out(vty,"<error> update is process,please wait several minutes\n");
	else if(ret == MALLOC_ERROR)
		vty_out(vty,"<error> free memory is not enough\n");
	else if(ret == MODEL_BIND_EVER)
		vty_out(vty,"<error> this model has been bound ever,please delete the bind relationship first\n");
	else
		vty_out(vty,"<error>  %d\n",ret);
	
	dbus_message_unref(reply);	
	
	free(buf_model);
	free(buf_name);
	
	return CMD_SUCCESS; 
}

DEFUN(	wtp_set_ap_update_base_model_config_cmd_func,
			wtp_set_ap_update_base_model_config,
			"set ap update base model MODEL",
			"model like: AQ2010\n"
	 )
{
	int ret;
	DBusMessage *query, *reply;	
	DBusMessageIter  iter;
	DBusError err;

	char *buf_model = NULL;
	int fd;

	buf_model = (char*)malloc(strlen(argv[0])+1);
	if(buf_model == NULL){		
		vty_out(vty,"malloc failed\n");
		return CMD_SUCCESS;
	}
	memset(buf_model, 0, strlen(argv[0])+1);
	memcpy(buf_model, argv[0], strlen(argv[0]));	
	str2higher(&buf_model);

	dbus_error_init(&err);
	
	int index = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_AP_UPDATE_BASE_MODEL);
	
	dbus_message_append_args(query,
						DBUS_TYPE_STRING,&buf_model,
						DBUS_TYPE_INVALID);
	
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);

	dbus_message_unref(query);

	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		free(buf_model);
		return CMD_SUCCESS;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		vty_out(vty,"wireless-control set ap update base model <%s> successfully\n",argv[0]);
	else if(ret == WID_NO_SURPORT_MODEL)
		vty_out(vty,"<error> wireless-control does not surport model %s\n",argv[0]);
	else if(ret == MODEL_BIND_EVER)
		vty_out(vty,"<error> model %s has been set ever, there's no need to set again\n",argv[0]);
	else if(ret == UPDATE_PROCESS)
		vty_out(vty,"<error> update is process,please wait several minutes\n");
	else
		vty_out(vty,"<error>  %d\n",ret);
	
	dbus_message_unref(reply);	

	free(buf_model);

	return CMD_SUCCESS; 
}

DEFUN(	show_model_tar_file_bind_info_cmd_func,
			show_model_tar_file_bind_info,
			"show model tar_file bind info",
			"all bind info\n"
	 )
{
	int ret;
	int i=0,j=0,num=0;
	DBusMessage *query, *reply;	
	DBusMessageIter  iter;
	DBusMessageIter	 iter_array;		
	DBusError err;

	dbus_error_init(&err);
	
	int index = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SHOW_MODEL_BIND_INFO);
	
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);

	dbus_message_unref(query);

	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	char *apmodel = NULL;
	char *filename = NULL;

	vty_out(vty,"AC model bind list summary\n");

	vty_out(vty,"==============================================================================\n");
	vty_out(vty,"%-25s  %-15s\n","Model","Bind_file");
	if(ret == 0 ){
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&num);
	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_recurse(&iter,&iter_array);

		for (i = 0; i < num; i++) {
			DBusMessageIter iter_struct;
			
			dbus_message_iter_recurse(&iter_array,&iter_struct);
			dbus_message_iter_get_basic(&iter_struct,&(apmodel));	
			
			dbus_message_iter_next(&iter_struct);
			dbus_message_iter_get_basic(&iter_struct,&(filename));
				
			dbus_message_iter_next(&iter_array);
			
			vty_out(vty,"%-25s %-15s\n",apmodel,filename);
		}
	}
	else
		vty_out(vty,"<error>  %d\n",ret);
	
	dbus_message_unref(reply);	

	return CMD_SUCCESS; 
}

DEFUN(	delete_model_bind_info_config_cmd_func,
			delete_model_bind_info_config,
			"delete model MODEL bind info",
			"MODEL is the model of ap which has already been upgraded\n" 
			"model like: AQ2010\n"
	 )
{
	int ret;
	DBusMessage *query, *reply;	
	DBusMessageIter  iter;
	DBusError err;

	char *buf_model;

	buf_model = (char*)malloc(strlen(argv[0])+1);
	if(buf_model == NULL){		
		vty_out(vty,"buf malloc failed\n");
		return CMD_SUCCESS;
	}
	memset(buf_model, 0, strlen(argv[0])+1);
	memcpy(buf_model, argv[0], strlen(argv[0]));
	str2higher(&buf_model);

	dbus_error_init(&err);
	
	int index = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_DELETE_MODEL_BIND_INFO);

	dbus_message_append_args(query,
						DBUS_TYPE_STRING,&buf_model,
						DBUS_TYPE_INVALID);
	
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);

	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		free(buf_model);
		return CMD_SUCCESS;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		vty_out(vty,"wireless-control delete model <%s> bind info successfully\n",buf_model);
	else if(ret == MODEL_NO_EXIST)
		vty_out(vty,"<error> wireless-control does not surport model %s\n",buf_model);
	else if(ret == UPDATE_PROCESS)
		vty_out(vty,"<error> update is process,please wait several minutes\n");
	else if(ret == MODEL_BIND_NEVER)
		vty_out(vty,"<error> this model hasn't been bound ever,please make sure that first\n");
	else
		vty_out(vty,"<error>  %d\n",ret);
	
	dbus_message_unref(reply);	
	
	free(buf_model);
	
	return CMD_SUCCESS; 
}

DEFUN(wtp_clear_ap_one_model_update_config_func,
	  wtp_clear_ap_one_model_update_config,
	  "clear model MODEL update config",
	  "clear update config information of specified\n"
	  "clear update config information of specified\n"
	 )
{
	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;		

	int i=0,ret=0,num=0;
	int j=0;
	
	char *buf_model;

	buf_model = (char*)malloc(strlen(argv[0])+1);
	if(buf_model == NULL){		
		vty_out(vty,"buf malloc failed\n");
		return CMD_SUCCESS;
	}
	memset(buf_model, 0, strlen(argv[0])+1);
	memcpy(buf_model, argv[0], strlen(argv[0]));
	str2higher(&buf_model);

	dbus_error_init(&err);	
	int index = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_CLEAR_ONE_MODEL_UPDATE_CONFIG);

	dbus_message_append_args(query,
						DBUS_TYPE_STRING,&buf_model,
						DBUS_TYPE_INVALID);
	
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) 
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}

	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0 ){	
		vty_out(vty,"Clear model %s update config information success\n",argv[0]);
	}
	else if(ret == UPDATE_PROCESS){
		vty_out(vty,"upgrade is in process,changement of configuration is not allowed now\n");
	}
	else{
		vty_out(vty,"no update config information of model %s\n",argv[0]);
	}

	dbus_message_unref(reply);	

	return CMD_SUCCESS;

}

DEFUN(	show_detail_model_tar_file_bind_info_cmd_func,
			show_detail_model_tar_file_bind_info,
			"show detail model tar_file bind info",
			"all bind info\n"
	 )
{
	int ret;
	int i=0,j=0,num=0;
	DBusMessage *query, *reply;	
	DBusMessageIter  iter;
	DBusMessageIter	 iter_array;		
	DBusError err;

	dbus_error_init(&err);
	
	int index = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SHOW_DETAIL_MODEL_BIND_INFO);
	
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);

	dbus_message_unref(query);

	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	char *apmodel = NULL;
	char *apcode = NULL;
	char *apcodever = NULL;
	char *apcodepath = NULL;
	unsigned char code_num;

	vty_out(vty,"AC model bind list summary\n");

	vty_out(vty,"==============================================================================\n");
	vty_out(vty,"%s	%s	%s	%s\n","Model","APCode","APCodeVer","APCodePath");
	if(ret == 0 ){
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&num);
	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_recurse(&iter,&iter_array);

		for (i = 0; i < num; i++) {
			DBusMessageIter iter_struct;
			DBusMessageIter iter_sub_array;
			
			dbus_message_iter_recurse(&iter_array,&iter_struct);
			dbus_message_iter_get_basic(&iter_struct,&(code_num));	
			
			dbus_message_iter_next(&iter_struct);
			dbus_message_iter_recurse(&iter_struct,&iter_sub_array);
				
			for (j = 0; j < code_num; j++) {
				DBusMessageIter iter_sub_struct;
				
				dbus_message_iter_recurse(&iter_sub_array,&iter_sub_struct);
				dbus_message_iter_get_basic(&iter_sub_struct,&(apmodel));
				
				dbus_message_iter_next(&iter_sub_struct);	
				dbus_message_iter_get_basic(&iter_sub_struct,&apcode);

				dbus_message_iter_next(&iter_sub_struct);	
				dbus_message_iter_get_basic(&iter_sub_struct,&apcodever);

				dbus_message_iter_next(&iter_sub_struct);	
				dbus_message_iter_get_basic(&iter_sub_struct,&apcodepath);
				
				vty_out(vty,"%s	%s	%s	%s\n",apmodel,apcode,apcodever,apcodepath);

				dbus_message_iter_next(&iter_sub_array);
			}
			dbus_message_iter_next(&iter_array);
		}
	}
	else
		vty_out(vty,"<error>  %d\n",ret);
	
	dbus_message_unref(reply);	

	return CMD_SUCCESS; 
}

DEFUN(	wtp_set_ap_update_count_config_cmd_func,
			wtp_set_ap_update_count_config,
			"set ap update count_onetime <1-50>",
			"count_onetime \n"
			"count_onetime value\n"
	 )
{
	int ret;
	DBusMessage *query, *reply;	
	DBusMessageIter  iter;
	DBusError err;

	unsigned char count_onetime;
	ret = wid_wtp_parse_char_ID((char*)argv[0], &count_onetime);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown id format\n");
		return CMD_SUCCESS;
	}
	
	dbus_error_init(&err);
	
	int index = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_AP_UPDATE_COUNT_ONETIME);
	
	dbus_message_append_args(query,
						DBUS_TYPE_BYTE,&count_onetime,
						DBUS_TYPE_INVALID);
	
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);

	dbus_message_unref(query);

	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		vty_out(vty,"wireless-control set ap update count_onetime %s successfully\n",argv[0]);
	else if(ret == UPDATE_PROCESS)
		vty_out(vty,"upgrade has already started,it's not allowed to set the value unless upgrade is stopped\n");
	else
		vty_out(vty,"<error>  %d\n",ret);
	
	dbus_message_unref(reply);	

	return CMD_SUCCESS; 
}

DEFUN(	wtp_set_ap_update_control_config_cmd_func,
			wtp_set_ap_update_control_config,
			"set ap update batchlly (start|stop)",
			"start upgrade\n"
			"stop upgrade\n"
	 )
{
	int ret;
	DBusMessage *query, *reply;	
	DBusMessageIter  iter;
	DBusError err;
	unsigned char policy = 0;

	if (!strcmp(argv[0],"start"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[0],"stop"))
	{
		policy = 2;	
	}
	else
	{
		vty_out(vty,"<error> input parameter can only be 'start' or 'stop'\n");
		return CMD_SUCCESS;
	}

	dbus_error_init(&err);
	
	int index = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_AP_UPDATE_CONTROL);
	
	dbus_message_append_args(query,
						DBUS_TYPE_BYTE,&policy,
						DBUS_TYPE_INVALID);
	
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);

	dbus_message_unref(query);

	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		vty_out(vty,"wireless-control set ap update %s successfully\n",argv[0]);
	else if(ret == WID_NO_SURPORT_MODEL)
		vty_out(vty,"there's no upgrade configuration,it should be configured first\n");
	else
		vty_out(vty,"<error>  %d\n",ret);
	
	dbus_message_unref(reply);	

	return CMD_SUCCESS; 
}

DEFUN(	show_ap_upgrade_result_info_cmd_func,
			show_ap_upgrade_result_info,
			"show ap upgrade batchlly info",
			"ap upgrade result info\n"
	 )
{
	int ret;
	int i=0,j=0;
	int num_succ=0,num_fail=0,num_other=0;
	char* wtpip = NULL;
	char* wtpmodel = NULL;
	char ip[WTP_WTP_IP_LEN+1];
	unsigned int result = 0;
	DBusMessage *query, *reply;	
	DBusMessageIter  iter;
	DBusMessageIter	 iter_array;		
	DBusError err;

	dbus_error_init(&err);
	
	int index = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SHOW_AP_UPGRADE_RESULT_INFO);
	
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);

	dbus_message_unref(query);

	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	char *apmodel = NULL;
	char *apcode = NULL;
	char *apcodever = NULL;
	char *apcodepath = NULL;
	unsigned char code_num;

	vty_out(vty,"wtp list summary:\n"); 
	vty_out(vty,"==============================================================================\n");
	if(ret == 0 ){
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&num_succ);
	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&num_fail);
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&num_other);
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_recurse(&iter,&iter_array);

		vty_out(vty,"----------------------------------------------------------------------\n");
		vty_out(vty,"this is the ap upgrade successfully\n");
		vty_out(vty,"%-5s %-17s %-21s %-10s\n","WTPID","WTPMAC","WTPIP","WTPModel");
		vty_out(vty,"----------------------------------------------------------------------\n");
		for (i = 0; i < num_succ; i++) {
			
			WID_WTP *WTPINFO = NULL;
			WTPINFO =  (WID_WTP*)malloc(sizeof(WID_WTP));
			if(WTPINFO == NULL){		
				vty_out(vty,"WTPINFO malloc failed\n");
				return CMD_SUCCESS;
			}
			memset(WTPINFO, 0, sizeof(WID_WTP));
			
			WTPINFO->WTPMAC = (unsigned char *)malloc(MAC_LEN +1);
			if(WTPINFO->WTPMAC == NULL){		
				vty_out(vty,"WTPINFO->WTPMAC malloc failed\n");
				if(WTPINFO){
					free(WTPINFO);
					WTPINFO = NULL;
				}
				return CMD_SUCCESS;
			}
			memset(WTPINFO->WTPMAC,0,(MAC_LEN +1));
			
			DBusMessageIter iter_struct;
			dbus_message_iter_recurse(&iter_array,&iter_struct);
			dbus_message_iter_get_basic(&iter_struct,&(WTPINFO->WTPID));

			dbus_message_iter_next(&iter_struct);			
			dbus_message_iter_get_basic(&iter_struct,&WTPINFO->WTPMAC[0]);
			dbus_message_iter_next(&iter_struct);
			dbus_message_iter_get_basic(&iter_struct,&WTPINFO->WTPMAC[1]);
			dbus_message_iter_next(&iter_struct);		
			dbus_message_iter_get_basic(&iter_struct,&WTPINFO->WTPMAC[2]);
			dbus_message_iter_next(&iter_struct);		
			dbus_message_iter_get_basic(&iter_struct,&WTPINFO->WTPMAC[3]);
			dbus_message_iter_next(&iter_struct);		
			dbus_message_iter_get_basic(&iter_struct,&WTPINFO->WTPMAC[4]);
			dbus_message_iter_next(&iter_struct);			
			dbus_message_iter_get_basic(&iter_struct,&WTPINFO->WTPMAC[5]);	
			
			dbus_message_iter_next(&iter_struct);		
			dbus_message_iter_get_basic(&iter_struct,&wtpip);

			dbus_message_iter_next(&iter_struct);		
			dbus_message_iter_get_basic(&iter_struct,&wtpmodel);
		
			result = wtp_check_wtp_ip_addr(ip,wtpip);
			if(result != 1)
			{
				vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-21s %s\n",
					WTPINFO->WTPID,
					WTPINFO->WTPMAC[0],WTPINFO->WTPMAC[1],WTPINFO->WTPMAC[2],WTPINFO->WTPMAC[3],WTPINFO->WTPMAC[4],WTPINFO->WTPMAC[5],
					wtpip,wtpmodel);
			}
			else
			{
				vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-21s %s\n",
					WTPINFO->WTPID,
					WTPINFO->WTPMAC[0],WTPINFO->WTPMAC[1],WTPINFO->WTPMAC[2],WTPINFO->WTPMAC[3],WTPINFO->WTPMAC[4],WTPINFO->WTPMAC[5],
					ip,wtpmodel);
			}

			CW_FREE_OBJECT(WTPINFO->WTPMAC);
			CW_FREE_OBJECT(WTPINFO);
			dbus_message_iter_next(&iter_array);
		}
		
		vty_out(vty,"----------------------------------------------------------------------\n");
		vty_out(vty,"this is the ap upgrade failed or is upgrading\n");
		vty_out(vty,"%-5s %-17s %-21s %-10s\n","WTPID","WTPMAC","WTPIP","WTPModel");
		vty_out(vty,"----------------------------------------------------------------------\n");
		for (i = 0; i < num_fail; i++) {
			
			WID_WTP *WTPINFO = NULL;
			WTPINFO =  (WID_WTP*)malloc(sizeof(WID_WTP));
			if(WTPINFO == NULL){		
				vty_out(vty,"WTPINFO malloc failed\n");
				return CMD_SUCCESS;
			}
			memset(WTPINFO, 0, sizeof(WID_WTP));
			
			WTPINFO->WTPMAC = (unsigned char *)malloc(MAC_LEN +1);
			if(WTPINFO->WTPMAC == NULL){		
				vty_out(vty,"WTPINFO->WTPMAC malloc failed\n");
				if(WTPINFO){
					free(WTPINFO);
					WTPINFO = NULL;
				}
				return CMD_SUCCESS;
			}
			memset(WTPINFO->WTPMAC,0,(MAC_LEN +1));
			
			DBusMessageIter iter_struct;
			dbus_message_iter_recurse(&iter_array,&iter_struct);
			dbus_message_iter_get_basic(&iter_struct,&(WTPINFO->WTPID));

			dbus_message_iter_next(&iter_struct);			
			dbus_message_iter_get_basic(&iter_struct,&WTPINFO->WTPMAC[0]);
			dbus_message_iter_next(&iter_struct);
			dbus_message_iter_get_basic(&iter_struct,&WTPINFO->WTPMAC[1]);
			dbus_message_iter_next(&iter_struct);		
			dbus_message_iter_get_basic(&iter_struct,&WTPINFO->WTPMAC[2]);
			dbus_message_iter_next(&iter_struct);		
			dbus_message_iter_get_basic(&iter_struct,&WTPINFO->WTPMAC[3]);
			dbus_message_iter_next(&iter_struct);		
			dbus_message_iter_get_basic(&iter_struct,&WTPINFO->WTPMAC[4]);
			dbus_message_iter_next(&iter_struct);			
			dbus_message_iter_get_basic(&iter_struct,&WTPINFO->WTPMAC[5]);	
			
			dbus_message_iter_next(&iter_struct);		
			dbus_message_iter_get_basic(&iter_struct,&wtpip);

			dbus_message_iter_next(&iter_struct);		
			dbus_message_iter_get_basic(&iter_struct,&wtpmodel);
		
			result = wtp_check_wtp_ip_addr(ip,wtpip);
			if(result != 1)
			{
				vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-21s %s\n",
					WTPINFO->WTPID,
					WTPINFO->WTPMAC[0],WTPINFO->WTPMAC[1],WTPINFO->WTPMAC[2],WTPINFO->WTPMAC[3],WTPINFO->WTPMAC[4],WTPINFO->WTPMAC[5],
					wtpip,wtpmodel);
			}
			else
			{
				vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-21s %s\n",
					WTPINFO->WTPID,
					WTPINFO->WTPMAC[0],WTPINFO->WTPMAC[1],WTPINFO->WTPMAC[2],WTPINFO->WTPMAC[3],WTPINFO->WTPMAC[4],WTPINFO->WTPMAC[5],
					ip,wtpmodel);
			}

			CW_FREE_OBJECT(WTPINFO->WTPMAC);
			CW_FREE_OBJECT(WTPINFO);
			dbus_message_iter_next(&iter_array);
		}
		
		vty_out(vty,"----------------------------------------------------------------------\n");
		vty_out(vty,"this is the ap which does not need upgrade\n");
		vty_out(vty,"%-5s %-17s %-21s %-10s\n","WTPID","WTPMAC","WTPIP","WTPModel");
		vty_out(vty,"----------------------------------------------------------------------\n");
		for (i = 0; i < num_other; i++) {
			
			WID_WTP *WTPINFO = NULL;
			WTPINFO =  (WID_WTP*)malloc(sizeof(WID_WTP));
			if(WTPINFO == NULL){		
				vty_out(vty,"WTPINFO malloc failed\n");
				return CMD_SUCCESS;
			}
			memset(WTPINFO, 0, sizeof(WID_WTP));
			
			WTPINFO->WTPMAC = (unsigned char *)malloc(MAC_LEN +1);
			if(WTPINFO->WTPMAC == NULL){		
				vty_out(vty,"WTPINFO->WTPMAC malloc failed\n");
				if(WTPINFO)
				{
					free(WTPINFO);
					WTPINFO = NULL;
				}
				return CMD_SUCCESS;
			}
			memset(WTPINFO->WTPMAC,0,(MAC_LEN +1));
			
			DBusMessageIter iter_struct;
			dbus_message_iter_recurse(&iter_array,&iter_struct);
			dbus_message_iter_get_basic(&iter_struct,&(WTPINFO->WTPID));

			dbus_message_iter_next(&iter_struct);			
			dbus_message_iter_get_basic(&iter_struct,&WTPINFO->WTPMAC[0]);
			dbus_message_iter_next(&iter_struct);
			dbus_message_iter_get_basic(&iter_struct,&WTPINFO->WTPMAC[1]);
			dbus_message_iter_next(&iter_struct);		
			dbus_message_iter_get_basic(&iter_struct,&WTPINFO->WTPMAC[2]);
			dbus_message_iter_next(&iter_struct);		
			dbus_message_iter_get_basic(&iter_struct,&WTPINFO->WTPMAC[3]);
			dbus_message_iter_next(&iter_struct);		
			dbus_message_iter_get_basic(&iter_struct,&WTPINFO->WTPMAC[4]);
			dbus_message_iter_next(&iter_struct);			
			dbus_message_iter_get_basic(&iter_struct,&WTPINFO->WTPMAC[5]);	
			
			dbus_message_iter_next(&iter_struct);		
			dbus_message_iter_get_basic(&iter_struct,&wtpip);

			dbus_message_iter_next(&iter_struct);		
			dbus_message_iter_get_basic(&iter_struct,&wtpmodel);
		
			result = wtp_check_wtp_ip_addr(ip,wtpip);
			if(result != 1)
			{
				vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-21s %s\n",
					WTPINFO->WTPID,
					WTPINFO->WTPMAC[0],WTPINFO->WTPMAC[1],WTPINFO->WTPMAC[2],WTPINFO->WTPMAC[3],WTPINFO->WTPMAC[4],WTPINFO->WTPMAC[5],
					wtpip,wtpmodel);
			}
			else
			{
				vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-21s %s\n",
					WTPINFO->WTPID,
					WTPINFO->WTPMAC[0],WTPINFO->WTPMAC[1],WTPINFO->WTPMAC[2],WTPINFO->WTPMAC[3],WTPINFO->WTPMAC[4],WTPINFO->WTPMAC[5],
					ip,wtpmodel);
			}

			CW_FREE_OBJECT(WTPINFO->WTPMAC);
			CW_FREE_OBJECT(WTPINFO);
			dbus_message_iter_next(&iter_array);
		}
		vty_out(vty,"----------------------------------------------------------------------\n");
	}
	else
		vty_out(vty,"<error>  %d\n",ret);
	
	dbus_message_unref(reply);	

	return CMD_SUCCESS; 
}

#if 0
DEFUN(show_update_wtp_list_func,
	  show_update_wtp_list,
	  "show update wtp (list|all)",
	  SHOW_STR
	  "Display update wtps information\n"
	  "List update wtp summary\n"
	 )
{
	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;		
	char ready[] = "ready";
	char update[] = "update";
	char success[] = "success";
	char state[20];
	char ip[WTP_WTP_IP_LEN+1];
	unsigned int result = 0;
	WID_WTP **WTP;	
	int ret,i=0;
	unsigned int num = 0;
	unsigned int TotalNum = 0;

	time_t now,online_time;
	time(&now);
	int hour,min,sec;

	WTP = malloc(WTP_NUM*(sizeof(WID_WTP *)));
	
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
	}
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST_UPDATE);

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST_UPDATE);*/
	dbus_error_init(&err);
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);	
	dbus_message_unref(query);
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		free(WTP);
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0 ){
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&num);
	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_recurse(&iter,&iter_array);
		
		for (i = 0; i < num; i++) {
			DBusMessageIter iter_struct;
			
			WTP[i] = (WID_WTP*)malloc(sizeof(WID_WTP));
			WTP[i]->WTPMAC = (unsigned char *)malloc(MAC_LEN +1);
			memset(WTP[i]->WTPMAC,0,(MAC_LEN +1));
			dbus_message_iter_recurse(&iter_array,&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPID));
		
			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[0]);
			
			dbus_message_iter_next(&iter_struct);

			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[1]);
			
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[2]);
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[3]);
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[4]);
		
			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[5]);	
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPIP));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPModel));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPStat));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->updateStat));
			
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->manual_update_time));			

			dbus_message_iter_next(&iter_array);

			if(WTP[i]->WTPStat == 5)
			{
				TotalNum++;
			}
		}
	}
	
	dbus_message_unref(reply);
	
    vty_out(vty,"wtp update list summary:\n");	
    vty_out(vty,"==============================================================================\n");
	vty_out(vty,"%-5s %-17s %-20s %-7s %-8s %-7s %-6s\n","WTPID","WTPMAC","WTPIP","Model","RunState","UptInfo","Time");
	if(ret == 0)
		for (i = 0; i < num; i++) {	
			CheckWTPState(state,WTP[i]->WTPStat);
			result = wtp_check_wtp_ip_addr(ip,WTP[i]->WTPIP);
			online_time = now - WTP[i]->manual_update_time;
			hour = online_time/3600;
			min = (online_time-hour*3600)/60;
			sec = (online_time-hour*3600)%60;
			//vty_out(vty,"Run Time:	%02d:%02d:%02d\n",hour,min,sec);	
			if(result != 1)
			{
				vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-20s %-7s %-8s %-7s %02d:%02d:%02d\n",
					WTP[i]->WTPID,
					WTP[i]->WTPMAC[0],WTP[i]->WTPMAC[1],WTP[i]->WTPMAC[2],WTP[i]->WTPMAC[3],WTP[i]->WTPMAC[4],WTP[i]->WTPMAC[5],
					WTP[i]->WTPIP,
					WTP[i]->WTPModel,
					state,
					(WTP[i]->updateStat == 1)?update:((WTP[i]->updateStat == 2)?success:ready),
					hour,min,sec);
			}
			else
			{
				vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-20s %-7s %-8s %-7s %02d:%02d:%02d\n",
					WTP[i]->WTPID,
					WTP[i]->WTPMAC[0],WTP[i]->WTPMAC[1],WTP[i]->WTPMAC[2],WTP[i]->WTPMAC[3],WTP[i]->WTPMAC[4],WTP[i]->WTPMAC[5],
					ip,
					WTP[i]->WTPModel,
					state,
					(WTP[i]->updateStat == 1)?update:((WTP[i]->updateStat == 2)?success:ready),
					hour,min,sec);
			}
			free(WTP[i]->WTPMAC);
			WTP[i]->WTPMAC = NULL;
			free(WTP[i]);
			WTP[i] = NULL;
	}
	vty_out(vty,"==============================================================================\n");
	free(WTP);
	WTP = NULL;
	return CMD_SUCCESS;
	
}
#endif

DEFUN(show_update_wtp_list_func,
	  show_update_wtp_list,
	  "show update wtp (list|all)",
	  SHOW_STR
	  "Display update wtps information\n"
	  "List update wtp summary\n"
	 )
{
	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;		
	char ready[] = "ready";
	char update[] = "update";
	char success[] = "success";
	char state[20];
	char ip[WTP_WTP_IP_LEN+1];
	unsigned int result = 0;
	//WID_WTP **WTP;	
	int ret,i=0;
	unsigned int num = 0;
	unsigned int TotalNum = 0;

	time_t now,online_time;
	time(&now);
	int hour,min,sec;

	//WTP = malloc(WTP_NUM*(sizeof(WID_WTP *)));
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	 DCLI_WTP_API_GROUP_ONE * WTPINFO = NULL;
	 WTPINFO = dcli_wtp_show_api_group_one(
		index,
		SECOND,/*"show wtp (list|all)"*/
		0,
		0,
		0,
		0,/**/
		&ret,/*num2*/
		0,
		0,
		0,
		&localid,//num6
	//	WTPINFO,		
		dcli_dbus_connection,
		WID_DBUS_CONF_METHOD_WTPLIST_UPDATE
		);

    vty_out(vty,"wtp update list summary:\n");	
    vty_out(vty,"==============================================================================\n");
	vty_out(vty,"%-5s %-17s %-20s %-7s %-8s %-7s %-6s\n","WTPID","WTPMAC","WTPIP","Model","RunState","UptInfo","Time");
	if(ret == 0){
		for (i = 0; i < WTPINFO->num; i++) {	
			CheckWTPState(state,WTPINFO->WTP[i]->WTPStat);
			result = wtp_check_wtp_ip_addr(ip,WTPINFO->WTP[i]->WTPIP);
			online_time = now - WTPINFO->WTP[i]->manual_update_time;
			hour = online_time/3600;
			min = (online_time-hour*3600)/60;
			sec = (online_time-hour*3600)%60;
			//vty_out(vty,"Run Time:	%02d:%02d:%02d\n",hour,min,sec);	
			if(result != 1)
			{
				vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-20s %-7s %-8s %-7s %02d:%02d:%02d\n",
					WTPINFO->WTP[i]->WTPID,
					WTPINFO->WTP[i]->WTPMAC[0],WTPINFO->WTP[i]->WTPMAC[1],WTPINFO->WTP[i]->WTPMAC[2],WTPINFO->WTP[i]->WTPMAC[3],WTPINFO->WTP[i]->WTPMAC[4],WTPINFO->WTP[i]->WTPMAC[5],
					WTPINFO->WTP[i]->WTPIP,
					WTPINFO->WTP[i]->WTPModel,
					state,
					(WTPINFO->WTP[i]->updateStat == 1)?update:((WTPINFO->WTP[i]->updateStat == 2)?success:ready),
					hour,min,sec);
			}
			else
			{
				vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-20s %-7s %-8s %-7s %02d:%02d:%02d\n",
					WTPINFO->WTP[i]->WTPID,
					WTPINFO->WTP[i]->WTPMAC[0],WTPINFO->WTP[i]->WTPMAC[1],WTPINFO->WTP[i]->WTPMAC[2],WTPINFO->WTP[i]->WTPMAC[3],WTPINFO->WTP[i]->WTPMAC[4],WTPINFO->WTP[i]->WTPMAC[5],
					ip,
					WTPINFO->WTP[i]->WTPModel,
					state,
					(WTPINFO->WTP[i]->updateStat == 1)?update:((WTPINFO->WTP[i]->updateStat == 2)?success:ready),
					hour,min,sec);
			}
		}
		dcli_wtp_free_fun(WID_DBUS_CONF_METHOD_WTPLIST_UPDATE,WTPINFO);
	}
	else if(ret == WTP_ID_NOT_EXIST){
		vty_out(vty,"update wtp does not exist.\n");
	}
	vty_out(vty,"==============================================================================\n");
	return CMD_SUCCESS;
	
}

DEFUN(show_wtp_model_code_version_cmd_func,
	  show_wtp_model_code_version_cmd,
	  "show wtp version",
	  SHOW_STR
	  "WTP information\n"
	  "WTP model code version infomation\n"
	 )
{	
	unsigned int wtp_id = 0;
	//wtp_id = (unsigned int)vty->index;
	int ret,i;
	
//ID_WTP *WTP;
	int stat;
/*BusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;*/
	DCLI_WTP_API_GROUP_ONE *WTPINFO = NULL;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
 	if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
#if 0
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SHOW_WTP_MODEL_CODE_VERSION);
		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_WTP_METHOD_SHOW_WTP_MODEL_CODE_VERSION);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0 ){	

		WTP = (WID_WTP*)malloc(sizeof(WID_WTP));
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->WTPModel));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->APCode));	
		
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->ver));	

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(WTP->codever));	

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&(stat));	
	
	}
	
	dbus_message_unref(reply);
#endif
	WTPINFO = dcli_wtp_show_api_group_one(
	   index,
	   EIGHTH,/*"show wtp version"*/
	   wtp_id,
	   0,
	   0,
	   0,/**/
	   &ret,/*num2*/
	   0,
	   0,
	   0,
	   &localid,//num6
	 //  WTPINFO,
	   dcli_dbus_connection,
	   WID_DBUS_WTP_METHOD_SHOW_WTP_MODEL_CODE_VERSION
	   );
	if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == 0){
		vty_out(vty,"WTP %d model code version infomation\n",wtp_id);
		vty_out(vty,"==============================================================================\n");
		vty_out(vty,"WTP Model:	%s\n",WTPINFO->WTP[0]->WTPModel);	
		vty_out(vty,"WTP Code:	%s\n",WTPINFO->WTP[0]->APCode);
		vty_out(vty,"WTP Software Version:	%s\n",WTPINFO->WTP[0]->ver);	
		vty_out(vty,"WTP Code Version:	%s\n",WTPINFO->WTP[0]->codever);
		vty_out(vty,"Img stat:	%d\n",WTPINFO->WTP[0]->img_now_state);		
		vty_out(vty,"==============================================================================\n");
	/*	if(WTPINFO->WTP[0]){
			free(WTPINFO->WTP[0]);
			WTPINFO->WTP[0] = NULL;
		}
		if(WTPINFO->WTP){
			free(WTPINFO->WTP);
			WTPINFO->WTP = NULL;
		}*/
		dcli_wtp_free_fun(WID_DBUS_WTP_METHOD_SHOW_WTP_MODEL_CODE_VERSION,WTPINFO);
	}else if(ret == WTP_ID_NOT_EXIST){
		vty_out(vty,"<error> wtp id does not exist\n");
	}
	else 
		vty_out(vty,"<error>  %d\n",ret);
/*	if(WTPINFO){
		free(WTPINFO);
		WTPINFO = NULL;
	}*/
	return CMD_SUCCESS;
}

#if _GROUP_POLICY

DEFUN(update_wtp_img_cmd_func,
	  update_wtp_img_cmd,
	  "update ap img-file FILENAME version VERSION (now|later)",
	  	  	  "set update img file name\n"
	"fixed format input ap\n"
	"fixed format input img-file\n" 
	"img file name value\n"
	"fixed format input version\n" 
	"version value\n"
	"execute command now or later\n"
	"execute command now or later\n"
	 )
{	
	int ret = 0;
	int i = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;

	char *buf_version;
	char *buf_path;
	int fd;
	unsigned char commandmode;

	buf_path = (char*)malloc(strlen(argv[0])+1);
	memset(buf_path, 0, strlen(argv[0])+1);
	memcpy(buf_path, argv[0], strlen(argv[0]));	
	
	buf_version = (char*)malloc(strlen(argv[1])+1);
	memset(buf_version, 0, strlen(argv[1])+1);
	memcpy(buf_version, argv[1], strlen(argv[1]));	

	if (!strcmp(argv[2],"now"))
	{
		commandmode = 1;	
	}
	else
	{
		commandmode = 0;	
	}

	
	char syscmd[WID_SYSTEM_CMD_LENTH];
	memset(syscmd,0,WID_SYSTEM_CMD_LENTH);
	sprintf(syscmd,"/mnt/wtp/%s",buf_path);

	fd = open(syscmd, O_RDONLY);
	if(fd < 0)
	{
		vty_out(vty, "%% set update failed due to system cann't find file\n");

		free(buf_path);
		free(buf_version);

		return CMD_WARNING;
	}
	else 
	{
		close(fd);
	}	

	if(strstr(buf_path,buf_version) == NULL)
	{
		vty_out(vty, "%% set update failed due to file version error\n");

		free(buf_path);
		free(buf_version);
		return CMD_WARNING;
	}
	
	if(vty->node == WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	WtpList_Head = update_wtp_img_cmd_update_ap_img_file_version(index,localid,dcli_dbus_connection,type,id,buf_version,
		buf_path,commandmode,&count,&ret);
if(type==0)
{
		if(ret == 0)
		vty_out(vty,"set wtp update version<%s> image path<%s> successfully\n",buf_version,buf_path);
		else
		vty_out(vty,"<error>  %d\n",ret);
	
		free(buf_path);
		free(buf_version);
}
if(type==1)
{
	if(ret == 0)
			{
				vty_out(vty,"group %d set wtp update version<%s> image path<%s> successfully\n",buf_version,buf_path);
				if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL))
					{
						vty_out(vty,"wtp ");					
						for(i=0; i<count; i++)
						{
							if(Wtp_Show_Node == NULL)
							Wtp_Show_Node = WtpList_Head->WtpList_list;
							else 
							Wtp_Show_Node = Wtp_Show_Node->next;
	
							if(Wtp_Show_Node == NULL)
							break;
						
							vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
						}
					
						vty_out(vty," failed.\n");
						dcli_free_WtpList(WtpList_Head);
					}
			}
		else if (ret == GROUP_ID_NOT_EXIST)
			  vty_out(vty,"<error> group id does not exist\n");
}


	return CMD_SUCCESS; 

}


#else
DEFUN(update_wtp_img_cmd_func,
	  update_wtp_img_cmd,
	  "update ap img-file FILENAME version VERSION (now|later)",
	  	  "set update img file name\n"
	"fixed format input ap\n"
	"fixed format input img-file\n" 
	"img file name value\n"
	"fixed format input version\n" 
	"version value\n"
	"execute command now or later\n"
	"execute command now or later\n"
	 )
{	
	int ret;
	DBusMessage *query, *reply;	
	DBusMessageIter  iter;
	DBusError err;

	char *buf_version;
	char *buf_path;
	int fd;
	unsigned char commandmode;
	unsigned int wtp_id = 0;
	//wtp_id = (unsigned int)vty->index;

	
	buf_path = (char*)malloc(strlen(argv[0])+1);
	memset(buf_path, 0, strlen(argv[0])+1);
	memcpy(buf_path, argv[0], strlen(argv[0]));	
	
	buf_version = (char*)malloc(strlen(argv[1])+1);
	memset(buf_version, 0, strlen(argv[1])+1);
	memcpy(buf_version, argv[1], strlen(argv[1]));	

	if (!strcmp(argv[2],"now"))
	{
		commandmode = 1;	
	}
	else
	{
		commandmode = 0;	
	}

	
	char syscmd[WID_SYSTEM_CMD_LENTH];
	memset(syscmd,0,WID_SYSTEM_CMD_LENTH);
	sprintf(syscmd,"/mnt/wtp/%s",buf_path);

	fd = open(syscmd, O_RDONLY);
	if(fd < 0)
	{
		vty_out(vty, "%% set update failed due to system cann't find file\n");

		free(buf_path);
		free(buf_version);

		return CMD_WARNING;
	}
	else 
	{
		close(fd);
	}	

	if(strstr(buf_path,buf_version) == NULL)
	{
		vty_out(vty, "%% set update failed due to file version error\n");

		free(buf_path);
		free(buf_version);
		return CMD_WARNING;
	}
	
	dbus_error_init(&err);
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_UPDATE_WTP_IMG);
		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_WTP_METHOD_UPDATE_WTP_IMG);*/

	dbus_message_append_args(query,
							DBUS_TYPE_UINT32,&wtp_id,
							DBUS_TYPE_STRING,&buf_version,
							DBUS_TYPE_STRING,&buf_path,
							DBUS_TYPE_BYTE,&commandmode,
							DBUS_TYPE_INVALID);
		
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);

	dbus_message_unref(query);

	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		free(buf_path);
		free(buf_version);
		return CMD_SUCCESS;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		vty_out(vty,"set wtp update version<%s> image path<%s> successfully\n",buf_version,buf_path);
	else
		vty_out(vty,"<error>  %d\n",ret);
	
	dbus_message_unref(reply);	

	free(buf_path);
	free(buf_version);
	return CMD_SUCCESS; 

}
#endif
#if _GROUP_POLICY

DEFUN(clear_wtp_img_cmd_func,
	  clear_wtp_img_cmd,
	  "clear ap img info",
	   "clear ap img info\n"
	   "clear ap img info\n"
	   "clear ap img info\n"
	 )
{	

	int ret = 0;
	int i = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	if(vty->node == WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	WtpList_Head = clear_wtp_img_cmd_clear_ap_img_info(index,localid,dcli_dbus_connection,type,id,&count,&ret);

if(type==0)
{
	if(ret == 0)
	vty_out(vty,"clear wtp update info successfully\n");
	else
	vty_out(vty,"<error>  %d\n",ret);
}

if(type==1)
{
	if(ret == 0)
			{
				vty_out(vty,"group %d clear wtp update info successfully\n",id);
				if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL))
					{
						vty_out(vty,"wtp ");					
						for(i=0; i<count; i++)
						{
							if(Wtp_Show_Node == NULL)
							Wtp_Show_Node = WtpList_Head->WtpList_list;
							else 
							Wtp_Show_Node = Wtp_Show_Node->next;
	
							if(Wtp_Show_Node == NULL)
							break;
						
							vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
						}
					
						vty_out(vty," failed.\n");
						dcli_free_WtpList(WtpList_Head);
					}
			}
		else if (ret == GROUP_ID_NOT_EXIST)
			  vty_out(vty,"<error> group id does not exist\n");
}

	return CMD_SUCCESS; 

}

#else
DEFUN(clear_wtp_img_cmd_func,
	  clear_wtp_img_cmd,
	  "clear ap img info",
	   "clear ap img info\n"
	   "clear ap img info\n"
	   "clear ap img info\n"
	 )
{	
	int ret;
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusError err;

	unsigned int wtp_id = 0;
	//wtp_id = (unsigned int)vty->index;
	
	dbus_error_init(&err);
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_CLEAR_UPDATE_WTP_IMG);
		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_WTP_METHOD_CLEAR_UPDATE_WTP_IMG);*/
	
	dbus_message_append_args(query,
							DBUS_TYPE_UINT32,&wtp_id,
							DBUS_TYPE_INVALID);

		
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);

	dbus_message_unref(query);

	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		vty_out(vty,"clear wtp update info successfully\n");
	else
		vty_out(vty,"<error>  %d\n",ret);
	
	dbus_message_unref(reply);	

	return CMD_SUCCESS; 

}
#endif
DEFUN(optional_update_wtp_img_cmd_func,
	  optional_update_wtp_img_cmd,
	  "update ap img-file FILENAME version VERSION (now|later) for LIST",
	  	  "set update img file name\n"
	"fixed format input ap\n"
	"fixed format input img-file\n" 
	"img file name value\n"
	"fixed format input version\n" 
	"version value\n"
	"execute command now or later\n"
	"execute command now or later\n"
	"fixed format input for\n"
	"update wtp list like 1,5,9-12,18\n"
	 )
{	
	int ret;
	DBusMessage *query, *reply;	
	DBusMessageIter  iter;
	DBusMessageIter iter_array;
	DBusMessageIter iter_array_fail;
	DBusError err;

	char *buf_version;
	char *buf_path;
	int fd;
	unsigned char commandmode;
	unsigned int wtp_id = 0;
	unsigned int i = 0;
	update_wtp_list *wtplist;
	struct tag_wtpid *tmp = NULL;

	unsigned int num;	

	
	buf_path = (char*)malloc(strlen(argv[0])+1);
	memset(buf_path, 0, strlen(argv[0])+1);
	memcpy(buf_path, argv[0], strlen(argv[0]));	
	
	buf_version = (char*)malloc(strlen(argv[1])+1);
	memset(buf_version, 0, strlen(argv[1])+1);
	memcpy(buf_version, argv[1], strlen(argv[1]));	

	if (!strcmp(argv[2],"now"))
	{
		commandmode = 1;	
	}
	else
	{
		commandmode = 0;	
	}

	
	char syscmd[WID_SYSTEM_CMD_LENTH];
	memset(syscmd,0,WID_SYSTEM_CMD_LENTH);
	sprintf(syscmd,"/mnt/wtp/%s",buf_path);

	fd = open(syscmd, O_RDONLY);
	if(fd < 0)
	{
		vty_out(vty, "%% set update failed due to system cann't find file\n");

		free(buf_path);
		free(buf_version);

		return CMD_WARNING;
	}
	else 
	{
		close(fd);
	}	

	if(strstr(buf_path,buf_version) == NULL)
	{
		vty_out(vty, "%% set update failed due to file version error\n");

		free(buf_path);
		free(buf_version);
		return CMD_WARNING;
	}
	

	wtplist = (struct tag_wtpid_list*)malloc(sizeof(struct tag_wtpid_list));
	wtplist->wtpidlist = NULL ;		
	wtplist->count = 0;
	ret = parse_wtpid_list((char*)argv[3],&wtplist);
	if(ret != 0)
	{
		vty_out(vty, "%% set wtp list error,like 1,8,9-20,33\n");

		free(buf_path);
		free(buf_version);
		destroy_input_wtp_list(wtplist);
		return CMD_WARNING;
	}
	else
	{
		//
		
		delsame(wtplist);
		
		/*
		phead = wtplist->wtpidlist;
		
		while(phead != NULL)
		{	
			
			pnext = phead->next;
			vty_out(vty, "wtpid:%d\n",phead->wtpid);
			phead = pnext;

		}
		*/
		
	}

	
	dbus_error_init(&err);
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_UPDATE_WTP_IMG_LIST);

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_WTP_METHOD_UPDATE_WTP_IMG_LIST);*/


	num = wtplist->count;
	dbus_message_iter_init_append (query, &iter);
			
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_STRING,
										 &buf_version);

	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_STRING,
										 &buf_path);

	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &commandmode);

		// Total slot count
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
	tmp = wtplist->wtpidlist;
	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);
	
	for(i = 0; i < num; i++){			
		DBusMessageIter iter_struct;		/* Huangleilei add it by AXSSZFI-1621: dbus may be not accept more than 255 elements, as string add to it */
		dbus_message_iter_open_container(&iter_array, DBUS_TYPE_STRUCT, NULL, &iter_struct);
		dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT32, &(tmp->wtpid));
		dbus_message_iter_close_container (&iter_array, &iter_struct);
		tmp = tmp->next;
	}
	dbus_message_iter_close_container (&iter, &iter_array);
	#if 0
	for(i = 0; i < num; i++){
		
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &(tmp->wtpid));
		tmp = tmp->next;

	}	
	#endif
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query, 5000, &err);

	dbus_message_unref(query);

	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		free(buf_path);
		free(buf_version);
		destroy_input_wtp_list(wtplist);
		return CMD_SUCCESS;
	}
	unsigned int fail_num = 0;         //fengwenchao add 20110516
	int fail_wtp = 0;                          //fengwenchao add 20110516
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	dbus_message_iter_next(&iter);                                  //fengwenchao add 20110516
	dbus_message_iter_get_basic(&iter,&fail_num);
	if(ret == 0)
		vty_out(vty,"set wtp update version<%s> image path<%s> successfully\n",buf_version,buf_path);
	else if(ret == WTP_ID_NOT_EXIST)                       //fengwenchao add 20110516
		vty_out(vty,"all wtpid is not exist\n");
	else
		vty_out(vty,"<error>  %d\n",ret);

	/*fengwenchao add 20110516*/
	dbus_message_iter_next(&iter);	
	dbus_message_iter_recurse(&iter, &iter_array_fail);
	if((fail_num != 0)&&(ret != WTP_ID_NOT_EXIST))
	{
		vty_out(vty,"WTP :");
		for(i = 0; i < fail_num; i++){		/* Huangleilei add it by AXSSZFI-1621: dbus may be not accept more than 255 elements, as string add to it */
			DBusMessageIter iter_struct;
			dbus_message_iter_recurse(&iter_array_fail, &iter_struct);
			dbus_message_iter_get_basic(&iter_struct, &fail_wtp);
			vty_out(vty," %d ",fail_wtp);
			dbus_message_iter_next(&iter_array_fail);
		}
		vty_out(vty," is not exist");
	}
	/*fengwenchao add end*/
	
	dbus_message_unref(reply);	

	free(buf_path);
	free(buf_version);
	destroy_input_wtp_list(wtplist);
	return CMD_SUCCESS; 

}

DEFUN(optional_clear_wtp_img_cmd_func,
	  optional_clear_wtp_img_cmd,
	  "clear ap img info for LIST",
	   "clear ap img info\n"
	   "clear ap img info\n"
	   "clear ap img info\n"
	   "clear ap list like 1,5-9,12\n"
	 )
{	
	int ret;
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusMessageIter iter_array;
	DBusError err;
	unsigned int wtp_id;
	int i;
	update_wtp_list *wtplist;
	struct tag_wtpid *tmp = NULL;

	unsigned int num;	

	wtplist = (struct tag_wtpid_list*)malloc(sizeof(struct tag_wtpid_list));
	wtplist->wtpidlist = NULL ;		
	wtplist->count = 0;
	
	if (!strcmp(argv[0],"all"))
	{
		num = 0;
		ret = 0;
	}
	else
	{
		ret = parse_wtpid_list((char*)argv[0],&wtplist);
	}
	
	if(ret != 0)
	{
		vty_out(vty, "%% set wtp list error,like 1,8,9-20,33\n");

		destroy_input_wtp_list(wtplist);
		return CMD_WARNING;
	}
	else
	{
		//
		
		delsame(wtplist);
		
		
	}

	
	dbus_error_init(&err);
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_CLEAR_UPDATE_WTP_IMG_LIST);

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_WTP_METHOD_CLEAR_UPDATE_WTP_IMG_LIST);*/


	num = wtplist->count;
	dbus_message_iter_init_append (query, &iter);
			
		// Total slot count
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
	tmp = wtplist->wtpidlist;
	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);
	
	for(i = 0; i < num; i++){			
		DBusMessageIter iter_struct;		/* Huangleilei add it by AXSSZFI-1621: dbus may be not accept more than 255 elements, as string add to it */
		dbus_message_iter_open_container(&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_UINT32,&(tmp->wtpid));
		dbus_message_iter_close_container (&iter_array, &iter_struct);
		tmp = tmp->next;
	}
	dbus_message_iter_close_container (&iter, &iter_array);
	#if 0
	for(i = 0; i < num; i++){
		
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &(tmp->wtpid));
		tmp = tmp->next;

	}	
	#endif
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);

	dbus_message_unref(query);

	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		destroy_input_wtp_list(wtplist);
		return CMD_SUCCESS;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		vty_out(vty,"clear %s wtps image successfully\n", argv[0]);
	else
		vty_out(vty,"<error>  %d\n",ret);
	
	dbus_message_unref(reply);	

	destroy_input_wtp_list(wtplist);
	return CMD_SUCCESS; 

}
DEFUN(show_ac_access_wtp_info_cmd_func,
	  show_ac_access_wtp_info_cmd,
	  "show ac-access-wtp-info list [remote] [local] [PARAMETER]",
	  SHOW_STR
	  "Display wtps information\n"
	  "List wtp summary\n"
	  "'remote' or 'local' hansi\n"
	  "'remote' or 'local' hansi\n"
	  "slotid-instid\n"
	 )
{
/*	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;		
	struct wtp_access_info **WTP;	*/
	int ret,i=0;
	unsigned int num = 0;
	unsigned char *ip;
	int profile = 0;
	int instRun = 0;
	int flag = 0;
	
	//WTP = malloc(WTP_NUM*(sizeof(struct wtp_access_info *)));
	DCLI_WTP_API_GROUP_ONE *WTPINFO = NULL;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	
	if((argc == 1)||(argc == 3)){
		vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
		return CMD_SUCCESS;
	}
	if(argc == 2){
		if (!strcmp(argv[0],"remote")){
			localid = 0;
		}else if(!strcmp(argv[0],"local")){
			localid = 1;
		}else{
			vty_out(vty,"parameter should be 'remote' or 'local'\n");
			return CMD_SUCCESS;
		}
		
		if((!strcmp(argv[0],"remote"))&&(!strcmp(argv[1],"local"))){
			vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
			return CMD_SUCCESS;
		}
		
		ret = parse_slot_hansi_id((char*)argv[1],&slot_id,&profile);
		if(ret != WID_DBUS_SUCCESS){
			slot_id = HostSlotId;
			flag = 1;
			ret = parse_int_ID((char*)argv[1], &profile);
			if(ret != WID_DBUS_SUCCESS){
				if(ret == WID_ILLEGAL_INPUT){
					vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
				}
				else{
					vty_out(vty,"<error> unknown id format\n");
				}
				return CMD_WARNING;
			}	
		}
		if(distributFag == 0){
			if(slot_id != 0){
				vty_out(vty,"<error> slot id should be 0\n");
				return CMD_WARNING;
			}	
		}else if(flag == 1){
			slot_id = HostSlotId;
		}
		if(slot_id >= MAX_SLOT_NUM || slot_id < 0){
			vty_out(vty,"<error> slot id should be 1 to %d\n",MAX_SLOT_NUM-1);
			return CMD_WARNING;
		}	
		if(profile >= MAX_INSTANCE || profile == 0){
			vty_out(vty,"<error> hansi id should be 1 to %d\n",MAX_INSTANCE-1);
			return CMD_WARNING;
		}
		instRun = dcli_hmd_hansi_is_running(vty,slot_id,localid,profile);
		if (INSTANCE_NO_CREATED == instRun) {
			vty_out(vty,"<error> the instance %s %d-%d is not running\n",((localid == 1)?"local-hansi":"hansi"),slot_id,profile);
			return CMD_WARNING;
		}
		
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		if(localid == 0)
			goto hansi_parameter;
		else if(localid == 1)
			goto local_hansi_parameter; 
	}
#if 0	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_AC_ACCESS_WTPLIST);

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_AC_ACCESS_WTPLIST);*/
	dbus_error_init(&err);
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);	
	dbus_message_unref(query);
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		free(WTP);
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0 ){
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&num);
	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_recurse(&iter,&iter_array);
		
		for (i = 0; i < num; i++) {
			DBusMessageIter iter_struct;
			WTP[i] = (struct wtp_access_info*)malloc(sizeof(struct wtp_access_info));
			WTP[i]->WTPMAC = (unsigned char *)malloc(MAC_LEN +1);
			dbus_message_iter_recurse(&iter_array,&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->ip));
		
			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPMAC[0]));
		
			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPMAC[1]));
		
			dbus_message_iter_next(&iter_struct);

			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPMAC[2]));
		
			dbus_message_iter_next(&iter_struct);

			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPMAC[3]));
		
			dbus_message_iter_next(&iter_struct);

			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPMAC[4]));
		
			dbus_message_iter_next(&iter_struct);

			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPMAC[5]));
		
			dbus_message_iter_next(&iter_struct);

			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->model));
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->apcode));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->sn));

			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->ifname));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->version));
			
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->codever));			
		
			dbus_message_iter_next(&iter_array);

		}
	}
	
	dbus_message_unref(reply);
#endif
	if(vty->node != VIEW_NODE){
		WTPINFO = dcli_wtp_show_api_group_one(
		   index,
		   SEVENTH,/*"show ac-access-wtp-info list"*/
		   0,
		   0,
		   0,
		   0,/**/
		   &ret,/*num2*/
		   0,
		   0,
		   0,
		   &localid,//num6
		//   WTPINFO,
		   dcli_dbus_connection,
		   WID_DBUS_CONF_METHOD_AC_ACCESS_WTPLIST
		   );
	    vty_out(vty,"wtp access list summary:\n");	
	    vty_out(vty,"%d WTPs attempt accessing\n",(ret != 0)?0:WTPINFO->num);
	    vty_out(vty,"==============================================================================\n");
		vty_out(vty,"%-17s %-15s %-13s %-8s %-8s %-8s %s\n","WTPMAC","WTPIP","WTPMODEL","APCode","Version","CodeTag","IFNAME");
		if(ret == -1){
			cli_syslog_info("<error> failed get reply.\n");
		}
		else if(ret == 0){
			for (i = 0; i < WTPINFO->num; i++) {	
				// = &(WTPINFO->WTP[i]->WTPIP);
				vty_out(vty,"%02X:%02X:%02X:%02X:%02X:%02X %-3d.%-3d.%-3d.%-3d %-13s %-13s %-8s %-8s %s\n",
					WTPINFO->WTP[i]->WTPMAC[0],WTPINFO->WTP[i]->WTPMAC[1],WTPINFO->WTP[i]->WTPMAC[2],WTPINFO->WTP[i]->WTPMAC[3],WTPINFO->WTP[i]->WTPMAC[4],WTPINFO->WTP[i]->WTPMAC[5],
					(unsigned char)WTPINFO->WTP[i]->WTPIP[0],(unsigned char)WTPINFO->WTP[i]->WTPIP[1],(unsigned char)WTPINFO->WTP[i]->WTPIP[2],(unsigned char)WTPINFO->WTP[i]->WTPIP[3],
					WTPINFO->WTP[i]->WTPModel,
					WTPINFO->WTP[i]->APCode,
					WTPINFO->WTP[i]->ver,
					WTPINFO->WTP[i]->codever,
					WTPINFO->WTP[i]->apply_interface_name
					);
				vty_out(vty,"SN:%s\n",WTPINFO->WTP[i]->WTPSN);
				
			//	free(WTPINFO->WTP[i]);
			//	WTPINFO->WTP[i] = NULL;
			}
			//free(WTPINFO->WTP);
			//WTPINFO->WTP = NULL;
			dcli_wtp_free_fun(WID_DBUS_CONF_METHOD_AC_ACCESS_WTPLIST,WTPINFO);
		}
		vty_out(vty,"==============================================================================\n");
		//free(WTPINFO);
		//WTPINFO = NULL;
	}
	
	if(vty->node == VIEW_NODE){
		//for remote hansi info
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 0;
			
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,0,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}

		hansi_parameter:
				WTPINFO = dcli_wtp_show_api_group_one(
				   profile,
				   SEVENTH,/*"show ac-access-wtp-info list"*/
				   0,
				   0,
				   0,
				   0,/**/
				   &ret,/*num2*/
				   0,
				   0,
				   0,
				   &localid,//num6
				   dcli_dbus_connection,
				   WID_DBUS_CONF_METHOD_AC_ACCESS_WTPLIST
				   );
			    vty_out(vty,"==============================================================================\n");
			    vty_out(vty,"hansi %d-%d\n",slot_id,profile);
			    vty_out(vty,"-----------------------------------------------------------------------------\n");
			    vty_out(vty,"wtp access list summary:\n");	
			    vty_out(vty,"%d WTPs attempt accessing\n",(ret != 0)?0:WTPINFO->num);
			    vty_out(vty,"-----------------------------------------------------------------------------\n");
				vty_out(vty,"%-17s %-15s %-13s %-8s %-8s %-8s %s\n","WTPMAC","WTPIP","WTPMODEL","APCode","Version","CodeTag","IFNAME");
				if(ret == -1){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == 0){
					for (i = 0; i < WTPINFO->num; i++) {	
						vty_out(vty,"%02X:%02X:%02X:%02X:%02X:%02X %-3d.%-3d.%-3d.%-3d %-13s %-13s %-8s %-8s %s\n",
							WTPINFO->WTP[i]->WTPMAC[0],WTPINFO->WTP[i]->WTPMAC[1],WTPINFO->WTP[i]->WTPMAC[2],WTPINFO->WTP[i]->WTPMAC[3],WTPINFO->WTP[i]->WTPMAC[4],WTPINFO->WTP[i]->WTPMAC[5],
							(unsigned char)WTPINFO->WTP[i]->WTPIP[0],(unsigned char)WTPINFO->WTP[i]->WTPIP[1],(unsigned char)WTPINFO->WTP[i]->WTPIP[2],(unsigned char)WTPINFO->WTP[i]->WTPIP[3],
							WTPINFO->WTP[i]->WTPModel,
							WTPINFO->WTP[i]->APCode,
							WTPINFO->WTP[i]->ver,
							WTPINFO->WTP[i]->codever,
							WTPINFO->WTP[i]->apply_interface_name
							);
						vty_out(vty,"SN:%s\n",WTPINFO->WTP[i]->WTPSN);
						
					}
					dcli_wtp_free_fun(WID_DBUS_CONF_METHOD_AC_ACCESS_WTPLIST,WTPINFO);
				}
				vty_out(vty,"==============================================================================\n");
				if(argc == 2){
					return CMD_SUCCESS;
				}
			}
		}

		//for local hansi info
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 1;
			
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,1,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}

		local_hansi_parameter:
				WTPINFO = dcli_wtp_show_api_group_one(
				   profile,
				   SEVENTH,/*"show ac-access-wtp-info list"*/
				   0,
				   0,
				   0,
				   0,/**/
				   &ret,/*num2*/
				   0,
				   0,
				   0,
				   &localid,//num6
				   dcli_dbus_connection,
				   WID_DBUS_CONF_METHOD_AC_ACCESS_WTPLIST
				   );
			    vty_out(vty,"==============================================================================\n");
			    vty_out(vty,"local hansi %d-%d\n",slot_id,profile);
			    vty_out(vty,"-----------------------------------------------------------------------------\n");
				vty_out(vty,"wtp access list summary:\n");	
				vty_out(vty,"%d WTPs attempt accessing\n",(ret != 0)?0:WTPINFO->num);
			    vty_out(vty,"-----------------------------------------------------------------------------\n");
				vty_out(vty,"%-17s %-15s %-13s %-8s %-8s %-8s %s\n","WTPMAC","WTPIP","WTPMODEL","APCode","Version","CodeTag","IFNAME");
				if(ret == -1){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == 0){
					for (i = 0; i < WTPINFO->num; i++) {	
						vty_out(vty,"%02X:%02X:%02X:%02X:%02X:%02X %-3d.%-3d.%-3d.%-3d %-13s %-13s %-8s %-8s %s\n",
							WTPINFO->WTP[i]->WTPMAC[0],WTPINFO->WTP[i]->WTPMAC[1],WTPINFO->WTP[i]->WTPMAC[2],WTPINFO->WTP[i]->WTPMAC[3],WTPINFO->WTP[i]->WTPMAC[4],WTPINFO->WTP[i]->WTPMAC[5],
							(unsigned char)WTPINFO->WTP[i]->WTPIP[0],(unsigned char)WTPINFO->WTP[i]->WTPIP[1],(unsigned char)WTPINFO->WTP[i]->WTPIP[2],(unsigned char)WTPINFO->WTP[i]->WTPIP[3],
							WTPINFO->WTP[i]->WTPModel,
							WTPINFO->WTP[i]->APCode,
							WTPINFO->WTP[i]->ver,
							WTPINFO->WTP[i]->codever,
							WTPINFO->WTP[i]->apply_interface_name
							);
						vty_out(vty,"SN:%s\n",WTPINFO->WTP[i]->WTPSN);
						
					}
					dcli_wtp_free_fun(WID_DBUS_CONF_METHOD_AC_ACCESS_WTPLIST,WTPINFO);
				}
				vty_out(vty,"==============================================================================\n");
				if(argc == 2){
					return CMD_SUCCESS;
				}
			}
		}
	}

	return CMD_SUCCESS;
}
DEFUN(clean_ac_access_wtp_info_cmd_func,
	  clean_ac_access_wtp_info_cmd,
	  "clean ac-access-wtp-info list",
	  SHOW_STR
	  "Display wtps information\n"
	  "List wtp summary\n"
	 )
{
	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;
	int ret;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_CLEAN_AC_ACCESS_WTPLIST);

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_CLEAN_AC_ACCESS_WTPLIST);*/
	dbus_error_init(&err);
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);	
	dbus_message_unref(query);
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	
	if(ret == 0)
	{
		vty_out(vty,"clean ac-access-wtp-info list successfully\n");
	}
	dbus_message_unref(reply);	
	
	return CMD_SUCCESS;

}

DEFUN(old_ap_img_data_cmd_func,
	  old_ap_img_data_cmd,
	  "old_ap_img_data (open|close) ",
	  SHOW_STR
	  "Display wtps information\n"
	  "open or close\n"
	 )
{
	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;
	int ret;
	int stat;
	if (!strcmp(argv[0],"open"))
	{
		stat = 1;
	}
	else{
		stat = 0;
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_OLD_AP_IMG);

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_OLD_AP_IMG);*/
	dbus_error_init(&err);
	
	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&stat,
							 DBUS_TYPE_INVALID);
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);	
	dbus_message_unref(query);
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	
	if(ret == 0)
	{
		vty_out(vty,"old_ap_img_data %s\n",argv[0]);
	}
	dbus_message_unref(reply);		
	return CMD_SUCCESS;

}
#if _GROUP_POLICY

DEFUN(set_wtp_sn_cmd_func,
	  set_wtp_sn_cmd,
	  "set wtp sn SN",
	  CONFIG_STR
	  "wtp information\n"
	  "wtp sn\n"
	  "wtp sn length <1-127>\n"
	 )
{	
	int ret = 0;
	int i = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;

	char *name = NULL;
	int len = 0;

	len = strlen(argv[0]);
	
	if(len > 128){		
		vty_out(vty,"<error> wtp sn is too long,should be 1 to 127\n");
		return CMD_SUCCESS;
	}
	name = (char*)malloc(strlen(argv[0])+1);
	memset(name, 0, strlen(argv[0])+1);
	memcpy(name, argv[0], strlen(argv[0]));
	
	if(vty->node == WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	WtpList_Head = set_wtp_sn_cmd_set_wtp_sn_SN(index,localid,dcli_dbus_connection,type,id,name,&count,&ret);

if(type == 0)
{
	if(ret == 0)
	{		
		vty_out(vty,"set wtp sn %s successfully\n",argv[0]);
	}
	else if (ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else
	{
		vty_out(vty,"<error> wtp be running\n");
	}
	free(name);
	name = NULL;
}
if(type==1)
	{
		if(ret == 0)
			{
				vty_out(vty,"group %d set wtp sn %s successfully\n",id,argv[0]);
				if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL))
					{
						vty_out(vty,"wtp ");					
						for(i=0; i<count; i++)
						{
							if(Wtp_Show_Node == NULL)
							Wtp_Show_Node = WtpList_Head->WtpList_list;
							else 
							Wtp_Show_Node = Wtp_Show_Node->next;
	
							if(Wtp_Show_Node == NULL)
							break;
						
							vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
						}
					
						vty_out(vty," failed.\n");
						dcli_free_WtpList(WtpList_Head);
					}
			}
		else if (ret == GROUP_ID_NOT_EXIST)
			  vty_out(vty,"<error> group id does not exist\n");
	}
	return CMD_SUCCESS;

}

#else
DEFUN(set_wtp_sn_cmd_func,
	  set_wtp_sn_cmd,
	  "set wtp sn SN",
	  CONFIG_STR
	  "wtp information\n"
	  "wtp sn\n"
	  "wtp sn length <1-127>\n"
	 )
{	
	
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;
	unsigned int WTPID = 0;
	int ret = WID_DBUS_SUCCESS;
	char *name = NULL;
	int len = 0;
	//WTPID = (unsigned int)vty->index;

	len = strlen(argv[0]);
	
	if(len >= 128){		//book modify
		vty_out(vty,"<error> wtp sn is too long,should be 1 to 127\n");
		return CMD_SUCCESS;
	}
	name = (char*)malloc(strlen(argv[0])+1);
	memset(name, 0, strlen(argv[0])+1);
	memcpy(name, argv[0], strlen(argv[0]));
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTPSN);
		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTPSN);*/
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_STRING,&name,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		if(name)
		{
			free(name);
			name = NULL;
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
		
	dbus_message_unref(reply);
	if(ret == 0)
	{		
		vty_out(vty,"set wtp sn %s successfully\n",argv[0]);
	}
	else if (ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else {
		vty_out(vty,"<error> wtp be running\n");
	}
	free(name);
	name = NULL;
	return CMD_SUCCESS;
}
#endif
DEFUN(show_update_fail_wtp_list_func,
	  show_update_fail_wtp_list,
	  "show update fail wtp (list|all)",
	  SHOW_STR
	  "Display update fail wtps information\n"
	  "List update fail wtp summary\n"
	 )
{
/*	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;	*/	
	char noaccess[] = "noaccess";
	char overuptcount[] = "upterror";
	char pkterror[] = "pkterror";
	char state[20];
	char ip[WTP_WTP_IP_LEN+1];
	unsigned int result = 0;
//	WID_WTP **WTP;	
	int ret,i=0;
	unsigned int num = 0;
	unsigned int TotalNum = 0;

	//WTP = malloc(WTP_NUM*(sizeof(WID_WTP *)));
	DCLI_WTP_API_GROUP_ONE *WTPINFO = NULL;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
#if 0
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST_UPDATE_FAIL_LIST);

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST_UPDATE_FAIL_LIST);*/
	dbus_error_init(&err);
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);	
	dbus_message_unref(query);
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		free(WTP);
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(ret == 0 ){
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&num);
	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_recurse(&iter,&iter_array);
		
		for (i = 0; i < num; i++) {
			DBusMessageIter iter_struct;
			
			WTP[i] = (WID_WTP*)malloc(sizeof(WID_WTP));
			WTP[i]->WTPMAC = (unsigned char *)malloc(MAC_LEN +1);
			memset(WTP[i]->WTPMAC,0,(MAC_LEN +1));
			dbus_message_iter_recurse(&iter_array,&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPID));
		
			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[0]);
			
			dbus_message_iter_next(&iter_struct);

			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[1]);
			
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[2]);
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[3]);
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[4]);
		
			dbus_message_iter_next(&iter_struct);
			
			dbus_message_iter_get_basic(&iter_struct,&WTP[i]->WTPMAC[5]);	
		
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPIP));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPModel));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->WTPStat));

			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->updatefailstate));
			
			dbus_message_iter_next(&iter_struct);
		
			dbus_message_iter_get_basic(&iter_struct,&(WTP[i]->updatefailcount));			

			dbus_message_iter_next(&iter_array);

			if(WTP[i]->WTPStat == 5)
			{
				TotalNum++;
			}
		}
	}
	
	dbus_message_unref(reply);
#endif
	WTPINFO = dcli_wtp_show_api_group_one(
	   index,
	   SIXTH,/*"show update fail wtp (list|all)"*/
	   0,
	   0,
	   0,
	   0,/**/
	   &ret,/*num2*/
	   0,
	   0,
	   0,
	   &localid,//num6
	 //  WTPINFO,
	   dcli_dbus_connection,
	   WID_DBUS_CONF_METHOD_WTPLIST_UPDATE_FAIL_LIST
	   );
    vty_out(vty,"wtp update list summary:\n");	
    vty_out(vty,"==============================================================================\n");
	vty_out(vty,"%-5s %-17s %-20s %-8s %-10s %-5s\n","WTPID","WTPMAC","WTPIP","RunState","FailInfo","Count");
	if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == 0){
		for (i = 0; i < WTPINFO->num; i++) {	
			CheckWTPState(state,WTPINFO->WTP[i]->WTPStat);
			result = wtp_check_wtp_ip_addr(ip,WTPINFO->WTP[i]->WTPIP);
			if(result != 1)
			{
				vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-20s %-8s %-10s %-5d\n",
					WTPINFO->WTP[i]->WTPID,
					WTPINFO->WTP[i]->WTPMAC[0],WTPINFO->WTP[i]->WTPMAC[1],WTPINFO->WTP[i]->WTPMAC[2],WTPINFO->WTP[i]->WTPMAC[3],WTPINFO->WTP[i]->WTPMAC[4],WTPINFO->WTP[i]->WTPMAC[5],
					WTPINFO->WTP[i]->WTPIP,
					state,
					(WTPINFO->WTP[i]->updatefailstate == 1)?overuptcount:((WTPINFO->WTP[i]->updatefailstate == 2)?pkterror:noaccess),
					WTPINFO->WTP[i]->updatefailcount);
			}
			else
			{
				vty_out(vty,"%-5d %02X:%02X:%02X:%02X:%02X:%02X %-20s %-8s %-10s %-5d\n",
					WTPINFO->WTP[i]->WTPID,
					WTPINFO->WTP[i]->WTPMAC[0],WTPINFO->WTP[i]->WTPMAC[1],WTPINFO->WTP[i]->WTPMAC[2],WTPINFO->WTP[i]->WTPMAC[3],WTPINFO->WTP[i]->WTPMAC[4],WTPINFO->WTP[i]->WTPMAC[5],
					ip,
					state,
					(WTPINFO->WTP[i]->updatefailstate == 1)?overuptcount:((WTPINFO->WTP[i]->updatefailstate == 2)?pkterror:noaccess),
					WTPINFO->WTP[i]->updatefailcount);

			}
			/*
			free(WTPINFO->WTP[i]->WTPMAC);
			WTPINFO->WTP[i]->WTPMAC = NULL;
			free(WTPINFO->WTP[i]);
			WTPINFO->WTP[i] = NULL;
			free(WTPINFO->WTP);
			WTPINFO->WTP = NULL;
			*/
	}
		dcli_wtp_free_fun(WID_DBUS_CONF_METHOD_WTPLIST_UPDATE_FAIL_LIST,WTPINFO);
	}
	vty_out(vty,"==============================================================================\n");
/*	free(WTPINFO->WTP);
	WTPINFO->WTP = NULL;
	free(WTPINFO);
	WTPINFO = NULL;*/
	return CMD_SUCCESS;
	
}

DEFUN(clear_update_fail_wtp_cmd_func,
	  clear_update_fail_wtp_cmd,
	  "clear update fail wtp for LIST",
	   "clear update fail wtp\n"
	   "clear update fail wtp\n"
	   "clear update fail wtp\n"
	   "clear clear update fail wtp list like 1,5-9,12\n"
	 )
{	
	int ret;
	DBusMessage *query, *reply; 
	DBusMessageIter  iter;
	DBusMessageIter	 iter_array;
	DBusError err;
	unsigned int wtp_id;
	int i;
	update_wtp_list *wtplist;
	struct tag_wtpid *tmp = NULL;

	unsigned int num;	

	wtplist = (struct tag_wtpid_list*)malloc(sizeof(struct tag_wtpid_list));
	wtplist->wtpidlist = NULL ;		
	wtplist->count = 0;
	
	if (!strcmp(argv[0],"all"))
	{
		num = 0;
		ret = 0;
	}
	else
	{
		ret = parse_wtpid_list((char*)argv[0],&wtplist);
	}
	
	if(ret != 0)
	{
		vty_out(vty, "%% set wtp list error,like 1,8,9-20,33\n");

		destroy_input_wtp_list(wtplist);
		return CMD_WARNING;
	}
	else
	{
		//
		
		delsame(wtplist);
		
		
	}

	
	dbus_error_init(&err);
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_CLEAR_UPDATE_FAIL_WTP_LIST);

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_WTP_METHOD_CLEAR_UPDATE_FAIL_WTP_LIST);*/


	num = wtplist->count;
	dbus_message_iter_init_append (query, &iter);
			
		// Total slot count
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
	tmp = wtplist->wtpidlist;
	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);
	
	for(i = 0; i < num; i++){			
		DBusMessageIter iter_struct;		/* Huangleilei add it for AXSSZFI-1621: dbus may be not accept more than 255 elements, as string add to it */
		dbus_message_iter_open_container(&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_UINT32,&(tmp->wtpid));
		dbus_message_iter_close_container (&iter_array, &iter_struct);
		tmp = tmp->next;
	}
	dbus_message_iter_close_container (&iter, &iter_array);
	
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);

	dbus_message_unref(query);

	
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		destroy_input_wtp_list(wtplist);
		return CMD_SUCCESS;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
		vty_out(vty,"clear update fial wtp list successfully\n");
	else
		vty_out(vty,"<error>  %d\n",ret);
	
	dbus_message_unref(reply);	

	destroy_input_wtp_list(wtplist);
	return CMD_SUCCESS; 

}
DEFUN(show_old_ap_img_data_cmd_func,
	  show_old_ap_img_data_cmd,
	  "show old_ap_img_data config",
	  SHOW_STR
	  "Display old_ap_img_data information\n"
	  "Display old_ap_img_data information\n"
	 )
{
/*	DBusMessage *query, *reply;
	DBusError err;
	DBusMessageIter	 iter;*/
	//int state;
	int ret = 0;
	char statopen[] = "open";
	char statclose[] = "close";
	DCLI_WTP_API_GROUP_THREE *WTPINFO = NULL;
//	CW_CREATE_OBJECT_ERR(WTPINFO, DCLI_WTP_API_GROUP_THREE, return NULL;);	
//	WTPINFO->old_ap_img_state = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
#if 0	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SHOW_OLD_AP_IMG);

/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
						WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_OLD_AP_IMG);*/
	dbus_error_init(&err);
	
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);	
	dbus_message_unref(query);
	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&state);
#endif
 WTPINFO = dcli_wtp_show_api_group_three(
	index,
	NINTH,/*"show old_ap_img_data config"*/
	0,
	1,
	0,
	&ret,/**/
	0,/*num2*/
	0,
	0,
	0,
	&localid,//num6
//	WTPINFO,
	dcli_dbus_connection,
	WID_DBUS_CONF_METHOD_SHOW_OLD_AP_IMG
	);
	if(WTPINFO){
		vty_out(vty,"old_ap_img_data is %s\n",((WTPINFO->old_ap_img_state==1)?statopen:statclose));
	//	dbus_message_unref(reply);		
		dcli_wtp_free_fun_three(WID_DBUS_CONF_METHOD_SHOW_OLD_AP_IMG,WTPINFO);
	}
//	CW_FREE_OBJECT(WTPINFO);
	return CMD_SUCCESS;

}
#if _GROUP_POLICY
DEFUN(set_ap_networkaddr_command_func,
	  set_ap_networkaddr_command_cmd,
	  "set ap network address IP mask MASK gateway GATEWAY fstdns DNS1 snddns DNS2",
	  "wireless-control config\n"
	  "ap network config\n"
	  "ip address\n"
	  "ip address\n"
	  "ip address like 192.168.8.11\n"
	  "subnet mask\n"
	  "subnet mask like 192.168.8.1\n"
	  "gateway address\n"
	  "gateway address like 202.106.0.20\n"
	  "first dns address\n"
	  "dns like 202.106.0.20\n"
	  "secend dns address\n"
	  "dns address like 192.168.8.1\n"	  
	 )
{
	int ret = 0;
	int ret1 = 0;
	int ret2 = 0;
	
    unsigned int ip;
	unsigned int mask;
	unsigned int gateway;
	unsigned int fstdns;
	unsigned int snddns;
	
	unsigned char myipBuf[WTP_IP_BUFF_LEN] = {0};	
	unsigned char *myipPtr = myipBuf;
	
	int i = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	ret1 = WID_Check_IP_Format((char*)argv[0]);
	if(ret1 != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown ip format\n");
		return CMD_SUCCESS;
	}
	ip = dcli_ip2ulong((char*)argv[0]);


	ret1 = WID_Check_Mask_Format((char*)argv[1]);
	if(ret1 != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown mask format\n");
		return CMD_SUCCESS;
	}

	mask = dcli_ip2ulong((char*)argv[1]);



	ret2 = WID_Check_IP_Format((char*)argv[2]);
	if(ret2 != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown gateway format\n");
		return CMD_SUCCESS;
	}
	gateway = dcli_ip2ulong((char*)argv[2]);

	ret2 = WID_Check_IP_Format((char*)argv[3]);
	if(ret2 != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown dns format\n");
		return CMD_SUCCESS;
	}
	fstdns = dcli_ip2ulong((char*)argv[3]);

	ret2 = WID_Check_IP_Format((char*)argv[4]);
	if(ret2 != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown dns format\n");
		return CMD_SUCCESS;
	}
	snddns = dcli_ip2ulong((char*)argv[4]);	
	
	if(vty->node == WTP_NODE){
		index = 0;			
		id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	WtpList_Head = set_ap_networkaddr_command_cmd_set_ap_network_address_mask_gateway_fstdns_snddns(index,localid,dcli_dbus_connection,
		type,id,ip,mask,gateway,fstdns,snddns,&count,&ret);

	if(type==0)
		{
			if(ret == 0)
				{
					vty_out(vty,"set ap network information successfully\n");
				}
			else if(ret == WTP_ID_NOT_EXIST)
					vty_out(vty,"<error> wtp id does not exist\n");
			else
				{
					vty_out(vty,"<error>  %d\n",ret);
				}
		}

	if(type==1)
		{
			if(ret == 0)
				{
					vty_out(vty,"group %d set ap network information successfully\n",id);
					if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL))
						{
							vty_out(vty,"wtp ");					
							for(i=0; i<count; i++)
							{
								if(Wtp_Show_Node == NULL)
								Wtp_Show_Node = WtpList_Head->WtpList_list;
								else 
								Wtp_Show_Node = Wtp_Show_Node->next;
		
								if(Wtp_Show_Node == NULL)
								break;
							
								vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
							}
						
							vty_out(vty," failed.\n");
							dcli_free_WtpList(WtpList_Head);
						}
				}
			else if (ret == GROUP_ID_NOT_EXIST)
				  vty_out(vty,"<error> group id does not exist\n");
		}
		return CMD_SUCCESS;
		
}

#else
DEFUN(set_ap_networkaddr_command_func,
	  set_ap_networkaddr_command_cmd,
	  "set ap network address IP mask MASK gateway GATEWAY fstdns DNS1 snddns DNS2",
	  "wireless-control config\n"
	  "ap network config\n"
	  "ip address\n"
	  "ip address\n"
	  "ip address like 192.168.8.11\n"
	  "subnet mask\n"
	  "subnet mask like 192.168.8.1\n"
	  "gateway address\n"
	  "gateway address like 202.106.0.20\n"
	  "first dns address\n"
	  "dns like 202.106.0.20\n"
	  "secend dns address\n"
	  "dns address like 192.168.8.1\n"	  
	 )
{
	int ret,ret1,ret2;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

    unsigned int ip;
	unsigned int mask;
	unsigned int gateway;
	unsigned int fstdns;
	unsigned int snddns;
	
	unsigned int wtp_id = 0;
	unsigned char myipBuf[WTP_IP_BUFF_LEN] = {0};	
	unsigned char *myipPtr = myipBuf;

	
	wtp_id = (unsigned int)vty->index;
	
	ret = WID_Check_IP_Format((char*)argv[0]);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown ip format\n");
		return CMD_SUCCESS;
	}
	ip = dcli_ip2ulong((char*)argv[0]);


	ret = WID_Check_Mask_Format((char*)argv[1]);
	if(ret != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown mask format\n");
		return CMD_SUCCESS;
	}

	mask = dcli_ip2ulong((char*)argv[1]);



	ret2 = WID_Check_IP_Format((char*)argv[2]);
	if(ret2 != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown gateway format\n");
		return CMD_SUCCESS;
	}
	gateway = dcli_ip2ulong((char*)argv[2]);

	ret2 = WID_Check_IP_Format((char*)argv[3]);
	if(ret2 != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown dns format\n");
		return CMD_SUCCESS;
	}
	fstdns = dcli_ip2ulong((char*)argv[3]);

	ret2 = WID_Check_IP_Format((char*)argv[4]);
	if(ret2 != WID_DBUS_SUCCESS){
		vty_out(vty,"<error> unknown dns format\n");
		return CMD_SUCCESS;
	}
	snddns = dcli_ip2ulong((char*)argv[4]);	
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_AP_IP_GATEWAY_DNS);
		

	/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_AP_IP_GATEWAY_DNS);
					*/
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,
							 DBUS_TYPE_UINT32,&ip,
							 DBUS_TYPE_UINT32,&mask,
							 DBUS_TYPE_UINT32,&gateway,
							 DBUS_TYPE_UINT32,&fstdns,
							 DBUS_TYPE_UINT32,&snddns,							 
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty,"set ap network information successfully\n");
	}
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	
	return CMD_SUCCESS;			
}

#endif
DEFUN(set_wtp_list_dhcp_snooping_enable_func,
		  set_wtp_list_dhcp_snooping_enable_cmd,
		  "set wtp dhcp snooping (enable|disable) base WTPLIST",
		  "ap dhcp snooping config\n"
		  "ap dhcp snooping enable|disable\n"
		  "wtp list "
	 )
{	
	int ret;
	unsigned int wtp_id = 0;
	unsigned int i = 0;
	update_wtp_list *wtplist;
    int policy = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;

	
	if (!strcmp(argv[0],"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[0],"disable"))
	{
		policy = 0;	
	}
	else
	{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}

	wtplist = (struct tag_wtpid_list*)malloc(sizeof(struct tag_wtpid_list));
	wtplist->wtpidlist = NULL ; 	
	wtplist->count = 0;
	
	if (!strcmp(argv[1],"all"))
	{
		;	
	}else{
		ret = parse_wtpid_list((char*)argv[1],&wtplist);
		if(ret != 0)
		{
			vty_out(vty, "%% set wtp list error,like 1,8,9-20,33\n");
			destroy_input_wtp_list(wtplist);
			return CMD_WARNING;
		}
		else
		{
			delsame(wtplist);		
		}
	}
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	
	ret = dcli_wtp_list_set_dhcp_snooping(index,localid,policy,wtplist,dcli_dbus_connection);
	if(ret == 0)
		vty_out(vty,"set wtp dhcp snooping %s base %s successfully\n",argv[0],argv[1]);
	else
		vty_out(vty,"<error>  %d\n",ret);
	
	return CMD_SUCCESS; 

}
#if _GROUP_POLICY

DEFUN(set_wtp_dhcp_snooping_enable_func,
		  set_wtp_dhcp_snooping_enable_cmd,
		  "set wtp dhcp snooping (enable|disable)",
		  "ap dhcp snooping config\n"
		  "ap dhcp snooping enable|disable\n"
	 )
{	
	int i = 0;
	int ret = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int policy = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;


	
	if (!strcmp(argv[0],"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[0],"disable"))
	{
		policy = 0;	
	}
	else
	{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}

	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	
	WtpList_Head = set_wtp_dhcp_snooping_enable_cmd_set_wtp_dhcp_snooping(index,localid,dcli_dbus_connection,type,id,
		policy,&count,&ret);

	if(type==0)
		{
			if(ret == 0)
				vty_out(vty,"set wtp dhcp snooping %s base successfully\n",argv[0]);
			else
				vty_out(vty,"<error>  %d\n",ret);
	
		}

	if(type==1)
		{
			if(ret == 0)
				{
					vty_out(vty,"group %d set wtp dhcp snooping %s base successfully\n",id,argv[0]);
					if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL))
						{
							vty_out(vty,"wtp ");					
							for(i=0; i<count; i++)
							{
								if(Wtp_Show_Node == NULL)
								Wtp_Show_Node = WtpList_Head->WtpList_list;
								else 
								Wtp_Show_Node = Wtp_Show_Node->next;
		
								if(Wtp_Show_Node == NULL)
								break;
							
								vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
							}
						
							vty_out(vty," failed.\n");
							dcli_free_WtpList(WtpList_Head);
						}
				}
			else if (ret == GROUP_ID_NOT_EXIST)
				  vty_out(vty,"<error> group id does not exist\n");
		}
		return CMD_SUCCESS; 

}

#else
DEFUN(set_wtp_dhcp_snooping_enable_func,
		  set_wtp_dhcp_snooping_enable_cmd,
		  "set wtp dhcp snooping (enable|disable)",
		  "ap dhcp snooping config\n"
		  "ap dhcp snooping enable|disable\n"
	 )
{	
	int ret = 0;
	unsigned int wtp_id = 0;
	unsigned int i = 0;
    int policy = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;

	
	if (!strcmp(argv[0],"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[0],"disable"))
	{
		policy = 0;	
	}
	else
	{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}

	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
		wtp_id = 0;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
		wtp_id = 0;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ret = dcli_wtp_set_dhcp_snooping(index,localid,policy,wtp_id,dcli_dbus_connection);
	if(ret == 0)
		vty_out(vty,"set wtp dhcp snooping %s base successfully\n",argv[0]);
	else
		vty_out(vty,"<error>  %d\n",ret);
	
	return CMD_SUCCESS; 

}
#endif
/*fengwenchao,20110221,for trap_ap_rogue_threshold,trap_wtp_ac_discovery_danger_ap,trap_wtp_find_unsafe_essid,trap_wtp_find_wids_attack*/
DEFUN(set_wid_rogue_danger_unsafe_attack_trap_state_func,
          set_wid_rogue_danger_unsafe_attack_trap_state_cmd,
          "set (ap_rogue_threshold|discovery_danger_ap|find_wids_attack) trap (enable|disable)",
          SETT_STR
          "wid_dbus_trap_ap_rogue_threshold"
          "wid_dbus_trap_wtp_ac_discovery_danger_ap"
          "wid_dbus_trap_wtp_find_wids_attack"
          "Enable or disable\n")
{
  int ret = 0;
  unsigned int wid_trap_state = 0;
  unsigned int set_trap_type = 0;//1--ap_rogue_threshold,2--discovery_danger_ap,3--find_unsafe_essid,4--find_wids_attack
  int localid = 1;
  int slot_id = HostSlotId;
  int index = 0;
  unsigned int wtp_id = 0;
   

  if(vty->node == WTP_NODE){
		index = 0;
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index;
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index;
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

  if(!strcmp(argv[0],"ap_rogue_threshold"))
		{
			set_trap_type = 1;
		}
  else if (!strcmp(argv[0],"discovery_danger_ap"))
		{
			
			set_trap_type = 2;
		}
  else if (!strcmp(argv[0],"find_wids_attack"))
		{
			
			set_trap_type = 3;
		}
  else
		{
			vty_out(vty, "Please input ap_rogue_threshold,discovery_danger_ap or find_wids_attack.\n");
			return CMD_FAILURE;
		}


  if (!strcmp(argv[1],"enable"))
		{
			wid_trap_state = 1;
		}
		else if (!strcmp(argv[1],"disable"))
		{
			
			wid_trap_state = 0;
		}
		else
		{
			vty_out(vty, "Please input enable or disable.\n");
			return CMD_FAILURE;
		}

  ret = set_wid_rogue_danger_unsafe_attack_trap_state_cmd_trap(index,localid,set_trap_type,wid_trap_state,dcli_dbus_connection,wtp_id);
  
		if (ret == WID_DBUS_SUCCESS)
		{
			if(1 == set_trap_type)
				{
					vty_out(vty,"set wid_dbus_trap_ap_rogue_threshold %s",(wid_trap_state==1)?"enable":"disable");
				}
			else if(2 == set_trap_type)
				{
					vty_out(vty,"set wid_dbus_trap_wtp_ac_discovery_danger_ap %s",(wid_trap_state==1)?"enable":"disable");
				}
			else if(3 == set_trap_type)
				{
					vty_out(vty,"set wid_dbus_trap_wtp_find_wids_attack %s",(wid_trap_state==1)?"enable":"disable");
				}
		}
		else
		{
            vty_out(vty,"<error>ret = %d\n",ret);
		}
	
		return CMD_SUCCESS;
}
//fengwenchao add end

DEFUN(set_wtp_list_sta_info_report_enable_func,
		  set_wtp_list_sta_info_report_enable_cmd,
		  "set wtp sta info report (enable|disable) base WTPLIST",
		  "sta info report config\n"
		  "sta info report enable|disable\n"
		  "wtp list "
	 )
{	
	int ret;
	unsigned int wtp_id = 0;
	unsigned int i = 0;
	update_wtp_list *wtplist;
    int policy = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;

	
	if (!strcmp(argv[0],"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[0],"disable"))
	{
		policy = 0;	
	}
	else
	{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}

	wtplist = (struct tag_wtpid_list*)malloc(sizeof(struct tag_wtpid_list));
	wtplist->wtpidlist = NULL ; 	
	wtplist->count = 0;
	
	if (!strcmp(argv[1],"all"))
	{
		;	
	}else{
		ret = parse_wtpid_list((char*)argv[1],&wtplist);
		if(ret != 0)
		{
			vty_out(vty, "%% set wtp list error,like 1,8,9-20,33\n");
			destroy_input_wtp_list(wtplist);
			return CMD_WARNING;
		}
		else
		{
			delsame(wtplist);		
		}
	}
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	
	ret = dcli_wtp_list_sta_info_report(index,localid,policy,wtplist,dcli_dbus_connection);
	if(ret == 0)
		vty_out(vty,"set wtp sta info report %s base %s successfully\n",argv[0],argv[1]);
	else
		vty_out(vty,"<error>  %d\n",ret);
	
	return CMD_SUCCESS; 

}
#if _GROUP_POLICY

DEFUN(set_wtp_sta_info_report_enable_func,
		  set_wtp_sta_info_report_enable_cmd,
		  "set wtp sta info report (enable|disable)",
		  "sta info report config\n"
		  "wtp sta info report enable|disable\n"
	 )
{	
	int i = 0;
	int ret = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int policy = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;


	
	if (!strcmp(argv[0],"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[0],"disable"))
	{
		policy = 0;	
	}
	else
	{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}

	if(vty->node == HANSI_NODE){  /*wcl modify for globle varible*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle varible*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		id= (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	WtpList_Head = set_wtp_sta_info_report_enable_cmd_set_wtp_sta_info_report_enable(index,localid,dcli_dbus_connection,type,
		id,policy,&count,&ret);

	if(type==0)
		{
			if(ret == 0)
				vty_out(vty,"set wtp sta info report %s base successfully\n",argv[0]);
			else
				vty_out(vty,"<error>  %d\n",ret);
	
		}

	if(type==1)
		{
			if(ret == 0)
				{
					vty_out(vty,"group %d set wtp sta info report %s base successfully\n",id,argv[0]);
					if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL))
						{
							vty_out(vty,"wtp ");					
							for(i=0; i<count; i++)
							{
								if(Wtp_Show_Node == NULL)
								Wtp_Show_Node = WtpList_Head->WtpList_list;
								else 
								Wtp_Show_Node = Wtp_Show_Node->next;
		
								if(Wtp_Show_Node == NULL)
								break;
							
								vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
							}
						
							vty_out(vty," failed.\n");
							dcli_free_WtpList(WtpList_Head);
						}
				}
			else if (ret == GROUP_ID_NOT_EXIST)
				  vty_out(vty,"<error> group id does not exist\n");
		}
		return CMD_SUCCESS; 		
	}
#else
DEFUN(set_wtp_sta_info_report_enable_func,
		  set_wtp_sta_info_report_enable_cmd,
		  "set wtp sta info report (enable|disable)",
		  "sta info report config\n"
		  "wtp sta info report enable|disable\n"
	 )
{	
	int ret;
	unsigned int wtp_id = 0;
	unsigned int i = 0;
    int policy = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;

	
	if (!strcmp(argv[0],"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[0],"disable"))
	{
		policy = 0;	
	}
	else
	{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}

	if(vty->node == HANSI_NODE){  /*wcl modify for globle varible*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle varible*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		wtp_id = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtp_id = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ret = dcli_wtp_sta_info_report(index,localid,policy,wtp_id,dcli_dbus_connection);
	if(ret == 0)
		vty_out(vty,"set wtp sta info report %s base successfully\n",argv[0]);
	else
		vty_out(vty,"<error>  %d\n",ret);
	
	return CMD_SUCCESS; 

}
#endif
DEFUN(set_wtp_trap_threshold_cmd_func,
	  set_wtp_trap_threshold_cmd,
	  "set wtp (rogueap|rogueterminal|cpu|memory) threshold VALUE",
	  CONFIG_STR
	  "wtp trap threshold information\n"
	  "wtp rogueap trap\n"
	  "wtp rogueterminal trap\n"
	  "wtp cpu trap\n"
	  "wtp memory trap\n"
	  "wtp trap threshold\n"
	  "wtp rogueap rogue terminal :0-50000,cpu and memory :0-100\n"
	 )
	{
		
		DBusMessage *query, *reply; 
		DBusMessageIter  iter;
		DBusError err;
		unsigned int value = 0;
		int ret = WID_DBUS_SUCCESS;
		unsigned int policy = 0;
		unsigned int wtp_id = 0;
		int localid = 1;
		int slot_id = HostSlotId;
		int index = 0;
		if(vty->node == WTP_NODE){
			index = 0;			
			wtp_id = (int)vty->index;
		}else if(vty->node == HANSI_WTP_NODE){
			index = vty->index; 		
			wtp_id = (int)vty->index_sub;
			localid = vty->local;
			slot_id = vty->slotindex;
		}else if(vty->node == LOCAL_HANSI_WTP_NODE){
			index = vty->index; 		
			wtp_id = (int)vty->index_sub;
			localid = vty->local;
			slot_id = vty->slotindex;
		}else if((vty->node == CONFIG_NODE)){
			index = 0;			
			wtp_id = 0;
		}else if((vty->node == HANSI_NODE)){
			index = vty->index; 		
			wtp_id = 0;
			localid = vty->local;
			slot_id = vty->slotindex;
		}else if((vty->node == LOCAL_HANSI_NODE)){
			index = vty->index; 		
			wtp_id = 0;
			localid = vty->local;
			slot_id = vty->slotindex;
		}
		DBusConnection *dcli_dbus_connection = NULL;
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		if (!strcmp(argv[0],"rogueap"))
		{
			policy = 1; 
		}
		else if (!strcmp(argv[0],"rogueterminal"))
		{
			policy = 2; 
		}
		else if (!strcmp(argv[0],"cpu"))
		{
			policy = 3; 
		}
		else if(!strcmp(argv[0],"memory"))
		{
			policy = 4; 
		}
		else
		{
			vty_out(vty,"<error> input patameter only with 'rogueap','rogueterminal','cpu' or 'memory'\n");
			return CMD_SUCCESS;
		}
	
		ret = parse_int_ID((char*)argv[1], &value);
		if(ret != WID_DBUS_SUCCESS){
				vty_out(vty,"<error> unknown id format\n");
				return CMD_SUCCESS;
		}
		if((policy == 1)||(policy == 2))
		{
			if(value >50000/* || value < 0*/){
				vty_out(vty,"<error>parameters error, threshold should be less than 50000\n");
				return CMD_SUCCESS;
			}
		}
		else if((policy == 3))
		{
			if(value > 100  /* || value < 0*/){
				vty_out(vty,"<error> ap cpu use threshold parameters error,should be 0-100\n");
				return CMD_SUCCESS;
			}
		}
		else if(policy == 4)
		{
			if(value > 100 /* || value < 0*/){
				vty_out(vty,"<error> ap memory use threshold parameters error,should be 0-100\n");
				return CMD_SUCCESS;
			}
		}
		ret = dcli_set_ap_rogueap_rogueterminal_cpu_mem_threshold(index,localid,policy,value,wtp_id,dcli_dbus_connection);
		if(ret == 0)
		{
			vty_out(vty," set ap %s threshold %s successfully\n",argv[0],argv[1]);
		}	
		else if (ret == WTP_NOT_IN_RUN_STATE)
		{
			vty_out(vty,"<error> wtp id does not run\n");
		}
		else
		{
			vty_out(vty,"<error>  %d\n",ret);
		}
		return CMD_SUCCESS; 		
	}
DEFUN(show_ap_trap_rogue_ap_ter_cpu_mem_threshold_func,
	  show_ap_trap_rogue_ap_ter_cpu_mem_threshold_cmd,
	  "show wtp trap threshold",
	  SHOW_STR
	  "ap trap information\n"
	  "ap trap threshold information\n"
	 )
{	
	
	int ret = WID_DBUS_SUCCESS;
	int i = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	int wtpid = 0;
	if(vty->node == WTP_NODE){
		index = 0;			
		wtpid = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtpid = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtpid = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if((vty->node == CONFIG_NODE)){
		index = 0;			
		wtpid = 0;
	}else if((vty->node == HANSI_NODE)){
		index = vty->index; 		
		wtpid = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if((vty->node == LOCAL_HANSI_NODE)){
		index = vty->index; 		
		wtpid = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	WID_TRAP_THRESHOLD *DCLI_INFIO = NULL;
	DCLI_INFIO = dcli_show_wtp_trap_threshod(index,localid,wtpid,&ret,dcli_dbus_connection);
	if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if((ret == 0) || (ret == 5)){
		vty_out(vty,"==============================================================================\n");
		if(wtpid==0)
			vty_out(vty,"WTP threshold infomation(all wtp):\n");
		else 
		vty_out(vty,"WTP %d threshold infomation:\n",wtpid);
		vty_out(vty,"==============================================================================\n");
		vty_out(vty,"WTP trap switch:	%s\n",(DCLI_INFIO->trap_switch==1)?"enable":"disable");
		vty_out(vty,"AP rogue ap threshold:	%d\n",DCLI_INFIO->rogue_ap_threshold);
		vty_out(vty,"AP rogue terminal threshold: %d\n",DCLI_INFIO->rogue_termi_threshold);
		vty_out(vty,"AP cpu threshold: %d\n",DCLI_INFIO->cpu);
		vty_out(vty,"AP memory use threshold: %d\n",DCLI_INFIO->memoryuse);
		if(wtpid !=0){
			vty_out(vty,"collecttime: %d\n",DCLI_INFIO->collecttime);
		vty_out(vty,"same channel rssi threshold: %d\n",DCLI_INFIO->samechannelrssi_theshold);
		vty_out(vty,"neighbor channel rssi threshold: %d\n",DCLI_INFIO->neighborchannelrssi_theshold);
	    }
		vty_out(vty,"==============================================================================\n");
	}
	else if(ret == WID_DBUS_ERROR) 
		vty_out(vty,"<error> other error\n");
    else
        vty_out(vty,"ret = %d\n",ret);
	dcli_wtp_free_fun_trap_threshold(DCLI_INFIO);
	return CMD_SUCCESS;
}

DEFUN(set_wtp_trap_collect_cmd_func,
	  set_wtp_trap_collect_cmd,
	  "set wtp collecttime VALUE",
	  CONFIG_STR
	  "wtp collect information\n"
	  "wtp trap collect\n"
	  "wtp collect time: 0~86400\n"
	 )
	{
		DBusMessage *query, *reply; 
		DBusMessageIter  iter;
		DBusError err;
		unsigned int value;
		int ret = WID_DBUS_SUCCESS;
		int policy = 0;
		unsigned int wtp_id = 0;
		if(vty->node == WTP_NODE){
			wtp_id = (unsigned int)vty->index;
		}
		else if((vty->node == CONFIG_NODE)){
			wtp_id = 0;
		}
		
		if (strlen(argv[0]) > 5)
		{
			vty_out(vty, "<error>input collect time's value is too large!!!\n");
			return CMD_SUCCESS;			
		}
		ret = parse_int_ID((char*)argv[0], &value);
		if(ret != WID_DBUS_SUCCESS){
				vty_out(vty,"<error> collect time error\n");
				return CMD_SUCCESS;
		}
		if (value > 86400)
		{
			vty_out(vty, "<error>input collect time's value is too large!!!\n");
			return CMD_SUCCESS;
		}
				
		int localid = 1;
		int slot_id = HostSlotId;
		int index = 0;
		char BUSNAME[PATH_LEN];
		char OBJPATH[PATH_LEN];
		char INTERFACE[PATH_LEN];
		if(vty->node == WTP_NODE){
			index = 0;			
			wtp_id = (int)vty->index;
		}else if(vty->node == HANSI_WTP_NODE){
			index = vty->index; 		
			wtp_id = (int)vty->index_sub;
			localid = vty->local;
			slot_id = vty->slotindex;
		}
		else if(vty->node == LOCAL_HANSI_WTP_NODE){
			index = vty->index; 		
			wtp_id = (int)vty->index_sub;
			localid = vty->local;
			slot_id = vty->slotindex;
		}
		DBusConnection *dcli_dbus_connection = NULL;
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
		ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
		ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
		query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SET_WTP_COLLECT_TIME);

		/*query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_OBJPATH,\
							WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_WTP_COLLECT_TIME);*/
		dbus_error_init(&err);
		dbus_message_append_args(query,
								 DBUS_TYPE_UINT32,&wtp_id,
								 DBUS_TYPE_UINT32,&policy,
								 DBUS_TYPE_UINT32,&value,
								 DBUS_TYPE_INVALID);
		reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
		dbus_message_unref(query);
		if (NULL == reply)
		{
			cli_syslog_info("<error> failed get reply.\n");
			if (dbus_error_is_set(&err))
			{
				cli_syslog_info("%s raised: %s",err.name,err.message);
				dbus_error_free_for_dcli(&err);
			}
			return CMD_SUCCESS;
		}
		dbus_message_iter_init(reply,&iter);
		dbus_message_iter_get_basic(&iter,&ret);
		if(ret == 0)
		{
			vty_out(vty," set trap collect time successfully\n",argv[0]);
		}	
		else
		{
			vty_out(vty,"<error>  %d\n",ret);
		}
		dbus_message_unref(reply);
		return CMD_SUCCESS; 		
	}
#if _GROUP_POLICY

DEFUN(set_wtp_trap_switch_cmd_func,
	  set_wtp_trap_switch_cmd,
	  "set wtp trap switch (enable|disable)",
	  CONFIG_STR
	  "wtp trap threshold information\n"
	  "wtp trap\n"
	  "wtp rogueap rogue terminal cpu mem\n"
	 )
	{
		

		int i = 0;
		int ret = 0;
		int count = 0;
		int localid = 1;
		int slot_id = HostSlotId;
		int index = 0;
		unsigned int policy = 0;
		unsigned int id = 0;
		unsigned int type = 0;
		struct WtpList *WtpList_Head = NULL;
		struct WtpList *Wtp_Show_Node = NULL;
		
		//DBusConnection *dbus_connection = dcli_dbus_connection;


		if (!strcmp(argv[0],"enable"))
		{
			policy = 1; 
		}
		else if (!strcmp(argv[0],"disable"))
		{
			policy = 2; 
		}
		else
		{
			vty_out(vty,"<error> input patameter only with 'enable'or'disable'\n");
			return CMD_SUCCESS;
		}
		if(vty->node == WTP_NODE){
			index = 0;			
			id = (unsigned)vty->index;
		}else if(vty->node == HANSI_WTP_NODE){
			index = vty->index; 		
			id = (int)vty->index_sub;
			type = 0;
			localid = vty->local;
			slot_id = vty->slotindex;
		}else if(vty->node == LOCAL_HANSI_WTP_NODE){
			index = vty->index; 		
			id = (int)vty->index_sub;
			type = 0;
			localid = vty->local;
			slot_id = vty->slotindex;
		}else if(vty->node == AP_GROUP_WTP_NODE){
			index = 0;			
			id = (unsigned)vty->index;
			type = 1;
			vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
		}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
			index = vty->index; 		
			id = (int)vty->index_sub;
			type = 1;
			localid = vty->local;
			slot_id = vty->slotindex;
		}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
			index = vty->index; 		
			id = (int)vty->index_sub;
			type = 1;
			localid = vty->local;
			slot_id = vty->slotindex;
		}
		DBusConnection *dcli_dbus_connection = NULL;
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

		WtpList_Head = set_wtp_trap_switch_cmd_set_wtp_trap_switch(index,localid,dcli_dbus_connection,type,id,policy,&count,&ret);

		if(type==0)
			{
				if(ret == 0)
					{
						vty_out(vty," set wtp %d switch %s successfully\n",id,argv[0]);
					}	
				else
					{
						vty_out(vty,"<error>  %d\n",ret);
					}
			
			}

		if(type==1)
			{
				if(ret == 0)
					{
						vty_out(vty,"group %d set wtp switch %s successfully\n",id,argv[0]);
						if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL))
							{
								vty_out(vty,"wtp ");					
								for(i=0; i<count; i++)
								{
									if(Wtp_Show_Node == NULL)
										Wtp_Show_Node = WtpList_Head->WtpList_list;
									else 
										Wtp_Show_Node = Wtp_Show_Node->next;
		
									if(Wtp_Show_Node == NULL)
										break;
							
									vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
								}
						
							vty_out(vty," failed.\n");
							dcli_free_WtpList(WtpList_Head);
						}
					}
				else if (ret == GROUP_ID_NOT_EXIST)
				   vty_out(vty,"<error> group id does not exist\n");
			}
		return CMD_SUCCESS; 		
	}

#else
DEFUN(set_wtp_trap_switch_cmd_func,
	  set_wtp_trap_switch_cmd,
	  "set wtp trap switch (enable|disable)",
	  CONFIG_STR
	  "wtp trap threshold information\n"
	  "wtp trap\n"
	  "wtp rogueap rogue terminal cpu mem\n"
	 )
	{
		
		DBusMessage *query, *reply; 
		DBusMessageIter  iter;
		DBusError err;
		unsigned int value;
		int ret = WID_DBUS_SUCCESS;
		int policy = 0;
		int localid = 1;
		int slot_id = HostSlotId;
		int index = 0;
		unsigned int wtp_id = 0;
		wtp_id = (unsigned int)vty->index;
		if (!strcmp(argv[0],"enable"))
		{
			policy = 1; 
		}
		else if (!strcmp(argv[0],"disable"))
		{
			policy = 2; 
		}
		else
		{
			vty_out(vty,"<error> input patameter only with 'enable'or'disable'\n");
			return CMD_SUCCESS;
		}
		if(vty->node == WTP_NODE){
			index = 0;			
			wtp_id = (int)vty->index;
		}else if(vty->node == HANSI_WTP_NODE){
			index = vty->index; 		
			wtp_id = (int)vty->index_sub;
			localid = vty->local;
			slot_id = vty->slotindex;
		}else if(vty->node == LOCAL_HANSI_WTP_NODE){
			index = vty->index; 		
			wtp_id = (int)vty->index_sub;
			localid = vty->local;
			slot_id = vty->slotindex;
		}
		DBusConnection *dcli_dbus_connection = NULL;
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		ret = dcli_set_ap_trap_switch_able(index,localid,policy,wtp_id,dcli_dbus_connection);
		if(ret == 0)
		{
			vty_out(vty," set wtp %d switch %s successfully\n",wtp_id,argv[0]);
		}	
		else
		{
			vty_out(vty,"<error>  %d\n",ret);
		}
			
		return CMD_SUCCESS; 		
	}
#endif

/*wcl add*/
#if _GROUP_POLICY

DEFUN(set_wtp_seqnum_switch_cmd_func,
	  set_wtp_seqnum_switch_cmd,
	  "set wtp seqnum check (enable|disable)",
	  CONFIG_STR
	  "wtp \n"
	  "wtp \n"
	  "wtp \n"
	 )
	{
		

		int i = 0;
		int ret = 0;
		int count = 0;
		int localid = 1;
		int slot_id = HostSlotId;
		int index = 0;
		unsigned int policy = 0;
		unsigned int id = 0;
		unsigned int type = 0;
		struct WtpList *WtpList_Head = NULL;
		struct WtpList *Wtp_Show_Node = NULL;
		
		//DBusConnection *dbus_connection = dcli_dbus_connection;


		if (!strcmp(argv[0],"enable"))
		{
			policy = 1; 
		}
		else if (!strcmp(argv[0],"disable"))
		{
			policy = 2; 
		}
		else
		{
			vty_out(vty,"<error> input patameter only with 'enable'or'disable'\n");
			return CMD_SUCCESS;
		}
		if(vty->node == WTP_NODE){
			index = 0;			
			id = (unsigned)vty->index;
		}else if(vty->node == HANSI_WTP_NODE){
			index = vty->index; 		
			id = (int)vty->index_sub;
			type = 0;
			localid = vty->local;
			slot_id = vty->slotindex;
		}else if(vty->node == LOCAL_HANSI_WTP_NODE){
			index = vty->index; 		
			id = (int)vty->index_sub;
			type = 0;
			localid = vty->local;
			slot_id = vty->slotindex;
		}else if(vty->node == AP_GROUP_WTP_NODE){
			index = 0;			
			id = (unsigned)vty->index;
			type = 1;
			vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
		}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
			index = vty->index; 		
			id = (int)vty->index_sub;
			type = 1;
			localid = vty->local;
			slot_id = vty->slotindex;
		}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
			index = vty->index; 		
			id = (int)vty->index_sub;
			type = 1;
			localid = vty->local;
			slot_id = vty->slotindex;
		}
		DBusConnection *dcli_dbus_connection = NULL;
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

		WtpList_Head = set_wtp_seqnum_switch_cmd_set_wtp_seqnum_switch(index,localid,dcli_dbus_connection,type,id,policy,&count,&ret);

		if(type==0)
			{
				if(ret == 0)
					{
						vty_out(vty," set wtp %d switch %s successfully\n",id,argv[0]);
					}	
				else
					{
						vty_out(vty,"<error>  %d\n",ret);
					}
			
			}

		if(type==1)
			{
				if(ret == 0)
					{
						vty_out(vty,"group %d set wtp switch %s successfully\n",id,argv[0]);
						if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL))
							{
								vty_out(vty,"wtp ");					
								for(i=0; i<count; i++)
								{
									if(Wtp_Show_Node == NULL)
										Wtp_Show_Node = WtpList_Head->WtpList_list;
									else 
										Wtp_Show_Node = Wtp_Show_Node->next;
		
									if(Wtp_Show_Node == NULL)
										break;
							
									vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
								}
						
							vty_out(vty," failed.\n");
							dcli_free_WtpList(WtpList_Head);
						}
					}
				else if (ret == GROUP_ID_NOT_EXIST)
				   vty_out(vty,"<error> group id does not exist\n");
			}
		return CMD_SUCCESS; 		
	}

#else
DEFUN(set_wtp_seqnum_switch_cmd_func,
	  set_wtp_seqnum_switch_cmd,
	  "set wtp seqnum check (enable|disable)",
	  CONFIG_STR
	  "wtp \n"
	  "wtp \n"
	  "wtp \n"
	 )
	{
		
		DBusMessage *query, *reply; 
		DBusMessageIter  iter;
		DBusError err;
		unsigned int value;
		int ret = WID_DBUS_SUCCESS;
		int policy = 0;
		int localid = 1;
		int slot_id = HostSlotId;
		int index = 0;
		unsigned int wtp_id = 0;
		wtp_id = (unsigned int)vty->index;
		if (!strcmp(argv[0],"enable"))
		{
			policy = 1; 
		}
		else if (!strcmp(argv[0],"disable"))
		{
			policy = 2; 
		}
		else
		{
			vty_out(vty,"<error> input patameter only with 'enable'or'disable'\n");
			return CMD_SUCCESS;
		}
		if(vty->node == WTP_NODE){
			index = 0;			
			wtp_id = (int)vty->index;
		}else if(vty->node == HANSI_WTP_NODE){
			index = vty->index; 		
			wtp_id = (int)vty->index_sub;
			localid = vty->local;
			slot_id = vty->slotindex;
		}else if(vty->node == LOCAL_HANSI_WTP_NODE){
			index = vty->index; 		
			wtp_id = (int)vty->index_sub;
			localid = vty->local;
			slot_id = vty->slotindex;
		}
		DBusConnection *dcli_dbus_connection = NULL;
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		ret = dcli_set_ap_seqnum_switch_able(index,localid,policy,wtp_id,dcli_dbus_connection);
		if(ret == 0)
		{
			vty_out(vty," set wtp %d switch %s successfully\n",wtp_id,argv[0]);
		}	
		else
		{
			vty_out(vty,"<error>  %d\n",ret);
		}
			
		return CMD_SUCCESS; 		
	}
#endif


/*end*/
#if _GROUP_POLICY

DEFUN(set_ap_sta_wapi_info_report_enable_func,
	  set_ap_sta_wapi_info_report_enable_cmd,
	  "set ap sta wapi info report switch (enable|disable)",
	  CONFIG_STR
	  "wtp config\n"
	  "wtp sta wapi info\n"
	  "wtp sta wapi info\n"
	  "wtp sta wapi info report switch\n"
	  "wtp sta wapi info report switch\n"
	  "wtp sta wapi info report switch enable|disable\n"
	 )
{
	int i = 0;
	int ret = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	int policy = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	if (!strcmp(argv[0],"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[0],"disable"))
	{
		policy = 0;	
	}
	else
	{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}

	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	WtpList_Head = set_ap_sta_wapi_info_report_enable_cmd_set_ap_sta_wapi_info_report_switch(index,localid,dcli_dbus_connection,
		type,id,policy,&count,&ret);

	if(type==0)
		{
			if(ret == -1)
				{
					cli_syslog_info("<error> failed get reply.\n");
				}
			else if(ret == 0)
				{
					vty_out(vty," set wtp %d sta wapi info report switch %s successfully\n",id,argv[0]);
				}
			else if (ret == WTP_ID_NOT_EXIST)
					vty_out(vty,"<error> wtp id does not exist\n");
			else if (ret == WTP_NOT_IN_RUN_STATE)
					vty_out(vty,"<error> wtp id does not run\n");
			else
				{
					vty_out(vty,"<error>  %d\n",ret);
				}
		
		}

	if(type==1)
		{
			if(ret == 0)
				{
					vty_out(vty,"group %d set wtp sta wapi info report switch %s successfully\n",id,argv[0]);
					if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL))
						{
							vty_out(vty,"wtp ");					
							for(i=0; i<count; i++)
								{
									if(Wtp_Show_Node == NULL)
										Wtp_Show_Node = WtpList_Head->WtpList_list;
									else 
										Wtp_Show_Node = Wtp_Show_Node->next;
		
									if(Wtp_Show_Node == NULL)
										break;
							
									vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
								}
						
							vty_out(vty," failed.\n");
							dcli_free_WtpList(WtpList_Head);
						}
				}
			else if (ret == GROUP_ID_NOT_EXIST)
				   vty_out(vty,"<error> group id does not exist\n");
		}
	
	return CMD_SUCCESS;			
}

#else
DEFUN(set_ap_sta_wapi_info_report_enable_func,
	  set_ap_sta_wapi_info_report_enable_cmd,
	  "set ap sta wapi info report switch (enable|disable)",
	  CONFIG_STR
	  "wtp config\n"
	  "wtp sta wapi info\n"
	  "wtp sta wapi info\n"
	  "wtp sta wapi info report switch\n"
	  "wtp sta wapi info report switch\n"
	  "wtp sta wapi info report switch enable|disable\n"
	 )
{
	int ret;
/*
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;*/
	//unsigned int WTPID = 0;
    int policy = 0;
	//WTPID = (unsigned int)vty->index;
	
	if (!strcmp(argv[0],"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[0],"disable"))
	{
		policy = 0;	
	}
	else
	{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}
	/*
	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_STA_WAPI_INFO_SWITCH);
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);

	*/
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	int wtpid = 0;
	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		wtpid = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtpid = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtpid = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ret = dcli_set_ap_sta_wapi_info_report_able(index,localid,policy,wtpid,dcli_dbus_connection);
	/*
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);*/
	if(ret == -1){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == 0)
	{
		vty_out(vty," set wtp %d sta wapi info report switch %s successfully\n",wtpid,argv[0]);
	}
	else if (ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else if (ret == WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp id does not run\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
//	dbus_message_unref(reply);

	
	return CMD_SUCCESS;			
}
#endif
#if _GROUP_POLICY
DEFUN(set_ap_sta_wapi_info_reportinterval_cmd_func,
	  set_ap_sta_wapi_info_reportinterval_cmd,
	  "set ap sta wapi info reportinterval PARAMETER",
	  "wireless-control config\n"
	  "ap sta wapi info\n"
	  "ap sta wapi info\n"
	  "ap sta wapi info\n"
	  "ap sta wapi info reportinterval\n"
	  "ap sta wapi info reportinterval s \n"
	 )
{
	int i = 0;
	int ret = 0;
	int count = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int id = 0;
	unsigned int type = 0;
	unsigned char interval = 0;
	struct WtpList *WtpList_Head = NULL;
	struct WtpList *Wtp_Show_Node = NULL;
	
	//DBusConnection *dbus_connection = dcli_dbus_connection;

    
	
	ret = parse_char_ID((char*)argv[0], &interval);
	if(ret != WID_DBUS_SUCCESS){
            if(ret == WID_ILLEGAL_INPUT){
            	vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
            }
			else{
			vty_out(vty,"<error> unknown id format\n");
			}
			return CMD_SUCCESS;
	}	
	if(interval > 120 || interval == 0){
		vty_out(vty,"<error> ap sta infomation reportinterval error\n");
		return CMD_SUCCESS;
	}
	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == AP_GROUP_WTP_NODE){
		index = 0;			
		id = (unsigned)vty->index;
		type = 1;
		vty_out(vty,"*******type == 1*** AP_GROUP_WTP_NODE*****\n");
	}else if(vty->node == HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_AP_GROUP_WTP_NODE){
		index = vty->index; 		
		id = (int)vty->index_sub;
		type = 1;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	
	WtpList_Head = set_ap_sta_wapi_info_reportinterval_cmd_set_ap_sta_wapi_info_reportinterval(index,localid,dcli_dbus_connection,
		type,id,interval,&count,&ret);

	if(type==0)
		{
			if(ret == -1)
				{
					cli_syslog_info("<error> failed get reply.\n");
				}
			else if(ret == 0)
				{
					vty_out(vty,"set ap sta wapi info reportinterval %s successfully\n",argv[0]);
				}
			else if (ret == WTP_NOT_IN_RUN_STATE)
					vty_out(vty,"<error> wtp is not in run state\n");
			else if(ret == WTP_ID_NOT_EXIST)
					vty_out(vty,"<error> wtp id does not exist\n");
			else
				{
					vty_out(vty,"<error>  %d\n",ret);
				}
		}

	if(type==1)
		{
			if(ret == 0)
				{
					vty_out(vty,"group %d set ap sta wapi info reportinterval %s successfully\n",id,argv[0]);
					if((count != 0)&&(type == 1)&&(WtpList_Head!=NULL))
						{
							vty_out(vty,"wtp ");					
							for(i=0; i<count; i++)
								{
									if(Wtp_Show_Node == NULL)
										Wtp_Show_Node = WtpList_Head->WtpList_list;
									else 
										Wtp_Show_Node = Wtp_Show_Node->next;
		
									if(Wtp_Show_Node == NULL)
										break;
							
									vty_out(vty,"%d ",Wtp_Show_Node->WtpId);					
								}
						
							vty_out(vty," failed.\n");
							dcli_free_WtpList(WtpList_Head);
						}
				}
			else if (ret == GROUP_ID_NOT_EXIST)
				   vty_out(vty,"<error> group id does not exist\n");
		}

	return CMD_SUCCESS;			
}

#else
DEFUN(set_ap_sta_wapi_info_reportinterval_cmd_func,
	  set_ap_sta_wapi_info_reportinterval_cmd,
	  "set ap sta wapi info reportinterval PARAMETER",
	  "wireless-control config\n"
	  "ap sta wapi info\n"
	  "ap sta wapi info\n"
	  "ap sta wapi info\n"
	  "ap sta wapi info reportinterval\n"
	  "ap sta wapi info reportinterval s \n"
	  "ap sta wapi info reportinterval 1-32767\n"
	 )
{
	int ret = 0;
	/*
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;*/

    unsigned int interval = 0;
	//unsigned int wtp_id = 0;
	//wtp_id = (unsigned int)vty->index;
	
	ret = parse_int_ID((char*)argv[0], &interval);
	if(ret != WID_DBUS_SUCCESS){
            if(ret == WID_ILLEGAL_INPUT){
            	vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
            }
			else{
			vty_out(vty,"<error> unknown id format\n");
			}
			return CMD_SUCCESS;
	}	
	if(interval > 32767 || interval == 0){   /*fengwenchao chang 120 to 32767*/
		vty_out(vty,"<error> ap sta infomation reportinterval error,should be 1-32767\n");
		return CMD_SUCCESS;
	}
	
	/*
	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_STA_WAPI_INFO_REPORTINTERVAL);
	
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtp_id,	
							 DBUS_TYPE_BYTE,&interval,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	*/
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	int wtpid = 0;
	if(vty->node == HANSI_NODE){  /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){ /*wcl modify for globle variable*/
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == WTP_NODE){
		index = 0;			
		wtpid = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtpid = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtpid = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ret = dcli_set_ap_sta_wapi_info_report_reportinterval(index,localid,interval,wtpid,dcli_dbus_connection);
	//dbus_message_iter_init(reply,&iter);
	//dbus_message_iter_get_basic(&iter,&ret);
	if(ret == -1){
		printf("<error> failed get reply.\n");
	}
	else if(ret == 0)
	{
		vty_out(vty,"set ap sta wapi info reportinterval %s successfully\n",argv[0]);
	}
	else if (ret == WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp is not in run state\n");
	else if(ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	//dbus_message_unref(reply);

	
	return CMD_SUCCESS;			
}
#endif
/*liuzhenhua append 2010-05-28
talbe 25*/
DEFUN(show_all_wtp_station_information_func,
	  show_all_wtp_station_information_cmd,
	  "show station information of all wtp",
	  "show station information of all wtp\n"
	 )
{
	struct WtpStaInfo * StaHead =NULL;
	struct WtpStaInfo * StaNode =NULL;

	int ret=0;
	unsigned int wtp_num;
	unsigned char * ip;
	int localid = 1;
	int slot_id = HostSlotId;
	int index=0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);	
	StaHead=show_sta_info_of_all_wtp(index,localid,dcli_dbus_connection,&wtp_num,&ret);
	if((StaHead !=NULL)&&(ret == 0)){
		StaNode=StaHead;
		vty_out(vty,"WTPNum:%-5u  \n",wtp_num);
		int radio_support_rate = 44;
		int rssi_support_interval = 17;	
		char strRate[12][6]={"1M","2M","5.5M","6M","9M","11M","12M","18M","24M","36M","48M","54M"};//1-12
		char strSignalStrengthRegion[17][8]={">-10","-10~-19","-20~-39","-40~-49","-50~-59","-60~-64","-65~-67","-68~-70","-71~-73",
				"-74~-76","-77~-79","-80~-82","-83~-85","-86~-88","-89~-91","-92~-94","<-94"};
		while(StaNode){
			int m,mcs_idx;
			ip = &(StaNode->wtpStaIp);
			/*//qiuchen add it 2012.10.31
			time_t now,now_sysrun,wtp_access_time;
			time(&now);
			get_sysruntime(&now_sysrun);
			wtp_access_time = now - (now_sysrun - StaNode->wtpterminalaccesstime_int+StaNode->sta_online_time);
			//end*/
			vty_out(vty,"========================================================================== \n");
            vty_out(vty,"wtpName :					%s  \n",  StaNode->wtpName);
			vty_out(vty,"wtpMacAddr :		 			%-5s  \n",StaNode->wtpMacAddr);
			vty_out(vty,"wtpTerminalMacAddr :				%s  \n",StaNode->wtpTerminalMacAddr);
			vty_out(vty,"wtpStaIp :					%d.%d.%d.%d \n",ip[0],ip[1],ip[2],ip[3]);
			vty_out(vty,"wtpWirelessClientSNR :				%-5lu  \n",StaNode->wtpWirelessClientSNR);
			vty_out(vty,"wtpSendTerminalPackMount :			%-5llu  \n",StaNode->wtpSendTerminalPackMount);
			vty_out(vty,"wtpSendTerminalDataPackMount :			%-5llu  \n",StaNode->wtpSendTerminalDataPackMount);
			vty_out(vty,"wtpSendTerminalByteMount :			%-5llu  \n",StaNode->wtpSendTerminalByteMount);
			vty_out(vty,"wtpTerminalRecvPackMount :			%-5llu  \n",StaNode->wtpTerminalRecvPackMount);
			vty_out(vty,"wtpTerminalRecvDataPackMount :			%-5llu  \n",StaNode->wtpTerminalRecvDataPackMount);
			vty_out(vty,"wtpTerminalRecvByteMount :			%-5llu  \n",StaNode->wtpTerminalRecvByteMount);
			vty_out(vty,"wtpTerminalResPack :				%-5lu  \n",StaNode->wtpTerminalResPack);
			vty_out(vty,"wtpTerminalResByte :				%-5d  \n",StaNode->wtpTerminalResByte);
			vty_out(vty,"wtpTerminalRecvWrongPack :			%-5lu  \n",StaNode->wtpTerminalRecvWrongPack);
			vty_out(vty,"wtpMacTermAddrUsrOnlineTime :			%-5d  \n",StaNode->wtpMacTermAddrUsrOnlineTime);
			vty_out(vty,"wtpMacTermAddrUsrSendSpd :			%-5llu  \n",StaNode->wtpMacTermAddrUsrSendSpd);
			vty_out(vty,"wtpMacTermAddrUsrRecvSpd :			%-5llu  \n",StaNode->wtpMacTermAddrUsrRecvSpd);
			vty_out(vty,"wtpMacTermAddrUsrAllThroughput :		%-5llu  \n",StaNode->wtpMacTermAddrUsrAllThroughput);
			vty_out(vty,"wtpMacTermAPReceivedStaSignalStrength: 		%s  \n",StaNode->wtpMacTermAPReceivedStaSignalStrength);
			vty_out(vty,"wtpMacTermStaTxFragmentedPkts :			%-5llu  \n",StaNode->wtpMacTermStaTxFragmentedPkts);
			vty_out(vty,"wtpMacTermAPTxFragmentedPkts :			%-5llu  \n",StaNode->wtpMacTermAPTxFragmentedPkts);
			vty_out(vty,"wtpBelongAPID :					%-5d  \n",StaNode->wtpBelongAPID);
			vty_out(vty,"wtpterminalaccesstime :				%s  \n",StaNode->wtpterminalaccesstime);
			vty_out(vty,"wtpterminalaccesstime_int :			%u	\n",StaNode->sta_access_time);//qiuchen change it 2012.10.31
			vty_out(vty,"StaAuthType :					%s	\n",dcli_auth_type_to_text(StaNode->security_type));
			vty_out(vty,"User name :					%s	\n",StaNode->identity);
			vty_out(vty, "MAXofRatesetFirstAssociate :                    %-5f\n", (float)(((float)(StaNode->MAXofRateset) ) / 10));
			vty_out(vty, "--------------------------------------------------------------------------\n");
			vty_out(vty, "TxDataRatePkts:\n");
			for(m = 0, mcs_idx = 0; m < radio_support_rate; m ++)
			{
				if(m < 12)
					vty_out(vty, "%5s:%-10u  %s", strRate[m], StaNode->wtp_sta_statistics_info.APStaTxDataRatePkts[m], (m % 4 == 3) ? "\n" : "");
				else
					vty_out(vty, "MCS%02d:%-10u  %s", mcs_idx++, StaNode->wtp_sta_statistics_info.APStaTxDataRatePkts[m], (m % 4 == 3) ? "\n" : "");
			}			
			vty_out(vty, "\nRxDataRatePkts:\n");
			for(m = 0, mcs_idx = 0; m < radio_support_rate; m ++)
			{
				if(m < 12)
					vty_out(vty, "%5s:%-10u  %s", strRate[m], StaNode->wtp_sta_statistics_info.APStaRxDataRatePkts[m], (m % 4 == 3) ? "\n" : "");
				else
					vty_out(vty, "MCS%02d:%-10u  %s", mcs_idx++, StaNode->wtp_sta_statistics_info.APStaRxDataRatePkts[m], (m % 4 == 3) ? "\n" : "");
			}
			vty_out(vty,"\nTxSignalStrengthPkts:\n");
			for(m = 0;m < rssi_support_interval; m ++)
			{
				vty_out(vty, "[%7s]:%-9u %s", strSignalStrengthRegion[m], StaNode->wtp_sta_statistics_info.APStaTxSignalStrengthPkts[m], (m % 4 == 3) ? "\n" : "");
			}
			vty_out(vty, "\n");
			vty_out(vty, "--------------------------------------------------------------------------\n");
			vty_out(vty,"========================================================================== \n");
			StaNode=StaNode->next;
			}
		dcli_free_wtp_sta_info_head(StaHead);
		}
	else if (ret == 0){
		vty_out(vty,"<error> There is no sta now\n");
		}
	else if (ret == ASD_DBUS_ERROR){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == ASD_WTP_NOT_EXIST){
		vty_out(vty,"<error> There is no WTP now.\n");
	}
	else{
		vty_out(vty,"<error> ret = %d\n",ret);
		}
	return CMD_SUCCESS;

}

/*liuzhenhua append 2010-05-27
talbe 24*/
DEFUN(show_all_wtp_wlan_data_pkts_information_func,
	  show_all_wtp_wlan_data_pkts_information_cmd,
	  "show wlan datapkts information of all wtp",
	  "show wlan datapkts information of all wtp\n"
	 )
{
	struct WtpWlanDataPktsInfo* WtpHead = NULL;
	struct WtpWlanDataPktsInfo* WtpNode = NULL;
	struct WlanDataPktsInfo* WlanNode = NULL;

	int ret=0;
	unsigned int wtp_num;
	int localid = 1;
	int slot_id = HostSlotId;
	int index=0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	WtpHead=show_WlanDataPkts_Info_of_all_wtp(index,localid,dcli_dbus_connection,&wtp_num,&ret);
	if((WtpHead!=NULL)&&(ret == 0)){
		WtpNode=WtpHead;
		vty_out(vty,"WTPNum:%-5d  \n",wtp_num);
		while(WtpNode){
			vty_out(vty,"========================================================================== \n");
			vty_out(vty,"WTPID:   %-5d  \n",WtpNode->wtpCurrID);
			vty_out(vty,"WTP MAC:       %s\n",WtpNode->wtpMacAddr);
			vty_out(vty,"wlan_num:   %-5d  \n",WtpNode->wlan_num);
			WlanNode=WtpNode->wlan_list;
			while(WlanNode){
				vty_out(vty,"-------------------------------------------------------------------------\n");
				vty_out(vty,"\t wlanCurrID:							%-5lu  \n",WlanNode->wlanCurrID);
				vty_out(vty,"\t wtpSsidSendTermAllByte:				%-5llu  \n",WlanNode->wtpSsidSendTermAllByte);
				vty_out(vty,"\t wtpSsidRecvTermAllPack:				%-5lu  \n",WlanNode->wtpSsidRecvTermAllPack);
				vty_out(vty,"\t wtpSsidRecvTermAllByte:				%-5llu  \n",WlanNode->wtpSsidRecvTermAllByte);
				vty_out(vty,"\t wtpSsidWirelessMacRecvDataRightByte:	%-5llu  \n",WlanNode->wtpSsidWirelessMacRecvDataRightByte);
				vty_out(vty,"\t wtpSsidWirelessMacSendDataRightByte:	%-5llu  \n",WlanNode->wtpSsidWirelessMacSendDataRightByte);
				vty_out(vty,"\t wtpSsidWiredMacRecvDataWrongPack:	%-5lu  \n",WlanNode->wtpSsidWiredMacRecvDataWrongPack);
				vty_out(vty,"\t wtpNetWiredRecvPack:				%-5lu  \n",WlanNode->wtpNetWiredRecvPack);
				vty_out(vty,"\t wtpUsrWirelessMacRecvDataPack:				%-5lu  \n",WlanNode->wtpUsrWirelessMacRecvDataPack);
				vty_out(vty,"\t wtpUsrWirelessMacSendDataPack:				%-5lu  \n",WlanNode->wtpUsrWirelessMacSendDataPack);
				vty_out(vty,"\t wtpNetWiredSendPack:				%-5lu  \n",WlanNode->wtpNetWiredSendPack);
				vty_out(vty,"\t WtpWirelessSendFailPkts:			%-5lu  \n",WlanNode->WtpWirelessSendFailPkts);
				vty_out(vty,"\t wtpWirelessResendPkts:				%-5lu  \n",WlanNode->wtpWirelessResendPkts);
				vty_out(vty,"\t wtpWirelessWrongPktsRate:		%s  \n",WlanNode->wtpWirelessWrongPktsRate);
				vty_out(vty,"\t wtpWirelessSendBroadcastMsgNum:		%-5lu  \n",WlanNode->wtpWirelessSendBroadcastMsgNum);
				vty_out(vty,"\t wtpStaUplinkMaxRate:				%-5lu  \n",WlanNode->wtpStaUplinkMaxRate);
				vty_out(vty,"\t wtpStaDwlinkMaxRate:				%-5lu  \n",WlanNode->wtpStaDwlinkMaxRate);
				vty_out(vty,"\t wtpNetWiredRecvErrPack:				%-5lu  \n",WlanNode->wtpNetWiredRecvErrPack);
				vty_out(vty,"\t wtpNetWiredRecvRightPack:			%-5lu  \n",WlanNode->wtpNetWiredRecvRightPack);
				vty_out(vty,"\t wtpNetWiredRecvByte:				%-5llu  \n",WlanNode->wtpNetWiredRecvByte);
				vty_out(vty,"\t wtpNetWiredSendByte:				%-5llu  \n",WlanNode->wtpNetWiredSendByte);
				vty_out(vty,"\t wtpNetWiredSendErrPack:				%-5lu  \n",WlanNode->wtpNetWiredSendErrPack);
				vty_out(vty,"\t wtpNetWiredSendRightPack:			%-5lu  \n",WlanNode->wtpNetWiredSendRightPack);
				vty_out(vty,"\t wtpSsidSendDataAllPack:				%-5lu  \n",WlanNode->wtpSsidSendDataAllPack);
				vty_out(vty,"\t wtpNetWiredRxWrongPktsRate:		%s  \n",WlanNode->wtpNetWiredRxWrongPktsRate);
				vty_out(vty,"\t wtpNetWiredTxWrongPktsRate:		%s  \n",WlanNode->wtpNetWiredTxWrongPktsRate);
				vty_out(vty,"\t wtpSsidTxDataDropPkts:				%-5u  \n",WlanNode->wtpSsidTxDataDropPkts);
				vty_out(vty,"\t wtpSsidRxDataDropPkts:				%-5u  \n",WlanNode->wtpSsidRxDataDropPkts);
				vty_out(vty,"-------------------------------------------------------------------------\n");
				WlanNode=WlanNode->next;
				}
			vty_out(vty,"========================================================================== \n");
			WtpNode=WtpNode->next;
			}
		dcli_free_wtp_wlan_data_pktsinfo_head(WtpHead);
		}
	else if (ret == WID_DBUS_ERROR){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == WTP_ID_NOT_EXIST){
		vty_out(vty,"<error> There is no WTP now.\n");
	}
	else{
		vty_out(vty,"<error> ret = %d\n",ret);
	}

	
	return CMD_SUCCESS;
}

/*add  for showting wtp terminal information
*liuzhenhua add 2010-07-8 
table 23	*/
DEFUN(show_all_wtp_terminal_information_func,
	  show_all_wtp_terminal_information_cmd,
	  "show terminal information of all wtp",
	  SHOW_STR
	  "Display terminal information of all wtps\n"
	  "List wtp terminal information\n"
	  "by wtp display terminal information\n"
	 )
{
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	struct WtpTerminalInfo *WtpHead = NULL;
	struct WtpTerminalInfo *WtpShowNode = NULL;
	struct Wtp_TerminalInfo *WtpTermNode=NULL;
	
	int ret=0;
	int i=0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index=0;
	unsigned int num = 0;
	unsigned char *ip = NULL;

	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	
	WtpHead = show_terminal_info_of_all_wtp(index,localid,dcli_dbus_connection, &num, &ret);
	if((WtpHead!=NULL)&&(ret == 0)){	
		WtpShowNode=WtpHead;
		vty_out(vty,"WTPNum:%-5d  \n",num);
		do{	
			vty_out(vty,"========================================================================== \n");
			vty_out(vty,"WTPID:   %-5d  \n",WtpShowNode->wtpCurrID);
			vty_out(vty,"WTP MAC:       %s\n",WtpShowNode->wtpMacAddr);
			vty_out(vty,"sta_num:   %-5d  \n",WtpShowNode->sta_num);
			WtpTermNode=WtpShowNode->terminalInfo_list;
			while(WtpTermNode){
				vty_out(vty,"-------------------------------------------------------------------------\n");
				ip = &(WtpTermNode->wtpStaIPAddress);			
				vty_out(vty,"\tstaqSecID:   %-5d  \n",WtpTermNode->staqSecID);
				vty_out(vty,"\tstaqWlanID:   %-5d  \n",WtpTermNode->staqWlanID);
				vty_out(vty,"\tstaqRadioID:   %-5d  \n",WtpTermNode->staqRadioID);			
				vty_out(vty,"\tTerminal MAC:  %s\n",WtpTermNode->wtpTerminalMacAddr);
				vty_out(vty,"\twtpEndWMMSta:  %-5d  \n",WtpTermNode->wtpEndWMMSta);
				vty_out(vty,"\twtpStaIPAddress: %d.%d.%d.%d  \n",ip[0],ip[1],ip[2],ip[3]);
				//vty_out(vty,"\twtpStaRadioMode: %-5d \n",WtpTermNode->wtpStaRadioMode);
				vty_out(vty,"\twtpStaRadioMode:	");
				/*fengwenchao modify begin  20111109 for GM*/
				int flag_an = 0;int flag_gn = 0;
				if(WtpTermNode->wtpStaRadioMode != 0){				
					vty_out(vty,"11");			
					if((WtpTermNode->wtpStaRadioMode&IEEE80211_11A) > 0)
						vty_out(vty,"a");	
					if((WtpTermNode->wtpStaRadioMode&IEEE80211_11AN) > 0)
					{
						vty_out(vty,"an");
						flag_an = 1;
					}					
					if((WtpTermNode->wtpStaRadioMode&IEEE80211_11B) > 0)
						vty_out(vty,"b");
					if((WtpTermNode->wtpStaRadioMode&IEEE80211_11G) > 0)
						vty_out(vty,"g");
					if((WtpTermNode->wtpStaRadioMode&IEEE80211_11GN) > 0)
					{
						vty_out(vty,"gn");	
						flag_gn = 1;
					}					
					if(((WtpTermNode->wtpStaRadioMode&IEEE80211_11N) > 0)&&(flag_an == 0)&&(flag_gn == 0))
						vty_out(vty,"n");
				}
				/*fengwenchao modify  end*/
				vty_out(vty,"\n");
				vty_out(vty,"\twtpStaRadioChannel: %-5d  \n",WtpTermNode->wtpStaRadioChannel);
				vty_out(vty,"\twtpStaRxRates: %-5g  \n",WtpTermNode->wtpAPTxRates/10.0);    //fengwenchao modify 20110228
				vty_out(vty,"\twtpStaTxRates: %-5g  \n",WtpTermNode->wtpAPRxRates/10.0);    //fengwenchao modify 20110228
				vty_out(vty,"\twtpStaPowerSaveMode: %-5d  \n",WtpTermNode->wtpStaPowerSaveMode);
				vty_out(vty,"\twtpStaVlanId:  %-5d \n",WtpTermNode->wtpStaVlanId);
				vty_out(vty,"\twtpStaSSIDName: %s  \n",WtpTermNode->wtpStaSSIDName);
				vty_out(vty,"\twtpStaAuthenMode:  %-5d \n",WtpTermNode->wtpStaAuthenMode);
				vty_out(vty,"\twtpStaSecurityCiphers:  %-5d \n",WtpTermNode->wtpStaSecurityCiphers);
				vty_out(vty,"\twtpAutenModel:  %-5d \n",WtpTermNode->wtpAutenModel);
				vty_out(vty,"\tencryption_type:  %-5d \n",WtpTermNode->encryption_type);
				vty_out(vty,"-------------------------------------------------------------------------\n");
				WtpTermNode = WtpTermNode->next;
				}
			vty_out(vty,"========================================================================== \n");
			WtpShowNode=WtpShowNode->next;
		}while(WtpShowNode != NULL);
		
		dcli_free_wtp_terminalinfo_head(WtpHead);
		
	}
	else if (ret == ASD_DBUS_ERROR){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == ASD_WTP_NOT_EXIST){
		vty_out(vty,"<error> There is no WTP now.\n");
	}
	else{
		vty_out(vty,"<error> ret = %d\n",ret);
	}
	return CMD_SUCCESS;
}

/**************************************for mib optimize begin***********************************/
/*add  for showting wtp basic information by nl*/
DEFUN(show_all_wtp_basic_information_func,
	  show_all_wtp_basic_information_cmd,
	  "show basic information of all_wtp [remote] [local] [PARAMETER]",
	  SHOW_STR
	  "Display basic information of all wtps\n"
	  "List wtp basic information\n"
	  "of all wtp\n"
	  "by wtp display basic information\n"
	  "'remote' or 'local' hansi\n"
	  "'remote' or 'local' hansi\n"
	  "slotid-instid\n"
	 )
{
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	struct WtpBasicInfo *WtpHead = NULL;
	struct WtpBasicInfo *WtpShowNode = NULL;
	int ret=0;
	int i=0;
	unsigned int num = 0;
	int hour = 0,min = 0,sec = 0;
	int hour2 = 0,min2 = 0,sec2 = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	int profile = 0;
	int instRun = 0;
	int flag = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	if((argc == 1)||(argc == 3)){
		vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
		return CMD_SUCCESS;
	}
	if(argc == 2){
		if (!strcmp(argv[0],"remote")){
			localid = 0;
		}else if(!strcmp(argv[0],"local")){
			localid = 1;
		}else{
			vty_out(vty,"parameter should be 'remote' or 'local'\n");
			return CMD_SUCCESS;
		}
		
		if((!strcmp(argv[0],"remote"))&&(!strcmp(argv[1],"local"))){
			vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
			return CMD_SUCCESS;
		}
		
		ret = parse_slot_hansi_id((char*)argv[1],&slot_id,&profile);
		if(ret != WID_DBUS_SUCCESS){
			slot_id = HostSlotId;
			flag = 1;
			ret = parse_int_ID((char*)argv[1], &profile);
			if(ret != WID_DBUS_SUCCESS){
				if(ret == WID_ILLEGAL_INPUT){
					vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
				}
				else{
					vty_out(vty,"<error> unknown id format\n");
				}
				return CMD_WARNING;
			}	
		}
		if(distributFag == 0){
			if(slot_id != 0){
				vty_out(vty,"<error> slot id should be 0\n");
				return CMD_WARNING;
			}	
		}else if(flag == 1){
			slot_id = HostSlotId;
		}
		if(slot_id >= MAX_SLOT_NUM || slot_id < 0){
			vty_out(vty,"<error> slot id should be 1 to %d\n",MAX_SLOT_NUM-1);
			return CMD_WARNING;
		}	
		if(profile >= MAX_INSTANCE || profile == 0){
			vty_out(vty,"<error> hansi id should be 1 to %d\n",MAX_INSTANCE-1);
			return CMD_WARNING;
		}
		instRun = dcli_hmd_hansi_is_running(vty,slot_id,localid,profile);
		if (INSTANCE_NO_CREATED == instRun) {
			vty_out(vty,"<error> the instance %s %d-%d is not running\n",((localid == 1)?"local-hansi":"hansi"),slot_id,profile);
			return CMD_WARNING;
		}
		
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		if(localid == 0)
			goto hansi_parameter;
		else if(localid == 1)
			goto local_hansi_parameter; 
	}

	if(vty->node != VIEW_NODE){
		WtpHead = show_basic_info_of_all_wtp(index,localid,dcli_dbus_connection, &num, &ret);

		if((WtpHead!=NULL)&&(ret == 0)){
			vty_out(vty,"WTPNum:%-5d  \n",num);
			vty_out(vty,"========================================================================== \n");
			for (i = 0; i < num; i++) {	
				if(WtpShowNode == NULL)
					WtpShowNode = WtpHead->WtpBasicInfo_list;
				else 
					WtpShowNode = WtpShowNode->next;

				if(WtpShowNode == NULL)
					break;
				
				vty_out(vty,"WTPID:%-5d  \n",WtpShowNode->wtpCurrID);
				//vty_out(vty,"WTP NAME : %-20s  \t\t",WtpShowNode->wtpDevName,WtpShowNode->wtpSeriesNum,WtpShowNode->wtpModel);
				vty_out(vty,"WTP NAME : %-20s  \t\t",WtpShowNode->wtpDevName);
				vty_out(vty,"WTP SN : %-20s  \n",WtpShowNode->wtpSeriesNum);
				vty_out(vty,"WTP Model : %-20s  \t\t",WtpShowNode->wtpModel);
				
				vty_out(vty,"wtpProduct:%-5s \n",WtpShowNode->wtpProduct);
				vty_out(vty,"wtpSysSoftProductor: %-7s \t\t\t",WtpShowNode->wtpSysSoftProductor);
				vty_out(vty,"wtpPosInfo: %-7s \n",WtpShowNode->wtpPosInfo);
				vty_out(vty,"ElectrifyRegisterCircle:	%d \t\t",WtpShowNode->ElectrifyRegisterCircle);
				
				if(WtpShowNode->wtpOnlineTime == 0)
				{
					vty_out(vty,"Access Time:	Not Accessed\n");
					vty_out(vty,"Run Time:	NONE\t\t\t\t");
					vty_out(vty,"Mib Run Time:	NONE\n");
				}

				else{
					hour=WtpShowNode->wtpUpTime/3600;
					min=(WtpShowNode->wtpUpTime-hour*3600)/60;
					sec=(WtpShowNode->wtpUpTime-hour*3600)%60;

					hour2=WtpShowNode->Mib_wtpUpTime/3600;
					min2=(WtpShowNode->Mib_wtpUpTime-hour2*3600)/60;
					sec2=(WtpShowNode->Mib_wtpUpTime-hour2*3600)%60;
				
					vty_out(vty,"Access Time:%s",ctime(&WtpShowNode->wtpOnlineTime));
					vty_out(vty,"Run Time:%02d:%02d:%02d \t\t\t\t",hour,min,sec);
					vty_out(vty,"Mib Run Time:	%02d:%02d:%02d \n",hour2,min2,sec2);
				}

				vty_out(vty,"HW Version:	%s \t\t\t\t",WtpShowNode->wtpSysVersion);
				vty_out(vty,"SW Version:	%s \n",WtpShowNode->wtpVersionInfo);
				vty_out(vty,"SW Name:	%s \t\t",WtpShowNode->wtpSysSoftName);
				vty_out(vty,"WTP MAC: ");
				vty_out(vty,"%02X:%02X:%02X:%02X:%02X:%02X \n",
				WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
				WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
				
				vty_out(vty,"WTP DevTypeNum : %-20s  \t\t",WtpShowNode->wtpDevTypeNum);
				vty_out(vty,"acNeighbordeadTimes : %-5u  \n",WtpShowNode->acNeighbordeadTimes);
				vty_out(vty,"WTP longitude :%-16s	\t\t", WtpShowNode->longitude);
				vty_out(vty,"WTP latitude :%-16s\n", WtpShowNode->latitude);
				vty_out(vty,"WTP power mode :%-10s\t\t\t", WtpShowNode->power_mode == 0 ? "unknown" : (WtpShowNode->power_mode == 1 ? "AC" : "DC"));
				vty_out(vty,"WTP forward mode :%-10s\n", WtpShowNode->forward_mode == 0 ? "unknown" : (WtpShowNode->forward_mode == 1 ?"thin mode" : "fat mode"));
				vty_out(vty,"WTP manufacture date :%-20s\n", WtpShowNode->manufacture_date);
				vty_out(vty,"-------------------------------------------------------------------------\n");
				
			}
			
			vty_out(vty,"========================================================================== \n");
		
		}

		else if (ret == WID_DBUS_ERROR){
			vty_out(vty,"<error> failed get reply.\n");
		}
		else if(ret == WTP_ID_NOT_EXIST){
			vty_out(vty,"<error> There is no WTP now.\n");
		}
		else{
			vty_out(vty,"<error> ret = %d\n",ret);
		}
		
		dcli_free_WtpBasicInfo(WtpHead);
	}


	if(vty->node == VIEW_NODE){
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 0;
			
			//for remote hansi info
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,0,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}

	 	hansi_parameter:
				WtpHead = show_basic_info_of_all_wtp(profile,localid,dcli_dbus_connection, &num, &ret);

				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"hansi %d-%d\n",slot_id,profile);
				vty_out(vty,"------------------------------------------------------------\n");
				if((WtpHead!=NULL)&&(ret == 0)){
					vty_out(vty,"WTPNum:%-5d  \n",num);
					vty_out(vty,"========================================================================== \n");
					WtpShowNode = NULL;
					for (i = 0; i < num; i++) {	
						if(WtpShowNode == NULL)
							WtpShowNode = WtpHead->WtpBasicInfo_list;
						else 
							WtpShowNode = WtpShowNode->next;

						if(WtpShowNode == NULL)
							break;
						
						vty_out(vty,"WTPID:%-5d  \n",WtpShowNode->wtpCurrID);
						vty_out(vty,"WTP NAME : %-20s  \t\t",WtpShowNode->wtpDevName,WtpShowNode->wtpSeriesNum,WtpShowNode->wtpModel);
						vty_out(vty,"WTP SN : %-20s  \n",WtpShowNode->wtpSeriesNum);
						vty_out(vty,"WTP Model : %-20s  \t\t",WtpShowNode->wtpModel);
						
						vty_out(vty,"wtpProduct:%-5s \n",WtpShowNode->wtpProduct);
						vty_out(vty,"wtpSysSoftProductor: %-7s \t\t\t",WtpShowNode->wtpSysSoftProductor);
						vty_out(vty,"wtpPosInfo: %-7s \n",WtpShowNode->wtpPosInfo);
						vty_out(vty,"ElectrifyRegisterCircle:	%d \t\t",WtpShowNode->ElectrifyRegisterCircle);
						
						if(WtpShowNode->wtpOnlineTime == 0)
						{
							vty_out(vty,"Access Time:	Not Accessed\n");
							vty_out(vty,"Run Time:	NONE\t\t\t\t");
							vty_out(vty,"Mib Run Time:	NONE\n");
						}

						else{
							hour=WtpShowNode->wtpUpTime/3600;
							min=(WtpShowNode->wtpUpTime-hour*3600)/60;
							sec=(WtpShowNode->wtpUpTime-hour*3600)%60;

							hour2=WtpShowNode->Mib_wtpUpTime/3600;
							min2=(WtpShowNode->Mib_wtpUpTime-hour2*3600)/60;
							sec2=(WtpShowNode->Mib_wtpUpTime-hour2*3600)%60;
						
							vty_out(vty,"Access Time:%s",ctime(&WtpShowNode->wtpOnlineTime));
							vty_out(vty,"Run Time:%02d:%02d:%02d \t\t\t\t",hour,min,sec);
							vty_out(vty,"Mib Run Time:	%02d:%02d:%02d \n",hour2,min2,sec2);
						}

						vty_out(vty,"HW Version:	%s \t\t\t\t",WtpShowNode->wtpSysVersion);
						vty_out(vty,"SW Version:	%s \n",WtpShowNode->wtpVersionInfo);
						vty_out(vty,"SW Name:	%s \t\t",WtpShowNode->wtpSysSoftName);
						vty_out(vty,"WTP MAC: ");
						vty_out(vty,"%02X:%02X:%02X:%02X:%02X:%02X \n",
						WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
						WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
						
						vty_out(vty,"WTP DevTypeNum : %-20s  \t\t",WtpShowNode->wtpDevTypeNum);
						vty_out(vty,"acNeighbordeadTimes : %-5u  \n",WtpShowNode->acNeighbordeadTimes);
						vty_out(vty,"-------------------------------------------------------------------------\n");
						
					}
				}

				else if (ret == WID_DBUS_ERROR){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == WTP_ID_NOT_EXIST){
					vty_out(vty,"<error> There is no WTP now.\n");
				}
				else{
					vty_out(vty,"<error> ret = %d\n",ret);
				}
				
				dcli_free_WtpBasicInfo(WtpHead);
				vty_out(vty,"==============================================================================\n");
				if(argc == 2){
					return CMD_SUCCESS;
				}
			}
		}

	//for local hansi info
	for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		localid = 1;
		
		for (profile = 1; profile < MAX_INSTANCE; profile++) 
		{
			instRun = dcli_hmd_hansi_is_running(vty,slot_id,1,profile);
			if (INSTANCE_NO_CREATED == instRun) {
				continue;
			}
	
	 local_hansi_parameter:
			WtpHead = show_basic_info_of_all_wtp(profile,localid,dcli_dbus_connection, &num, &ret);

			vty_out(vty,"==============================================================================\n");
			vty_out(vty,"local hansi %d-%d\n",slot_id,profile);
			vty_out(vty,"------------------------------------------------------------\n");
			if((WtpHead!=NULL)&&(ret == 0)){
				vty_out(vty,"WTPNum:%-5d  \n",num);
				vty_out(vty,"========================================================================== \n");
				WtpShowNode = NULL;
				for (i = 0; i < num; i++) {	
					if(WtpShowNode == NULL)
						WtpShowNode = WtpHead->WtpBasicInfo_list;
					else 
						WtpShowNode = WtpShowNode->next;

					if(WtpShowNode == NULL)
						break;
					
					vty_out(vty,"WTPID:%-5d  \n",WtpShowNode->wtpCurrID);
					vty_out(vty,"WTP NAME : %-20s  \t\t",WtpShowNode->wtpDevName,WtpShowNode->wtpSeriesNum,WtpShowNode->wtpModel);
					vty_out(vty,"WTP SN : %-20s  \n",WtpShowNode->wtpSeriesNum);
					vty_out(vty,"WTP Model : %-20s  \t\t",WtpShowNode->wtpModel);
					
					vty_out(vty,"wtpProduct:%-5s \n",WtpShowNode->wtpProduct);
					vty_out(vty,"wtpSysSoftProductor: %-7s \t\t\t",WtpShowNode->wtpSysSoftProductor);
					vty_out(vty,"wtpPosInfo: %-7s \n",WtpShowNode->wtpPosInfo);
					vty_out(vty,"ElectrifyRegisterCircle:	%d \t\t",WtpShowNode->ElectrifyRegisterCircle);
					
					if(WtpShowNode->wtpOnlineTime == 0)
					{
						vty_out(vty,"Access Time:	Not Accessed\n");
						vty_out(vty,"Run Time:	NONE\t\t\t\t");
						vty_out(vty,"Mib Run Time:	NONE\n");
					}

					else{
						hour=WtpShowNode->wtpUpTime/3600;
						min=(WtpShowNode->wtpUpTime-hour*3600)/60;
						sec=(WtpShowNode->wtpUpTime-hour*3600)%60;

						hour2=WtpShowNode->Mib_wtpUpTime/3600;
						min2=(WtpShowNode->Mib_wtpUpTime-hour2*3600)/60;
						sec2=(WtpShowNode->Mib_wtpUpTime-hour2*3600)%60;
					
						vty_out(vty,"Access Time:%s",ctime(&WtpShowNode->wtpOnlineTime));
						vty_out(vty,"Run Time:%02d:%02d:%02d \t\t\t\t",hour,min,sec);
						vty_out(vty,"Mib Run Time:	%02d:%02d:%02d \n",hour2,min2,sec2);
					}

					vty_out(vty,"HW Version:	%s \t\t\t\t",WtpShowNode->wtpSysVersion);
					vty_out(vty,"SW Version:	%s \n",WtpShowNode->wtpVersionInfo);
					vty_out(vty,"SW Name:	%s \t\t",WtpShowNode->wtpSysSoftName);
					vty_out(vty,"WTP MAC: ");
					vty_out(vty,"%02X:%02X:%02X:%02X:%02X:%02X \n",
					WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
					WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
					
					vty_out(vty,"WTP DevTypeNum : %-20s  \t\t",WtpShowNode->wtpDevTypeNum);
					vty_out(vty,"acNeighbordeadTimes : %-5u  \n",WtpShowNode->acNeighbordeadTimes);
					vty_out(vty,"-------------------------------------------------------------------------\n");
					
				}
			}

			else if (ret == WID_DBUS_ERROR){
				cli_syslog_info("<error> failed get reply.\n");
			}
			else if(ret == WTP_ID_NOT_EXIST){
				vty_out(vty,"<error> There is no WTP now.\n");
			}
			else{
				vty_out(vty,"<error> ret = %d\n",ret);
			}
			
			dcli_free_WtpBasicInfo(WtpHead);
			vty_out(vty,"==============================================================================\n");
			if(argc == 2){
				return CMD_SUCCESS;
			}
			}
		}
	}
	
	return CMD_SUCCESS;	
}

/*add  for showting wtp collect information by nl*/
DEFUN(show_all_wtp_collect_information_func,
	  show_all_wtp_collect_information_cmd,
	  "show collect information of all_wtp [remote] [local] [PARAMETER]",
	  SHOW_STR
	  "Display collect information of all wtps\n"
	  "List wtp collect information\n"
	  "of all wtp\n"
	  "by wtp display collect information\n"
	  "'remote' or 'local' hansi\n"
	  "'remote' or 'local' hansi\n"
	  "slotid-instid\n"
	 )
{
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	struct WtpCollectInfo *WtpHead = NULL;
	struct WtpCollectInfo *WtpShowNode = NULL;
	int ret=0;
	int i=0;
	unsigned int num = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	int profile = 0;
	int instRun = 0;
	int flag = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	if((argc == 1)||(argc == 3)){
		vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
		return CMD_SUCCESS;
	}
	if(argc == 2){
		if (!strcmp(argv[0],"remote")){
			localid = 0;
		}else if(!strcmp(argv[0],"local")){
			localid = 1;
		}else{
			vty_out(vty,"parameter should be 'remote' or 'local'\n");
			return CMD_SUCCESS;
		}
		
		if((!strcmp(argv[0],"remote"))&&(!strcmp(argv[1],"local"))){
			vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
			return CMD_SUCCESS;
		}
		
		ret = parse_slot_hansi_id((char*)argv[1],&slot_id,&profile);
		if(ret != WID_DBUS_SUCCESS){
			slot_id = HostSlotId;
			flag = 1;
			ret = parse_int_ID((char*)argv[1], &profile);
			if(ret != WID_DBUS_SUCCESS){
				if(ret == WID_ILLEGAL_INPUT){
					vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
				}
				else{
					vty_out(vty,"<error> unknown id format\n");
				}
				return CMD_WARNING;
			}	
		}
		if(distributFag == 0){
			if(slot_id != 0){
				vty_out(vty,"<error> slot id should be 0\n");
				return CMD_WARNING;
			}	
		}else if(flag == 1){
			slot_id = HostSlotId;
		}
		if(slot_id >= MAX_SLOT_NUM || slot_id < 0){
			vty_out(vty,"<error> slot id should be 1 to %d\n",MAX_SLOT_NUM-1);
			return CMD_WARNING;
		}	
		if(profile >= MAX_INSTANCE || profile == 0){
			vty_out(vty,"<error> hansi id should be 1 to %d\n",MAX_INSTANCE-1);
			return CMD_WARNING;
		}
		instRun = dcli_hmd_hansi_is_running(vty,slot_id,localid,profile);
		if (INSTANCE_NO_CREATED == instRun) {
			vty_out(vty,"<error> the instance %s %d-%d is not running\n",((localid == 1)?"local-hansi":"hansi"),slot_id,profile);
			return CMD_WARNING;
		}
		
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		if(localid == 0)
			goto hansi_parameter;
		else if(localid == 1)
			goto local_hansi_parameter; 
	}

	if(vty->node != VIEW_NODE){
		WtpHead = show_collect_info_of_all_wtp(index,localid,dcli_dbus_connection, &num, &ret);

		if((WtpHead!=NULL)&&(ret == 0)){
			vty_out(vty,"WTPNum:%-5d  \n",num);
			vty_out(vty,"========================================================================== \n");
			for (i = 0; i < num; i++) {	
				if(WtpShowNode == NULL)
					WtpShowNode = WtpHead->WtpCollectInfo_list;
				else 
					WtpShowNode = WtpShowNode->next;

				if(WtpShowNode == NULL)
					break;
				
				vty_out(vty,"WTPID:   %-5d  \t\t",WtpShowNode->wtpCurrID);
				vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
				WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
				WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
				
				vty_out(vty,"RtCollectOnOff: %-5d  \t\t",WtpShowNode->wtpRtCollectOnOff);
				vty_out(vty,"MemRTUsage: %-5d %  \n",WtpShowNode->MemRTUsage);
				vty_out(vty,"IfIndiscardPkts: %-5d  \t",WtpShowNode->wtpIfIndiscardPkts);
				vty_out(vty,"cpu:	%0.2f %\n",WtpShowNode->CPURTUsage/100.00);
				
				vty_out(vty,"AssocTimes: %-5d  \t\t",WtpShowNode->wtpAssocTimes);
				vty_out(vty,"ReassocTimes:  %-5d \n",WtpShowNode->wtpReassocTimes);
				vty_out(vty,"StaRxBytes: %-5llu  \t\t",WtpShowNode->wtpStaRxBytes);
				vty_out(vty,"StaTxBytes:  %-5llu \n",WtpShowNode->wtpStaTxBytes);
				vty_out(vty,"wtpAssocFailtimes:  %-5d \n",WtpShowNode->wtpAssocFailtimes);
				vty_out(vty,"wtpReassocFailure:  %-5d \n",WtpShowNode->wtpReassocFailure);
				vty_out(vty,"wtpSuccAssociatedNum:  %-5u \n",WtpShowNode->wtpSuccAssociatedNum);
				vty_out(vty,"wtpMomentCollectSwith:  %-5s \n",((WtpShowNode->wtpMomentCollectSwith == 1)?"enable":"disable"));
				vty_out(vty,"-------------------------------------------------------------------------\n");
				
			}
			vty_out(vty,"========================================================================== \n");
		}

		else if (ret == WID_DBUS_ERROR){
			cli_syslog_info("<error> failed get reply.\n");
		}
		else if(ret == WTP_ID_NOT_EXIST){
			vty_out(vty,"<error> There is no WTP now.\n");
		}
		else{
			vty_out(vty,"<error> ret = %d\n",ret);
		}
		dcli_free_WtpCollectInfo(WtpHead);
	}

	if(vty->node == VIEW_NODE){
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 0;
			
			//for remote hansi info
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,0,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}

	 	hansi_parameter:
				WtpHead = show_collect_info_of_all_wtp(profile,localid,dcli_dbus_connection, &num, &ret);

				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"hansi %d-%d\n",slot_id,profile);
				vty_out(vty,"-----------------------------------------------------------------------------\n");
				if((WtpHead!=NULL)&&(ret == 0)){
					vty_out(vty,"WTPNum:%-5d  \n",num);
					vty_out(vty,"========================================================================== \n");
					WtpShowNode = NULL;
					for (i = 0; i < num; i++) {	
						if(WtpShowNode == NULL)
							WtpShowNode = WtpHead->WtpCollectInfo_list;
						else 
							WtpShowNode = WtpShowNode->next;

						if(WtpShowNode == NULL)
							break;
						
						vty_out(vty,"WTPID:   %-5d  \t\t",WtpShowNode->wtpCurrID);
						vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
						WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
						WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
						
						vty_out(vty,"RtCollectOnOff: %-5d  \t\t",WtpShowNode->wtpRtCollectOnOff);
						vty_out(vty,"MemRTUsage: %-5d %  \n",WtpShowNode->MemRTUsage);
						vty_out(vty,"IfIndiscardPkts: %-5d  \t",WtpShowNode->wtpIfIndiscardPkts);
						vty_out(vty,"cpu:	%0.2f %\n",WtpShowNode->CPURTUsage/100.00);
						
						vty_out(vty,"AssocTimes: %-5d  \t\t",WtpShowNode->wtpAssocTimes);
						vty_out(vty,"ReassocTimes:  %-5d \n",WtpShowNode->wtpReassocTimes);
						vty_out(vty,"StaRxBytes: %-5llu  \t\t",WtpShowNode->wtpStaRxBytes);
						vty_out(vty,"StaTxBytes:  %-5llu \n",WtpShowNode->wtpStaTxBytes);
						vty_out(vty,"wtpAssocFailtimes:  %-5d \n",WtpShowNode->wtpAssocFailtimes);
						vty_out(vty,"wtpReassocFailure:  %-5d \n",WtpShowNode->wtpReassocFailure);
						vty_out(vty,"wtpSuccAssociatedNum:  %-5u \n",WtpShowNode->wtpSuccAssociatedNum);
						vty_out(vty,"wtpMomentCollectSwith:  %-5s \n",((WtpShowNode->wtpMomentCollectSwith == 1)?"enable":"disable"));
						vty_out(vty,"-------------------------------------------------------------------------\n");
						
					}
				}

				else if (ret == WID_DBUS_ERROR){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == WTP_ID_NOT_EXIST){
					vty_out(vty,"<error> There is no WTP now.\n");
				}
				else{
					vty_out(vty,"<error> ret = %d\n",ret);
				}
				dcli_free_WtpCollectInfo(WtpHead);
				vty_out(vty,"==============================================================================\n");
				if(argc == 2){
					return CMD_SUCCESS;
				}
			}
		}

	//for local hansi info
	for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		localid = 1;
		
		for (profile = 1; profile < MAX_INSTANCE; profile++) 
		{
			instRun = dcli_hmd_hansi_is_running(vty,slot_id,1,profile);
			if (INSTANCE_NO_CREATED == instRun) {
				continue;
			}
	
	 local_hansi_parameter:
			WtpHead = show_collect_info_of_all_wtp(profile,localid,dcli_dbus_connection, &num, &ret);

			vty_out(vty,"==============================================================================\n");
			vty_out(vty,"local hansi %d-%d\n",slot_id,profile);
			vty_out(vty,"-----------------------------------------------------------------------------\n");
			if((WtpHead!=NULL)&&(ret == 0)){
				vty_out(vty,"WTPNum:%-5d  \n",num);
				vty_out(vty,"========================================================================== \n");
				WtpShowNode = NULL;
				for (i = 0; i < num; i++) {	
					if(WtpShowNode == NULL)
						WtpShowNode = WtpHead->WtpCollectInfo_list;
					else 
						WtpShowNode = WtpShowNode->next;

					if(WtpShowNode == NULL)
						break;
					
					vty_out(vty,"WTPID:   %-5d  \t\t",WtpShowNode->wtpCurrID);
					vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
					WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
					WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
					
					vty_out(vty,"RtCollectOnOff: %-5d  \t\t",WtpShowNode->wtpRtCollectOnOff);
					vty_out(vty,"MemRTUsage: %-5d %  \n",WtpShowNode->MemRTUsage);
					vty_out(vty,"IfIndiscardPkts: %-5d  \t",WtpShowNode->wtpIfIndiscardPkts);
					vty_out(vty,"cpu:	%0.2f %\n",WtpShowNode->CPURTUsage/100.00);
					
					vty_out(vty,"AssocTimes: %-5d  \t\t",WtpShowNode->wtpAssocTimes);
					vty_out(vty,"ReassocTimes:  %-5d \n",WtpShowNode->wtpReassocTimes);
					vty_out(vty,"StaRxBytes: %-5llu  \t\t",WtpShowNode->wtpStaRxBytes);
					vty_out(vty,"StaTxBytes:  %-5llu \n",WtpShowNode->wtpStaTxBytes);
					vty_out(vty,"wtpAssocFailtimes:  %-5d \n",WtpShowNode->wtpAssocFailtimes);
					vty_out(vty,"wtpReassocFailure:  %-5d \n",WtpShowNode->wtpReassocFailure);
					vty_out(vty,"wtpSuccAssociatedNum:  %-5u \n",WtpShowNode->wtpSuccAssociatedNum);
					vty_out(vty,"wtpMomentCollectSwith:  %-5s \n",((WtpShowNode->wtpMomentCollectSwith == 1)?"enable":"disable"));
					vty_out(vty,"-------------------------------------------------------------------------\n");
					
				}
			}

			else if (ret == WID_DBUS_ERROR){
				cli_syslog_info("<error> failed get reply.\n");
			}
			else if(ret == WTP_ID_NOT_EXIST){
				vty_out(vty,"<error> There is no WTP now.\n");
			}
			else{
				vty_out(vty,"<error> ret = %d\n",ret);
			}
			dcli_free_WtpCollectInfo(WtpHead);
			vty_out(vty,"==============================================================================\n");
			if(argc == 2){
				return CMD_SUCCESS;
			}
			}
		}
	}
	
	return CMD_SUCCESS;
}

/*add for showing wtp para information by nl*/
DEFUN(show_all_wtp_para_information_func,
	  show_all_wtp_para_information_cmd,
	  "show para information of all_wtp [remote] [local] [PARAMETER]",
	  SHOW_STR
	  "Display para information of all wtps\n"
	  "List wtp para information\n"
	  "of all wtp\n"
	  "by wtp display para information\n"
	  "'remote' or 'local' hansi\n"
	  "'remote' or 'local' hansi\n"
	  "slotid-instid\n"
	 )
{
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	struct WtpParaInfo *WtpHead = NULL;
	struct WtpParaInfo *WtpShowNode = NULL;
	int ret=0;
	int i=0;
	int j=0;
	int profile = 0;
	int instRun = 0;
	int flag = 0;
	unsigned int num = 0;
	char state[20];
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	if((argc == 1)||(argc == 3)){
		vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
		return CMD_SUCCESS;
	}
	if(argc == 2){
		if (!strcmp(argv[0],"remote")){
			localid = 0;
		}else if(!strcmp(argv[0],"local")){
			localid = 1;
		}else{
			vty_out(vty,"parameter should be 'remote' or 'local'\n");
			return CMD_SUCCESS;
		}
		
		if((!strcmp(argv[0],"remote"))&&(!strcmp(argv[1],"local"))){
			vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
			return CMD_SUCCESS;
		}
		
		ret = parse_slot_hansi_id((char*)argv[1],&slot_id,&profile);
		if(ret != WID_DBUS_SUCCESS){
			slot_id = HostSlotId;
			flag = 1;
			ret = parse_int_ID((char*)argv[1], &profile);
			if(ret != WID_DBUS_SUCCESS){
				if(ret == WID_ILLEGAL_INPUT){
					vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
				}
				else{
					vty_out(vty,"<error> unknown id format\n");
				}
				return CMD_WARNING;
			}	
		}
		if(distributFag == 0){
			if(slot_id != 0){
				vty_out(vty,"<error> slot id should be 0\n");
				return CMD_WARNING;
			}	
		}else if(flag == 1){
			slot_id = HostSlotId;
		}
		if(slot_id >= MAX_SLOT_NUM || slot_id < 0){
			vty_out(vty,"<error> slot id should be 1 to %d\n",MAX_SLOT_NUM-1);
			return CMD_WARNING;
		}	
		if(profile >= MAX_INSTANCE || profile == 0){
			vty_out(vty,"<error> hansi id should be 1 to %d\n",MAX_INSTANCE-1);
			return CMD_WARNING;
		}
		instRun = dcli_hmd_hansi_is_running(vty,slot_id,localid,profile);
		if (INSTANCE_NO_CREATED == instRun) {
			vty_out(vty,"<error> the instance %s %d-%d is not running\n",((localid == 1)?"local-hansi":"hansi"),slot_id,profile);
			return CMD_WARNING;
		}
		
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		if(localid == 0)
			goto hansi_parameter;
		else if(localid == 1)
			goto local_hansi_parameter; 
	}

	if(vty->node != VIEW_NODE){
		WtpHead = show_para_info_of_all_wtp(index,localid,dcli_dbus_connection, &num, &ret);

		if((WtpHead!=NULL)&&(ret == 0)){
			vty_out(vty,"WtpNum:%-5d  \n",num);
			vty_out(vty,"========================================================================== \n");
			for (i = 0; i < num; i++) {	
				if(WtpShowNode == NULL)
					WtpShowNode = WtpHead->WtpParaInfo_list;
				else 
					WtpShowNode = WtpShowNode->next;

				if(WtpShowNode == NULL)
					break;
				
				CheckWTPState(state,WtpShowNode->wtpState);
				vty_out(vty,"WtpID:   %-5d  \t\t\t",WtpShowNode->wtpCurrID);
				vty_out(vty,"WtpMAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
				WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
				WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
				vty_out(vty,"WtpModel:%-15s  \t\t",WtpShowNode->wtpModel);
				vty_out(vty,"NetElemCode:   %s  \n",WtpShowNode->wtpNetElementCode);

				vty_out(vty,"WtpAddrMask:   %s  \t\t",WtpShowNode->wtpAddrMask);
				vty_out(vty,"WtpGateAddr:   %s  \n",WtpShowNode->wtpGateAddr);
				vty_out(vty,"CurrAPMode:   %d  \t\t\t",WtpShowNode->wtpCurrAPMode);
				
				vty_out(vty,"DefenceDOSAttack:   %d  \n",WtpShowNode->wtpDefenceDOSAttack);
				vty_out(vty,"IGMPSwitch:   %d  \t\t\t",WtpShowNode->wtpIGMPSwitch);
				vty_out(vty,"ReceiverSignalPWL: %0.1f V \n",WtpShowNode->wtpReceiverSignalPWL/10.0);
				vty_out(vty,"IfType: %s \t\t\t",WtpShowNode->wtpIfType);
				
				vty_out(vty,"RemoteRestartFun: %d \n",WtpShowNode->wtpRemoteRestartFun);
				vty_out(vty,"State: %s \t\t\t\t",state);
				vty_out(vty,"CurBssidNumber: %d \n",WtpShowNode->wtpCurBssidNumber);
				vty_out(vty,"WtpIP: %s \t\t",WtpShowNode->wtpIP);
				vty_out(vty,"WtpNAME: %s \n",WtpShowNode->wtpName);
				vty_out(vty,"total_if_num: %d \n",WtpShowNode->total_if_num);

				/*xiaodawei add for telecom test, 20110302*/
				if(WtpShowNode->add_time == 0)
				{
					vty_out(vty,"Access Time:	Not Accessed\n");
				}
				else
				{
					vty_out(vty,"Access Time:	%s",ctime(&WtpShowNode->add_time));
				}
				
				if(WtpShowNode->ElectrifyRegisterCircle == 0)
				{
					vty_out(vty,"Start Time:	NONE\n");
				}
				else
				{
					WtpShowNode->starttime = WtpShowNode->add_time - WtpShowNode->ElectrifyRegisterCircle;
					time_t now,online_time;
					time(&now);
					online_time = now - WtpShowNode->starttime;
					int hour,min,sec;
					hour = online_time/3600;
					min = (online_time - hour*3600)/60;
					sec = (online_time - hour*3600)%60;
					vty_out(vty,"Start Time:	%s",ctime(&WtpShowNode->starttime));
					vty_out(vty,"Start Time:	%02d:%02d:%02d\n",hour,min,sec);
				}
			
				if(WtpShowNode->imagadata_time == 0)
				{
					vty_out(vty,"Imagedata Time:	No imagedata\n");
				}
				else
				{
					vty_out(vty,"Imagedata Time:	%s",ctime(&WtpShowNode->imagadata_time));
				}
				if(WtpShowNode->config_update_time == 0)
				{
					vty_out(vty,"Config update Time:	No configuration update\n");
				}
				else
				{
					vty_out(vty,"Config update Time:	%s",ctime(&WtpShowNode->config_update_time));
				}
				/*xiaodawei add for telecom test, END*/
				for(j=0;j<WtpShowNode->wtpCurBssidNumber;j++){
					vty_out(vty,"WtpCurBssid :%02X:%02X:%02X:%02X:%02X:%02X  \n",WtpShowNode->wtpCurBssid[6*j],
														WtpShowNode->wtpCurBssid[6*j+1],WtpShowNode->wtpCurBssid[6*j+2],
														WtpShowNode->wtpCurBssid[6*j+3],WtpShowNode->wtpCurBssid[6*j+4],
														WtpShowNode->wtpCurBssid[6*j+5]);
				}
				vty_out(vty,"-------------------------------------------------------------------------\n");
			}
			vty_out(vty,"========================================================================== \n");
		}

		else if (ret == WID_DBUS_ERROR){
			cli_syslog_info("<error> failed get reply.\n");
		}
		else if(ret == WTP_ID_NOT_EXIST){
			vty_out(vty,"<error> There is no WTP now.\n");
		}
		else{
			vty_out(vty,"<error> ret = %d\n",ret);
		}
		dcli_free_WtpParaInfo(WtpHead);
	}

	if(vty->node == VIEW_NODE){
		//for remote hansi info
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 0;
			
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,0,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}

		hansi_parameter:
				WtpHead = show_para_info_of_all_wtp(profile,localid,dcli_dbus_connection, &num, &ret);

				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"hansi %d-%d\n",slot_id,profile);
				vty_out(vty,"-----------------------------------------------------------------------------\n");
				if((WtpHead!=NULL)&&(ret == 0)){
					vty_out(vty,"WtpNum:%-5d  \n",num);
					vty_out(vty,"========================================================================== \n");
					WtpShowNode = NULL;
					for (i = 0; i < num; i++) {	
						if(WtpShowNode == NULL)
							WtpShowNode = WtpHead->WtpParaInfo_list;
						else 
							WtpShowNode = WtpShowNode->next;

						if(WtpShowNode == NULL)
							break;
						
						CheckWTPState(state,WtpShowNode->wtpState);
						vty_out(vty,"WtpID:   %-5d  \t\t\t",WtpShowNode->wtpCurrID);
						vty_out(vty,"WtpMAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
						WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
						WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
						vty_out(vty,"WtpModel:%-15s  \t\t",WtpShowNode->wtpModel);
						vty_out(vty,"NetElemCode:   %s  \n",WtpShowNode->wtpNetElementCode);

						vty_out(vty,"WtpAddrMask:   %s  \t\t",WtpShowNode->wtpAddrMask);
						vty_out(vty,"WtpGateAddr:   %s  \n",WtpShowNode->wtpGateAddr);
						vty_out(vty,"CurrAPMode:   %d  \t\t\t",WtpShowNode->wtpCurrAPMode);
						
						vty_out(vty,"DefenceDOSAttack:   %d  \n",WtpShowNode->wtpDefenceDOSAttack);
						vty_out(vty,"IGMPSwitch:   %d  \t\t\t",WtpShowNode->wtpIGMPSwitch);
						vty_out(vty,"ReceiverSignalPWL: %0.1f V \n",WtpShowNode->wtpReceiverSignalPWL/10.0);
						vty_out(vty,"IfType: %s \t\t\t",WtpShowNode->wtpIfType);
						
						vty_out(vty,"RemoteRestartFun: %d \n",WtpShowNode->wtpRemoteRestartFun);
						vty_out(vty,"State: %s \t\t\t\t",state);
						vty_out(vty,"CurBssidNumber: %d \n",WtpShowNode->wtpCurBssidNumber);
						vty_out(vty,"WtpIP: %s \t\t",WtpShowNode->wtpIP);
						vty_out(vty,"WtpNAME: %s \n",WtpShowNode->wtpName);
						vty_out(vty,"total_if_num: %d \n",WtpShowNode->total_if_num);

						/*xiaodawei add for telecom test, 20110302*/
						if(WtpShowNode->add_time == 0)
						{
							vty_out(vty,"Access Time:	Not Accessed\n");
						}
						else
						{
							vty_out(vty,"Access Time:	%s",ctime(&WtpShowNode->add_time));
						}
						
						if(WtpShowNode->ElectrifyRegisterCircle == 0)
						{
							vty_out(vty,"Start Time:	NONE\n");
						}
						else
						{
							WtpShowNode->starttime = WtpShowNode->add_time - WtpShowNode->ElectrifyRegisterCircle;
							time_t now,online_time;
							time(&now);
							online_time = now - WtpShowNode->starttime;
							int hour,min,sec;
							hour = online_time/3600;
							min = (online_time - hour*3600)/60;
							sec = (online_time - hour*3600)%60;
							vty_out(vty,"Start Time:	%s",ctime(&WtpShowNode->starttime));
							vty_out(vty,"Start Time:	%02d:%02d:%02d\n",hour,min,sec);
						}
					
						if(WtpShowNode->imagadata_time == 0)
						{
							vty_out(vty,"Imagedata Time:	No imagedata\n");
						}
						else
						{
							vty_out(vty,"Imagedata Time:	%s",ctime(&WtpShowNode->imagadata_time));
						}
						if(WtpShowNode->config_update_time == 0)
						{
							vty_out(vty,"Config update Time:	No configuration update\n");
						}
						else
						{
							vty_out(vty,"Config update Time:	%s",ctime(&WtpShowNode->config_update_time));
						}
						/*xiaodawei add for telecom test, END*/
						for(j=0;j<WtpShowNode->wtpCurBssidNumber;j++){
							vty_out(vty,"WtpCurBssid :%02X:%02X:%02X:%02X:%02X:%02X  \n",WtpShowNode->wtpCurBssid[6*j],
																WtpShowNode->wtpCurBssid[6*j+1],WtpShowNode->wtpCurBssid[6*j+2],
																WtpShowNode->wtpCurBssid[6*j+3],WtpShowNode->wtpCurBssid[6*j+4],
																WtpShowNode->wtpCurBssid[6*j+5]);
						}
						vty_out(vty,"-------------------------------------------------------------------------\n");
					}
				}

				else if (ret == WID_DBUS_ERROR){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == WTP_ID_NOT_EXIST){
					vty_out(vty,"<error> There is no WTP now.\n");
				}
				else{
					vty_out(vty,"<error> ret = %d\n",ret);
				}
				dcli_free_WtpParaInfo(WtpHead);
				vty_out(vty,"==============================================================================\n");
				if(argc == 2){
					return CMD_SUCCESS;
				}
			}
		}

	//for local hansi info
	for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		localid = 1;
		
		for (profile = 1; profile < MAX_INSTANCE; profile++) 
		{
			instRun = dcli_hmd_hansi_is_running(vty,slot_id,1,profile);
			if (INSTANCE_NO_CREATED == instRun) {
				continue;
			}
	
		local_hansi_parameter:
			WtpHead = show_para_info_of_all_wtp(profile,localid,dcli_dbus_connection, &num, &ret);

			vty_out(vty,"==============================================================================\n");
			vty_out(vty,"local hansi %d-%d\n",slot_id,profile);
			vty_out(vty,"-----------------------------------------------------------------------------\n");
			if((WtpHead!=NULL)&&(ret == 0)){
				vty_out(vty,"WtpNum:%-5d  \n",num);
				vty_out(vty,"========================================================================== \n");
				WtpShowNode = NULL;
				for (i = 0; i < num; i++) {	
					if(WtpShowNode == NULL)
						WtpShowNode = WtpHead->WtpParaInfo_list;
					else 
						WtpShowNode = WtpShowNode->next;

					if(WtpShowNode == NULL)
						break;
					
					CheckWTPState(state,WtpShowNode->wtpState);
					vty_out(vty,"WtpID:   %-5d  \t\t\t",WtpShowNode->wtpCurrID);
					vty_out(vty,"WtpMAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
					WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
					WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
					vty_out(vty,"WtpModel:%-15s  \t\t",WtpShowNode->wtpModel);
					vty_out(vty,"NetElemCode:   %s  \n",WtpShowNode->wtpNetElementCode);

					vty_out(vty,"WtpAddrMask:   %s  \t\t",WtpShowNode->wtpAddrMask);
					vty_out(vty,"WtpGateAddr:   %s  \n",WtpShowNode->wtpGateAddr);
					vty_out(vty,"CurrAPMode:   %d  \t\t\t",WtpShowNode->wtpCurrAPMode);
					
					vty_out(vty,"DefenceDOSAttack:   %d  \n",WtpShowNode->wtpDefenceDOSAttack);
					vty_out(vty,"IGMPSwitch:   %d  \t\t\t",WtpShowNode->wtpIGMPSwitch);
					vty_out(vty,"ReceiverSignalPWL: %0.1f V \n",WtpShowNode->wtpReceiverSignalPWL/10.0);
					vty_out(vty,"IfType: %s \t\t\t",WtpShowNode->wtpIfType);
					
					vty_out(vty,"RemoteRestartFun: %d \n",WtpShowNode->wtpRemoteRestartFun);
					vty_out(vty,"State: %s \t\t\t\t",state);
					vty_out(vty,"CurBssidNumber: %d \n",WtpShowNode->wtpCurBssidNumber);
					vty_out(vty,"WtpIP: %s \t\t",WtpShowNode->wtpIP);
					vty_out(vty,"WtpNAME: %s \n",WtpShowNode->wtpName);
					vty_out(vty,"total_if_num: %d \n",WtpShowNode->total_if_num);

					/*xiaodawei add for telecom test, 20110302*/
					if(WtpShowNode->add_time == 0)
					{
						vty_out(vty,"Access Time:	Not Accessed\n");
					}
					else
					{
						vty_out(vty,"Access Time:	%s",ctime(&WtpShowNode->add_time));
					}
					
					if(WtpShowNode->ElectrifyRegisterCircle == 0)
					{
						vty_out(vty,"Start Time:	NONE\n");
					}
					else
					{
						WtpShowNode->starttime = WtpShowNode->add_time - WtpShowNode->ElectrifyRegisterCircle;
						time_t now,online_time;
						time(&now);
						online_time = now - WtpShowNode->starttime;
						int hour,min,sec;
						hour = online_time/3600;
						min = (online_time - hour*3600)/60;
						sec = (online_time - hour*3600)%60;
						vty_out(vty,"Start Time:	%s",ctime(&WtpShowNode->starttime));
						vty_out(vty,"Start Time:	%02d:%02d:%02d\n",hour,min,sec);
					}
				
					if(WtpShowNode->imagadata_time == 0)
					{
						vty_out(vty,"Imagedata Time:	No imagedata\n");
					}
					else
					{
						vty_out(vty,"Imagedata Time:	%s",ctime(&WtpShowNode->imagadata_time));
					}
					if(WtpShowNode->config_update_time == 0)
					{
						vty_out(vty,"Config update Time:	No configuration update\n");
					}
					else
					{
						vty_out(vty,"Config update Time:	%s",ctime(&WtpShowNode->config_update_time));
					}
					/*xiaodawei add for telecom test, END*/
					for(j=0;j<WtpShowNode->wtpCurBssidNumber;j++){
						vty_out(vty,"WtpCurBssid :%02X:%02X:%02X:%02X:%02X:%02X  \n",WtpShowNode->wtpCurBssid[6*j],
															WtpShowNode->wtpCurBssid[6*j+1],WtpShowNode->wtpCurBssid[6*j+2],
															WtpShowNode->wtpCurBssid[6*j+3],WtpShowNode->wtpCurBssid[6*j+4],
															WtpShowNode->wtpCurBssid[6*j+5]);
					}
					vty_out(vty,"-------------------------------------------------------------------------\n");
				}
			}

			else if (ret == WID_DBUS_ERROR){
				cli_syslog_info("<error> failed get reply.\n");
			}
			else if(ret == WTP_ID_NOT_EXIST){
				vty_out(vty,"<error> There is no WTP now.\n");
			}
			else{
				vty_out(vty,"<error> ret = %d\n",ret);
			}
			dcli_free_WtpParaInfo(WtpHead);
			vty_out(vty,"==============================================================================\n");
			if(argc == 2){
				return CMD_SUCCESS;
			}
			}
		}
	}
	return CMD_SUCCESS;
}

/*add for showing wtp wirelessifstats information by nl 20100707*/
DEFUN(show_all_wtp_wirelessifstats_information_func,
	  show_all_wtp_wirelessifstats_information_cmd,
	  "show wirelessifstats information of all_wtp [remote] [local] [PARAMETER]",
	  SHOW_STR
	  "Display wirelessifstats of all wtps\n"
	  "List wtp wirelessifstats information\n"
	  "of all wtp\n"
	  "by wtp display wirelessifstats information\n"
	  "'remote' or 'local' hansi\n"
	  "'remote' or 'local' hansi\n"
	  "slotid-instid\n"
	 )
{
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	struct WtpWirelessIfstatsInfo *WtpHead = NULL;
	struct WtpWirelessIfstatsInfo *WtpShowNode = NULL;
	int ret=0;
	int i=0;
	int j=0;
	int profile = 0;
	int instRun = 0;
	int flag = 0;
	unsigned int wtp_num = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	
	if((argc == 1)||(argc == 3)){
		vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
		return CMD_SUCCESS;
	}
	if(argc == 2){
		if (!strcmp(argv[0],"remote")){
			localid = 0;
		}else if(!strcmp(argv[0],"local")){
			localid = 1;
		}else{
			vty_out(vty,"parameter should be 'remote' or 'local'\n");
			return CMD_SUCCESS;
		}
		
		if((!strcmp(argv[0],"remote"))&&(!strcmp(argv[1],"local"))){
			vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
			return CMD_SUCCESS;
		}
		
		ret = parse_slot_hansi_id((char*)argv[1],&slot_id,&profile);
		if(ret != WID_DBUS_SUCCESS){
			slot_id = HostSlotId;
			flag = 1;
			ret = parse_int_ID((char*)argv[1], &profile);
			if(ret != WID_DBUS_SUCCESS){
				if(ret == WID_ILLEGAL_INPUT){
					vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
				}
				else{
					vty_out(vty,"<error> unknown id format\n");
				}
				return CMD_WARNING;
			}	
		}
		if(distributFag == 0){
			if(slot_id != 0){
				vty_out(vty,"<error> slot id should be 0\n");
				return CMD_WARNING;
			}	
		}else if(flag == 1){
			slot_id = HostSlotId;
		}
		if(slot_id >= MAX_SLOT_NUM || slot_id < 0){
			vty_out(vty,"<error> slot id should be 1 to %d\n",MAX_SLOT_NUM-1);
			return CMD_WARNING;
		}	
		if(profile >= MAX_INSTANCE || profile == 0){
			vty_out(vty,"<error> hansi id should be 1 to %d\n",MAX_INSTANCE-1);
			return CMD_WARNING;
		}
		instRun = dcli_hmd_hansi_is_running(vty,slot_id,localid,profile);
		if (INSTANCE_NO_CREATED == instRun) {
			vty_out(vty,"<error> the instance %s %d-%d is not running\n",((localid == 1)?"local-hansi":"hansi"),slot_id,profile);
			return CMD_WARNING;
		}
		
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		if(localid == 0)
			goto hansi_parameter;
		else if(localid == 1)
			goto local_hansi_parameter; 
	}

	if(vty->node != VIEW_NODE){
		WtpHead = show_wirelessifstatsInfo_info_of_all_wtp(index,localid,dcli_dbus_connection, &wtp_num, &ret);
#if 1
		if((WtpHead!=NULL)&&(ret == 0)){
			vty_out(vty,"WTPNum:%-5u  \n",wtp_num);
			vty_out(vty,"========================================================================== \n");
			for (i = 0; i < wtp_num; i++) {	
				if(WtpShowNode == NULL)
					WtpShowNode = WtpHead->WtpWirelessIfstatsInfo_list;
				else 
					WtpShowNode = WtpShowNode->next;

				if(WtpShowNode == NULL)
					break;

				vty_out(vty,"    ========================WTPInformation============================     \n");
				vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
				vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
				WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
				WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
				
				vty_out(vty,"wtp_radio_num:   %-5u  \n",WtpShowNode->wtp_radio_num);
				//qiuchen copy from v1.3
				/*vty_out(vty,"wifi snr max:   %-5d  \n",WtpShowNode->wirelessIfHighestRxSignalStrength);
				vty_out(vty,"wifi snr avg:   %-5d  \t\t\t\t",WtpShowNode->wirelessIfAvgRxSignalStrength);
				if(WtpShowNode->wirelessIfLowestRxSignalStrength == 100){
					vty_out(vty,"wifi snr min:	0\n");
				}
				else{
					vty_out(vty,"wifi snr min:	%d\n",WtpShowNode->wirelessIfLowestRxSignalStrength);
				}*/
				
				//vty_out(vty,"math_AvgRxSignalStrength: %-5g  \t\t",WtpShowNode->math_wirelessIfAvgRxSignalStrength);

				//vty_out(vty,"wifi snr max2:   %-5d  \n",WtpShowNode->wirelessIfHighestRxSignalStrength2);
				//vty_out(vty,"wifi snr avg2:   %-5d  \t\t\t",WtpShowNode->wirelessIfAvgRxSignalStrength2);
				/*if(WtpShowNode->wirelessIfLowestRxSignalStrength2 == 4){
					vty_out(vty,"wifi snr min2:	0 \n");
				}
				else{
					vty_out(vty,"wifi snr min2:	%d \n",WtpShowNode->wirelessIfLowestRxSignalStrength2);
				}*/
				
				//vty_out(vty,"wifi snr min2: %d \n",WtpShowNode->wirelessIfLowestRxSignalStrength2);
				//vty_out(vty,"math_AvgRxSignalStrength2: %-5g  \n",WtpShowNode->math_wirelessIfAvgRxSignalStrength);
				vty_out(vty,"TxDataPkts:   %-5u  \t\t\t\t",WtpShowNode->wirelessIfTxDataPkts);
				vty_out(vty,"RxDataPkts:   %-5u  \n",WtpShowNode->wirelessIfRxDataPkts);
				vty_out(vty,"UplinkDataOctets:   %-5llu  \t\t\t",WtpShowNode->wirelessIfUplinkDataOctets);
				
				vty_out(vty,"DwlinkDataOctets:   %-5llu  \n",WtpShowNode->wirelessIfDwlinkDataOctets);
				vty_out(vty,"ChStatsPhyErrPkts:   %-5u  \t\t\t",WtpShowNode->wirelessIfChStatsPhyErrPkts);
				vty_out(vty,"ChStatsMacFcsErrPkts:   %-5u  \n",WtpShowNode->wirelessIfChStatsMacFcsErrPkts);
				
				vty_out(vty,"ChStatsMacMicErrPkts:   %-5u  \t\t\t",WtpShowNode->wirelessIfChStatsMacMicErrPkts);
				vty_out(vty,"ChStatsMacDecryptErrPkts:   %-5u  \n",WtpShowNode->wirelessIfChStatsMacDecryptErrPkts);
				vty_out(vty,"ChStatsFrameErrorCnt:   %-5u  \t\t\t",WtpShowNode->wirelessIfChStatsFrameErrorCnt);

				vty_out(vty,"asd_radio_num: %u\n",WtpShowNode->asd_radio_num);
				vty_out(vty,"-------------------------------------------------------------------------\n");
				/*fengwenchao add 20110523*/
				if(WtpShowNode == NULL)
					vty_out(vty,"  WtpShowNode  =  nulL\n");
				if(WtpShowNode->neighbor_ap_count > 0)
				{
					vty_out(vty,"------------------------neighbor wtp information--------------------------\n");
					struct Neighbor_AP_ELE *neighbor = NULL;
					char essid[10][ESSID_DEFAULT_LEN] = {0};
					int num = 0;
					int  k1 =0;
					for(j=0;WtpShowNode&&j<WtpShowNode->neighbor_ap_count;j++)
					{
						if(neighbor == NULL)
							neighbor = WtpShowNode->neighbor_wtp;
						else 
							neighbor = neighbor->next;

						if(neighbor == NULL){
							vty_out(vty,"break\n");
							break;
						}	
						if(num == 0)
						{
							memcpy(essid[0],neighbor->ESSID,ESSID_DEFAULT_LEN);
							vty_out(vty,"WTP : %d   ESSID : %s  \n",neighbor->wtpid,neighbor->ESSID);
							num++;
						}
						for(k1 = 0; k1 <num;k1++)
						{
							if(strcmp(neighbor->ESSID,essid[k1]) != 0)
							{
								vty_out(vty,"WTP : %d   ESSID : %s  \n",neighbor->wtpid,neighbor->ESSID);
								memcpy(essid[num],neighbor->ESSID,ESSID_DEFAULT_LEN);
								num++;
								break;
							}
						}
						if(num == 10)
							break;
					}
				}
				else
				{
					vty_out(vty,"------------------------neighbor wtp information--------------------------\n");
					vty_out(vty,"There is not neighbor ap \n");
				}
				/*fengwenchao add end*/
				struct WtpWirelessIfstatsInfo_radio *sub_radio = NULL;

				for(j=0;j<WtpShowNode->wtp_radio_num;j++){
					if(sub_radio == NULL)
						sub_radio = WtpShowNode->wireless_sub_radio_head;
					else 
						sub_radio = sub_radio->next;

					if(sub_radio == NULL){
						vty_out(vty,"break\n");
						break;
					}
					
					vty_out(vty,"------------------------radio information:------------------------------- \n");
					vty_out(vty,"local_radioid:  %-5u  \t\t\t\t",(sub_radio->wtpWirelessIfIndex+1));
					vty_out(vty,"UpdownTimes:  %-5u  \n",sub_radio->wirelessIfUpdownTimes);

					vty_out(vty,"ChStatsUplinkUniFrameCnt:  %-5u  \t\t",sub_radio->wirelessIfChStatsUplinkUniFrameCnt);
					vty_out(vty,"ChStatsDwlinkUniFrameCnt:  %-5u  \n",sub_radio->wirelessIfChStatsDwlinkUniFrameCnt);
					vty_out(vty,"UpChStatsFrameNonUniFrameCnt:  %-5u  \t\t",sub_radio->wirelessIfUpChStatsFrameNonUniFrameCnt);
					vty_out(vty,"DownChStatsFrameNonUniFrameCnt:  %-5u  \n",sub_radio->wirelessIfDownChStatsFrameNonUniFrameCnt);

					vty_out(vty,"wirelessIfRxMgmtFrameCnt:  %-5u	\t",sub_radio->sub_rx_pkt_mgmt);
					vty_out(vty,"wirelessIfRxCtrlFrameCnt:  %-5u	\n",sub_radio->wirelessIfRxCtrlFrameCnt);
					vty_out(vty,"wirelessIfRxDataFrameCnt:  %-5u	\t",sub_radio->wirelessIfRxDataFrameCnt);
					vty_out(vty,"wirelessIfRxAuthenFrameCnt:  %-5u	\n",sub_radio->wirelessIfRxAuthenFrameCnt);
					vty_out(vty,"wirelessIfRxAssociateFrameCnt:  %-5u	\t",sub_radio->wirelessIfRxAssociateFrameCnt);
					
					vty_out(vty,"wirelessIfTxMgmtFrameCnt:  %-5u	\n",sub_radio->sub_tx_pkt_mgmt);
					vty_out(vty,"wirelessIfTxCtrlFrameCnt:  %-5u	\t",sub_radio->wirelessIfTxCtrlFrameCnt);
					vty_out(vty,"wirelessIfTxDataFrameCnt:  %-5u	\n",sub_radio->wirelessIfTxDataFrameCnt);
					vty_out(vty,"wirelessIfTxAuthenFrameCnt:  %-5u	\t",sub_radio->wirelessIfTxAuthenFrameCnt);
					vty_out(vty,"wirelessIfTxAssociateFrameCnt:  %-5u	\n",sub_radio->wirelessIfTxAssociateFrameCnt);

					vty_out(vty,"sub_wirelessIfRxDataPkts:  %-5u	\t",sub_radio->sub_wirelessIfRxDataPkts);
					vty_out(vty,"sub_wirelessIfTxDataPkts:  %-5u	\n",sub_radio->sub_wirelessIfTxDataPkts);
					vty_out(vty,"sub_wirelessIfChStatsFrameErrorCnt:  %-5u\t",sub_radio->sub_wirelessIfChStatsFrameErrorCnt);
					vty_out(vty,"sub_wirelessIfRxErrPkts:  %-5lu	\n",sub_radio->sub_wirelessIfRxErrPkts);
					vty_out(vty,"sub_wirelessIfTxDropPkts:  %-5lu	\t",sub_radio->sub_wirelessIfTxDropPkts);				
					vty_out(vty,"sub_wirelessIfRxDropPkts:  %-5lu	\n",sub_radio->sub_wirelessIfRxDropPkts);
					vty_out(vty,"sub_wirelessIfDwlinkDataOctets:  %-5llu	\n",sub_radio->sub_wirelessIfDwlinkDataOctets);
					vty_out(vty,"sub_wirelessIfUplinkDataOctets:  %-5llu    \t",sub_radio->sub_wirelessIfUplinkDataOctets);
					
					vty_out(vty,"sub_wirelessIfChStatsMacFcsErrPkts:  %-5u	\n",sub_radio->sub_wirelessIfChStatsMacFcsErrPkts);
					vty_out(vty,"sub_wirelessIfChStatsMacDecryptErrPkts:  %-5u	",sub_radio->sub_wirelessIfChStatsMacDecryptErrPkts);
					vty_out(vty,"sub_wirelessIfChStatsMacMicErrPkts:  %-5u	\n",sub_radio->sub_wirelessIfChStatsMacMicErrPkts);
					vty_out(vty,"sub_wirelessIfChStatsPhyErrPkts:  %-5u	\t",sub_radio->sub_wirelessIfChStatsPhyErrPkts);
					vty_out(vty,"wirelessIfChStatsNumStations:  %-5u	\n",sub_radio->wirelessIfChStatsNumStations);
					/* book add for show retry packets of radio, 2011-5-19 */
					vty_out(vty,"TxSignalPkts:	 %-5u  \t\t\t",sub_radio->wirelessIfTxSignalPkts);
	    			vty_out(vty,"RxSignalPkts:	 %-5u  \n",sub_radio->wirelessIfRxSignalPkts);
	    			vty_out(vty,"ChStatsFrameRetryCnt:	 %-5u  \t\t",sub_radio->wirelessIfChStatsFrameRetryCnt);
	    			vty_out(vty,"ChStatsDwlinkTotRetryPkts:	 %-5u  \n",sub_radio->wirelessIfChStatsDwlinkTotRetryPkts);
					vty_out(vty,"radio_cur_snr:  %-5d	\t\t\t",sub_radio->radio_cur_snr2);
					vty_out(vty,"radio_max_snr:  %-5d	\n",sub_radio->radio_max_snr2);
					vty_out(vty,"radio_min_snr:  %-5d	\t\t\t",sub_radio->radio_min_snr2);
					vty_out(vty,"radio_aver_snr:  %-5g	\n",sub_radio->radio_aver_snr);
					
					vty_out(vty,"sub_rx_pkt_mgmt:  %-5u	\t\t\t",sub_radio->sub_rx_pkt_mgmt);
					vty_out(vty,"sub_tx_pkt_mgmt:  %-5u	\n",sub_radio->sub_tx_pkt_mgmt);
					vty_out(vty,"sub_rx_mgmt:  %-5llu	\t\t\t",sub_radio->sub_rx_mgmt);
					vty_out(vty,"sub_tx_mgmt:  %-5llu	\n",sub_radio->sub_tx_mgmt);

					vty_out(vty,"sub_total_rx_bytes:  %-5llu	\t\t",sub_radio->sub_total_rx_bytes);
					vty_out(vty,"sub_total_tx_bytes:  %-5llu	\n",sub_radio->sub_total_tx_bytes);
					vty_out(vty,"sub_total_rx_pkt:  %-5llu	\t\t",sub_radio->sub_total_rx_pkt);
					vty_out(vty,"sub_total_tx_pkt:  %-5llu	\n",sub_radio->sub_total_tx_pkt);
				}
			}
			vty_out(vty,"========================================================================== \n");
		}

		else if (ret == WID_DBUS_ERROR){
			cli_syslog_info("<error> failed get reply.\n");
		}
		else if(ret == WTP_ID_NOT_EXIST){
			vty_out(vty,"<error> There is no WTP now.\n");
		}
		else{
			vty_out(vty,"<error> ret = %d\n",ret);
		}

		dcli_free_wtp_wireless_ifstats_Info(WtpHead);
#endif
	}

	if(vty->node == VIEW_NODE){
		//for remote hansi info
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 0;
			
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,0,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}
	
		hansi_parameter:
				WtpHead = show_wirelessifstatsInfo_info_of_all_wtp(profile,localid,dcli_dbus_connection, &wtp_num, &ret);

				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"hansi %d-%d\n",slot_id,profile);
				vty_out(vty,"-----------------------------------------------------------------------------\n");
				if((WtpHead!=NULL)&&(ret == 0)){
					vty_out(vty,"WTPNum:%-5u  \n",wtp_num);
					vty_out(vty,"========================================================================== \n");
					WtpShowNode = NULL;
					for (i = 0; i < wtp_num; i++) { 
						if(WtpShowNode == NULL)
							WtpShowNode = WtpHead->WtpWirelessIfstatsInfo_list;
						else 
							WtpShowNode = WtpShowNode->next;
			
						if(WtpShowNode == NULL)
							break;
			
						vty_out(vty,"	 ========================WTPInformation============================ 	\n");
						vty_out(vty,"WTPID:   %-5d	\t\t\t\t",WtpShowNode->wtpCurrID);
						vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
						WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
						WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
						
						vty_out(vty,"wtp_radio_num:   %-5u	\n",WtpShowNode->wtp_radio_num);
						vty_out(vty,"math_AvgRxSignalStrength: %-5g  \t\t",WtpShowNode->math_wirelessIfAvgRxSignalStrength);
			
						vty_out(vty,"wifi snr max2:   %-5d	\n",WtpShowNode->wirelessIfHighestRxSignalStrength2);
						vty_out(vty,"wifi snr avg2:   %-5d	\t\t\t",WtpShowNode->wirelessIfAvgRxSignalStrength2);
						vty_out(vty,"wifi snr min2: %d \n",WtpShowNode->wirelessIfLowestRxSignalStrength2);
						vty_out(vty,"TxDataPkts:   %-5u  \t\t\t\t",WtpShowNode->wirelessIfTxDataPkts);
						vty_out(vty,"RxDataPkts:   %-5u  \n",WtpShowNode->wirelessIfRxDataPkts);
						vty_out(vty,"UplinkDataOctets:	 %-5llu  \t\t\t",WtpShowNode->wirelessIfUplinkDataOctets);
						
						vty_out(vty,"DwlinkDataOctets:	 %-5llu  \n",WtpShowNode->wirelessIfDwlinkDataOctets);
						vty_out(vty,"ChStatsPhyErrPkts:   %-5u	\t\t\t",WtpShowNode->wirelessIfChStatsPhyErrPkts);
						vty_out(vty,"ChStatsMacFcsErrPkts:	 %-5u  \n",WtpShowNode->wirelessIfChStatsMacFcsErrPkts);
						
						vty_out(vty,"ChStatsMacMicErrPkts:	 %-5u  \t\t\t",WtpShowNode->wirelessIfChStatsMacMicErrPkts);
						vty_out(vty,"ChStatsMacDecryptErrPkts:	 %-5u  \n",WtpShowNode->wirelessIfChStatsMacDecryptErrPkts);
						vty_out(vty,"ChStatsFrameErrorCnt:	 %-5u  \t\t\t",WtpShowNode->wirelessIfChStatsFrameErrorCnt);
			
						vty_out(vty,"asd_radio_num: %u\n",WtpShowNode->asd_radio_num);
						vty_out(vty,"-------------------------------------------------------------------------\n");
						/*fengwenchao add 20110523*/
						if(WtpShowNode == NULL)
							vty_out(vty,"  WtpShowNode	=  nulL\n");
						if(WtpShowNode->neighbor_ap_count > 0)
						{
							vty_out(vty,"------------------------neighbor wtp information--------------------------\n");
							struct Neighbor_AP_ELE *neighbor = NULL;
							char essid[10][ESSID_DEFAULT_LEN] = {0};
							int num = 0;
							int  k1 =0;
							for(j=0;WtpShowNode&&j<WtpShowNode->neighbor_ap_count;j++)
							{
								if(neighbor == NULL)
									neighbor = WtpShowNode->neighbor_wtp;
								else 
									neighbor = neighbor->next;
			
								if(neighbor == NULL){
									vty_out(vty,"break\n");
									break;
								}	
								if(num == 0)
								{
									memcpy(essid[0],neighbor->ESSID,ESSID_DEFAULT_LEN);
									vty_out(vty,"WTP : %d	ESSID : %s	\n",neighbor->wtpid,neighbor->ESSID);
									num++;
								}
								for(k1 = 0; k1 <num;k1++)
								{
									if(strcmp(neighbor->ESSID,essid[k1]) != 0)
									{
										vty_out(vty,"WTP : %d	ESSID : %s	\n",neighbor->wtpid,neighbor->ESSID);
										memcpy(essid[num],neighbor->ESSID,ESSID_DEFAULT_LEN);
										num++;
										break;
									}
								}
								if(num == 10)
									break;
							}
						}
						else
						{
							vty_out(vty,"------------------------neighbor wtp information--------------------------\n");
							vty_out(vty,"There is not neighbor ap \n");
						}
						/*fengwenchao add end*/
						struct WtpWirelessIfstatsInfo_radio *sub_radio = NULL;
			
						for(j=0;j<WtpShowNode->wtp_radio_num;j++){
							if(sub_radio == NULL)
								sub_radio = WtpShowNode->wireless_sub_radio_head;
							else 
								sub_radio = sub_radio->next;
			
							if(sub_radio == NULL){
								vty_out(vty,"break\n");
								break;
							}
							
							vty_out(vty,"------------------------radio information:------------------------------- \n");
							vty_out(vty,"local_radioid:  %-5u  \t\t\t\t",(sub_radio->wtpWirelessIfIndex+1));
							vty_out(vty,"UpdownTimes:  %-5u  \n",sub_radio->wirelessIfUpdownTimes);
			
							vty_out(vty,"ChStatsUplinkUniFrameCnt:	%-5u  \t\t",sub_radio->wirelessIfChStatsUplinkUniFrameCnt);
							vty_out(vty,"ChStatsDwlinkUniFrameCnt:	%-5u  \n",sub_radio->wirelessIfChStatsDwlinkUniFrameCnt);
							vty_out(vty,"UpChStatsFrameNonUniFrameCnt:	%-5u  \t\t",sub_radio->wirelessIfUpChStatsFrameNonUniFrameCnt);
							vty_out(vty,"DownChStatsFrameNonUniFrameCnt:  %-5u	\n",sub_radio->wirelessIfDownChStatsFrameNonUniFrameCnt);
			
							vty_out(vty,"wirelessIfRxMgmtFrameCnt:	%-5u	\t",sub_radio->sub_rx_pkt_mgmt);
							vty_out(vty,"wirelessIfRxCtrlFrameCnt:	%-5u	\n",sub_radio->wirelessIfRxCtrlFrameCnt);
							vty_out(vty,"wirelessIfRxDataFrameCnt:	%-5u	\t",sub_radio->wirelessIfRxDataFrameCnt);
							vty_out(vty,"wirelessIfRxAuthenFrameCnt:  %-5u	\n",sub_radio->wirelessIfRxAuthenFrameCnt);
							vty_out(vty,"wirelessIfRxAssociateFrameCnt:  %-5u	\t",sub_radio->wirelessIfRxAssociateFrameCnt);
							
							vty_out(vty,"wirelessIfTxMgmtFrameCnt:	%-5u	\n",sub_radio->sub_tx_pkt_mgmt);
							vty_out(vty,"wirelessIfTxCtrlFrameCnt:	%-5u	\t",sub_radio->wirelessIfTxCtrlFrameCnt);
							vty_out(vty,"wirelessIfTxDataFrameCnt:	%-5u	\n",sub_radio->wirelessIfTxDataFrameCnt);
							vty_out(vty,"wirelessIfTxAuthenFrameCnt:  %-5u	\t",sub_radio->wirelessIfTxAuthenFrameCnt);
							vty_out(vty,"wirelessIfTxAssociateFrameCnt:  %-5u	\n",sub_radio->wirelessIfTxAssociateFrameCnt);
			
							vty_out(vty,"sub_wirelessIfRxDataPkts:	%-5u	\t",sub_radio->sub_wirelessIfRxDataPkts);
							vty_out(vty,"sub_wirelessIfTxDataPkts:	%-5u	\n",sub_radio->sub_wirelessIfTxDataPkts);
							vty_out(vty,"sub_wirelessIfChStatsFrameErrorCnt:  %-5u\t",sub_radio->sub_wirelessIfChStatsFrameErrorCnt);
							vty_out(vty,"sub_wirelessIfRxErrPkts:  %-5lu	\n",sub_radio->sub_wirelessIfRxErrPkts);
							vty_out(vty,"sub_wirelessIfTxDropPkts:	%-5lu	\t",sub_radio->sub_wirelessIfTxDropPkts);				
							vty_out(vty,"sub_wirelessIfRxDropPkts:	%-5lu	\n",sub_radio->sub_wirelessIfRxDropPkts);
							vty_out(vty,"sub_wirelessIfDwlinkDataOctets:  %-5llu	\n",sub_radio->sub_wirelessIfDwlinkDataOctets);
							vty_out(vty,"sub_wirelessIfUplinkDataOctets:  %-5llu	\t",sub_radio->sub_wirelessIfUplinkDataOctets);
							
							vty_out(vty,"sub_wirelessIfChStatsMacFcsErrPkts:  %-5u	\n",sub_radio->sub_wirelessIfChStatsMacFcsErrPkts);
							vty_out(vty,"sub_wirelessIfChStatsMacDecryptErrPkts:  %-5u	",sub_radio->sub_wirelessIfChStatsMacDecryptErrPkts);
							vty_out(vty,"sub_wirelessIfChStatsMacMicErrPkts:  %-5u	\n",sub_radio->sub_wirelessIfChStatsMacMicErrPkts);
							vty_out(vty,"sub_wirelessIfChStatsPhyErrPkts:  %-5u \t",sub_radio->sub_wirelessIfChStatsPhyErrPkts);
							vty_out(vty,"wirelessIfChStatsNumStations:	%-5u	\n",sub_radio->wirelessIfChStatsNumStations);
							/* book add for show retry packets of radio, 2011-5-19 */
							vty_out(vty,"TxSignalPkts:	 %-5u  \t\t\t",sub_radio->wirelessIfTxSignalPkts);
							vty_out(vty,"RxSignalPkts:	 %-5u  \n",sub_radio->wirelessIfRxSignalPkts);
							vty_out(vty,"ChStatsFrameRetryCnt:	 %-5u  \t\t",sub_radio->wirelessIfChStatsFrameRetryCnt);
							vty_out(vty,"ChStatsDwlinkTotRetryPkts:  %-5u  \n",sub_radio->wirelessIfChStatsDwlinkTotRetryPkts);
							vty_out(vty,"radio_cur_snr:  %-5d	\t\t\t",sub_radio->radio_cur_snr2);
							vty_out(vty,"radio_max_snr:  %-5d	\n",sub_radio->radio_max_snr2);
							vty_out(vty,"radio_min_snr:  %-5d	\t\t\t",sub_radio->radio_min_snr2);
							vty_out(vty,"radio_aver_snr:  %-5g	\n",sub_radio->radio_aver_snr);
							
							vty_out(vty,"sub_rx_pkt_mgmt:  %-5u \t\t\t",sub_radio->sub_rx_pkt_mgmt);
							vty_out(vty,"sub_tx_pkt_mgmt:  %-5u \n",sub_radio->sub_tx_pkt_mgmt);
							vty_out(vty,"sub_rx_mgmt:  %-5llu	\t\t\t",sub_radio->sub_rx_mgmt);
							vty_out(vty,"sub_tx_mgmt:  %-5llu	\n",sub_radio->sub_tx_mgmt);
			
							vty_out(vty,"sub_total_rx_bytes:  %-5llu	\t\t",sub_radio->sub_total_rx_bytes);
							vty_out(vty,"sub_total_tx_bytes:  %-5llu	\n",sub_radio->sub_total_tx_bytes);
							vty_out(vty,"sub_total_rx_pkt:	%-5llu	\t\t",sub_radio->sub_total_rx_pkt);
							vty_out(vty,"sub_total_tx_pkt:	%-5llu	\n",sub_radio->sub_total_tx_pkt);
						}
					}
				}
			
				else if (ret == WID_DBUS_ERROR){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == WTP_ID_NOT_EXIST){
					vty_out(vty,"<error> There is no WTP now.\n");
				}
				else{
					vty_out(vty,"<error> ret = %d\n",ret);
				}
			
				dcli_free_wtp_wireless_ifstats_Info(WtpHead);
				vty_out(vty,"==============================================================================\n");
				if(argc == 2){
					return CMD_SUCCESS;
				}
			}
		}

		//for local hansi info
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 1;
			
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,1,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}
		
			local_hansi_parameter:
				WtpHead = show_wirelessifstatsInfo_info_of_all_wtp(profile,localid,dcli_dbus_connection, &wtp_num, &ret);
				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"local hansi %d-%d\n",slot_id,profile);
				vty_out(vty,"-----------------------------------------------------------------------------\n");
				if((WtpHead!=NULL)&&(ret == 0)){
					vty_out(vty,"WTPNum:%-5u  \n",wtp_num);
					vty_out(vty,"========================================================================== \n");
					WtpShowNode = NULL;
					for (i = 0; i < wtp_num; i++) { 
						if(WtpShowNode == NULL)
							WtpShowNode = WtpHead->WtpWirelessIfstatsInfo_list;
						else 
							WtpShowNode = WtpShowNode->next;
			
						if(WtpShowNode == NULL)
							break;
			
						vty_out(vty,"	 ========================WTPInformation============================ 	\n");
						vty_out(vty,"WTPID:   %-5d	\t\t\t\t",WtpShowNode->wtpCurrID);
						vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
						WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
						WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
						
						vty_out(vty,"wtp_radio_num:   %-5u	\n",WtpShowNode->wtp_radio_num);
						vty_out(vty,"math_AvgRxSignalStrength: %-5g  \t\t",WtpShowNode->math_wirelessIfAvgRxSignalStrength);
			
						vty_out(vty,"wifi snr max2:   %-5d	\n",WtpShowNode->wirelessIfHighestRxSignalStrength2);
						vty_out(vty,"wifi snr avg2:   %-5d	\t\t\t",WtpShowNode->wirelessIfAvgRxSignalStrength2);
						vty_out(vty,"wifi snr min2: %d \n",WtpShowNode->wirelessIfLowestRxSignalStrength2);
						vty_out(vty,"TxDataPkts:   %-5u  \t\t\t\t",WtpShowNode->wirelessIfTxDataPkts);
						vty_out(vty,"RxDataPkts:   %-5u  \n",WtpShowNode->wirelessIfRxDataPkts);
						vty_out(vty,"UplinkDataOctets:	 %-5llu  \t\t\t",WtpShowNode->wirelessIfUplinkDataOctets);
						
						vty_out(vty,"DwlinkDataOctets:	 %-5llu  \n",WtpShowNode->wirelessIfDwlinkDataOctets);
						vty_out(vty,"ChStatsPhyErrPkts:   %-5u	\t\t\t",WtpShowNode->wirelessIfChStatsPhyErrPkts);
						vty_out(vty,"ChStatsMacFcsErrPkts:	 %-5u  \n",WtpShowNode->wirelessIfChStatsMacFcsErrPkts);
						
						vty_out(vty,"ChStatsMacMicErrPkts:	 %-5u  \t\t\t",WtpShowNode->wirelessIfChStatsMacMicErrPkts);
						vty_out(vty,"ChStatsMacDecryptErrPkts:	 %-5u  \n",WtpShowNode->wirelessIfChStatsMacDecryptErrPkts);
						vty_out(vty,"ChStatsFrameErrorCnt:	 %-5u  \t\t\t",WtpShowNode->wirelessIfChStatsFrameErrorCnt);
			
						vty_out(vty,"asd_radio_num: %u\n",WtpShowNode->asd_radio_num);
						vty_out(vty,"-------------------------------------------------------------------------\n");
						/*fengwenchao add 20110523*/
						if(WtpShowNode == NULL)
							vty_out(vty,"  WtpShowNode	=  nulL\n");
						if(WtpShowNode->neighbor_ap_count > 0)
						{
							vty_out(vty,"------------------------neighbor wtp information--------------------------\n");
							struct Neighbor_AP_ELE *neighbor = NULL;
							char essid[10][ESSID_DEFAULT_LEN] = {0};
							int num = 0;
							int  k1 =0;
							for(j=0;WtpShowNode&&j<WtpShowNode->neighbor_ap_count;j++)
							{
								if(neighbor == NULL)
									neighbor = WtpShowNode->neighbor_wtp;
								else 
									neighbor = neighbor->next;
			
								if(neighbor == NULL){
									vty_out(vty,"break\n");
									break;
								}	
								if(num == 0)
								{
									memcpy(essid[0],neighbor->ESSID,ESSID_DEFAULT_LEN);
									vty_out(vty,"WTP : %d	ESSID : %s	\n",neighbor->wtpid,neighbor->ESSID);
									num++;
								}
								for(k1 = 0; k1 <num;k1++)
								{
									if(strcmp(neighbor->ESSID,essid[k1]) != 0)
									{
										vty_out(vty,"WTP : %d	ESSID : %s	\n",neighbor->wtpid,neighbor->ESSID);
										memcpy(essid[num],neighbor->ESSID,ESSID_DEFAULT_LEN);
										num++;
										break;
									}
								}
								if(num == 10)
									break;
							}
						}
						else
						{
							vty_out(vty,"------------------------neighbor wtp information--------------------------\n");
							vty_out(vty,"There is not neighbor ap \n");
						}
						/*fengwenchao add end*/
						struct WtpWirelessIfstatsInfo_radio *sub_radio = NULL;
			
						for(j=0;j<WtpShowNode->wtp_radio_num;j++){
							if(sub_radio == NULL)
								sub_radio = WtpShowNode->wireless_sub_radio_head;
							else 
								sub_radio = sub_radio->next;
			
							if(sub_radio == NULL){
								vty_out(vty,"break\n");
								break;
							}
							
							vty_out(vty,"------------------------radio information:------------------------------- \n");
							vty_out(vty,"local_radioid:  %-5u  \t\t\t\t",(sub_radio->wtpWirelessIfIndex+1));
							vty_out(vty,"UpdownTimes:  %-5u  \n",sub_radio->wirelessIfUpdownTimes);
			
							vty_out(vty,"ChStatsUplinkUniFrameCnt:	%-5u  \t\t",sub_radio->wirelessIfChStatsUplinkUniFrameCnt);
							vty_out(vty,"ChStatsDwlinkUniFrameCnt:	%-5u  \n",sub_radio->wirelessIfChStatsDwlinkUniFrameCnt);
							vty_out(vty,"UpChStatsFrameNonUniFrameCnt:	%-5u  \t\t",sub_radio->wirelessIfUpChStatsFrameNonUniFrameCnt);
							vty_out(vty,"DownChStatsFrameNonUniFrameCnt:  %-5u	\n",sub_radio->wirelessIfDownChStatsFrameNonUniFrameCnt);
			
							vty_out(vty,"wirelessIfRxMgmtFrameCnt:	%-5u	\t",sub_radio->sub_rx_pkt_mgmt);
							vty_out(vty,"wirelessIfRxCtrlFrameCnt:	%-5u	\n",sub_radio->wirelessIfRxCtrlFrameCnt);
							vty_out(vty,"wirelessIfRxDataFrameCnt:	%-5u	\t",sub_radio->wirelessIfRxDataFrameCnt);
							vty_out(vty,"wirelessIfRxAuthenFrameCnt:  %-5u	\n",sub_radio->wirelessIfRxAuthenFrameCnt);
							vty_out(vty,"wirelessIfRxAssociateFrameCnt:  %-5u	\t",sub_radio->wirelessIfRxAssociateFrameCnt);
							
							vty_out(vty,"wirelessIfTxMgmtFrameCnt:	%-5u	\n",sub_radio->sub_tx_pkt_mgmt);
							vty_out(vty,"wirelessIfTxCtrlFrameCnt:	%-5u	\t",sub_radio->wirelessIfTxCtrlFrameCnt);
							vty_out(vty,"wirelessIfTxDataFrameCnt:	%-5u	\n",sub_radio->wirelessIfTxDataFrameCnt);
							vty_out(vty,"wirelessIfTxAuthenFrameCnt:  %-5u	\t",sub_radio->wirelessIfTxAuthenFrameCnt);
							vty_out(vty,"wirelessIfTxAssociateFrameCnt:  %-5u	\n",sub_radio->wirelessIfTxAssociateFrameCnt);
			
							vty_out(vty,"sub_wirelessIfRxDataPkts:	%-5u	\t",sub_radio->sub_wirelessIfRxDataPkts);
							vty_out(vty,"sub_wirelessIfTxDataPkts:	%-5u	\n",sub_radio->sub_wirelessIfTxDataPkts);
							vty_out(vty,"sub_wirelessIfChStatsFrameErrorCnt:  %-5u\t",sub_radio->sub_wirelessIfChStatsFrameErrorCnt);
							vty_out(vty,"sub_wirelessIfRxErrPkts:  %-5lu	\n",sub_radio->sub_wirelessIfRxErrPkts);
							vty_out(vty,"sub_wirelessIfTxDropPkts:	%-5lu	\t",sub_radio->sub_wirelessIfTxDropPkts);				
							vty_out(vty,"sub_wirelessIfRxDropPkts:	%-5lu	\n",sub_radio->sub_wirelessIfRxDropPkts);
							vty_out(vty,"sub_wirelessIfDwlinkDataOctets:  %-5llu	\n",sub_radio->sub_wirelessIfDwlinkDataOctets);
							vty_out(vty,"sub_wirelessIfUplinkDataOctets:  %-5llu	\t",sub_radio->sub_wirelessIfUplinkDataOctets);
							
							vty_out(vty,"sub_wirelessIfChStatsMacFcsErrPkts:  %-5u	\n",sub_radio->sub_wirelessIfChStatsMacFcsErrPkts);
							vty_out(vty,"sub_wirelessIfChStatsMacDecryptErrPkts:  %-5u	",sub_radio->sub_wirelessIfChStatsMacDecryptErrPkts);
							vty_out(vty,"sub_wirelessIfChStatsMacMicErrPkts:  %-5u	\n",sub_radio->sub_wirelessIfChStatsMacMicErrPkts);
							vty_out(vty,"sub_wirelessIfChStatsPhyErrPkts:  %-5u \t",sub_radio->sub_wirelessIfChStatsPhyErrPkts);
							vty_out(vty,"wirelessIfChStatsNumStations:	%-5u	\n",sub_radio->wirelessIfChStatsNumStations);
							/* book add for show retry packets of radio, 2011-5-19 */
							vty_out(vty,"TxSignalPkts:	 %-5u  \t\t\t",sub_radio->wirelessIfTxSignalPkts);
							vty_out(vty,"RxSignalPkts:	 %-5u  \n",sub_radio->wirelessIfRxSignalPkts);
							vty_out(vty,"ChStatsFrameRetryCnt:	 %-5u  \t\t",sub_radio->wirelessIfChStatsFrameRetryCnt);
							vty_out(vty,"ChStatsDwlinkTotRetryPkts:  %-5u  \n",sub_radio->wirelessIfChStatsDwlinkTotRetryPkts);
							vty_out(vty,"radio_cur_snr:  %-5d	\t\t\t",sub_radio->radio_cur_snr2);
							vty_out(vty,"radio_max_snr:  %-5d	\n",sub_radio->radio_max_snr2);
							vty_out(vty,"radio_min_snr:  %-5d	\t\t\t",sub_radio->radio_min_snr2);
							vty_out(vty,"radio_aver_snr:  %-5g	\n",sub_radio->radio_aver_snr);
							
							vty_out(vty,"sub_rx_pkt_mgmt:  %-5u \t\t\t",sub_radio->sub_rx_pkt_mgmt);
							vty_out(vty,"sub_tx_pkt_mgmt:  %-5u \n",sub_radio->sub_tx_pkt_mgmt);
							vty_out(vty,"sub_rx_mgmt:  %-5llu	\t\t\t",sub_radio->sub_rx_mgmt);
							vty_out(vty,"sub_tx_mgmt:  %-5llu	\n",sub_radio->sub_tx_mgmt);
			
							vty_out(vty,"sub_total_rx_bytes:  %-5llu	\t\t",sub_radio->sub_total_rx_bytes);
							vty_out(vty,"sub_total_tx_bytes:  %-5llu	\n",sub_radio->sub_total_tx_bytes);
							vty_out(vty,"sub_total_rx_pkt:	%-5llu	\t\t",sub_radio->sub_total_rx_pkt);
							vty_out(vty,"sub_total_tx_pkt:	%-5llu	\n",sub_radio->sub_total_tx_pkt);
						}
					}
				}
			
				else if (ret == WID_DBUS_ERROR){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == WTP_ID_NOT_EXIST){
					vty_out(vty,"<error> There is no WTP now.\n");
				}
				else{
					vty_out(vty,"<error> ret = %d\n",ret);
				}
			
				dcli_free_wtp_wireless_ifstats_Info(WtpHead);
				vty_out(vty,"==============================================================================\n");
				if(argc == 2){
					return CMD_SUCCESS;
				}
			}
		}
	}

	return CMD_SUCCESS;
}

/*add for showing wtp device information*/
DEFUN(show_all_wtp_device_information_func,
	  show_all_wtp_device_information_cmd,
	  "show device information of all_wtp [remote] [local] [PARAMETER]",
	  SHOW_STR
	  "Display device information of all wtps\n"
	  "List wtp device information\n"
	  "of all wtp\n"
	  "by wtp display device information\n"
	  "'remote' or 'local' hansi\n"
	  "'remote' or 'local' hansi\n"
	  "slotid-instid\n"
	 )
{
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	struct WtpDeviceInfo *WtpHead = NULL;
	struct WtpDeviceInfo *WtpShowNode = NULL;
	int ret=0;
	int i=0;
	unsigned int num = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	int profile = 0;
	int instRun = 0;
	int flag = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	if((argc == 1)||(argc == 3)){
		vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
		return CMD_SUCCESS;
	}
	if(argc == 2){
		if (!strcmp(argv[0],"remote")){
			localid = 0;
		}else if(!strcmp(argv[0],"local")){
			localid = 1;
		}else{
			vty_out(vty,"parameter should be 'remote' or 'local'\n");
			return CMD_SUCCESS;
		}
		
		if((!strcmp(argv[0],"remote"))&&(!strcmp(argv[1],"local"))){
			vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
			return CMD_SUCCESS;
		}
		
		ret = parse_slot_hansi_id((char*)argv[1],&slot_id,&profile);
		if(ret != WID_DBUS_SUCCESS){
			slot_id = HostSlotId;
			flag = 1;
			ret = parse_int_ID((char*)argv[1], &profile);
			if(ret != WID_DBUS_SUCCESS){
				if(ret == WID_ILLEGAL_INPUT){
					vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
				}
				else{
					vty_out(vty,"<error> unknown id format\n");
				}
				return CMD_WARNING;
			}	
		}
		if(distributFag == 0){
			if(slot_id != 0){
				vty_out(vty,"<error> slot id should be 0\n");
				return CMD_WARNING;
			}	
		}else if(flag == 1){
			slot_id = HostSlotId;
		}
		if(slot_id >= MAX_SLOT_NUM || slot_id < 0){
			vty_out(vty,"<error> slot id should be 1 to %d\n",MAX_SLOT_NUM-1);
			return CMD_WARNING;
		}	
		if(profile >= MAX_INSTANCE || profile == 0){
			vty_out(vty,"<error> hansi id should be 1 to %d\n",MAX_INSTANCE-1);
			return CMD_WARNING;
		}
		instRun = dcli_hmd_hansi_is_running(vty,slot_id,localid,profile);
		if (INSTANCE_NO_CREATED == instRun) {
			vty_out(vty,"<error> the instance %s %d-%d is not running\n",((localid == 1)?"local-hansi":"hansi"),slot_id,profile);
			return CMD_WARNING;
		}
		
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		if(localid == 0)
			goto hansi_parameter;
		else if(localid == 1)
			goto local_hansi_parameter; 
	}

	if(vty->node != VIEW_NODE){
		WtpHead = show_WtpDeviceInfo_of_all_wtp(index,localid,dcli_dbus_connection, &num, &ret);

		if((WtpHead!=NULL)&&(ret == 0)){
			vty_out(vty,"WTPNum:%-5d  \n",num);
			vty_out(vty,"========================================================================== \n");
			for (i = 0; i < num; i++) {	
				if(WtpShowNode == NULL)
					WtpShowNode = WtpHead->WtpDeviceInfo_list;
				else 
					WtpShowNode = WtpShowNode->next;

				if(WtpShowNode == NULL)
					break;
				
				vty_out(vty,"WTPID:   %-5d  \t\t\t",WtpShowNode->wtpCurrID);
				vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
				WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
				WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);

				vty_out(vty,"WTPModel: %s  \t\t",WtpShowNode->wtpModel);
				vty_out(vty,"wtpFlashType: %-5s   \n",WtpShowNode->flashType_str);
				
				vty_out(vty,"CPUusageThreshhd:   %-5d  \t\t",WtpShowNode->wtpCPUusageThreshhd);
				vty_out(vty,"MemUsageThreshhd:   %-5d  \n",WtpShowNode->wtpMemUsageThreshhd);

				vty_out(vty,"wtpCPUType:   %5s   \t\t",WtpShowNode->cpuType_str);
				vty_out(vty,"wtpMemoryType:	 %-5s  \n",WtpShowNode->memType_str);
				vty_out(vty,"wtpCPURTUsage:	%0.2f %\t\t\t",WtpShowNode->wtpCPURTUsage/100.00);
				vty_out(vty,"wtpMemoryCapacity:	 %lld  \n",WtpShowNode->wtpMemoryCapacity);
				vty_out(vty,"wtpMemRTUsage:	 %-5d  \t\t",WtpShowNode->wtpMemRTUsage);
				
				vty_out(vty,"wtpFlashCapacity:	 %lld  \n",WtpShowNode->wtpFlashCapacity);
				vty_out(vty,"wtpFlashRemain:	 %-5d  \t\t",WtpShowNode->wtpFlashRemain);
				vty_out(vty,"wtpWayGetIP:	 %-5d  \n",WtpShowNode->wtpWayGetIP);
				vty_out(vty,"wtpWorkTemp:	 %-5d  \t\t",WtpShowNode->wtpWorkTemp);
				vty_out(vty,"WtpIP:	 % s  \n",WtpShowNode->WtpIP);
				//vty_out(vty,"cpu average:	%0.2f %\t\t\t",WtpShowNode->wtpCPUAvgUsage/100.00);
				
				vty_out(vty,"cpu average:	%0.2f %\t\t\t",WtpShowNode->cpu_collect_average/100.00);
				vty_out(vty,"cpu peak value:	%0.2f %\n",WtpShowNode->wtpCPUPeakUsage/100.00);
				vty_out(vty,"wtpMemAvgUsage:	 %-5d % \t\t",WtpShowNode->wtpMemAvgUsage);
				vty_out(vty,"wtpMemPeakUsage:	 %-5d % \n",WtpShowNode->wtpMemPeakUsage);

				vty_out(vty,"-------------------------------------------------------------------------\n");
			}
			vty_out(vty,"========================================================================== \n");
		}

		else if (ret == WID_DBUS_ERROR){
			cli_syslog_info("<error> failed get reply.\n");
		}
		else if(ret == WTP_ID_NOT_EXIST){
			vty_out(vty,"<error> There is no WTP now.\n");
		}
		else{
			vty_out(vty,"<error> ret = %d\n",ret);
		}
		dcli_free_wtp_device_Info(WtpHead);
	}

	if(vty->node == VIEW_NODE){
		//for remote hansi info
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 0;
			
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,0,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}

		hansi_parameter:
				
				WtpHead = show_WtpDeviceInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &num, &ret);

				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"hansi %d-%d\n",slot_id,profile);
				vty_out(vty,"-----------------------------------------------------------------------------\n");
				if((WtpHead!=NULL)&&(ret == 0)){
					vty_out(vty,"WTPNum:%-5d  \n",num);
					vty_out(vty,"========================================================================== \n");
					WtpShowNode = NULL;
					for (i = 0; i < num; i++) {	
						if(WtpShowNode == NULL)
							WtpShowNode = WtpHead->WtpDeviceInfo_list;
						else 
							WtpShowNode = WtpShowNode->next;

						if(WtpShowNode == NULL)
							break;
						
						vty_out(vty,"WTPID:   %-5d  \t\t\t",WtpShowNode->wtpCurrID);
						vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
						WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
						WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);

						vty_out(vty,"WTPModel: %s  \t\t",WtpShowNode->wtpModel);
						vty_out(vty,"wtpFlashType: %-5s   \n",WtpShowNode->flashType_str);
						
						vty_out(vty,"CPUusageThreshhd:   %-5d  \t\t",WtpShowNode->wtpCPUusageThreshhd);
						vty_out(vty,"MemUsageThreshhd:   %-5d  \n",WtpShowNode->wtpMemUsageThreshhd);

						vty_out(vty,"wtpCPUType:   %5s   \t\t",WtpShowNode->cpuType_str);
						vty_out(vty,"wtpMemoryType:	 %-5s  \n",WtpShowNode->memType_str);
						vty_out(vty,"wtpCPURTUsage:	%0.2f %\t\t\t",WtpShowNode->wtpCPURTUsage/100.00);
						vty_out(vty,"wtpMemoryCapacity:	 %lld  \n",WtpShowNode->wtpMemoryCapacity);
						vty_out(vty,"wtpMemRTUsage:	 %-5d  \t\t",WtpShowNode->wtpMemRTUsage);
						
						vty_out(vty,"wtpFlashCapacity:	 %lld  \n",WtpShowNode->wtpFlashCapacity);
						vty_out(vty,"wtpFlashRemain:	 %-5d  \t\t",WtpShowNode->wtpFlashRemain);
						vty_out(vty,"wtpWayGetIP:	 %-5d  \n",WtpShowNode->wtpWayGetIP);
						vty_out(vty,"wtpWorkTemp:	 %-5d  \t\t",WtpShowNode->wtpWorkTemp);
						vty_out(vty,"WtpIP:	 % s  \n",WtpShowNode->WtpIP);
						
						vty_out(vty,"cpu average:	%0.2f %\t\t\t",WtpShowNode->cpu_collect_average/100.00);
						vty_out(vty,"cpu peak value:	%0.2f %\n",WtpShowNode->wtpCPUPeakUsage/100.00);
						vty_out(vty,"wtpMemAvgUsage:	 %-5d % \t\t",WtpShowNode->wtpMemAvgUsage);
						vty_out(vty,"wtpMemPeakUsage:	 %-5d % \n",WtpShowNode->wtpMemPeakUsage);

						vty_out(vty,"-------------------------------------------------------------------------\n");
					}
				}

				else if (ret == WID_DBUS_ERROR){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == WTP_ID_NOT_EXIST){
					vty_out(vty,"<error> There is no WTP now.\n");
				}
				else{
					vty_out(vty,"<error> ret = %d\n",ret);
				}
				dcli_free_wtp_device_Info(WtpHead);
				vty_out(vty,"==============================================================================\n");
				if(argc == 2){
					return CMD_SUCCESS;
				}
			}
		}

	//for local hansi info
	for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		localid = 1;
		
		for (profile = 1; profile < MAX_INSTANCE; profile++) 
		{
			instRun = dcli_hmd_hansi_is_running(vty,slot_id,1,profile);
			if (INSTANCE_NO_CREATED == instRun) {
				continue;
			}
	
		local_hansi_parameter:
			WtpHead = show_WtpDeviceInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &num, &ret);

			vty_out(vty,"==============================================================================\n");
			vty_out(vty,"local hansi %d-%d\n",slot_id,profile);
			vty_out(vty,"-----------------------------------------------------------------------------\n");
			if((WtpHead!=NULL)&&(ret == 0)){
				vty_out(vty,"WTPNum:%-5d  \n",num);
				vty_out(vty,"========================================================================== \n");
				WtpShowNode = NULL;
				for (i = 0; i < num; i++) {	
					if(WtpShowNode == NULL)
						WtpShowNode = WtpHead->WtpDeviceInfo_list;
					else 
						WtpShowNode = WtpShowNode->next;

					if(WtpShowNode == NULL)
						break;
					
					vty_out(vty,"WTPID:   %-5d  \t\t\t",WtpShowNode->wtpCurrID);
					vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
					WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
					WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);

					vty_out(vty,"WTPModel: %s  \t\t",WtpShowNode->wtpModel);
					vty_out(vty,"wtpFlashType: %-5s   \n",WtpShowNode->flashType_str);
					
					vty_out(vty,"CPUusageThreshhd:   %-5d  \t\t",WtpShowNode->wtpCPUusageThreshhd);
					vty_out(vty,"MemUsageThreshhd:   %-5d  \n",WtpShowNode->wtpMemUsageThreshhd);

					vty_out(vty,"wtpCPUType:   %5s   \t\t",WtpShowNode->cpuType_str);
					vty_out(vty,"wtpMemoryType:	 %-5s  \n",WtpShowNode->memType_str);
					vty_out(vty,"wtpCPURTUsage:	%0.2f %\t\t\t",WtpShowNode->wtpCPURTUsage/100.00);
					vty_out(vty,"wtpMemoryCapacity:	 %lld  \n",WtpShowNode->wtpMemoryCapacity);
					vty_out(vty,"wtpMemRTUsage:	 %-5d  \t\t",WtpShowNode->wtpMemRTUsage);
					
					vty_out(vty,"wtpFlashCapacity:	 %lld  \n",WtpShowNode->wtpFlashCapacity);
					vty_out(vty,"wtpFlashRemain:	 %-5d  \t\t",WtpShowNode->wtpFlashRemain);
					vty_out(vty,"wtpWayGetIP:	 %-5d  \n",WtpShowNode->wtpWayGetIP);
					vty_out(vty,"wtpWorkTemp:	 %-5d  \t\t",WtpShowNode->wtpWorkTemp);
					vty_out(vty,"WtpIP:	 % s  \n",WtpShowNode->WtpIP);
					
					vty_out(vty,"cpu average:	%0.2f %\t\t\t",WtpShowNode->cpu_collect_average/100.00);
					vty_out(vty,"cpu peak value:	%0.2f %\n",WtpShowNode->wtpCPUPeakUsage/100.00);
					vty_out(vty,"wtpMemAvgUsage:	 %-5d % \t\t",WtpShowNode->wtpMemAvgUsage);
					vty_out(vty,"wtpMemPeakUsage:	 %-5d % \n",WtpShowNode->wtpMemPeakUsage);

					vty_out(vty,"-------------------------------------------------------------------------\n");
				}
			}

			else if (ret == WID_DBUS_ERROR){
				cli_syslog_info("<error> failed get reply.\n");
			}
			else if(ret == WTP_ID_NOT_EXIST){
				vty_out(vty,"<error> There is no WTP now.\n");
			}
			else{
				vty_out(vty,"<error> ret = %d\n",ret);
			}
			dcli_free_wtp_device_Info(WtpHead);
			vty_out(vty,"==============================================================================\n");
			if(argc == 2){
				return CMD_SUCCESS;
			}
			}
		}
	}

	return CMD_SUCCESS;
}

/*add for showing wtp data pkts information for table 6 by nl*/
DEFUN(show_all_wtp_data_pkts_information_func,
	  show_all_wtp_data_pkts_information_cmd,
	  "show data pkts information_of all_wtp [remote] [local] [PARAMETER]",
	  SHOW_STR
	  "data pkts\n"
	  "Display data pkts information of all wtps\n"
	  "List wtp data pkts information\n"
	  "by wtp display data pkts information\n"
	  "'remote' or 'local' hansi\n"
	  "'remote' or 'local' hansi\n"
	  "slotid-instid\n"
	 )
{
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	struct WtpDataPktsInfo *WtpHead = NULL;
	struct WtpDataPktsInfo *WtpShowNode = NULL;
	int ret=0;
	int i=0;
	unsigned int num = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	int profile = 0;
	int instRun = 0;
	int flag = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	if((argc == 1)||(argc == 3)){
		vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
		return CMD_SUCCESS;
	}
	if(argc == 2){
		if (!strcmp(argv[0],"remote")){
			localid = 0;
		}else if(!strcmp(argv[0],"local")){
			localid = 1;
		}else{
			vty_out(vty,"parameter should be 'remote' or 'local'\n");
			return CMD_SUCCESS;
		}
		
		if((!strcmp(argv[0],"remote"))&&(!strcmp(argv[1],"local"))){
			vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
			return CMD_SUCCESS;
		}
		
		ret = parse_slot_hansi_id((char*)argv[1],&slot_id,&profile);
		if(ret != WID_DBUS_SUCCESS){
			slot_id = HostSlotId;
			flag = 1;
			ret = parse_int_ID((char*)argv[1], &profile);
			if(ret != WID_DBUS_SUCCESS){
				if(ret == WID_ILLEGAL_INPUT){
					vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
				}
				else{
					vty_out(vty,"<error> unknown id format\n");
				}
				return CMD_WARNING;
			}	
		}
		if(distributFag == 0){
			if(slot_id != 0){
				vty_out(vty,"<error> slot id should be 0\n");
				return CMD_WARNING;
			}	
		}else if(flag == 1){
			slot_id = HostSlotId;
		}
		if(slot_id >= MAX_SLOT_NUM || slot_id < 0){
			vty_out(vty,"<error> slot id should be 1 to %d\n",MAX_SLOT_NUM-1);
			return CMD_WARNING;
		}	
		if(profile >= MAX_INSTANCE || profile == 0){
			vty_out(vty,"<error> hansi id should be 1 to %d\n",MAX_INSTANCE-1);
			return CMD_WARNING;
		}
		instRun = dcli_hmd_hansi_is_running(vty,slot_id,localid,profile);
		if (INSTANCE_NO_CREATED == instRun) {
			vty_out(vty,"<error> the instance %s %d-%d is not running\n",((localid == 1)?"local-hansi":"hansi"),slot_id,profile);
			return CMD_WARNING;
		}
		
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		if(localid == 0)
			goto hansi_parameter;
		else if(localid == 1)
			goto local_hansi_parameter; 
	}

	if(vty->node != VIEW_NODE){
		WtpHead = show_WtpDataPktsInfo_of_all_wtp(index,localid,dcli_dbus_connection, &num, &ret);

		if((WtpHead!=NULL)&&(ret == 0)){
			vty_out(vty,"WTPNum:%-5d  \n",num);
			vty_out(vty,"========================================================================== \n");
			for (i = 0; i < num; i++) {	
				if(WtpShowNode == NULL)
					WtpShowNode = WtpHead->WtpDataPktsInfo_list;
				else 
					WtpShowNode = WtpShowNode->next;

				if(WtpShowNode == NULL)
					break;
				
				vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
				
				vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
				WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
				WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);

				vty_out(vty,"WirelessMacRecvAllByte:   %-5llu  \t\t",WtpShowNode->wtpWirelessMacRecvAllByte);
				vty_out(vty,"WirelessMacSendAllByte:   %-5llu  \n",WtpShowNode->wtpWirelessMacSendAllByte);
				vty_out(vty,"WirelessMacRecvPack:   %-5d  \t\t\t",WtpShowNode->wtpWirelessMacRecvPack);
				vty_out(vty,"WirelessMacRecvWrongPack:   %-5d  \n",WtpShowNode->wtpWirelessMacRecvWrongPack);
				vty_out(vty,"DropPkts:   %-5d  \t\t\t\t",WtpShowNode->wtpDropPkts);
				vty_out(vty,"WirelessMacSendPack:   %-5d  \n",WtpShowNode->wtpWirelessMacSendPack);

				vty_out(vty,"WirelessMacSendErrPack:   %-5d  \t\t",WtpShowNode->wtpWirelessMacSendErrPack);
				vty_out(vty,"WirelessMacRecvRightPack:   %-5d  \n",WtpShowNode->wtpWirelessMacRecvRightPack);
				vty_out(vty,"WirelessMacSendRightPack:   %-5d  \t\t",WtpShowNode->wtpWirelessMacSendRightPack);
				vty_out(vty,"WirelessradioRecvBytes:   %-5d  \n",WtpShowNode->wtpWirelessradioRecvBytes);

				/*wired information*/
				vty_out(vty,"WiredMacRecvRightByte:   %-5llu  \t\t",WtpShowNode->wtpWiredMacRecvRightByte);
				vty_out(vty,"WiredMacSendAllByte:	 %-5llu  \n",WtpShowNode->wtpWiredMacSendAllByte);
				vty_out(vty,"WiredMacRecvWrongPack:	 %-5d  \t\t",WtpShowNode->wtpWiredMacRecvWrongPack);
				vty_out(vty,"WiredMacRecvPack:   %-5d  \n",WtpShowNode->wtpWiredMacRecvPack);

				vty_out(vty,"WiredMacRecvRightPack:   %-5d  \t\t",WtpShowNode->wtpWiredMacRecvRightPack);
				vty_out(vty,"WiredMacSendPack:	 %-5d  \n",WtpShowNode->wtpWiredMacSendPack);
				vty_out(vty,"WiredMacSendErrPack:	 %-5d  \t\t",WtpShowNode->wtpWiredMacSendErrPack);
				vty_out(vty,"WiredMacSendRightPack:   %-5d  \n",WtpShowNode->wtpWiredMacSendRightPack);
				/*ath information*/
				vty_out(vty,"WirelesscoreRecvBytes:   %-5llu  \n",WtpShowNode->wtpWirelesscoreRecvBytes);
				/*wtp information*/
				vty_out(vty,"WirelessRecvFlowByte:   %lld	\t\t",WtpShowNode->wtpWirelessRecvFlowByte);
				vty_out(vty,"WirelessSendFlowByte:   %lld	\n",WtpShowNode->wtpWirelessSendFlowByte);

				vty_out(vty,"-------------------------------------------------------------------------\n");
			}
			vty_out(vty,"========================================================================== \n");
		}

		else if (ret == WID_DBUS_ERROR){
			cli_syslog_info("<error> failed get reply.\n");
		}
		else if(ret == WTP_ID_NOT_EXIST){
			vty_out(vty,"<error> There is no WTP now.\n");
		}
		else{
			vty_out(vty,"<error> ret = %d\n",ret);
		}
		dcli_free_wtp_data_pkts_Info(WtpHead);
	}

	if(vty->node == VIEW_NODE){
		//for remote hansi info
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 0;
			
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,0,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}

		hansi_parameter:
				WtpHead = show_WtpDataPktsInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &num, &ret);

				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"hansi %d-%d\n",slot_id,profile);
				vty_out(vty,"-----------------------------------------------------------------------------\n");
				if((WtpHead!=NULL)&&(ret == 0)){
					vty_out(vty,"WTPNum:%-5d  \n",num);
					vty_out(vty,"========================================================================== \n");
					WtpShowNode = NULL;
					for (i = 0; i < num; i++) {	
						if(WtpShowNode == NULL)
							WtpShowNode = WtpHead->WtpDataPktsInfo_list;
						else 
							WtpShowNode = WtpShowNode->next;

						if(WtpShowNode == NULL)
							break;
						
						vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
						
						vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
						WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
						WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);

						vty_out(vty,"WirelessMacRecvAllByte:   %-5llu  \t\t",WtpShowNode->wtpWirelessMacRecvAllByte);
						vty_out(vty,"WirelessMacSendAllByte:   %-5llu  \n",WtpShowNode->wtpWirelessMacSendAllByte);
						vty_out(vty,"WirelessMacRecvPack:   %-5d  \t\t\t",WtpShowNode->wtpWirelessMacRecvPack);
						vty_out(vty,"WirelessMacRecvWrongPack:   %-5d  \n",WtpShowNode->wtpWirelessMacRecvWrongPack);
						vty_out(vty,"DropPkts:   %-5d  \t\t\t\t",WtpShowNode->wtpDropPkts);
						vty_out(vty,"WirelessMacSendPack:   %-5d  \n",WtpShowNode->wtpWirelessMacSendPack);

						vty_out(vty,"WirelessMacSendErrPack:   %-5d  \t\t",WtpShowNode->wtpWirelessMacSendErrPack);
						vty_out(vty,"WirelessMacRecvRightPack:   %-5d  \n",WtpShowNode->wtpWirelessMacRecvRightPack);
						vty_out(vty,"WirelessMacSendRightPack:   %-5d  \t\t",WtpShowNode->wtpWirelessMacSendRightPack);
						vty_out(vty,"WirelessradioRecvBytes:   %-5d  \n",WtpShowNode->wtpWirelessradioRecvBytes);

						/*wired information*/
						vty_out(vty,"WiredMacRecvRightByte:   %-5llu  \t\t",WtpShowNode->wtpWiredMacRecvRightByte);
						vty_out(vty,"WiredMacSendAllByte:	 %-5llu  \n",WtpShowNode->wtpWiredMacSendAllByte);
						vty_out(vty,"WiredMacRecvWrongPack:	 %-5d  \t\t",WtpShowNode->wtpWiredMacRecvWrongPack);
						vty_out(vty,"WiredMacRecvPack:   %-5d  \n",WtpShowNode->wtpWiredMacRecvPack);

						vty_out(vty,"WiredMacRecvRightPack:   %-5d  \t\t",WtpShowNode->wtpWiredMacRecvRightPack);
						vty_out(vty,"WiredMacSendPack:	 %-5d  \n",WtpShowNode->wtpWiredMacSendPack);
						vty_out(vty,"WiredMacSendErrPack:	 %-5d  \t\t",WtpShowNode->wtpWiredMacSendErrPack);
						vty_out(vty,"WiredMacSendRightPack:   %-5d  \n",WtpShowNode->wtpWiredMacSendRightPack);
						/*ath information*/
						vty_out(vty,"WirelesscoreRecvBytes:   %-5llu  \n",WtpShowNode->wtpWirelesscoreRecvBytes);
						/*wtp information*/
						vty_out(vty,"WirelessRecvFlowByte:   %lld	\t\t",WtpShowNode->wtpWirelessRecvFlowByte);
						vty_out(vty,"WirelessSendFlowByte:   %lld	\n",WtpShowNode->wtpWirelessSendFlowByte);

						vty_out(vty,"-------------------------------------------------------------------------\n");
					}
				}

				else if (ret == WID_DBUS_ERROR){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == WTP_ID_NOT_EXIST){
					vty_out(vty,"<error> There is no WTP now.\n");
				}
				else{
					vty_out(vty,"<error> ret = %d\n",ret);
				}
				dcli_free_wtp_data_pkts_Info(WtpHead);
				vty_out(vty,"==============================================================================\n");
				if(argc == 2){
					return CMD_SUCCESS;
				}
			}
		}

	//for local hansi info
	for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		localid = 1;
		
		for (profile = 1; profile < MAX_INSTANCE; profile++) 
		{
			instRun = dcli_hmd_hansi_is_running(vty,slot_id,1,profile);
			if (INSTANCE_NO_CREATED == instRun) {
				continue;
			}
	
		local_hansi_parameter:
			WtpHead = show_WtpDataPktsInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &num, &ret);

			vty_out(vty,"==============================================================================\n");
			vty_out(vty,"local hansi %d-%d\n",slot_id,profile);
			vty_out(vty,"-----------------------------------------------------------------------------\n");
			if((WtpHead!=NULL)&&(ret == 0)){
				vty_out(vty,"WTPNum:%-5d  \n",num);
				vty_out(vty,"========================================================================== \n");
				WtpShowNode = NULL;
				for (i = 0; i < num; i++) {	
					if(WtpShowNode == NULL)
						WtpShowNode = WtpHead->WtpDataPktsInfo_list;
					else 
						WtpShowNode = WtpShowNode->next;

					if(WtpShowNode == NULL)
						break;
					
					vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
					
					vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
					WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
					WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);

					vty_out(vty,"WirelessMacRecvAllByte:   %-5llu  \t\t",WtpShowNode->wtpWirelessMacRecvAllByte);
					vty_out(vty,"WirelessMacSendAllByte:   %-5llu  \n",WtpShowNode->wtpWirelessMacSendAllByte);
					vty_out(vty,"WirelessMacRecvPack:   %-5d  \t\t\t",WtpShowNode->wtpWirelessMacRecvPack);
					vty_out(vty,"WirelessMacRecvWrongPack:   %-5d  \n",WtpShowNode->wtpWirelessMacRecvWrongPack);
					vty_out(vty,"DropPkts:   %-5d  \t\t\t\t",WtpShowNode->wtpDropPkts);
					vty_out(vty,"WirelessMacSendPack:   %-5d  \n",WtpShowNode->wtpWirelessMacSendPack);

					vty_out(vty,"WirelessMacSendErrPack:   %-5d  \t\t",WtpShowNode->wtpWirelessMacSendErrPack);
					vty_out(vty,"WirelessMacRecvRightPack:   %-5d  \n",WtpShowNode->wtpWirelessMacRecvRightPack);
					vty_out(vty,"WirelessMacSendRightPack:   %-5d  \t\t",WtpShowNode->wtpWirelessMacSendRightPack);
					vty_out(vty,"WirelessradioRecvBytes:   %-5d  \n",WtpShowNode->wtpWirelessradioRecvBytes);

					/*wired information*/
					vty_out(vty,"WiredMacRecvRightByte:   %-5llu  \t\t",WtpShowNode->wtpWiredMacRecvRightByte);
					vty_out(vty,"WiredMacSendAllByte:	 %-5llu  \n",WtpShowNode->wtpWiredMacSendAllByte);
					vty_out(vty,"WiredMacRecvWrongPack:	 %-5d  \t\t",WtpShowNode->wtpWiredMacRecvWrongPack);
					vty_out(vty,"WiredMacRecvPack:   %-5d  \n",WtpShowNode->wtpWiredMacRecvPack);

					vty_out(vty,"WiredMacRecvRightPack:   %-5d  \t\t",WtpShowNode->wtpWiredMacRecvRightPack);
					vty_out(vty,"WiredMacSendPack:	 %-5d  \n",WtpShowNode->wtpWiredMacSendPack);
					vty_out(vty,"WiredMacSendErrPack:	 %-5d  \t\t",WtpShowNode->wtpWiredMacSendErrPack);
					vty_out(vty,"WiredMacSendRightPack:   %-5d  \n",WtpShowNode->wtpWiredMacSendRightPack);
					/*ath information*/
					vty_out(vty,"WirelesscoreRecvBytes:   %-5llu  \n",WtpShowNode->wtpWirelesscoreRecvBytes);
					/*wtp information*/
					vty_out(vty,"WirelessRecvFlowByte:   %lld	\t\t",WtpShowNode->wtpWirelessRecvFlowByte);
					vty_out(vty,"WirelessSendFlowByte:   %lld	\n",WtpShowNode->wtpWirelessSendFlowByte);

					vty_out(vty,"-------------------------------------------------------------------------\n");
				}
			}

			else if (ret == WID_DBUS_ERROR){
				cli_syslog_info("<error> failed get reply.\n");
			}
			else if(ret == WTP_ID_NOT_EXIST){
				vty_out(vty,"<error> There is no WTP now.\n");
			}
			else{
				vty_out(vty,"<error> ret = %d\n",ret);
			}
			dcli_free_wtp_data_pkts_Info(WtpHead);
			vty_out(vty,"==============================================================================\n");
			if(argc == 2){
				return CMD_SUCCESS;
			}
			}
		}
	}
	
	return CMD_SUCCESS;
}

/*add for showing wtp stats  information table 7*/
DEFUN(show_all_wtp_stats_information_func,
	  show_all_wtp_stats_information_cmd,
	  "show stats information_of all_wtp [remote] [local] [PARAMETER]",
	  SHOW_STR
	  "Display stats information of all wtps\n"
	  "List wtp stats information\n"
	  "by wtp display stats information\n"
	  "'remote' or 'local' hansi\n"
	  "'remote' or 'local' hansi\n"
	  "slotid-instid\n"
	 )
{
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	struct WtpStatsInfo *WtpHead = NULL;
	struct WtpStatsInfo *WtpShowNode = NULL;
	int ret=0;
	int i=0;
	int j=0;
	int profile = 0;
	int instRun = 0;
	int flag = 0;
	unsigned int num = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	if((argc == 1)||(argc == 3)){
		vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
		return CMD_SUCCESS;
	}
	if(argc == 2){
		if (!strcmp(argv[0],"remote")){
			localid = 0;
		}else if(!strcmp(argv[0],"local")){
			localid = 1;
		}else{
			vty_out(vty,"parameter should be 'remote' or 'local'\n");
			return CMD_SUCCESS;
		}
		
		if((!strcmp(argv[0],"remote"))&&(!strcmp(argv[1],"local"))){
			vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
			return CMD_SUCCESS;
		}
		
		ret = parse_slot_hansi_id((char*)argv[1],&slot_id,&profile);
		if(ret != WID_DBUS_SUCCESS){
			slot_id = HostSlotId;
			flag = 1;
			ret = parse_int_ID((char*)argv[1], &profile);
			if(ret != WID_DBUS_SUCCESS){
				if(ret == WID_ILLEGAL_INPUT){
					vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
				}
				else{
					vty_out(vty,"<error> unknown id format\n");
				}
				return CMD_WARNING;
			}	
		}
		if(distributFag == 0){
			if(slot_id != 0){
				vty_out(vty,"<error> slot id should be 0\n");
				return CMD_WARNING;
			}	
		}else if(flag == 1){
			slot_id = HostSlotId;
		}
		if(slot_id >= MAX_SLOT_NUM || slot_id < 0){
			vty_out(vty,"<error> slot id should be 1 to %d\n",MAX_SLOT_NUM-1);
			return CMD_WARNING;
		}	
		if(profile >= MAX_INSTANCE || profile == 0){
			vty_out(vty,"<error> hansi id should be 1 to %d\n",MAX_INSTANCE-1);
			return CMD_WARNING;
		}
		instRun = dcli_hmd_hansi_is_running(vty,slot_id,localid,profile);
		if (INSTANCE_NO_CREATED == instRun) {
			vty_out(vty,"<error> the instance %s %d-%d is not running\n",((localid == 1)?"local-hansi":"hansi"),slot_id,profile);
			return CMD_WARNING;
		}
		
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		if(localid == 0)
			goto hansi_parameter;
		else if(localid == 1)
			goto local_hansi_parameter; 
	}

	if(vty->node != VIEW_NODE){
		WtpHead = show_WtpStatsInfo_of_all_wtp(index,localid,dcli_dbus_connection, &num, &ret);

		if((WtpHead!=NULL)&&(ret == 0)){
			vty_out(vty,"WTPNum:%-5d  \n",num);
			vty_out(vty,"========================================================================== \n");
			for (i = 0; i < num; i++) {	
				if(WtpShowNode == NULL)
					WtpShowNode = WtpHead->WtpStatsInfo_list;
				else 
					WtpShowNode = WtpShowNode->next;

				if(WtpShowNode == NULL)
					break;
				
				vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
				
				vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
				WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
				WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);

				vty_out(vty,"wtpSSIDNum   :   %-5d  \t\t\t",WtpShowNode->wtpSSIDNum);
				vty_out(vty,"wtpConfigBSSIDNum   :   %-5d  \n",WtpShowNode->wtpConfigBSSIDNum);
				vty_out(vty,"wtpRadioCount   :   %-5d  \t\t\t",WtpShowNode->wtpRadioCount);
				vty_out(vty,"wtpBwlanNum   :   %-5d  \n",WtpShowNode->wtpBwlanNum);

				vty_out(vty,"wlanid  :  ");
				for(j=0;j<WtpShowNode->wtpBwlanNum;j++){
					vty_out(vty,"%d ",WtpShowNode->wtpSupportSSID[j]);
				}
				vty_out(vty,"\n");
				vty_out(vty,"wtpAllowConUsrMnt:   %-5d  \n",WtpShowNode->wtpAllowConUsrMnt);

				vty_out(vty,"wtpMountConUsrTimes:   %-5d	\t\t",WtpShowNode->wtpMountConUsrTimes);
				vty_out(vty,"wtpMountConReasTimes:   %-5d	\n",WtpShowNode->wtpMountConReasTimes);
				vty_out(vty,"wtpMountConSuccTimes:   %-5d	\t\t",WtpShowNode->wtpMountConSuccTimes);
				vty_out(vty,"wtpMountReConSuccTimes:   %-5d	\n",WtpShowNode->wtpMountReConSuccTimes);
				vty_out(vty,"wtpMountConFailTimes:   %-5d	\t\t",WtpShowNode->wtpMountConFailTimes);
				vty_out(vty,"wtpMountReConFailTimes:   %-5d	\n",WtpShowNode->wtpMountReConFailTimes);
				vty_out(vty,"wtpStatsDisassociated:   %-5d  \n",WtpShowNode->wtpStatsDisassociated);
				vty_out(vty,"wtpOnlineUsrNum:   %-5d  \t\t\t",WtpShowNode->wtpOnlineUsrNum);
				vty_out(vty,"wtpAllStaAssTime:   %-5d  \n",WtpShowNode->wtpAllStaAssTime);

				vty_out(vty,"wtpUsrRequestConnect:   %-5d  \t\t\t",WtpShowNode->wtpUsrRequestConnect);
				vty_out(vty,"wtpResponseUsrConnect:   %-5d  \n",WtpShowNode->wtpResponseUsrConnect);
				vty_out(vty,"wtpResponseUsrSuccConnect:   %-5d  \n",WtpShowNode->wtpResponseUsrSuccConnect);
				vty_out(vty,"wtpResponseUsrFailConnect:   %-5d  \n",WtpShowNode->wtpResponseUsrFailConnect);

				vty_out(vty,"wtpLoginSuccNum:   %-5d  \t\t\t",WtpShowNode->wtpLoginSuccNum);
				vty_out(vty,"wtpLessResourceRefuseNewUsrMount:   %-5d  \n",WtpShowNode->wtpLessResourceRefuseNewUsrMount);
				vty_out(vty,"total_if_num:   %-5d  \n",WtpShowNode->total_if_num);
				/*fengwenchao add 20111125 for GM-3*/
				vty_out(vty,"heart_time_avarge   :   %-5d  \n",WtpShowNode->heart_time_avarge);
				vty_out(vty,"heart_lose_pkt   :   %-5d  \n",WtpShowNode->heart_lose_pkt);
				vty_out(vty,"heart_transfer_pkt   :   %-5d  \n",WtpShowNode->heart_transfer_pkt);
				/*fengwenchao add end*/
				vty_out(vty,"is_refuse_lowrssi:   %-5d  \n",WtpShowNode->is_refuse_lowrssi);  //fengwenchao add  for chinamobile-177,20111123

				vty_out(vty,"-------------------------------------------------------------------------\n");
			}
			vty_out(vty,"========================================================================== \n");
		}

		else if (ret == WID_DBUS_ERROR){
			cli_syslog_info("<error> failed get reply.\n");
		}
		else if(ret == WTP_ID_NOT_EXIST){
			vty_out(vty,"<error> There is no WTP now.\n");
		}
		else if(ret == ASD_WTP_ID_LARGE_THAN_MAX){
			vty_out(vty,"<error> WTPID is larger than MAX.\n");
		}
		else{
			vty_out(vty,"<error> ret = %d\n",ret);
		}
		dcli_free_wtp_stats_Info(WtpHead);
	}

	if(vty->node == VIEW_NODE){
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 0;
			
			//for remote hansi info
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,0,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}

	 	hansi_parameter:
				WtpHead = show_WtpStatsInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &num, &ret);
			
				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"hansi %d-%d\n",slot_id,profile);
				vty_out(vty,"------------------------------------------------------------\n");
				if((WtpHead!=NULL)&&(ret == 0)){
					vty_out(vty,"WTPNum:%-5d  \n",num);
					vty_out(vty,"========================================================================== \n");
					WtpShowNode = NULL;
					for (i = 0; i < num; i++) { 
						if(WtpShowNode == NULL){
							WtpShowNode = WtpHead->WtpStatsInfo_list;
						}
						else{
							WtpShowNode = WtpShowNode->next;
						}
			
						if(WtpShowNode == NULL)
							break;
						
						vty_out(vty,"WTPID:   %-5d	\t\t\t\t",WtpShowNode->wtpCurrID);
						
						vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
						WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
						WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
			
						vty_out(vty,"wtpSSIDNum   :   %-5d	\t\t\t",WtpShowNode->wtpSSIDNum);
						vty_out(vty,"wtpConfigBSSIDNum	 :	 %-5d  \n",WtpShowNode->wtpConfigBSSIDNum);
						vty_out(vty,"wtpRadioCount	 :	 %-5d  \t\t\t",WtpShowNode->wtpRadioCount);
						vty_out(vty,"wtpBwlanNum   :   %-5d  \n",WtpShowNode->wtpBwlanNum);
			
						vty_out(vty,"wlanid  :	");
						for(j=0;j<WtpShowNode->wtpBwlanNum;j++){
							vty_out(vty,"%d ",WtpShowNode->wtpSupportSSID[j]);
						}
						vty_out(vty,"\n");
						vty_out(vty,"wtpAllowConUsrMnt:   %-5d	\n",WtpShowNode->wtpAllowConUsrMnt);
			
						vty_out(vty,"wtpMountConUsrTimes:	%-5d	\t\t",WtpShowNode->wtpMountConUsrTimes);
						vty_out(vty,"wtpMountConReasTimes:	 %-5d	\n",WtpShowNode->wtpMountConReasTimes);
						vty_out(vty,"wtpMountConSuccTimes:	 %-5d	\t\t",WtpShowNode->wtpMountConSuccTimes);
						vty_out(vty,"wtpMountReConSuccTimes:   %-5d \n",WtpShowNode->wtpMountReConSuccTimes);
						vty_out(vty,"wtpMountConFailTimes:	 %-5d	\t\t",WtpShowNode->wtpMountConFailTimes);
						vty_out(vty,"wtpMountReConFailTimes:   %-5d \n",WtpShowNode->wtpMountReConFailTimes);
						vty_out(vty,"wtpStatsDisassociated:   %-5d	\n",WtpShowNode->wtpStatsDisassociated);
						vty_out(vty,"wtpOnlineUsrNum:	%-5d  \t\t\t",WtpShowNode->wtpOnlineUsrNum);
						vty_out(vty,"wtpAllStaAssTime:	 %-5d  \n",WtpShowNode->wtpAllStaAssTime);
			
						vty_out(vty,"wtpUsrRequestConnect:	 %-5d  \t\t\t",WtpShowNode->wtpUsrRequestConnect);
						vty_out(vty,"wtpResponseUsrConnect:   %-5d	\n",WtpShowNode->wtpResponseUsrConnect);
						vty_out(vty,"wtpResponseUsrSuccConnect:   %-5d	\n",WtpShowNode->wtpResponseUsrSuccConnect);
						vty_out(vty,"wtpResponseUsrFailConnect:   %-5d	\n",WtpShowNode->wtpResponseUsrFailConnect);
			
						vty_out(vty,"wtpLoginSuccNum:	%-5d  \t\t\t",WtpShowNode->wtpLoginSuccNum);
						vty_out(vty,"wtpLessResourceRefuseNewUsrMount:	 %-5d  \n",WtpShowNode->wtpLessResourceRefuseNewUsrMount);
						vty_out(vty,"total_if_num:	 %-5d  \n",WtpShowNode->total_if_num);
						/*fengwenchao add 20111125 for GM-3*/
						vty_out(vty,"heart_time_avarge	 :	 %-5d  \n",WtpShowNode->heart_time_avarge);
						vty_out(vty,"heart_lose_pkt   :   %-5d	\n",WtpShowNode->heart_lose_pkt);
						vty_out(vty,"heart_transfer_pkt   :   %-5d	\n",WtpShowNode->heart_transfer_pkt);
						/*fengwenchao add end*/
						vty_out(vty,"is_refuse_lowrssi:   %-5d	\n",WtpShowNode->is_refuse_lowrssi);  //fengwenchao add  for chinamobile-177,20111123
			
						vty_out(vty,"-------------------------------------------------------------------------\n");
					}
				}
			
				else if (ret == WID_DBUS_ERROR){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == WTP_ID_NOT_EXIST){
					vty_out(vty,"<error> There is no WTP now.\n");
				}
				else if(ret == ASD_WTP_ID_LARGE_THAN_MAX){
					vty_out(vty,"<error> WTPID is larger than MAX.\n");
				}
				else{
					vty_out(vty,"<error> ret = %d\n",ret);
				}
				dcli_free_wtp_stats_Info(WtpHead);
				vty_out(vty,"========================================================================== \n");
				if(argc == 2){
					return CMD_SUCCESS;
				}
			}
		}

		//for local hansi info
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 1;
			
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,1,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}
		
		 	local_hansi_parameter:
				WtpHead = show_WtpStatsInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &num, &ret);
				
				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"local hansi %d-%d\n",slot_id,profile);
				vty_out(vty,"------------------------------------------------------------\n");
				if((WtpHead!=NULL)&&(ret == 0)){
					vty_out(vty,"WTPNum:%-5d  \n",num);
					vty_out(vty,"========================================================================== \n");
					WtpShowNode = NULL;
					for (i = 0; i < num; i++) { 
						if(WtpShowNode == NULL)
							WtpShowNode = WtpHead->WtpStatsInfo_list;
						else 
							WtpShowNode = WtpShowNode->next;
			
						if(WtpShowNode == NULL)
							break;
						
						vty_out(vty,"WTPID:   %-5d	\t\t\t\t",WtpShowNode->wtpCurrID);
						
						vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
						WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
						WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
			
						vty_out(vty,"wtpSSIDNum   :   %-5d	\t\t\t",WtpShowNode->wtpSSIDNum);
						vty_out(vty,"wtpConfigBSSIDNum	 :	 %-5d  \n",WtpShowNode->wtpConfigBSSIDNum);
						vty_out(vty,"wtpRadioCount	 :	 %-5d  \t\t\t",WtpShowNode->wtpRadioCount);
						vty_out(vty,"wtpBwlanNum   :   %-5d  \n",WtpShowNode->wtpBwlanNum);
			
						vty_out(vty,"wlanid  :	");
						for(j=0;j<WtpShowNode->wtpBwlanNum;j++){
							vty_out(vty,"%d ",WtpShowNode->wtpSupportSSID[j]);
						}
						vty_out(vty,"\n");
						vty_out(vty,"wtpAllowConUsrMnt:   %-5d	\n",WtpShowNode->wtpAllowConUsrMnt);
			
						vty_out(vty,"wtpMountConUsrTimes:	%-5d	\t\t",WtpShowNode->wtpMountConUsrTimes);
						vty_out(vty,"wtpMountConReasTimes:	 %-5d	\n",WtpShowNode->wtpMountConReasTimes);
						vty_out(vty,"wtpMountConSuccTimes:	 %-5d	\t\t",WtpShowNode->wtpMountConSuccTimes);
						vty_out(vty,"wtpMountReConSuccTimes:   %-5d \n",WtpShowNode->wtpMountReConSuccTimes);
						vty_out(vty,"wtpMountConFailTimes:	 %-5d	\t\t",WtpShowNode->wtpMountConFailTimes);
						vty_out(vty,"wtpMountReConFailTimes:   %-5d \n",WtpShowNode->wtpMountReConFailTimes);
						vty_out(vty,"wtpStatsDisassociated:   %-5d	\n",WtpShowNode->wtpStatsDisassociated);
						vty_out(vty,"wtpOnlineUsrNum:	%-5d  \t\t\t",WtpShowNode->wtpOnlineUsrNum);
						vty_out(vty,"wtpAllStaAssTime:	 %-5d  \n",WtpShowNode->wtpAllStaAssTime);
			
						vty_out(vty,"wtpUsrRequestConnect:	 %-5d  \t\t\t",WtpShowNode->wtpUsrRequestConnect);
						vty_out(vty,"wtpResponseUsrConnect:   %-5d	\n",WtpShowNode->wtpResponseUsrConnect);
						vty_out(vty,"wtpResponseUsrSuccConnect:   %-5d	\n",WtpShowNode->wtpResponseUsrSuccConnect);
						vty_out(vty,"wtpResponseUsrFailConnect:   %-5d	\n",WtpShowNode->wtpResponseUsrFailConnect);
			
						vty_out(vty,"wtpLoginSuccNum:	%-5d  \t\t\t",WtpShowNode->wtpLoginSuccNum);
						vty_out(vty,"wtpLessResourceRefuseNewUsrMount:	 %-5d  \n",WtpShowNode->wtpLessResourceRefuseNewUsrMount);
						vty_out(vty,"total_if_num:	 %-5d  \n",WtpShowNode->total_if_num);
						/*fengwenchao add 20111125 for GM-3*/
						vty_out(vty,"heart_time_avarge	 :	 %-5d  \n",WtpShowNode->heart_time_avarge);
						vty_out(vty,"heart_lose_pkt   :   %-5d	\n",WtpShowNode->heart_lose_pkt);
						vty_out(vty,"heart_transfer_pkt   :   %-5d	\n",WtpShowNode->heart_transfer_pkt);
						/*fengwenchao add end*/
						vty_out(vty,"is_refuse_lowrssi:   %-5d	\n",WtpShowNode->is_refuse_lowrssi);  //fengwenchao add  for chinamobile-177,20111123
			
						vty_out(vty,"-------------------------------------------------------------------------\n");
					}
				}
			
				else if (ret == WID_DBUS_ERROR){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == WTP_ID_NOT_EXIST){
					vty_out(vty,"<error> There is no WTP now.\n");
				}
				else if(ret == ASD_WTP_ID_LARGE_THAN_MAX){
					vty_out(vty,"<error> WTPID is larger than MAX.\n");
				}
				else{
					vty_out(vty,"<error> ret = %d\n",ret);
				}
				dcli_free_wtp_stats_Info(WtpHead);
				vty_out(vty,"========================================================================== \n");
				if(argc == 2){
					return CMD_SUCCESS;
				}
			}
		}
	}
	
	return CMD_SUCCESS;
}

/*add for showing wlan stats  information table 8 by nl*/
DEFUN(show_all_wlan_stats_information_func,
	  show_all_wlan_stats_information_cmd,
	  "show wlan stats information_of all_wtp [remote] [local] [PARAMETER]",
	  SHOW_STR
	  "Display wlan stats information of all wtps\n"
	  "List wlan stats information\n"
	  "by wtp display stats information\n"
	  "all wtp\n"
	  "'remote' or 'local' hansi\n"
	  "'remote' or 'local' hansi\n"
	  "slotid-instid\n"
	 )
{
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	struct WtpWlanStatsInfo *WtpHead = NULL;
	struct WtpWlanStatsInfo *WtpShowNode = NULL;
	int ret=0;
	int i=0;
	int j=0;
	unsigned int num = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	int profile = 0;
	int instRun = 0;
	int flag = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	if((argc == 1)||(argc == 3)){
		vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
		return CMD_SUCCESS;
	}
	if(argc == 2){
		if (!strcmp(argv[0],"remote")){
			localid = 0;
		}else if(!strcmp(argv[0],"local")){
			localid = 1;
		}else{
			vty_out(vty,"parameter should be 'remote' or 'local'\n");
			return CMD_SUCCESS;
		}
		
		if((!strcmp(argv[0],"remote"))&&(!strcmp(argv[1],"local"))){
			vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
			return CMD_SUCCESS;
		}
		
		ret = parse_slot_hansi_id((char*)argv[1],&slot_id,&profile);
		if(ret != WID_DBUS_SUCCESS){
			slot_id = HostSlotId;
			flag = 1;
			ret = parse_int_ID((char*)argv[1], &profile);
			if(ret != WID_DBUS_SUCCESS){
				if(ret == WID_ILLEGAL_INPUT){
					vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
				}
				else{
					vty_out(vty,"<error> unknown id format\n");
				}
				return CMD_WARNING;
			}	
		}
		if(distributFag == 0){
			if(slot_id != 0){
				vty_out(vty,"<error> slot id should be 0\n");
				return CMD_WARNING;
			}	
		}else if(flag == 1){
			slot_id = HostSlotId;
		}
		if(slot_id >= MAX_SLOT_NUM || slot_id < 0){
			vty_out(vty,"<error> slot id should be 1 to %d\n",MAX_SLOT_NUM-1);
			return CMD_WARNING;
		}	
		if(profile >= MAX_INSTANCE || profile == 0){
			vty_out(vty,"<error> hansi id should be 1 to %d\n",MAX_INSTANCE-1);
			return CMD_WARNING;
		}
		instRun = dcli_hmd_hansi_is_running(vty,slot_id,localid,profile);
		if (INSTANCE_NO_CREATED == instRun) {
			vty_out(vty,"<error> the instance %s %d-%d is not running\n",((localid == 1)?"local-hansi":"hansi"),slot_id,profile);
			return CMD_WARNING;
		}
		
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		if(localid == 0)
			goto hansi_parameter;
		else if(localid == 1)
			goto local_hansi_parameter; 
	}

	if(vty->node != VIEW_NODE){
		WtpHead = show_WtpWlanStatsInfo_of_all_wtp(index,localid,dcli_dbus_connection, &num, &ret);

		if((WtpHead!=NULL)&&(ret == 0)){
			vty_out(vty,"WTPNum:%-5d  \n",num);
			vty_out(vty,"========================================================================== \n");
			for (i = 0; i < num; i++) {	
				if(WtpShowNode == NULL)
					WtpShowNode = WtpHead->WtpWlanStatsInfo_list;
				else 
					WtpShowNode = WtpShowNode->next;

				if(WtpShowNode == NULL)
					break;
				
				vty_out(vty,"------------------------------WTP information------------------------------\n");
				vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
				
				vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
				WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
				WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);

				//vty_out(vty,"wtpL2Insulate:   %-5d  \n",WtpShowNode->wtpL2Insulate);
				vty_out(vty,"wlan num:");
				for(j=0;j<WtpShowNode->wtpBwlanNum;j++){
					vty_out(vty,"%d  ",WtpShowNode->wtpSupportSSID[j]);
					
				}
				vty_out(vty,"\n");
				vty_out(vty,"------------------------------WLAN information-----------------------------\n");
				struct WtpWlanStatsInfo_wlan *sub_wlan = NULL;
				for(j=0;j<WtpShowNode->wtpBwlanNum;j++){
									
					if(sub_wlan == NULL)
						sub_wlan = WtpShowNode->WtpWlanStatsInfo_wlan_head;
					else 
						sub_wlan = sub_wlan->next;

					if(sub_wlan == NULL){
						vty_out(vty,"break\n");
						break;
					}
					
					vty_out(vty,"wirelessSSID:  %02X:%02X:%02X:%02X:%02X:%02X \t\t",
					sub_wlan->wirelessSSID[0],sub_wlan->wirelessSSID[1],sub_wlan->wirelessSSID[2],
					sub_wlan->wirelessSSID[3],sub_wlan->wirelessSSID[4],sub_wlan->wirelessSSID[5]);
					vty_out(vty,"wlanessid: %s \n",sub_wlan->wlan_essid);
					vty_out(vty,"wlanid: %d \t\t\t\t\t",sub_wlan->wlan_id);
					vty_out(vty,"wlanL2Isolation: %d \n",sub_wlan->wlanL2Isolation);

					vty_out(vty,"wtpUsrNumAppendThreshold: %d \t\t\t ",sub_wlan->wtpUsrNumAppendThreshold);
					vty_out(vty,"wtpAttachedFlowThreshold: %d \n",sub_wlan->wtpAttachedFlowThreshold);
					vty_out(vty,"wtpLoadBalance: %d \t\t\t \t",sub_wlan->wtpLoadBalance);
					vty_out(vty,"wtpSsidBroadcast: %d \n",sub_wlan->wtpSsidBroadcast);
					vty_out(vty,"wlanSecID: %d \t\t\t\t\t",sub_wlan->wlanSecID);
					vty_out(vty,"wtpConRadiusServerPort: %d \n",sub_wlan->wtpConRadiusServerPort);
					vty_out(vty,"wtpEAPAuthenSupport: %d \t\t\t\t",sub_wlan->wtpEAPAuthenSupport);
					vty_out(vty,"wtpConfSecurMech: %d \n",sub_wlan->wtpConfSecurMech);
					vty_out(vty,"wtpSsidCurrOnlineUsrNum: %d \t\t\t",sub_wlan->wtpSsidCurrOnlineUsrNum);
					vty_out(vty,"wtpAcAppointDistOnlineUsrNum: %d \n",sub_wlan->wtpAcAppointDistOnlineUsrNum);

					/*fengwenchao add 20110426 for dot11WlanDataPktsTable*/
					vty_out(vty,"ethernetRecvCorrectFrames : %d \t\t",sub_wlan->ethernetRecvCorrectFrames);
					vty_out(vty,"ethernetRecvCorrectBytes : %llu\n",sub_wlan->ethernetRecvCorrectBytes);
					vty_out(vty,"ethernetSendCorrectBytes : %llu\n",sub_wlan->ethernetSendCorrectBytes);
					/*fengwenchao add end*/
					vty_out(vty,"\n");
				}

				vty_out(vty,"-------------------------------------------------------------------------\n");
			}
			vty_out(vty,"========================================================================== \n");
		}

		else if (ret == WID_DBUS_ERROR){
			cli_syslog_info("<error> failed get reply.\n");
		}
		else if(ret == WTP_ID_NOT_EXIST){
			vty_out(vty,"<error> There is no WTP now.\n");
		}
		else{
			vty_out(vty,"<error> ret = %d\n",ret);
		}
		dcli_free_wlan_stats_Info(WtpHead);
	}

	if(vty->node == VIEW_NODE){
		//for remote hansi info
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 0;
			
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,0,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}

		hansi_parameter:
				WtpHead = show_WtpWlanStatsInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &num, &ret);

				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"hansi %d-%d\n",slot_id,profile);
				vty_out(vty,"-----------------------------------------------------------------------------\n");
				if((WtpHead!=NULL)&&(ret == 0)){
					vty_out(vty,"WTPNum:%-5d  \n",num);
					vty_out(vty,"========================================================================== \n");
					WtpShowNode = NULL;
					for (i = 0; i < num; i++) {	
						if(WtpShowNode == NULL)
							WtpShowNode = WtpHead->WtpWlanStatsInfo_list;
						else 
							WtpShowNode = WtpShowNode->next;

						if(WtpShowNode == NULL)
							break;
						
						vty_out(vty,"------------------------------WTP information------------------------------\n");
						vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
						
						vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
						WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
						WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);

						vty_out(vty,"wlan num:");
						for(j=0;j<WtpShowNode->wtpBwlanNum;j++){
							vty_out(vty,"%d  ",WtpShowNode->wtpSupportSSID[j]);
							
						}
						vty_out(vty,"\n");
						vty_out(vty,"------------------------------WLAN information-----------------------------\n");
						struct WtpWlanStatsInfo_wlan *sub_wlan = NULL;
						for(j=0;j<WtpShowNode->wtpBwlanNum;j++){
											
							if(sub_wlan == NULL)
								sub_wlan = WtpShowNode->WtpWlanStatsInfo_wlan_head;
							else 
								sub_wlan = sub_wlan->next;

							if(sub_wlan == NULL){
								vty_out(vty,"break\n");
								break;
							}
							
							vty_out(vty,"wirelessSSID:  %02X:%02X:%02X:%02X:%02X:%02X \t\t",
							sub_wlan->wirelessSSID[0],sub_wlan->wirelessSSID[1],sub_wlan->wirelessSSID[2],
							sub_wlan->wirelessSSID[3],sub_wlan->wirelessSSID[4],sub_wlan->wirelessSSID[5]);
							vty_out(vty,"wlanessid: %s \n",sub_wlan->wlan_essid);
							vty_out(vty,"wlanid: %d \t\t\t\t\t",sub_wlan->wlan_id);
							vty_out(vty,"wlanL2Isolation: %d \n",sub_wlan->wlanL2Isolation);

							vty_out(vty,"wtpUsrNumAppendThreshold: %d \t\t\t ",sub_wlan->wtpUsrNumAppendThreshold);
							vty_out(vty,"wtpAttachedFlowThreshold: %d \n",sub_wlan->wtpAttachedFlowThreshold);
							vty_out(vty,"wtpLoadBalance: %d \t\t\t \t",sub_wlan->wtpLoadBalance);
							vty_out(vty,"wtpSsidBroadcast: %d \n",sub_wlan->wtpSsidBroadcast);
							vty_out(vty,"wlanSecID: %d \t\t\t\t\t",sub_wlan->wlanSecID);
							vty_out(vty,"wtpConRadiusServerPort: %d \n",sub_wlan->wtpConRadiusServerPort);
							vty_out(vty,"wtpEAPAuthenSupport: %d \t\t\t\t",sub_wlan->wtpEAPAuthenSupport);
							vty_out(vty,"wtpConfSecurMech: %d \n",sub_wlan->wtpConfSecurMech);
							vty_out(vty,"wtpSsidCurrOnlineUsrNum: %d \t\t\t",sub_wlan->wtpSsidCurrOnlineUsrNum);
							vty_out(vty,"wtpAcAppointDistOnlineUsrNum: %d \n",sub_wlan->wtpAcAppointDistOnlineUsrNum);

							/*fengwenchao add 20110426 for dot11WlanDataPktsTable*/
							vty_out(vty,"ethernetRecvCorrectFrames : %d \t\t",sub_wlan->ethernetRecvCorrectFrames);
							vty_out(vty,"ethernetRecvCorrectBytes : %llu\n",sub_wlan->ethernetRecvCorrectBytes);
							vty_out(vty,"ethernetSendCorrectBytes : %llu\n",sub_wlan->ethernetSendCorrectBytes);
							/*fengwenchao add end*/
							vty_out(vty,"\n");
						}

						vty_out(vty,"-------------------------------------------------------------------------\n");
					}
				}

				else if (ret == WID_DBUS_ERROR){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == WTP_ID_NOT_EXIST){
					vty_out(vty,"<error> There is no WTP now.\n");
				}
				else{
					vty_out(vty,"<error> ret = %d\n",ret);
				}
				dcli_free_wlan_stats_Info(WtpHead);
				vty_out(vty,"==============================================================================\n");
				if(argc == 2){
					return CMD_SUCCESS;
				}
			}
		}

	//for local hansi info
	for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		localid = 1;
		
		for (profile = 1; profile < MAX_INSTANCE; profile++) 
		{
			instRun = dcli_hmd_hansi_is_running(vty,slot_id,1,profile);
			if (INSTANCE_NO_CREATED == instRun) {
				continue;
			}
	
		local_hansi_parameter:
			WtpHead = show_WtpWlanStatsInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &num, &ret);

			vty_out(vty,"==============================================================================\n");
			vty_out(vty,"local hansi %d-%d\n",slot_id,profile);
			vty_out(vty,"-----------------------------------------------------------------------------\n");
			if((WtpHead!=NULL)&&(ret == 0)){
				vty_out(vty,"WTPNum:%-5d  \n",num);
				vty_out(vty,"========================================================================== \n");
				WtpShowNode = NULL;
				for (i = 0; i < num; i++) {	
					if(WtpShowNode == NULL)
						WtpShowNode = WtpHead->WtpWlanStatsInfo_list;
					else 
						WtpShowNode = WtpShowNode->next;

					if(WtpShowNode == NULL)
						break;
					
					vty_out(vty,"------------------------------WTP information------------------------------\n");
					vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
					
					vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
					WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
					WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);

					vty_out(vty,"wlan num:");
					for(j=0;j<WtpShowNode->wtpBwlanNum;j++){
						vty_out(vty,"%d  ",WtpShowNode->wtpSupportSSID[j]);
						
					}
					vty_out(vty,"\n");
					vty_out(vty,"------------------------------WLAN information-----------------------------\n");
					struct WtpWlanStatsInfo_wlan *sub_wlan = NULL;
					for(j=0;j<WtpShowNode->wtpBwlanNum;j++){
										
						if(sub_wlan == NULL)
							sub_wlan = WtpShowNode->WtpWlanStatsInfo_wlan_head;
						else 
							sub_wlan = sub_wlan->next;

						if(sub_wlan == NULL){
							vty_out(vty,"break\n");
							break;
						}
						
						vty_out(vty,"wirelessSSID:  %02X:%02X:%02X:%02X:%02X:%02X \t\t",
						sub_wlan->wirelessSSID[0],sub_wlan->wirelessSSID[1],sub_wlan->wirelessSSID[2],
						sub_wlan->wirelessSSID[3],sub_wlan->wirelessSSID[4],sub_wlan->wirelessSSID[5]);
						vty_out(vty,"wlanessid: %s \n",sub_wlan->wlan_essid);
						vty_out(vty,"wlanid: %d \t\t\t\t\t",sub_wlan->wlan_id);
						vty_out(vty,"wlanL2Isolation: %d \n",sub_wlan->wlanL2Isolation);

						vty_out(vty,"wtpUsrNumAppendThreshold: %d \t\t\t ",sub_wlan->wtpUsrNumAppendThreshold);
						vty_out(vty,"wtpAttachedFlowThreshold: %d \n",sub_wlan->wtpAttachedFlowThreshold);
						vty_out(vty,"wtpLoadBalance: %d \t\t\t \t",sub_wlan->wtpLoadBalance);
						vty_out(vty,"wtpSsidBroadcast: %d \n",sub_wlan->wtpSsidBroadcast);
						vty_out(vty,"wlanSecID: %d \t\t\t\t\t",sub_wlan->wlanSecID);
						vty_out(vty,"wtpConRadiusServerPort: %d \n",sub_wlan->wtpConRadiusServerPort);
						vty_out(vty,"wtpEAPAuthenSupport: %d \t\t\t\t",sub_wlan->wtpEAPAuthenSupport);
						vty_out(vty,"wtpConfSecurMech: %d \n",sub_wlan->wtpConfSecurMech);
						vty_out(vty,"wtpSsidCurrOnlineUsrNum: %d \t\t\t",sub_wlan->wtpSsidCurrOnlineUsrNum);
						vty_out(vty,"wtpAcAppointDistOnlineUsrNum: %d \n",sub_wlan->wtpAcAppointDistOnlineUsrNum);

						/*fengwenchao add 20110426 for dot11WlanDataPktsTable*/
						vty_out(vty,"ethernetRecvCorrectFrames : %d \t\t",sub_wlan->ethernetRecvCorrectFrames);
						vty_out(vty,"ethernetRecvCorrectBytes : %llu\n",sub_wlan->ethernetRecvCorrectBytes);
						vty_out(vty,"ethernetSendCorrectBytes : %llu\n",sub_wlan->ethernetSendCorrectBytes);
						/*fengwenchao add end*/
						vty_out(vty,"\n");
					}

					vty_out(vty,"-------------------------------------------------------------------------\n");
				}
				vty_out(vty,"========================================================================== \n");
			}

			else if (ret == WID_DBUS_ERROR){
				cli_syslog_info("<error> failed get reply.\n");
			}
			else if(ret == WTP_ID_NOT_EXIST){
				vty_out(vty,"<error> There is no WTP now.\n");
			}
			else{
				vty_out(vty,"<error> ret = %d\n",ret);
			}
			dcli_free_wlan_stats_Info(WtpHead);
			vty_out(vty,"==============================================================================\n");
			if(argc == 2){
				return CMD_SUCCESS;
			}
			}
		}
	}
	
	return CMD_SUCCESS;
}

#if 0  //for old version
/*add for showing wtp SSIDStats  information table 9*/
DEFUN(show_all_wlan_ssid_stats_information_func,
	  show_all_wlan_ssid_stats_information_cmd,
	  "show wlan ssid stats information_of all_wtp",
	  SHOW_STR
	  "Display wlan ssid stats information of all wtps\n"
	  "List wlan ssid stats information\n"
	  "by wtp display ssid stats information\n"
	 )
{
	DBusConnection *dbus_connection = dcli_dbus_connection;
	
	struct SSIDStatsInfo *WtpHead = NULL;
	struct SSIDStatsInfo *WtpShowNode = NULL;
	int ret=0;
	int i=0, j=0;
	unsigned int num = 0;
	int index = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
	}

	WtpHead = show_wtp_wlan_SSIDStatsInfo_of_all_wtp(index,dbus_connection, &num, &ret);

	if((WtpHead!=NULL)&&(ret == 0)){
		vty_out(vty,"WTPNum:%-5d  \n",num);
		vty_out(vty,"========================================================================== \n");
		for (i = 0; i < num; i++) {	
			struct SSIDStatsInfo_sub_wlan *sub_wlan = NULL;
			if(WtpShowNode == NULL)
				WtpShowNode = WtpHead->SSIDStatsInfo_list;
			else 
				WtpShowNode = WtpShowNode->next;

			if(WtpShowNode == NULL)
				break;
			
			vty_out(vty,"------------------------------WTP information------------------------------\n");
			vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
			vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
			WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
			WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
			vty_out(vty,"SSIDTxSignalPkts:   %-5d	\t\t",WtpShowNode->SSIDTxSignalPkts);
			vty_out(vty,"SSIDRxSignalPkts:   %-5d	\n",WtpShowNode->SSIDRxSignalPkts);
			
			vty_out(vty,"wlan id:");
			for(j=0;j<WtpShowNode->wtpBwlanNum;j++){
				vty_out(vty,"%d  ",WtpShowNode->wtpSupportSSID[j]);
			}
			vty_out(vty,"\n");
			
			vty_out(vty,"------------------------------WLAN information-----------------------------\n");
			for(j=0;j<WtpShowNode->wtpBwlanNum;j++){
				if(sub_wlan == NULL)
					sub_wlan = WtpShowNode->SSIDStatsInfo_sub_wlan_head;
				else 
					sub_wlan = sub_wlan->next;

				if(sub_wlan == NULL){
					vty_out(vty,"break\n");
					break;
				}

				vty_out(vty,"SSIDChStatsDwlinkTotRetryPkts: %llu \n",sub_wlan->SSIDChStatsDwlinkTotRetryPkts);
				vty_out(vty,"SSIDChStatsUplinkUniFrameCnt: %llu \n",sub_wlan->SSIDChStatsUplinkUniFrameCnt);
				vty_out(vty,"SSIDChStatsDwlinkUniFrameCnt: %llu \n",sub_wlan->SSIDChStatsDwlinkUniFrameCnt);
				vty_out(vty,"SSIDUpChStatsFrameNonUniFrameCnt: %llu \n",sub_wlan->SSIDUpChStatsFrameNonUniFrameCnt);
				vty_out(vty,"SSIDDownChStatsFrameNonUniFrameCnt: %llu \n",sub_wlan->SSIDDownChStatsFrameNonUniFrameCnt);
				vty_out(vty,"SSIDDwlinkTotFrameCnt: %llu \n",sub_wlan->SSIDDwlinkTotFrameCnt);
				vty_out(vty,"SSIDUplinkTotFrameCnt: %llu \n",sub_wlan->SSIDUplinkTotFrameCnt);
				
				vty_out(vty,"SSIDRxCtrlFrameCnt: %d \t\t\t\t",sub_wlan->SSIDRxCtrlFrameCnt);
				vty_out(vty,"SSIDRxDataFrameCnt: %d \n",sub_wlan->SSIDRxDataFrameCnt);
				vty_out(vty,"SSIDRxAuthenFrameCnt: %d \t\t\t",sub_wlan->SSIDRxAuthenFrameCnt);
				
				vty_out(vty,"SSIDRxAssociateFrameCnt: %d \n",sub_wlan->SSIDRxAssociateFrameCnt);
				vty_out(vty,"SSIDTxCtrlFrameCnt: %d \t\t\t\t",sub_wlan->SSIDTxCtrlFrameCnt);
				vty_out(vty,"SSIDTxDataFrameCnt: %d \n",sub_wlan->SSIDTxDataFrameCnt);
				
				vty_out(vty,"SSIDTxAuthenFrameCnt: %d \t\t\t",sub_wlan->SSIDTxAuthenFrameCnt);
				vty_out(vty,"SSIDTxAssociateFrameCnt: %d \n",sub_wlan->SSIDTxAssociateFrameCnt);
				vty_out(vty,"SSIDApChStatsNumStations: %d \t\t\t",sub_wlan->SSIDApChStatsNumStations);

				vty_out(vty,"wtpSSIDMaxLoginUsr: %d \n",sub_wlan->wtpSSIDMaxLoginUsr);
				vty_out(vty,"wtpSSIDState:  %d \t\t\t\t",sub_wlan->wtpSSIDState);
				vty_out(vty,"wtpSSIDSecurityPolicyID: %d \n",sub_wlan->wtpSSIDSecurityPolicyID);
				vty_out(vty,"wtpSSIDLoadBalance: %d \t\t\t\t",sub_wlan->wtpSSIDLoadBalance);
				vty_out(vty,"wtpSSIDESSID: %s \n",sub_wlan->wtpSSIDESSID);

				vty_out(vty,"wtpSSIDName:  %02X:%02X:%02X:%02X:%02X:%02X \n",
				sub_wlan->wtpSSIDName[0],sub_wlan->wtpSSIDName[1],sub_wlan->wtpSSIDName[2],
				sub_wlan->wtpSSIDName[3],sub_wlan->wtpSSIDName[4],sub_wlan->wtpSSIDName[5]);
				vty_out(vty,"WlanName: %s \n",sub_wlan->WlanName);
			}
			vty_out(vty,"-------------------------------------------------------------------------\n");
		}
		vty_out(vty,"========================================================================== \n");
	}

	else if (ret == WID_DBUS_ERROR){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == WTP_ID_NOT_EXIST){
		vty_out(vty,"<error> There is no WTP now.\n");
	}
	else{
		vty_out(vty,"<error> ret = %d\n",ret);
	}
	dcli_free_ssid_stats_Info(WtpHead);
	return CMD_SUCCESS;
}
#endif

//mahz add 2011.11.9 for GuangZhou Mobile
DEFUN(show_all_wtp_station_statistic_information_func,
	  show_all_wtp_station_statistic_information_cmd,
	  "show station statistic information of all wtp",
	  "show information of sta about no authenticate auth and associate auth\n"
	 )
{
	struct WtpStationinfo * StaHead =NULL;
	struct WtpStationinfo * StaNode =NULL;
	
	int ret=0;
	unsigned int wtp_num;
	
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	StaHead=show_station_information_of_all_wtp(index,localid,dcli_dbus_connection,&wtp_num,&ret);
	if((StaHead !=NULL)&&(ret == 0)){
		StaNode=StaHead;
		vty_out(vty,"WTPNum:%-5u  \n",wtp_num);
		while(StaNode){
			vty_out(vty,"========================================================================== \n");
			vty_out(vty,"wtpid :                                          %d\n",StaNode->wtpid);
			vty_out(vty,"wtpMacAddr :                                     %s\n",StaNode->wtpMacAddr);
			vty_out(vty,"No Authentication Accessed Sta Num:              %d\n",StaNode->no_auth_sta_num);
			vty_out(vty,"Assoc Authentication Accessed Sta Num:           %d\n",StaNode->assoc_auth_sta_num);
			vty_out(vty,"No Authentication Sta Total Online time:         %d\n",StaNode->no_auth_accessed_total_time);
			vty_out(vty,"Assoc Authentication Sta Total Online time:      %d\n",StaNode->assoc_auth_accessed_total_time);
			vty_out(vty,"No Authentication Sta Abnormal Down times:       %d\n",StaNode->no_auth_sta_abnormal_down_num);
			vty_out(vty,"Assoc Authentication Sta Abnormal Down times:    %d\n",StaNode->assoc_auth_sta_abnormal_down_num);
			vty_out(vty,"Assoc Authentication Request times:              %d\n",StaNode->assoc_auth_req_num);
			vty_out(vty,"Assoc Authentication Success Times :             %d\n",StaNode->assoc_auth_succ_num);
			vty_out(vty,"Assoc Authentication Fail Times :                %d\n",StaNode->assoc_auth_fail_num);
			//qiuchen
			vty_out(vty,"WEP/PSK Authentication Accessed Sta Num:         %d\n",StaNode->assoc_auth_online_sta_num);
			vty_out(vty,"WEP/PSK Authentication Sta Total Online time:    %d\n",StaNode->all_assoc_auth_sta_total_time);
			vty_out(vty,"WEP/PSK Authentication Sta Abnormal Down times:  %d\n",StaNode->assoc_auth_sta_drop_cnt);
			vty_out(vty,"SIM/PEAP Authentication Accessed Sta Num:        %d\n",StaNode->auto_auth_online_sta_num);
			vty_out(vty,"SIM/PEAP Authentication Request times:           %d\n",StaNode->auto_auth_req_cnt);
			vty_out(vty,"SIM/PEAP Authentication Success Times :          %d\n",StaNode->auto_auth_suc_cnt);
			vty_out(vty,"SIM/PEAP Authentication Fail Times :             %d\n",StaNode->auto_auth_fail_cnt);
			vty_out(vty,"SIM/PEAP Authentication Sta Total Online time:   %d\n",StaNode->auto_auth_sta_total_time);
			vty_out(vty,"SIM/PEAP Authentication Sta Abnormal Down times: %d\n",StaNode->auto_auth_sta_drop_cnt);
			vty_out(vty,"========================================================================== \n");
			StaNode=StaNode->next;
		}
		dcli_free_wtp_sta_info(StaHead);
	}
	else if (ret == 0){
		vty_out(vty,"<error> There is no sta now\n");
	}
	else if (ret == ASD_DBUS_ERROR){
		vty_out(vty,"<error> failed get reply.\n");
	}
	else if(ret == ASD_WTP_NOT_EXIST){
		vty_out(vty,"<error> There is no WTP now.\n");
	}
	else{
		vty_out(vty,"<error> ret = %d\n",ret);
	}
	return CMD_SUCCESS;

}

DEFUN(show_ac_sta_information_func,
	  show_ac_sta_information_cmd,
	  "show ac sta online information of all",
	  "show information of sta about no authenticate auth and associate auth\n"
	 )
{
	int ret=0;
	unsigned int bss_num;
	struct WtpStationinfo * StaNode =NULL;
	
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	StaNode=show_ac_station_information_of_all(index,localid,dcli_dbus_connection,&bss_num,&ret);
	if((StaNode !=NULL)&&(ret == 0)){
		vty_out(vty,"========================================================================== \n");
		vty_out(vty,"No Authentication Accessed Sta Num:              %d\n",StaNode->no_auth_sta_num);
		vty_out(vty,"Assoc Authentication Accessed Sta Num:           %d\n",StaNode->assoc_auth_sta_num);
		vty_out(vty,"No Authentication Sta Total Online time:         %d\n",StaNode->no_auth_accessed_total_time);
		vty_out(vty,"Assoc Authentication Sta Total Online time:      %d\n",StaNode->assoc_auth_accessed_total_time);
		vty_out(vty,"No Authentication Sta Abnormal Down times:       %d\n",StaNode->no_auth_sta_abnormal_down_num);
		vty_out(vty,"Assoc Authentication Sta Abnormal Down times:    %d\n",StaNode->assoc_auth_sta_abnormal_down_num);
		vty_out(vty,"Assoc Authentication Request times:              %d\n",StaNode->assoc_auth_req_num);
		vty_out(vty,"Assoc Authentication Success Times :             %d\n",StaNode->assoc_auth_succ_num);
		vty_out(vty,"Assoc Authentication Fail Times :                %d\n",StaNode->assoc_auth_fail_num);
		vty_out(vty,"WEP/PSK Authentication Accessed Sta Num:         %d\n",StaNode->assoc_auth_online_sta_num);
		vty_out(vty,"WEP/PSK Authentication Sta Abnormal Down times:  %d\n",StaNode->assoc_auth_sta_drop_cnt);
		vty_out(vty,"WEP/PSK Authentication Request times:            %d\n",StaNode->weppsk_assoc_req_cnt);
		vty_out(vty,"WEP/PSK Authentication Success Times:            %d\n",StaNode->weppsk_assoc_succ_cnt);
		vty_out(vty,"WEP/PSK Authentication Fail Times:         	 %d\n",StaNode->weppsk_assoc_fail_cnt);
		vty_out(vty,"Radius Authentication Response Times :           %d\n",StaNode->auto_auth_resp_cnt);
		vty_out(vty,"SIM/PEAP Authentication Accessed Sta Num:        %d\n",StaNode->auto_auth_online_sta_num);
		vty_out(vty,"SIM/PEAP Authentication Sta Abnormal Down times: %d\n",StaNode->auto_auth_sta_drop_cnt);
		vty_out(vty,"========================================================================== \n");
	}
	else if (ret == 0){
		vty_out(vty,"<error> There is no sta now\n");
	}
	else if (ret == ASD_DBUS_ERROR){
		vty_out(vty,"<error> failed get reply.\n");
	}
	else if(ret == ASD_BSS_NOT_EXIST){
		vty_out(vty,"<error> There is no BSS now.\n");
	}
	else{
		vty_out(vty,"<error> ret = %d\n",ret);
	}

	dcli_free_wtp_sta_info(StaNode);
	return CMD_SUCCESS;
}

//fengwenchao add 20110112   for dot11RadioStatisticsTable ,dot11WlanRadioDataTable
DEFUN(show_all_wlan_ssid_stats_information_of_all_radio_func,
	  show_all_wlan_ssid_stats_information_of_all_radio_cmd,
	  "show wlan ssid stats information_of all_radio",
	  SHOW_STR
	  "Display wlan ssid stats information of all radios\n"
	  "List wlan ssid stats information\n"
	  "by wtp display ssid stats information\n"
	 )
{
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	struct SSIDStatsInfo *WtpHead = NULL;
	struct SSIDStatsInfo *WtpShowNode = NULL;
	int ret=0;
	int i=0;
	int j=0;
	int k=0;
	unsigned int num = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	WtpHead = show_wtp_wlan_SSIDStatsInfo_of_all_wtp(index,localid,dcli_dbus_connection, &num, &ret);

	if((WtpHead!=NULL)&&(ret == 0)){
		//vty_out(vty,"WTPNum:%-5d  \n",num);
		//vty_out(vty,"========================================================================== \n");
		for (i = 0; i < num; i++) {	
			if(WtpShowNode == NULL)
				WtpShowNode = WtpHead->SSIDStatsInfo_list;
			else 
				WtpShowNode = WtpShowNode->next;

			if(WtpShowNode == NULL)
				break;
			
			//vty_out(vty,"------------------------------WTP information------------------------------\n");
			//vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
			//vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
			//WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
			//WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
			//vty_out(vty,"SSIDTxSignalPkts:   %-5d	\t\t",WtpShowNode->SSIDTxSignalPkts);
			//vty_out(vty,"SSIDRxSignalPkts:   %-5d	\n",WtpShowNode->SSIDRxSignalPkts);

			vty_out(vty,"Radio ID: ");
			for(j=0;j<WtpShowNode->wtpBwlanRadioNum;j++){
				vty_out(vty,"%d  ",WtpShowNode->wtpSupportRadioId[j]);
			}
			
			vty_out(vty,"\n");
			struct SSIDStatsInfo_Radioid_info *Radioid_info_node = NULL;
			vty_out(vty,"------------------------------Radio information-----------------------------\n");
			for(j=0;j<WtpShowNode->wtpBwlanRadioNum;j++){
                if(Radioid_info_node == NULL){
                   Radioid_info_node=WtpShowNode->SSIDStatsInfo_Radioid_info_head;
				}
				else{
                   Radioid_info_node=Radioid_info_node->next;
				}
				if(Radioid_info_node == NULL){
                   vty_out(vty,"break\n");
					break;
				}
                vty_out(vty,"wtpSupportRadioId: %d \n",Radioid_info_node->radioId);
				vty_out(vty,"pureN Mixed: %s \n",(Radioid_info_node->Mixed_Green_Field.Mixed_Greenfield == 1)?"pureN":"Mixed");  //fengwenchao add 20110331
                vty_out(vty,"\n");
				vty_out(vty,"Wlan ID: ");
			    for(k=0;k<Radioid_info_node->radioBwlanNum;k++){
				   vty_out(vty,"%d ",Radioid_info_node->RadioidSupportSSID[k]);
				
			    }
				
			    vty_out(vty,"\n");
				
                struct SSIDStatsInfo_sub_wlan *sub_wlan = NULL;
			    vty_out(vty,"------------------------------wlan information-----------------------------\n");
					for(k=0;k<Radioid_info_node->radioBwlanNum;k++){
						if(sub_wlan==NULL){
                          sub_wlan = Radioid_info_node->SSIDStatsInfo_sub_wlan_head;
						  
						}
						else{
                          sub_wlan = sub_wlan->next;
						}
						if(sub_wlan == NULL){
						  
					      vty_out(vty,"break\n");
					     break;
				        }
						vty_out(vty,"\nRadioBindWlanID: %d \n",Radioid_info_node->RadioidSupportSSID[k]);
						vty_out(vty,"Wireless Up Flow:	 %-5lu(byte)  \t\t",sub_wlan->wl_up_flow);
						vty_out(vty,"Wireless Down Flow:   %-5lu(byte)  \n",sub_wlan->wl_dw_flow);
						vty_out(vty,"Channel Down Packets:	 %-5lu  \t\t",sub_wlan->ch_dw_pck);
						vty_out(vty,"Channel Down Loss Packets:   %-5lu  \n",sub_wlan->ch_dw_los_pck);
						vty_out(vty,"Channel Down MAC Error Packets:   %-5lu  \t",sub_wlan->ch_dw_mac_err_pck);
						vty_out(vty,"Channel Down Resend Packets:	%-5lu  \n",sub_wlan->ch_dw_resend_pck);
						vty_out(vty,"Channel Up Frames:   %-5lu	\t\t",sub_wlan->ch_up_frm);
						vty_out(vty,"Channel Down Frames:	%-5lu  \n",sub_wlan->ch_dw_pck);
						vty_out(vty,"Channel Down Error:   %-5lu  \t\t\t",sub_wlan->ch_dw_err_frm);
						vty_out(vty,"Channel Down Loss Frames:	 %-5lu	\n",sub_wlan->ch_dw_los_frm);
						vty_out(vty,"Channel Down Resend Frames:   %-5lu  \t\t",sub_wlan->ch_dw_resend_pck);
						vty_out(vty,"Channel Up Loss Frames:   %-5u  \n",sub_wlan->ch_up_los_frm);
						vty_out(vty,"Channel Up Resend Frames:	 %-5u  \n",sub_wlan->ch_up_resend_frm);
						vty_out(vty,"WlanradioRecvSpeed:	 %-5u  \t\t",sub_wlan->WlanradioRecvSpeed);
						vty_out(vty,"WlanradioSendSpeed:	 %-5u  \n",sub_wlan->WlanradioSendSpeed);
						vty_out(vty,"TrafficLimitState:	 %-5u  \t\t",sub_wlan->traffic_limit_able);   //fengwenchao add 20110331
						vty_out(vty,"TrafficLimitValue:	 %-5u  \n",sub_wlan->send_traffic_limit);   //fengwenchao add 20110331

						/*vty_out(vty,"\nRadioBindWlanID: %d \n",Radioid_info_node->RadioidSupportSSID[k]);
                        vty_out(vty,"SSIDChStatsDwlinkTotRetryPkts: %llu \n",sub_wlan->SSIDChStatsDwlinkTotRetryPkts);
						vty_out(vty,"SSIDChStatsUplinkUniFrameCnt: %llu \n",sub_wlan->SSIDChStatsUplinkUniFrameCnt);
						vty_out(vty,"SSIDChStatsDwlinkUniFrameCnt: %llu \n",sub_wlan->SSIDChStatsDwlinkUniFrameCnt);
						vty_out(vty,"SSIDUpChStatsFrameNonUniFrameCnt: %llu \n",sub_wlan->SSIDUpChStatsFrameNonUniFrameCnt);
						vty_out(vty,"SSIDDownChStatsFrameNonUniFrameCnt: %llu \n",sub_wlan->SSIDDownChStatsFrameNonUniFrameCnt);
						vty_out(vty,"SSIDDwlinkTotFrameCnt: %llu \n",sub_wlan->SSIDDwlinkTotFrameCnt);
						vty_out(vty,"SSIDUplinkTotFrameCnt: %llu \n",sub_wlan->SSIDUplinkTotFrameCnt);
						
						vty_out(vty,"SSIDRxCtrlFrameCnt: %u \t\t\t\t",sub_wlan->SSIDRxCtrlFrameCnt);
						vty_out(vty,"SSIDRxDataFrameCnt: %u \n",sub_wlan->SSIDRxDataFrameCnt);
						vty_out(vty,"SSIDRxAuthenFrameCnt: %u \t\t\t",sub_wlan->SSIDRxAuthenFrameCnt);
						
						vty_out(vty,"SSIDRxAssociateFrameCnt: %u \n",sub_wlan->SSIDRxAssociateFrameCnt);
						vty_out(vty,"SSIDTxCtrlFrameCnt: %u \t\t\t\t",sub_wlan->SSIDTxCtrlFrameCnt);
						vty_out(vty,"SSIDTxDataFrameCnt: %u \n",sub_wlan->SSIDTxDataFrameCnt);
						
						vty_out(vty,"SSIDTxAuthenFrameCnt: %u \t\t\t",sub_wlan->SSIDTxAuthenFrameCnt);
						vty_out(vty,"SSIDTxAssociateFrameCnt: %u \n",sub_wlan->SSIDTxAssociateFrameCnt);
						vty_out(vty,"SSIDApChStatsNumStations: %u \t\t\t",sub_wlan->SSIDApChStatsNumStations);

						vty_out(vty,"wtpSSIDMaxLoginUsr: %u \n",sub_wlan->wtpSSIDMaxLoginUsr);
						vty_out(vty,"wtpSSIDState:  %d \t\t\t\t",sub_wlan->wtpSSIDState);
						vty_out(vty,"wtpSSIDSecurityPolicyID: %d \n",sub_wlan->wtpSSIDSecurityPolicyID);
						vty_out(vty,"wtpSSIDLoadBalance: %d \t\t\t\t",sub_wlan->wtpSSIDLoadBalance);
						vty_out(vty,"wtpSSIDESSID: %s \n",sub_wlan->wtpSSIDESSID);

						vty_out(vty,"wtpSSIDName:  %02X:%02X:%02X:%02X:%02X:%02X \n",
						sub_wlan->wtpSSIDName[0],sub_wlan->wtpSSIDName[1],sub_wlan->wtpSSIDName[2],
						sub_wlan->wtpSSIDName[3],sub_wlan->wtpSSIDName[4],sub_wlan->wtpSSIDName[5]);

						vty_out(vty,"wtpSSID_VlanID: %d \n",sub_wlan->vlanid);


						vty_out(vty,"SSIDInDropRate: %-5u \n",sub_wlan->SSIDInDropRate);
						vty_out(vty,"SSIDOutDropRate: %-5u \n",sub_wlan->SSIDOutDropRate);
						vty_out(vty,"SSIDDownBandWidthRate: %-5u \n",sub_wlan->SSIDDownBandWidthRate);
						vty_out(vty,"SSIDUpBandWidthRate: %-5u \n",sub_wlan->SSIDUpBandWidthRate);
						
						vty_out(vty,"SSIDDwErrPkts: %-5u \n",sub_wlan->SSIDDwErrPkts);
						vty_out(vty,"SSIDDwDropPkts: %-5u \n",sub_wlan->SSIDDwDropPkts);
						vty_out(vty,"SSIDDwTotErrFrames: %-5u \n",sub_wlan->SSIDDwTotErrFrames);
						vty_out(vty,"SSIDUpErrPkts: %-5u \n",sub_wlan->SSIDUpErrPkts);
						vty_out(vty,"SSIDUpDropPkts: %-5u \n",sub_wlan->SSIDUpDropPkts);
						vty_out(vty,"SSIDUpTotErrFrames: %-5u \n",sub_wlan->SSIDUpTotErrFrames);*/
						vty_out(vty,"\n");
						
					
					}
				vty_out(vty,"-------------------------------------------------------------------------\n");
			}
			vty_out(vty,"-------------------------------------------------------------------------\n");
		}
		vty_out(vty,"========================================================================== \n");
	}

	else if (ret == WID_DBUS_ERROR){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == WTP_ID_NOT_EXIST){
		vty_out(vty,"<error> There is no WTP now.\n");
	}
	else{
		vty_out(vty,"<error> ret = %d\n",ret);
	}
	dcli_free_ssid_stats_Info(WtpHead);
	return CMD_SUCCESS;
}
//fengwenchao add end

/* zhangshu copy from 1.2, 2010-09-13 */
/*add for showing wtp SSIDStats  information table 9*/
DEFUN(show_all_wlan_ssid_stats_information_func,
	  show_all_wlan_ssid_stats_information_cmd,
	  "show wlan ssid stats information_of all_wtp [remote] [local] [PARAMETER]",
	  SHOW_STR
	  "Display wlan ssid stats information of all wtps\n"
	  "List wlan ssid stats information\n"
	  "List wlan ssid stats information\n"
	  "List wlan ssid stats information\n"
	  "by wtp display ssid stats information\n"
	  "'remote' or 'local' hansi\n"
	  "'remote' or 'local' hansi\n"
	  "slotid-instid\n"
	 )
{
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	struct SSIDStatsInfo *WtpHead = NULL;
	struct SSIDStatsInfo *WtpShowNode = NULL;
	int ret=0;
	int i=0;
	int j=0;
	int k=0;
	int profile = 0;
	int instRun = 0;
	int flag = 0;
	unsigned int num = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	if((argc == 1)||(argc == 3)){
		vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
		return CMD_SUCCESS;
	}
	if(argc == 2){
		if (!strcmp(argv[0],"remote")){
			localid = 0;
		}else if(!strcmp(argv[0],"local")){
			localid = 1;
		}else{
			vty_out(vty,"parameter should be 'remote' or 'local'\n");
			return CMD_SUCCESS;
		}
		
		if((!strcmp(argv[0],"remote"))&&(!strcmp(argv[1],"local"))){
			vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
			return CMD_SUCCESS;
		}
		
		ret = parse_slot_hansi_id((char*)argv[1],&slot_id,&profile);
		if(ret != WID_DBUS_SUCCESS){
			slot_id = HostSlotId;
			flag = 1;
			ret = parse_int_ID((char*)argv[1], &profile);
			if(ret != WID_DBUS_SUCCESS){
				if(ret == WID_ILLEGAL_INPUT){
					vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
				}
				else{
					vty_out(vty,"<error> unknown id format\n");
				}
				return CMD_WARNING;
			}	
		}
		if(distributFag == 0){
			if(slot_id != 0){
				vty_out(vty,"<error> slot id should be 0\n");
				return CMD_WARNING;
			}	
		}else if(flag == 1){
			slot_id = HostSlotId;
		}
		if(slot_id >= MAX_SLOT_NUM || slot_id < 0){
			vty_out(vty,"<error> slot id should be 1 to %d\n",MAX_SLOT_NUM-1);
			return CMD_WARNING;
		}	
		if(profile >= MAX_INSTANCE || profile == 0){
			vty_out(vty,"<error> hansi id should be 1 to %d\n",MAX_INSTANCE-1);
			return CMD_WARNING;
		}
		instRun = dcli_hmd_hansi_is_running(vty,slot_id,localid,profile);
		if (INSTANCE_NO_CREATED == instRun) {
			vty_out(vty,"<error> the instance %s %d-%d is not running\n",((localid == 1)?"local-hansi":"hansi"),slot_id,profile);
			return CMD_WARNING;
		}
		
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		if(localid == 0)
			goto hansi_parameter;
		else if(localid == 1)
			goto local_hansi_parameter; 
	}

	if(vty->node != VIEW_NODE){
		WtpHead = show_wtp_wlan_SSIDStatsInfo_of_all_wtp(index,localid,dcli_dbus_connection, &num, &ret);

		if((WtpHead!=NULL)&&(ret == 0)){
			vty_out(vty,"WTPNum:%-5d  \n",num);
			vty_out(vty,"========================================================================== \n");
			for (i = 0; i < num; i++) {	
				if(WtpShowNode == NULL)
					WtpShowNode = WtpHead->SSIDStatsInfo_list;
				else 
					WtpShowNode = WtpShowNode->next;

				if(WtpShowNode == NULL)
					break;
				
				vty_out(vty,"------------------------------WTP information------------------------------\n");
				vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
				vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
				WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
				WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
				vty_out(vty,"SSIDTxSignalPkts:   %-5d	\t\t",WtpShowNode->SSIDTxSignalPkts);
				vty_out(vty,"SSIDRxSignalPkts:   %-5d	\n",WtpShowNode->SSIDRxSignalPkts);

				
				//vty_out(vty,"tiao shi xin xi WtpShowNode->wtpBwlanRadioNum===%c \n ",WtpShowNode->wtpBwlanRadioNum);
				vty_out(vty,"Radio ID: ");
				for(j=0;j<WtpShowNode->wtpBwlanRadioNum;j++){
					vty_out(vty,"%d  ",WtpShowNode->wtpSupportRadioId[j]);
				}
				
				vty_out(vty,"\n");
				struct SSIDStatsInfo_Radioid_info *Radioid_info_node = NULL;
				vty_out(vty,"------------------------------Radio information-----------------------------\n");
				for(j=0;j<WtpShowNode->wtpBwlanRadioNum;j++){
	                if(Radioid_info_node == NULL){
	                   Radioid_info_node=WtpShowNode->SSIDStatsInfo_Radioid_info_head;
					}
					else{
	                   Radioid_info_node=Radioid_info_node->next;
					}
					if(Radioid_info_node == NULL){
	                   vty_out(vty,"break\n");
						break;
					}
	                vty_out(vty,"wtpSupportRadioId: %d ",Radioid_info_node->radioId);
	                vty_out(vty,"\n");
					vty_out(vty,"Wlan ID: ");
				    for(k=0;k<Radioid_info_node->radioBwlanNum;k++){
					   vty_out(vty,"%d ",Radioid_info_node->RadioidSupportSSID[k]);
					
				    }
					
				    vty_out(vty,"\n");
					
	                struct SSIDStatsInfo_sub_wlan *sub_wlan = NULL;
				    vty_out(vty,"------------------------------wlan information-----------------------------\n");
						for(k=0;k<Radioid_info_node->radioBwlanNum;k++){
							if(sub_wlan==NULL){
	                          sub_wlan = Radioid_info_node->SSIDStatsInfo_sub_wlan_head;
							  
							}
							else{
	                          sub_wlan = sub_wlan->next;
							}
							if(sub_wlan == NULL){
							  
						      vty_out(vty,"break\n");
						     break;
					        }
							vty_out(vty,"\nRadioBindWlanID: %d \n",Radioid_info_node->RadioidSupportSSID[k]);    //fengwenchao add 20110127
	                        vty_out(vty,"SSIDChStatsDwlinkTotRetryPkts: %llu \n",sub_wlan->SSIDChStatsDwlinkTotRetryPkts);
							vty_out(vty,"SSIDChStatsUplinkUniFrameCnt: %llu \n",sub_wlan->SSIDChStatsUplinkUniFrameCnt);
							vty_out(vty,"SSIDChStatsDwlinkUniFrameCnt: %llu \n",sub_wlan->SSIDChStatsDwlinkUniFrameCnt);
							vty_out(vty,"SSIDUpChStatsFrameNonUniFrameCnt: %llu \n",sub_wlan->SSIDUpChStatsFrameNonUniFrameCnt);
							vty_out(vty,"SSIDDownChStatsFrameNonUniFrameCnt: %llu \n",sub_wlan->SSIDDownChStatsFrameNonUniFrameCnt);
							vty_out(vty,"SSIDDwlinkTotFrameCnt: %llu \n",sub_wlan->SSIDDwlinkTotFrameCnt);
							vty_out(vty,"SSIDUplinkTotFrameCnt: %llu \n",sub_wlan->SSIDUplinkTotFrameCnt);
							
							vty_out(vty,"SSIDRxCtrlFrameCnt: %u \t\t\t\t",sub_wlan->SSIDRxCtrlFrameCnt);
							vty_out(vty,"SSIDRxDataFrameCnt: %u \n",sub_wlan->SSIDRxDataFrameCnt);
							vty_out(vty,"SSIDRxAuthenFrameCnt: %u \t\t\t",sub_wlan->SSIDRxAuthenFrameCnt);
							
							vty_out(vty,"SSIDRxAssociateFrameCnt: %u \n",sub_wlan->SSIDRxAssociateFrameCnt);
							vty_out(vty,"SSIDTxCtrlFrameCnt: %u \t\t\t\t",sub_wlan->SSIDTxCtrlFrameCnt);
							vty_out(vty,"SSIDTxDataFrameCnt: %u \n",sub_wlan->SSIDTxDataFrameCnt);
							
							vty_out(vty,"SSIDTxAuthenFrameCnt: %u \t\t\t",sub_wlan->SSIDTxAuthenFrameCnt);
							vty_out(vty,"SSIDTxAssociateFrameCnt: %u \n",sub_wlan->SSIDTxAssociateFrameCnt);
							vty_out(vty,"SSIDApChStatsNumStations: %u \t\t\t",sub_wlan->SSIDApChStatsNumStations);

							vty_out(vty,"wtpSSIDMaxLoginUsr: %u \n",sub_wlan->wtpSSIDMaxLoginUsr);
							vty_out(vty,"wtpSSIDState:  %d \t\t\t\t",sub_wlan->wtpSSIDState);
							vty_out(vty,"wtpSSIDSecurityPolicyID: %d \n",sub_wlan->wtpSSIDSecurityPolicyID);
							vty_out(vty,"wtpSSIDLoadBalance: %d \t\t\t\t",sub_wlan->wtpSSIDLoadBalance);
							vty_out(vty,"wtpSSIDESSID: %s \n",sub_wlan->wtpSSIDESSID);
							vty_out(vty,"Access times: %u \n",sub_wlan->SSIDAccessTimes);

							vty_out(vty,"wtpSSIDName:  %02X:%02X:%02X:%02X:%02X:%02X \n",
							sub_wlan->wtpSSIDName[0],sub_wlan->wtpSSIDName[1],sub_wlan->wtpSSIDName[2],
							sub_wlan->wtpSSIDName[3],sub_wlan->wtpSSIDName[4],sub_wlan->wtpSSIDName[5]);
							//fengwenchao add 20110127
							vty_out(vty,"wtpSSID_VlanID: %d \n",sub_wlan->vlanid);						
							vty_out(vty,"SSIDDwErrPkts: %-5u \n",sub_wlan->SSIDDwErrPkts);
							vty_out(vty,"SSIDDwDropPkts: %-5u \n",sub_wlan->SSIDDwDropPkts);
							vty_out(vty,"SSIDDwTotErrFrames: %-5u \n",sub_wlan->SSIDDwTotErrFrames);
							vty_out(vty,"SSIDUpErrPkts: %-5u \n",sub_wlan->SSIDUpErrPkts);
							vty_out(vty,"SSIDUpDropPkts: %-5u \n",sub_wlan->SSIDUpDropPkts);
							vty_out(vty,"SSIDUpTotErrFrames: %-5u \n",sub_wlan->SSIDUpTotErrFrames);
							//fengwenchao add end
							vty_out(vty,"\n");
							
						
						}
					vty_out(vty,"-------------------------------------------------------------------------\n");
				}
				vty_out(vty,"-------------------------------------------------------------------------\n");
			}
			vty_out(vty,"========================================================================== \n");
		}

		else if (ret == WID_DBUS_ERROR){
			cli_syslog_info("<error> failed get reply.\n");
		}
		else if(ret == WTP_ID_NOT_EXIST){
			vty_out(vty,"<error> There is no WTP now.\n");
		}
		else{
			vty_out(vty,"<error> ret = %d\n",ret);
		}
		dcli_free_ssid_stats_Info(WtpHead);
	}

	if(vty->node == VIEW_NODE){
		//for remote hansi info
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 0;
			
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,0,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}

		hansi_parameter:
				WtpHead = show_wtp_wlan_SSIDStatsInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &num, &ret);

				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"hansi %d-%d\n",slot_id,profile);
				vty_out(vty,"-----------------------------------------------------------------------------\n");
				if((WtpHead!=NULL)&&(ret == 0)){
					vty_out(vty,"WTPNum:%-5d  \n",num);
					vty_out(vty,"========================================================================== \n");
					WtpShowNode = NULL;
					for (i = 0; i < num; i++) {	
						if(WtpShowNode == NULL)
							WtpShowNode = WtpHead->SSIDStatsInfo_list;
						else 
							WtpShowNode = WtpShowNode->next;

						if(WtpShowNode == NULL)
							break;
						
						vty_out(vty,"------------------------------WTP information------------------------------\n");
						vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
						vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
						WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
						WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
						vty_out(vty,"SSIDTxSignalPkts:   %-5d	\t\t",WtpShowNode->SSIDTxSignalPkts);
						vty_out(vty,"SSIDRxSignalPkts:   %-5d	\n",WtpShowNode->SSIDRxSignalPkts);

						vty_out(vty,"Radio ID: ");
						for(j=0;j<WtpShowNode->wtpBwlanRadioNum;j++){
							vty_out(vty,"%d  ",WtpShowNode->wtpSupportRadioId[j]);
						}
						
						vty_out(vty,"\n");
						struct SSIDStatsInfo_Radioid_info *Radioid_info_node = NULL;
						vty_out(vty,"------------------------------Radio information-----------------------------\n");
						for(j=0;j<WtpShowNode->wtpBwlanRadioNum;j++){
			                if(Radioid_info_node == NULL){
			                   Radioid_info_node=WtpShowNode->SSIDStatsInfo_Radioid_info_head;
							}
							else{
			                   Radioid_info_node=Radioid_info_node->next;
							}
							if(Radioid_info_node == NULL){
			                   vty_out(vty,"break\n");
								break;
							}
			                vty_out(vty,"wtpSupportRadioId: %d ",Radioid_info_node->radioId);
			                vty_out(vty,"\n");
							vty_out(vty,"Wlan ID: ");
						    for(k=0;k<Radioid_info_node->radioBwlanNum;k++){
							   vty_out(vty,"%d ",Radioid_info_node->RadioidSupportSSID[k]);
							
						    }
							
						    vty_out(vty,"\n");
							
			                struct SSIDStatsInfo_sub_wlan *sub_wlan = NULL;
						    vty_out(vty,"------------------------------wlan information-----------------------------\n");
								for(k=0;k<Radioid_info_node->radioBwlanNum;k++){
									if(sub_wlan==NULL){
			                          sub_wlan = Radioid_info_node->SSIDStatsInfo_sub_wlan_head;
									  
									}
									else{
			                          sub_wlan = sub_wlan->next;
									}
									if(sub_wlan == NULL){
									  
								      vty_out(vty,"break\n");
								     break;
							        }
									vty_out(vty,"\nRadioBindWlanID: %d \n",Radioid_info_node->RadioidSupportSSID[k]);    //fengwenchao add 20110127
			                        vty_out(vty,"SSIDChStatsDwlinkTotRetryPkts: %llu \n",sub_wlan->SSIDChStatsDwlinkTotRetryPkts);
									vty_out(vty,"SSIDChStatsUplinkUniFrameCnt: %llu \n",sub_wlan->SSIDChStatsUplinkUniFrameCnt);
									vty_out(vty,"SSIDChStatsDwlinkUniFrameCnt: %llu \n",sub_wlan->SSIDChStatsDwlinkUniFrameCnt);
									vty_out(vty,"SSIDUpChStatsFrameNonUniFrameCnt: %llu \n",sub_wlan->SSIDUpChStatsFrameNonUniFrameCnt);
									vty_out(vty,"SSIDDownChStatsFrameNonUniFrameCnt: %llu \n",sub_wlan->SSIDDownChStatsFrameNonUniFrameCnt);
									vty_out(vty,"SSIDDwlinkTotFrameCnt: %llu \n",sub_wlan->SSIDDwlinkTotFrameCnt);
									vty_out(vty,"SSIDUplinkTotFrameCnt: %llu \n",sub_wlan->SSIDUplinkTotFrameCnt);
									
									vty_out(vty,"SSIDRxCtrlFrameCnt: %u \t\t\t\t",sub_wlan->SSIDRxCtrlFrameCnt);
									vty_out(vty,"SSIDRxDataFrameCnt: %u \n",sub_wlan->SSIDRxDataFrameCnt);
									vty_out(vty,"SSIDRxAuthenFrameCnt: %u \t\t\t",sub_wlan->SSIDRxAuthenFrameCnt);
									
									vty_out(vty,"SSIDRxAssociateFrameCnt: %u \n",sub_wlan->SSIDRxAssociateFrameCnt);
									vty_out(vty,"SSIDTxCtrlFrameCnt: %u \t\t\t\t",sub_wlan->SSIDTxCtrlFrameCnt);
									vty_out(vty,"SSIDTxDataFrameCnt: %u \n",sub_wlan->SSIDTxDataFrameCnt);
									
									vty_out(vty,"SSIDTxAuthenFrameCnt: %u \t\t\t",sub_wlan->SSIDTxAuthenFrameCnt);
									vty_out(vty,"SSIDTxAssociateFrameCnt: %u \n",sub_wlan->SSIDTxAssociateFrameCnt);
									vty_out(vty,"SSIDApChStatsNumStations: %u \t\t\t",sub_wlan->SSIDApChStatsNumStations);

									vty_out(vty,"wtpSSIDMaxLoginUsr: %u \n",sub_wlan->wtpSSIDMaxLoginUsr);
									vty_out(vty,"wtpSSIDState:  %d \t\t\t\t",sub_wlan->wtpSSIDState);
									vty_out(vty,"wtpSSIDSecurityPolicyID: %d \n",sub_wlan->wtpSSIDSecurityPolicyID);
									vty_out(vty,"wtpSSIDLoadBalance: %d \t\t\t\t",sub_wlan->wtpSSIDLoadBalance);
									vty_out(vty,"wtpSSIDESSID: %s \n",sub_wlan->wtpSSIDESSID);
									vty_out(vty,"Access times: %u \n",sub_wlan->SSIDAccessTimes);

									vty_out(vty,"wtpSSIDName:  %02X:%02X:%02X:%02X:%02X:%02X \n",
									sub_wlan->wtpSSIDName[0],sub_wlan->wtpSSIDName[1],sub_wlan->wtpSSIDName[2],
									sub_wlan->wtpSSIDName[3],sub_wlan->wtpSSIDName[4],sub_wlan->wtpSSIDName[5]);
									//fengwenchao add 20110127
									vty_out(vty,"wtpSSID_VlanID: %d \n",sub_wlan->vlanid);						
									vty_out(vty,"SSIDDwErrPkts: %-5u \n",sub_wlan->SSIDDwErrPkts);
									vty_out(vty,"SSIDDwDropPkts: %-5u \n",sub_wlan->SSIDDwDropPkts);
									vty_out(vty,"SSIDDwTotErrFrames: %-5u \n",sub_wlan->SSIDDwTotErrFrames);
									vty_out(vty,"SSIDUpErrPkts: %-5u \n",sub_wlan->SSIDUpErrPkts);
									vty_out(vty,"SSIDUpDropPkts: %-5u \n",sub_wlan->SSIDUpDropPkts);
									vty_out(vty,"SSIDUpTotErrFrames: %-5u \n",sub_wlan->SSIDUpTotErrFrames);
									//fengwenchao add end
									vty_out(vty,"\n");
									
								
								}
							vty_out(vty,"-------------------------------------------------------------------------\n");
						}
						vty_out(vty,"-------------------------------------------------------------------------\n");
					}
				}

				else if (ret == WID_DBUS_ERROR){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == WTP_ID_NOT_EXIST){
					vty_out(vty,"<error> There is no WTP now.\n");
				}
				else{
					vty_out(vty,"<error> ret = %d\n",ret);
				}
				dcli_free_ssid_stats_Info(WtpHead);
				vty_out(vty,"==============================================================================\n");
				if(argc == 2){
					return CMD_SUCCESS;
				}
			}
		}

	//for local hansi info
	for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		localid = 1;
		
		for (profile = 1; profile < MAX_INSTANCE; profile++) 
		{
			instRun = dcli_hmd_hansi_is_running(vty,slot_id,1,profile);
			if (INSTANCE_NO_CREATED == instRun) {
				continue;
			}
	
		local_hansi_parameter:
			WtpHead = show_wtp_wlan_SSIDStatsInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &num, &ret);

			vty_out(vty,"==============================================================================\n");
			vty_out(vty,"local hansi %d-%d\n",slot_id,profile);
			vty_out(vty,"-----------------------------------------------------------------------------\n");
			if((WtpHead!=NULL)&&(ret == 0)){
				vty_out(vty,"WTPNum:%-5d  \n",num);
				vty_out(vty,"========================================================================== \n");
				WtpShowNode = NULL;
				for (i = 0; i < num; i++) {	
					if(WtpShowNode == NULL)
						WtpShowNode = WtpHead->SSIDStatsInfo_list;
					else 
						WtpShowNode = WtpShowNode->next;

					if(WtpShowNode == NULL)
						break;
					
					vty_out(vty,"------------------------------WTP information------------------------------\n");
					vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
					vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
					WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
					WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
					vty_out(vty,"SSIDTxSignalPkts:   %-5d	\t\t",WtpShowNode->SSIDTxSignalPkts);
					vty_out(vty,"SSIDRxSignalPkts:   %-5d	\n",WtpShowNode->SSIDRxSignalPkts);
					vty_out(vty,"Radio ID: ");
					for(j=0;j<WtpShowNode->wtpBwlanRadioNum;j++){
						vty_out(vty,"%d  ",WtpShowNode->wtpSupportRadioId[j]);
					}
					
					vty_out(vty,"\n");
					struct SSIDStatsInfo_Radioid_info *Radioid_info_node = NULL;
					vty_out(vty,"------------------------------Radio information-----------------------------\n");
					for(j=0;j<WtpShowNode->wtpBwlanRadioNum;j++){
		                if(Radioid_info_node == NULL){
		                   Radioid_info_node=WtpShowNode->SSIDStatsInfo_Radioid_info_head;
						}
						else{
		                   Radioid_info_node=Radioid_info_node->next;
						}
						if(Radioid_info_node == NULL){
		                   vty_out(vty,"break\n");
							break;
						}
		                vty_out(vty,"wtpSupportRadioId: %d ",Radioid_info_node->radioId);
		                vty_out(vty,"\n");
						vty_out(vty,"Wlan ID: ");
					    for(k=0;k<Radioid_info_node->radioBwlanNum;k++){
						   vty_out(vty,"%d ",Radioid_info_node->RadioidSupportSSID[k]);
						
					    }
						
					    vty_out(vty,"\n");
						
		                struct SSIDStatsInfo_sub_wlan *sub_wlan = NULL;
					    vty_out(vty,"------------------------------wlan information-----------------------------\n");
							for(k=0;k<Radioid_info_node->radioBwlanNum;k++){
								if(sub_wlan==NULL){
		                          sub_wlan = Radioid_info_node->SSIDStatsInfo_sub_wlan_head;
								  
								}
								else{
		                          sub_wlan = sub_wlan->next;
								}
								if(sub_wlan == NULL){
								  
							      vty_out(vty,"break\n");
							     break;
						        }
								vty_out(vty,"\nRadioBindWlanID: %d \n",Radioid_info_node->RadioidSupportSSID[k]);    //fengwenchao add 20110127
		                        vty_out(vty,"SSIDChStatsDwlinkTotRetryPkts: %llu \n",sub_wlan->SSIDChStatsDwlinkTotRetryPkts);
								vty_out(vty,"SSIDChStatsUplinkUniFrameCnt: %llu \n",sub_wlan->SSIDChStatsUplinkUniFrameCnt);
								vty_out(vty,"SSIDChStatsDwlinkUniFrameCnt: %llu \n",sub_wlan->SSIDChStatsDwlinkUniFrameCnt);
								vty_out(vty,"SSIDUpChStatsFrameNonUniFrameCnt: %llu \n",sub_wlan->SSIDUpChStatsFrameNonUniFrameCnt);
								vty_out(vty,"SSIDDownChStatsFrameNonUniFrameCnt: %llu \n",sub_wlan->SSIDDownChStatsFrameNonUniFrameCnt);
								vty_out(vty,"SSIDDwlinkTotFrameCnt: %llu \n",sub_wlan->SSIDDwlinkTotFrameCnt);
								vty_out(vty,"SSIDUplinkTotFrameCnt: %llu \n",sub_wlan->SSIDUplinkTotFrameCnt);
								
								vty_out(vty,"SSIDRxCtrlFrameCnt: %u \t\t\t\t",sub_wlan->SSIDRxCtrlFrameCnt);
								vty_out(vty,"SSIDRxDataFrameCnt: %u \n",sub_wlan->SSIDRxDataFrameCnt);
								vty_out(vty,"SSIDRxAuthenFrameCnt: %u \t\t\t",sub_wlan->SSIDRxAuthenFrameCnt);
								
								vty_out(vty,"SSIDRxAssociateFrameCnt: %u \n",sub_wlan->SSIDRxAssociateFrameCnt);
								vty_out(vty,"SSIDTxCtrlFrameCnt: %u \t\t\t\t",sub_wlan->SSIDTxCtrlFrameCnt);
								vty_out(vty,"SSIDTxDataFrameCnt: %u \n",sub_wlan->SSIDTxDataFrameCnt);
								
								vty_out(vty,"SSIDTxAuthenFrameCnt: %u \t\t\t",sub_wlan->SSIDTxAuthenFrameCnt);
								vty_out(vty,"SSIDTxAssociateFrameCnt: %u \n",sub_wlan->SSIDTxAssociateFrameCnt);
								vty_out(vty,"SSIDApChStatsNumStations: %u \t\t\t",sub_wlan->SSIDApChStatsNumStations);

								vty_out(vty,"wtpSSIDMaxLoginUsr: %u \n",sub_wlan->wtpSSIDMaxLoginUsr);
								vty_out(vty,"wtpSSIDState:  %d \t\t\t\t",sub_wlan->wtpSSIDState);
								vty_out(vty,"wtpSSIDSecurityPolicyID: %d \n",sub_wlan->wtpSSIDSecurityPolicyID);
								vty_out(vty,"wtpSSIDLoadBalance: %d \t\t\t\t",sub_wlan->wtpSSIDLoadBalance);
								vty_out(vty,"wtpSSIDESSID: %s \n",sub_wlan->wtpSSIDESSID);
								vty_out(vty,"Access times: %u \n",sub_wlan->SSIDAccessTimes);

								vty_out(vty,"wtpSSIDName:  %02X:%02X:%02X:%02X:%02X:%02X \n",
								sub_wlan->wtpSSIDName[0],sub_wlan->wtpSSIDName[1],sub_wlan->wtpSSIDName[2],
								sub_wlan->wtpSSIDName[3],sub_wlan->wtpSSIDName[4],sub_wlan->wtpSSIDName[5]);
								//fengwenchao add 20110127
								vty_out(vty,"wtpSSID_VlanID: %d \n",sub_wlan->vlanid);						
								vty_out(vty,"SSIDDwErrPkts: %-5u \n",sub_wlan->SSIDDwErrPkts);
								vty_out(vty,"SSIDDwDropPkts: %-5u \n",sub_wlan->SSIDDwDropPkts);
								vty_out(vty,"SSIDDwTotErrFrames: %-5u \n",sub_wlan->SSIDDwTotErrFrames);
								vty_out(vty,"SSIDUpErrPkts: %-5u \n",sub_wlan->SSIDUpErrPkts);
								vty_out(vty,"SSIDUpDropPkts: %-5u \n",sub_wlan->SSIDUpDropPkts);
								vty_out(vty,"SSIDUpTotErrFrames: %-5u \n",sub_wlan->SSIDUpTotErrFrames);
								//fengwenchao add end
								vty_out(vty,"\n");
								
							
							}
						vty_out(vty,"-------------------------------------------------------------------------\n");
					}
					vty_out(vty,"-------------------------------------------------------------------------\n");
				}
			}

			else if (ret == WID_DBUS_ERROR){
				cli_syslog_info("<error> failed get reply.\n");
			}
			else if(ret == WTP_ID_NOT_EXIST){
				vty_out(vty,"<error> There is no WTP now.\n");
			}
			else{
				vty_out(vty,"<error> ret = %d\n",ret);
			}
			dcli_free_ssid_stats_Info(WtpHead);
			vty_out(vty,"==============================================================================\n");
			if(argc == 2){
				return CMD_SUCCESS;
			}
			}
		}
	}
	
	return CMD_SUCCESS;
}


/*nl add  for showting wtp ifname information table 10*/
DEFUN(show_all_wtp_ifname_information_func,
	  show_all_wtp_ifname_information_cmd,
	  "show the ifname information of all_wtp [remote] [local] [PARAMETER]",
	  SHOW_STR
	  "ifname information\n"
	  "ifname information\n"
	  "Display ifname information of all wtps\n"
	  "List wtp ifname information\n"
	  "by wtp display ifname information\n"
	  "'remote' or 'local' hansi\n"
	  "'remote' or 'local' hansi\n"
	  "slotid-instid\n"
	 )
{
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	struct WtpIfnameInfo *WtpHead = NULL;
	struct WtpIfnameInfo *WtpShowNode = NULL;
	int ret=0;
	int i=0;
	int j=0;
	int profile = 0;
	int instRun = 0;
	int flag = 0;
	unsigned int num = 0;
	int hour,min,sec;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	if((argc == 1)||(argc == 3)){
		vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
		return CMD_SUCCESS;
	}
	if(argc == 2){
		if (!strcmp(argv[0],"remote")){
			localid = 0;
		}else if(!strcmp(argv[0],"local")){
			localid = 1;
		}else{
			vty_out(vty,"parameter should be 'remote' or 'local'\n");
			return CMD_SUCCESS;
		}
		
		if((!strcmp(argv[0],"remote"))&&(!strcmp(argv[1],"local"))){
			vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
			return CMD_SUCCESS;
		}
		
		ret = parse_slot_hansi_id((char*)argv[1],&slot_id,&profile);
		if(ret != WID_DBUS_SUCCESS){
			slot_id = HostSlotId;
			flag = 1;
			ret = parse_int_ID((char*)argv[1], &profile);
			if(ret != WID_DBUS_SUCCESS){
				if(ret == WID_ILLEGAL_INPUT){
					vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
				}
				else{
					vty_out(vty,"<error> unknown id format\n");
				}
				return CMD_WARNING;
			}	
		}
		if(distributFag == 0){
			if(slot_id != 0){
				vty_out(vty,"<error> slot id should be 0\n");
				return CMD_WARNING;
			}	
		}else if(flag == 1){
			slot_id = HostSlotId;
		}
		if(slot_id >= MAX_SLOT_NUM || slot_id < 0){
			vty_out(vty,"<error> slot id should be 1 to %d\n",MAX_SLOT_NUM-1);
			return CMD_WARNING;
		}	
		if(profile >= MAX_INSTANCE || profile == 0){
			vty_out(vty,"<error> hansi id should be 1 to %d\n",MAX_INSTANCE-1);
			return CMD_WARNING;
		}
		instRun = dcli_hmd_hansi_is_running(vty,slot_id,localid,profile);
		if (INSTANCE_NO_CREATED == instRun) {
			vty_out(vty,"<error> the instance %s %d-%d is not running\n",((localid == 1)?"local-hansi":"hansi"),slot_id,profile);
			return CMD_WARNING;
		}
		
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		if(localid == 0)
			goto hansi_parameter;
		else if(localid == 1)
			goto local_hansi_parameter; 
	}

	if(vty->node != VIEW_NODE){
		WtpHead = show_WtpIfnameInfo_of_all_wtp(index,localid,dcli_dbus_connection, &num, &ret);

		if((WtpHead!=NULL)&&(ret == 0)){
			vty_out(vty,"WTPNum:%-5d  \n",num);
			vty_out(vty,"========================================================================== \n");
			for (i = 0; i < num; i++) {	
				if(WtpShowNode == NULL)
					WtpShowNode = WtpHead->WtpIfnameInfo_list;
				else 
					WtpShowNode = WtpShowNode->next;

				if(WtpShowNode == NULL)
					break;
				
				vty_out(vty,"-------------------------------------------------------------------------\n");
				vty_out(vty,"WTP information:\n");
				vty_out(vty,"WTPID:%-5d  \n",WtpShowNode->wtpCurrID);
				vty_out(vty,"WTP MAC:  %s ",WtpShowNode->wtpMacAddr);
				vty_out(vty,"%02X:%02X:%02X:%02X:%02X:%02X \t\t",
				WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
				WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
				vty_out(vty,"wtpIfIndexNum:%-5d  \n",WtpShowNode->wtpIfIndexNum);
				vty_out(vty,"\n");
				
				vty_out(vty,"WTP sub information:\n");
				struct WtpIfInfo_sub_info *SubShowNode = NULL;
				for(j=0;j<WtpShowNode->wtpIfIndexNum;j++){
									
					if(SubShowNode == NULL)
						SubShowNode = WtpShowNode->WtpIfInfo_sub_info_head;
					else 
						SubShowNode = SubShowNode->next;

					if(SubShowNode == NULL){
						vty_out(vty,"break\n");
						break;
					}
					
					vty_out(vty,"wtpIfIndex:%-5d  \n",SubShowNode->wtpIfIndex);
					vty_out(vty,"wtpIfSpeed:%d  \t\t\t",SubShowNode->wtpIfSpeed);
					vty_out(vty,"wtpMTU:%d  \t\t\t",SubShowNode->wtpMTU);
					vty_out(vty,"wtpIfType:%d  \n",SubShowNode->wtpIfType);
					vty_out(vty,"wtpifinfo_report_switch:%s  \t\t",(SubShowNode->wtpifinfo_report_switch == 1?"en" :"dis"));
					vty_out(vty,"wtpIfAdminStatus : %d  \n",SubShowNode->wtpIfAdminStatus);
					vty_out(vty,"wtpIfOperStatus:%d  \t\t\t",SubShowNode->wtpIfOperStatus);
					vty_out(vty,"state_time:%d  \n",SubShowNode->state_time);
					vty_out(vty,"wtpIfLastChange:%d  \t\t",SubShowNode->wtpIfLastChange);
					vty_out(vty,"wtpIfUplinkRealtimeRate:%d  \n",SubShowNode->wtpIfUplinkRealtimeRate);
					vty_out(vty,"wtpIfDownlinkRealtimeRate:%d  \t\t\t",SubShowNode->wtpIfDownlinkRealtimeRate);
					vty_out(vty,"\n");
		
				}

			}
			
			vty_out(vty,"========================================================================== \n");
		
		}

		else if (ret == WID_DBUS_ERROR){
			cli_syslog_info("<error> failed get reply.\n");
		}
		else if(ret == WTP_ID_NOT_EXIST){
			vty_out(vty,"<error> There is no WTP now.\n");
		}
		else{
			vty_out(vty,"<error> ret = %d\n",ret);
		}
		
		dcli_free_WtpIfnameInfo(WtpHead);
	}

	if(vty->node == VIEW_NODE){
		//for remote hansi info
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 0;
			
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,0,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}

		hansi_parameter:
				WtpHead = show_WtpIfnameInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &num, &ret);

				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"hansi %d-%d\n",slot_id,profile);
				vty_out(vty,"-----------------------------------------------------------------------------\n");
				if((WtpHead!=NULL)&&(ret == 0)){
					vty_out(vty,"WTPNum:%-5d  \n",num);
					vty_out(vty,"========================================================================== \n");
					WtpShowNode = NULL;
					for (i = 0; i < num; i++) {	
						if(WtpShowNode == NULL)
							WtpShowNode = WtpHead->WtpIfnameInfo_list;
						else 
							WtpShowNode = WtpShowNode->next;

						if(WtpShowNode == NULL)
							break;
						
						vty_out(vty,"-------------------------------------------------------------------------\n");
						vty_out(vty,"WTP information:\n");
						vty_out(vty,"WTPID:%-5d  \n",WtpShowNode->wtpCurrID);
						vty_out(vty,"WTP MAC:  %s ",WtpShowNode->wtpMacAddr);
						vty_out(vty,"%02X:%02X:%02X:%02X:%02X:%02X \t\t",
						WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
						WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
						vty_out(vty,"wtpIfIndexNum:%-5d  \n",WtpShowNode->wtpIfIndexNum);
						vty_out(vty,"\n");
						
						vty_out(vty,"WTP sub information:\n");
						struct WtpIfInfo_sub_info *SubShowNode = NULL;
						for(j=0;j<WtpShowNode->wtpIfIndexNum;j++){
											
							if(SubShowNode == NULL)
								SubShowNode = WtpShowNode->WtpIfInfo_sub_info_head;
							else 
								SubShowNode = SubShowNode->next;

							if(SubShowNode == NULL){
								vty_out(vty,"break\n");
								break;
							}
							
							vty_out(vty,"wtpIfIndex:%-5d  \n",SubShowNode->wtpIfIndex);
							vty_out(vty,"wtpIfSpeed:%d  \t\t\t",SubShowNode->wtpIfSpeed);
							vty_out(vty,"wtpMTU:%d  \t\t\t",SubShowNode->wtpMTU);
							vty_out(vty,"wtpIfType:%d  \n",SubShowNode->wtpIfType);
							vty_out(vty,"wtpifinfo_report_switch:%s  \t\t",(SubShowNode->wtpifinfo_report_switch == 1?"en" :"dis"));
							vty_out(vty,"wtpIfAdminStatus : %d  \n",SubShowNode->wtpIfAdminStatus);
							vty_out(vty,"wtpIfOperStatus:%d  \t\t\t",SubShowNode->wtpIfOperStatus);
							vty_out(vty,"state_time:%d  \n",SubShowNode->state_time);
							vty_out(vty,"wtpIfLastChange:%d  \t\t",SubShowNode->wtpIfLastChange);
							vty_out(vty,"wtpIfUplinkRealtimeRate:%d  \n",SubShowNode->wtpIfUplinkRealtimeRate);
							vty_out(vty,"wtpIfDownlinkRealtimeRate:%d  \t\t\t",SubShowNode->wtpIfDownlinkRealtimeRate);
							vty_out(vty,"\n");
				
						}
					}
				}

				else if (ret == WID_DBUS_ERROR){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == WTP_ID_NOT_EXIST){
					vty_out(vty,"<error> There is no WTP now.\n");
				}
				else{
					vty_out(vty,"<error> ret = %d\n",ret);
				}
				
				dcli_free_WtpIfnameInfo(WtpHead);
				vty_out(vty,"==============================================================================\n");
				if(argc == 2){
					return CMD_SUCCESS;
				}
			}
		}

	//for local hansi info
	for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		localid = 1;
		
		for (profile = 1; profile < MAX_INSTANCE; profile++) 
		{
			instRun = dcli_hmd_hansi_is_running(vty,slot_id,1,profile);
			if (INSTANCE_NO_CREATED == instRun) {
				continue;
			}
	
		local_hansi_parameter:
			WtpHead = show_WtpIfnameInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &num, &ret);

			vty_out(vty,"==============================================================================\n");
			vty_out(vty,"local hansi %d-%d\n",slot_id,profile);
			vty_out(vty,"-----------------------------------------------------------------------------\n");
			if((WtpHead!=NULL)&&(ret == 0)){
				vty_out(vty,"WTPNum:%-5d  \n",num);
				vty_out(vty,"========================================================================== \n");
				WtpShowNode = NULL;
				for (i = 0; i < num; i++) {	
					if(WtpShowNode == NULL)
						WtpShowNode = WtpHead->WtpIfnameInfo_list;
					else 
						WtpShowNode = WtpShowNode->next;

					if(WtpShowNode == NULL)
						break;
					
					vty_out(vty,"-------------------------------------------------------------------------\n");
					vty_out(vty,"WTP information:\n");
					vty_out(vty,"WTPID:%-5d  \n",WtpShowNode->wtpCurrID);
					vty_out(vty,"WTP MAC:  %s ",WtpShowNode->wtpMacAddr);
					vty_out(vty,"%02X:%02X:%02X:%02X:%02X:%02X \t\t",
					WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
					WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
					vty_out(vty,"wtpIfIndexNum:%-5d  \n",WtpShowNode->wtpIfIndexNum);
					vty_out(vty,"\n");
					
					vty_out(vty,"WTP sub information:\n");
					struct WtpIfInfo_sub_info *SubShowNode = NULL;
					for(j=0;j<WtpShowNode->wtpIfIndexNum;j++){
										
						if(SubShowNode == NULL)
							SubShowNode = WtpShowNode->WtpIfInfo_sub_info_head;
						else 
							SubShowNode = SubShowNode->next;

						if(SubShowNode == NULL){
							vty_out(vty,"break\n");
							break;
						}
						
						vty_out(vty,"wtpIfIndex:%-5d  \n",SubShowNode->wtpIfIndex);
						vty_out(vty,"wtpIfSpeed:%d  \t\t\t",SubShowNode->wtpIfSpeed);
						vty_out(vty,"wtpMTU:%d  \t\t\t",SubShowNode->wtpMTU);
						vty_out(vty,"wtpIfType:%d  \n",SubShowNode->wtpIfType);
						vty_out(vty,"wtpifinfo_report_switch:%s  \t\t",(SubShowNode->wtpifinfo_report_switch == 1?"en" :"dis"));
						vty_out(vty,"wtpIfAdminStatus : %d  \n",SubShowNode->wtpIfAdminStatus);
						vty_out(vty,"wtpIfOperStatus:%d  \t\t\t",SubShowNode->wtpIfOperStatus);
						vty_out(vty,"state_time:%d  \n",SubShowNode->state_time);
						vty_out(vty,"wtpIfLastChange:%d  \t\t",SubShowNode->wtpIfLastChange);
						vty_out(vty,"wtpIfUplinkRealtimeRate:%d  \n",SubShowNode->wtpIfUplinkRealtimeRate);
						vty_out(vty,"wtpIfDownlinkRealtimeRate:%d  \t\t\t",SubShowNode->wtpIfDownlinkRealtimeRate);
						vty_out(vty,"\n");
			
					}

				}
			}

			else if (ret == WID_DBUS_ERROR){
				cli_syslog_info("<error> failed get reply.\n");
			}
			else if(ret == WTP_ID_NOT_EXIST){
				vty_out(vty,"<error> There is no WTP now.\n");
			}
			else{
				vty_out(vty,"<error> ret = %d\n",ret);
			}
			
			dcli_free_WtpIfnameInfo(WtpHead);
			vty_out(vty,"==============================================================================\n");
			if(argc == 2){
				return CMD_SUCCESS;
			}
			}
		}
	}
	
	return CMD_SUCCESS;
}

/*nl add for showing wtp radio para information table 11*/
DEFUN(show_all_wtp_the_radio_para_information_func,
	  show_all_wtp_the_radio_para_information_cmd,
	  "show the radio para_information of all_wtp [remote] [local] [PARAMETER]",
	  SHOW_STR
	  "radio para information\n"
	  "radio para information\n"
	  "Display radio para information of all wtps\n"
	  "List wtp radio para information\n"
	  "by wtp display radio para information\n"
	  "'remote' or 'local' hansi\n"
	  "'remote' or 'local' hansi\n"
	  "slotid-instid\n"
	 )
{
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	struct WtpRadioParaInfo *WtpHead = NULL;
	struct WtpRadioParaInfo *WtpShowNode = NULL;
	int ret=0;
	int i=0;
	int j=0;
	int profile = 0;
	int instRun = 0;
	int flag = 0;
	unsigned int wtp_num = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	
	if((argc == 1)||(argc == 3)){
		vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
		return CMD_SUCCESS;
	}
	if(argc == 2){
		if (!strcmp(argv[0],"remote")){
			localid = 0;
		}else if(!strcmp(argv[0],"local")){
			localid = 1;
		}else{
			vty_out(vty,"parameter should be 'remote' or 'local'\n");
			return CMD_SUCCESS;
		}
		
		if((!strcmp(argv[0],"remote"))&&(!strcmp(argv[1],"local"))){
			vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
			return CMD_SUCCESS;
		}
		
		ret = parse_slot_hansi_id((char*)argv[1],&slot_id,&profile);
		if(ret != WID_DBUS_SUCCESS){
			slot_id = HostSlotId;
			flag = 1;
			ret = parse_int_ID((char*)argv[1], &profile);
			if(ret != WID_DBUS_SUCCESS){
				if(ret == WID_ILLEGAL_INPUT){
					vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
				}
				else{
					vty_out(vty,"<error> unknown id format\n");
				}
				return CMD_WARNING;
			}	
		}
		if(distributFag == 0){
			if(slot_id != 0){
				vty_out(vty,"<error> slot id should be 0\n");
				return CMD_WARNING;
			}	
		}else if(flag == 1){
			slot_id = HostSlotId;
		}
		if(slot_id >= MAX_SLOT_NUM || slot_id < 0){
			vty_out(vty,"<error> slot id should be 1 to %d\n",MAX_SLOT_NUM-1);
			return CMD_WARNING;
		}	
		if(profile >= MAX_INSTANCE || profile == 0){
			vty_out(vty,"<error> hansi id should be 1 to %d\n",MAX_INSTANCE-1);
			return CMD_WARNING;
		}
		instRun = dcli_hmd_hansi_is_running(vty,slot_id,localid,profile);
		if (INSTANCE_NO_CREATED == instRun) {
			vty_out(vty,"<error> the instance %s %d-%d is not running\n",((localid == 1)?"local-hansi":"hansi"),slot_id,profile);
			return CMD_WARNING;
		}
		
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		if(localid == 0)
			goto hansi_parameter;
		else if(localid == 1)
			goto local_hansi_parameter; 
	}

	if(vty->node != VIEW_NODE){
		WtpHead = show_WtpRadioParaInfo_of_all_wtp(index,localid,dcli_dbus_connection, &wtp_num, &ret);
		
		if((WtpHead!=NULL)&&(ret == 0)){
			vty_out(vty,"WTPNum:%-5d  \n",wtp_num);
			vty_out(vty,"========================================================================== \n");
			for (i = 0; i < wtp_num; i++) {	
				if(WtpShowNode == NULL)
					WtpShowNode = WtpHead->WtpRadioParaInfo_list;
				else 
					WtpShowNode = WtpShowNode->next;

				if(WtpShowNode == NULL)
					break;

				vty_out(vty,"    ========================WTPInformation============================     \n");
				vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
				vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
				WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
				WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
				
				vty_out(vty,"wtpRadioNum:   %-5d  \t\t\t\t",WtpShowNode->wtpRadioNum);
				vty_out(vty,"wtpSignalSNR:   %-5d  \n",WtpShowNode->wtpSignalSNR);

				vty_out(vty,"-------------------------------------------------------------------------\n");

				struct Sub_RadioParaInfo *sub_radio = NULL;
				for(j=0;j<WtpShowNode->wtpRadioNum;j++){
					
					if(sub_radio == NULL)
						sub_radio = WtpShowNode->Sub_RadioParaInfo_head;
					else 
						sub_radio = sub_radio->next;

					if(sub_radio == NULL){
						vty_out(vty,"break\n");
						break;
					}
					
					vty_out(vty,"------------------------radio information:------------------------------- \n");
					vty_out(vty,"local_radioid:  %-5d  \t\t\t\t",(sub_radio->wtpRadLocalID));
					vty_out(vty,"global_radioid:  %-5d  \n",sub_radio->wtpRadCurrID);

					vty_out(vty,"wtpFrequencyHopTimes:  %-5d  \t\t\t",sub_radio->wtpFrequencyHopTimes);
					vty_out(vty,"wtpFreHopDetectTime:  %-5d  \n",sub_radio->wtpFreHopDetectTime);
					vty_out(vty,"wtpConfigLongRetransThreshold:  %-5d  \t\t",sub_radio->wtpConfigLongRetransThreshold);
					vty_out(vty,"wtpMessageNeafThreshold:  %-5d  \n",sub_radio->wtpMessageNeafThreshold);

					vty_out(vty,"wtpRTSThreshold:  %-5d	\t\t\t",sub_radio->wtpRTSThreshold);
					vty_out(vty,"wtpSignalAveIntensity:  %-5d	\n",sub_radio->wtpSignalAveIntensity);
					vty_out(vty,"wtpPreambleLen:  %-5d	\t",sub_radio->wtpPreambleLen);
					vty_out(vty,"\n");
					
				
					
				}
			}
			vty_out(vty,"========================================================================== \n");
		}

		else if (ret == WID_DBUS_ERROR){
			cli_syslog_info("<error> failed get reply.\n");
		}
		else if(ret == WTP_ID_NOT_EXIST){
			vty_out(vty,"<error> There is no WTP now.\n");
		}
		else{
			vty_out(vty,"<error> ret = %d\n",ret);
		}

		dcli_free_wtp_WtpRadioParaInfo(WtpHead);
	}

	if(vty->node == VIEW_NODE){
		//for remote hansi info
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 0;
			
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,0,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}

		hansi_parameter:
				WtpHead = show_WtpRadioParaInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &wtp_num, &ret);
				
				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"hansi %d-%d\n",slot_id,profile);
				vty_out(vty,"-----------------------------------------------------------------------------\n");
				if((WtpHead!=NULL)&&(ret == 0)){
					vty_out(vty,"WTPNum:%-5d  \n",wtp_num);
					vty_out(vty,"========================================================================== \n");
					WtpShowNode = NULL;
					for (i = 0; i < wtp_num; i++) {	
						if(WtpShowNode == NULL)
							WtpShowNode = WtpHead->WtpRadioParaInfo_list;
						else 
							WtpShowNode = WtpShowNode->next;

						if(WtpShowNode == NULL)
							break;

						vty_out(vty,"    ========================WTPInformation============================     \n");
						vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
						vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
						WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
						WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
						
						vty_out(vty,"wtpRadioNum:   %-5d  \t\t\t\t",WtpShowNode->wtpRadioNum);
						vty_out(vty,"wtpSignalSNR:   %-5d  \n",WtpShowNode->wtpSignalSNR);

						vty_out(vty,"-------------------------------------------------------------------------\n");

						struct Sub_RadioParaInfo *sub_radio = NULL;
						for(j=0;j<WtpShowNode->wtpRadioNum;j++){
							
							if(sub_radio == NULL)
								sub_radio = WtpShowNode->Sub_RadioParaInfo_head;
							else 
								sub_radio = sub_radio->next;

							if(sub_radio == NULL){
								vty_out(vty,"break\n");
								break;
							}
							
							vty_out(vty,"------------------------radio information:------------------------------- \n");
							vty_out(vty,"local_radioid:  %-5d  \t\t\t\t",(sub_radio->wtpRadLocalID));
							vty_out(vty,"global_radioid:  %-5d  \n",sub_radio->wtpRadCurrID);

							vty_out(vty,"wtpFrequencyHopTimes:  %-5d  \t\t\t",sub_radio->wtpFrequencyHopTimes);
							vty_out(vty,"wtpFreHopDetectTime:  %-5d  \n",sub_radio->wtpFreHopDetectTime);
							vty_out(vty,"wtpConfigLongRetransThreshold:  %-5d  \t\t",sub_radio->wtpConfigLongRetransThreshold);
							vty_out(vty,"wtpMessageNeafThreshold:  %-5d  \n",sub_radio->wtpMessageNeafThreshold);

							vty_out(vty,"wtpRTSThreshold:  %-5d	\t\t\t",sub_radio->wtpRTSThreshold);
							vty_out(vty,"wtpSignalAveIntensity:  %-5d	\n",sub_radio->wtpSignalAveIntensity);
							vty_out(vty,"wtpPreambleLen:  %-5d	\t",sub_radio->wtpPreambleLen);
							vty_out(vty,"\n");
							
						
							
						}
					}
				}

				else if (ret == WID_DBUS_ERROR){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == WTP_ID_NOT_EXIST){
					vty_out(vty,"<error> There is no WTP now.\n");
				}
				else{
					vty_out(vty,"<error> ret = %d\n",ret);
				}

				dcli_free_wtp_WtpRadioParaInfo(WtpHead);
				vty_out(vty,"==============================================================================\n");
				if(argc == 2){
					return CMD_SUCCESS;
				}
			}
		}

	//for local hansi info
	for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		localid = 1;
		
		for (profile = 1; profile < MAX_INSTANCE; profile++) 
		{
			instRun = dcli_hmd_hansi_is_running(vty,slot_id,1,profile);
			if (INSTANCE_NO_CREATED == instRun) {
				continue;
			}
	
		local_hansi_parameter:
			WtpHead = show_WtpRadioParaInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &wtp_num, &ret);
			
			vty_out(vty,"==============================================================================\n");
			vty_out(vty,"local hansi %d-%d\n",slot_id,profile);
			vty_out(vty,"-----------------------------------------------------------------------------\n");
			if((WtpHead!=NULL)&&(ret == 0)){
				vty_out(vty,"WTPNum:%-5d  \n",wtp_num);
				vty_out(vty,"========================================================================== \n");
				WtpShowNode = NULL;
				for (i = 0; i < wtp_num; i++) {	
					if(WtpShowNode == NULL)
						WtpShowNode = WtpHead->WtpRadioParaInfo_list;
					else 
						WtpShowNode = WtpShowNode->next;

					if(WtpShowNode == NULL)
						break;

					vty_out(vty,"    ========================WTPInformation============================     \n");
					vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
					vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
					WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
					WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
					
					vty_out(vty,"wtpRadioNum:   %-5d  \t\t\t\t",WtpShowNode->wtpRadioNum);
					vty_out(vty,"wtpSignalSNR:   %-5d  \n",WtpShowNode->wtpSignalSNR);

					vty_out(vty,"-------------------------------------------------------------------------\n");

					struct Sub_RadioParaInfo *sub_radio = NULL;
					for(j=0;j<WtpShowNode->wtpRadioNum;j++){
						
						if(sub_radio == NULL)
							sub_radio = WtpShowNode->Sub_RadioParaInfo_head;
						else 
							sub_radio = sub_radio->next;

						if(sub_radio == NULL){
							vty_out(vty,"break\n");
							break;
						}
						
						vty_out(vty,"------------------------radio information:------------------------------- \n");
						vty_out(vty,"local_radioid:  %-5d  \t\t\t\t",(sub_radio->wtpRadLocalID));
						vty_out(vty,"global_radioid:  %-5d  \n",sub_radio->wtpRadCurrID);

						vty_out(vty,"wtpFrequencyHopTimes:  %-5d  \t\t\t",sub_radio->wtpFrequencyHopTimes);
						vty_out(vty,"wtpFreHopDetectTime:  %-5d  \n",sub_radio->wtpFreHopDetectTime);
						vty_out(vty,"wtpConfigLongRetransThreshold:  %-5d  \t\t",sub_radio->wtpConfigLongRetransThreshold);
						vty_out(vty,"wtpMessageNeafThreshold:  %-5d  \n",sub_radio->wtpMessageNeafThreshold);

						vty_out(vty,"wtpRTSThreshold:  %-5d	\t\t\t",sub_radio->wtpRTSThreshold);
						vty_out(vty,"wtpSignalAveIntensity:  %-5d	\n",sub_radio->wtpSignalAveIntensity);
						vty_out(vty,"wtpPreambleLen:  %-5d	\t",sub_radio->wtpPreambleLen);
						vty_out(vty,"\n");
						
					
						
					}
				}
			}

			else if (ret == WID_DBUS_ERROR){
				cli_syslog_info("<error> failed get reply.\n");
			}
			else if(ret == WTP_ID_NOT_EXIST){
				vty_out(vty,"<error> There is no WTP now.\n");
			}
			else{
				vty_out(vty,"<error> ret = %d\n",ret);
			}

			dcli_free_wtp_WtpRadioParaInfo(WtpHead);
			vty_out(vty,"==============================================================================\n");
			if(argc == 2){
				return CMD_SUCCESS;
			}
			}
		}
	}
	
	return CMD_SUCCESS;
}

/*add  for showting wtp eth port information table 12*/
DEFUN(show_all_wtp_eth_port_information_func,
	  show_all_wtp_eth_port_information_cmd,
	  "show the eth port information of all_wtp [remote] [local] [PARAMETER]",
	  SHOW_STR
	  "eth port information\n"
	  "eth port information\n"
	  "eth port information\n"
	  "Display eth port information of all wtps\n"
	  "List wtp eth port information\n"
	  "by wtp display eth port information\n"
	  "'remote' or 'local' hansi\n"
	  "'remote' or 'local' hansi\n"
	  "slotid-instid\n"
	 )
{
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	struct WtpEthPortInfo *WtpHead = NULL;
	struct WtpEthPortInfo *WtpShowNode = NULL;
	int ret=0;
	int i=0;
	int profile = 0;
	int instRun = 0;
	int flag = 0;
	unsigned int num = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	if((argc == 1)||(argc == 3)){
		vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
		return CMD_SUCCESS;
	}
	if(argc == 2){
		if (!strcmp(argv[0],"remote")){
			localid = 0;
		}else if(!strcmp(argv[0],"local")){
			localid = 1;
		}else{
			vty_out(vty,"parameter should be 'remote' or 'local'\n");
			return CMD_SUCCESS;
		}
		
		if((!strcmp(argv[0],"remote"))&&(!strcmp(argv[1],"local"))){
			vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
			return CMD_SUCCESS;
		}
		
		ret = parse_slot_hansi_id((char*)argv[1],&slot_id,&profile);
		if(ret != WID_DBUS_SUCCESS){
			slot_id = HostSlotId;
			flag = 1;
			ret = parse_int_ID((char*)argv[1], &profile);
			if(ret != WID_DBUS_SUCCESS){
				if(ret == WID_ILLEGAL_INPUT){
					vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
				}
				else{
					vty_out(vty,"<error> unknown id format\n");
				}
				return CMD_WARNING;
			}	
		}
		if(distributFag == 0){
			if(slot_id != 0){
				vty_out(vty,"<error> slot id should be 0\n");
				return CMD_WARNING;
			}	
		}else if(flag == 1){
			slot_id = HostSlotId;
		}
		if(slot_id >= MAX_SLOT_NUM || slot_id < 0){
			vty_out(vty,"<error> slot id should be 1 to %d\n",MAX_SLOT_NUM-1);
			return CMD_WARNING;
		}	
		if(profile >= MAX_INSTANCE || profile == 0){
			vty_out(vty,"<error> hansi id should be 1 to %d\n",MAX_INSTANCE-1);
			return CMD_WARNING;
		}
		instRun = dcli_hmd_hansi_is_running(vty,slot_id,localid,profile);
		if (INSTANCE_NO_CREATED == instRun) {
			vty_out(vty,"<error> the instance %s %d-%d is not running\n",((localid == 1)?"local-hansi":"hansi"),slot_id,profile);
			return CMD_WARNING;
		}
		
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		if(localid == 0)
			goto hansi_parameter;
		else if(localid == 1)
			goto local_hansi_parameter; 
	}

	if(vty->node != VIEW_NODE){
		WtpHead = show_WtpEthPortInfo_of_all_wtp(index,localid,dcli_dbus_connection, &num, &ret);

		if((WtpHead!=NULL)&&(ret == 0)){
			vty_out(vty,"WTPNum:%-5d  \n",num);
			vty_out(vty,"========================================================================== \n");
			for (i = 0; i < num; i++) {	
				if(WtpShowNode == NULL)
					WtpShowNode = WtpHead->WtpEthPortInfo_list;
				else 
					WtpShowNode = WtpShowNode->next;

				if(WtpShowNode == NULL)
					break;
				
				vty_out(vty,"WTPID:%-5d  \n",WtpShowNode->wtpCurrID);
				
				vty_out(vty,"WTP MAC:  %s ",WtpShowNode->wtpMacAddr);
				vty_out(vty,"%02X:%02X:%02X:%02X:%02X:%02X \t\t",
				WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
				WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);

				vty_out(vty,"wtpWirelessUpPortRate:%d  \n",WtpShowNode->wtpWirelessUpPortRate);
				vty_out(vty,"wtpWirelessDownPortRate:%d  \t\t\t",WtpShowNode->wtpWirelessDownPortRate);
				vty_out(vty,"wtpWirelessUpPortUDTimes:%d  \n",WtpShowNode->wtpWirelessUpPortUDTimes);
				vty_out(vty,"wtpWirelessDownPortUDTimes:%d  \t\t\t",WtpShowNode->wtpWirelessDownPortUDTimes);
				if(WtpShowNode->wtpUplinkDataThroughput <= 2)
				{
					WtpShowNode->wtpUplinkDataThroughput = 2;
				}
				if(WtpShowNode->wtpDownlinkDataThroughput <= 2)
				{
					WtpShowNode->wtpDownlinkDataThroughput = 2;
				}
				vty_out(vty,"wtpUplinkDataThroughput:%d  \n",WtpShowNode->wtpUplinkDataThroughput);
				vty_out(vty,"wtpDownlinkDataThroughput:%d  \t\t\t",WtpShowNode->wtpDownlinkDataThroughput);
				vty_out(vty,"wtpPhyInterMnt:%d  \n",WtpShowNode->wtpPhyInterMnt);
				
				
				vty_out(vty,"-------------------------------------------------------------------------\n");
				
			}
			
			vty_out(vty,"========================================================================== \n");
		
		}

		else if (ret == WID_DBUS_ERROR){
			cli_syslog_info("<error> failed get reply.\n");
		}
		else if(ret == WTP_ID_NOT_EXIST){
			vty_out(vty,"<error> There is no WTP now.\n");
		}
		else{
			vty_out(vty,"<error> ret = %d\n",ret);
		}

		dcli_free_WtpEthPortInfo(WtpHead);
	}
	
	if(vty->node == VIEW_NODE){
		//for remote hansi info
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 0;
			
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,0,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}

		hansi_parameter:
				WtpHead = show_WtpEthPortInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &num, &ret);

				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"hansi %d-%d\n",slot_id,profile);
				vty_out(vty,"-----------------------------------------------------------------------------\n");
				if((WtpHead!=NULL)&&(ret == 0)){
					vty_out(vty,"WTPNum:%-5d  \n",num);
					vty_out(vty,"========================================================================== \n");
					WtpShowNode = NULL;
					for (i = 0; i < num; i++) {	
						if(WtpShowNode == NULL)
							WtpShowNode = WtpHead->WtpEthPortInfo_list;
						else 
							WtpShowNode = WtpShowNode->next;

						if(WtpShowNode == NULL)
							break;
						
						vty_out(vty,"WTPID:%-5d  \n",WtpShowNode->wtpCurrID);
						
						vty_out(vty,"WTP MAC:  %s ",WtpShowNode->wtpMacAddr);
						vty_out(vty,"%02X:%02X:%02X:%02X:%02X:%02X \t\t",
						WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
						WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);

						vty_out(vty,"wtpWirelessUpPortRate:%d  \n",WtpShowNode->wtpWirelessUpPortRate);
						vty_out(vty,"wtpWirelessDownPortRate:%d  \t\t\t",WtpShowNode->wtpWirelessDownPortRate);
						vty_out(vty,"wtpWirelessUpPortUDTimes:%d  \n",WtpShowNode->wtpWirelessUpPortUDTimes);
						vty_out(vty,"wtpWirelessDownPortUDTimes:%d  \t\t\t",WtpShowNode->wtpWirelessDownPortUDTimes);
						if(WtpShowNode->wtpUplinkDataThroughput <= 2)
						{
							WtpShowNode->wtpUplinkDataThroughput = 2;
						}
						if(WtpShowNode->wtpDownlinkDataThroughput <= 2)
						{
							WtpShowNode->wtpDownlinkDataThroughput = 2;
						}
						vty_out(vty,"wtpUplinkDataThroughput:%d  \n",WtpShowNode->wtpUplinkDataThroughput);
						vty_out(vty,"wtpDownlinkDataThroughput:%d  \t\t\t",WtpShowNode->wtpDownlinkDataThroughput);
						vty_out(vty,"wtpPhyInterMnt:%d  \n",WtpShowNode->wtpPhyInterMnt);
						
						
						vty_out(vty,"-------------------------------------------------------------------------\n");
						
					}
				}

				else if (ret == WID_DBUS_ERROR){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == WTP_ID_NOT_EXIST){
					vty_out(vty,"<error> There is no WTP now.\n");
				}
				else{
					vty_out(vty,"<error> ret = %d\n",ret);
				}

				dcli_free_WtpEthPortInfo(WtpHead);
				vty_out(vty,"==============================================================================\n");
				if(argc == 2){
					return CMD_SUCCESS;
				}
			}
		}

	//for local hansi info
	for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		localid = 1;
		
		for (profile = 1; profile < MAX_INSTANCE; profile++) 
		{
			instRun = dcli_hmd_hansi_is_running(vty,slot_id,1,profile);
			if (INSTANCE_NO_CREATED == instRun) {
				continue;
			}
	
		local_hansi_parameter:
			WtpHead = show_WtpEthPortInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &num, &ret);

			vty_out(vty,"==============================================================================\n");
			vty_out(vty,"local hansi %d-%d\n",slot_id,profile);
			vty_out(vty,"-----------------------------------------------------------------------------\n");
			if((WtpHead!=NULL)&&(ret == 0)){
				vty_out(vty,"WTPNum:%-5d  \n",num);
				vty_out(vty,"========================================================================== \n");
				WtpShowNode = NULL;
				for (i = 0; i < num; i++) {	
					if(WtpShowNode == NULL)
						WtpShowNode = WtpHead->WtpEthPortInfo_list;
					else 
						WtpShowNode = WtpShowNode->next;

					if(WtpShowNode == NULL)
						break;
					
					vty_out(vty,"WTPID:%-5d  \n",WtpShowNode->wtpCurrID);
					
					vty_out(vty,"WTP MAC:  %s ",WtpShowNode->wtpMacAddr);
					vty_out(vty,"%02X:%02X:%02X:%02X:%02X:%02X \t\t",
					WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
					WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);

					vty_out(vty,"wtpWirelessUpPortRate:%d  \n",WtpShowNode->wtpWirelessUpPortRate);
					vty_out(vty,"wtpWirelessDownPortRate:%d  \t\t\t",WtpShowNode->wtpWirelessDownPortRate);
					vty_out(vty,"wtpWirelessUpPortUDTimes:%d  \n",WtpShowNode->wtpWirelessUpPortUDTimes);
					vty_out(vty,"wtpWirelessDownPortUDTimes:%d  \t\t\t",WtpShowNode->wtpWirelessDownPortUDTimes);
					if(WtpShowNode->wtpUplinkDataThroughput <= 2)
					{
						WtpShowNode->wtpUplinkDataThroughput = 2;
					}
					if(WtpShowNode->wtpDownlinkDataThroughput <= 2)
					{
						WtpShowNode->wtpDownlinkDataThroughput = 2;
					}
					vty_out(vty,"wtpUplinkDataThroughput:%d  \n",WtpShowNode->wtpUplinkDataThroughput);
					vty_out(vty,"wtpDownlinkDataThroughput:%d  \t\t\t",WtpShowNode->wtpDownlinkDataThroughput);
					vty_out(vty,"wtpPhyInterMnt:%d  \n",WtpShowNode->wtpPhyInterMnt);
					
					
					vty_out(vty,"-------------------------------------------------------------------------\n");
					
				}
				
				vty_out(vty,"========================================================================== \n");
			
			}

			else if (ret == WID_DBUS_ERROR){
				cli_syslog_info("<error> failed get reply.\n");
			}
			else if(ret == WTP_ID_NOT_EXIST){
				vty_out(vty,"<error> There is no WTP now.\n");
			}
			else{
				vty_out(vty,"<error> ret = %d\n",ret);
			}

			dcli_free_WtpEthPortInfo(WtpHead);
			vty_out(vty,"==============================================================================\n");
			if(argc == 2){
				return CMD_SUCCESS;
			}
			}
		}
	}
	
	return CMD_SUCCESS;
}
/*add for showing wtp radio stats information 20100520 nl table 13*/
DEFUN(show_all_wtp_radio_stats_information_func,
	  show_all_wtp_radio_stats_information_cmd,
	  "show the radio stats of all_wtp [remote] [local] [PARAMETER]",
	  SHOW_STR
	  "radio stats\n"
	  "radio stats\n"
	  "Display radio stats of all wtps\n"
	  "List wtp radio stats information\n"
	  "by wtp display radio stats information\n"
	  "'remote' or 'local' hansi\n"
	  "'remote' or 'local' hansi\n"
	  "slotid-instid\n"
	 )
{
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	struct RadioStatsInfo *WtpHead = NULL;
	struct RadioStatsInfo *WtpShowNode = NULL;
	int ret=0;
	int i=0;
	int j=0;
	int profile = 0;
	int instRun = 0;
	int flag = 0;
	unsigned int wtp_num = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	
	if((argc == 1)||(argc == 3)){
		vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
		return CMD_SUCCESS;
	}
	if(argc == 2){
		if (!strcmp(argv[0],"remote")){
			localid = 0;
		}else if(!strcmp(argv[0],"local")){
			localid = 1;
		}else{
			vty_out(vty,"parameter should be 'remote' or 'local'\n");
			return CMD_SUCCESS;
		}
		
		if((!strcmp(argv[0],"remote"))&&(!strcmp(argv[1],"local"))){
			vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
			return CMD_SUCCESS;
		}
		
		ret = parse_slot_hansi_id((char*)argv[1],&slot_id,&profile);
		if(ret != WID_DBUS_SUCCESS){
			slot_id = HostSlotId;
			flag = 1;
			ret = parse_int_ID((char*)argv[1], &profile);
			if(ret != WID_DBUS_SUCCESS){
				if(ret == WID_ILLEGAL_INPUT){
					vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
				}
				else{
					vty_out(vty,"<error> unknown id format\n");
				}
				return CMD_WARNING;
			}	
		}
		if(distributFag == 0){
			if(slot_id != 0){
				vty_out(vty,"<error> slot id should be 0\n");
				return CMD_WARNING;
			}	
		}else if(flag == 1){
			slot_id = HostSlotId;
		}
		if(slot_id >= MAX_SLOT_NUM || slot_id < 0){
			vty_out(vty,"<error> slot id should be 1 to %d\n",MAX_SLOT_NUM-1);
			return CMD_WARNING;
		}	
		if(profile >= MAX_INSTANCE || profile == 0){
			vty_out(vty,"<error> hansi id should be 1 to %d\n",MAX_INSTANCE-1);
			return CMD_WARNING;
		}
		instRun = dcli_hmd_hansi_is_running(vty,slot_id,localid,profile);
		if (INSTANCE_NO_CREATED == instRun) {
			vty_out(vty,"<error> the instance %s %d-%d is not running\n",((localid == 1)?"local-hansi":"hansi"),slot_id,profile);
			return CMD_WARNING;
		}
		
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		if(localid == 0)
			goto hansi_parameter;
		else if(localid == 1)
			goto local_hansi_parameter; 
	}

	if(vty->node != VIEW_NODE){
		WtpHead = show_RadioStatsInfo_of_all_wtp(index,localid,dcli_dbus_connection, &wtp_num, &ret);
		
#if 1
		if((WtpHead!=NULL)&&(ret == 0)){
			vty_out(vty,"WTPNum:%-5d  \n",wtp_num);
			vty_out(vty,"========================================================================== \n");
			for (i = 0; i < wtp_num; i++) {	
				if(WtpShowNode == NULL)
					WtpShowNode = WtpHead->RadioStatsInfo_list;
				else 
					WtpShowNode = WtpShowNode->next;

				if(WtpShowNode == NULL)
					break;

				vty_out(vty,"    ========================WTPInformation============================     \n");
				vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
				vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
				WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
				WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
				
				vty_out(vty,"wtp_radio_num:   %-5d  \t\t\t",WtpShowNode->wtp_radio_num);
				vty_out(vty,"wtpPowerManage:   %-5d  \n",WtpShowNode->wtpPowerManage);
				vty_out(vty,"wtpSampleTime:   %-5d  \t\t\t",WtpShowNode->wtpSampleTime);
				vty_out(vty,"\n");
				
				vty_out(vty,"asd_radio_num: %d\n",WtpShowNode->wtp_radio_num);
				vty_out(vty,"-------------------------------------------------------------------------\n");
				
				struct Sub_RadioStatsInfo *sub_radio = NULL;
				for(j=0;j<WtpShowNode->wtp_radio_num;j++){
					if(sub_radio == NULL)
						sub_radio = WtpShowNode->Sub_RadioStatsInfo_head;
					else 
						sub_radio = sub_radio->next;

					if(sub_radio == NULL){
						vty_out(vty,"break\n");
						break;
					}
					
					vty_out(vty,"------------------------radio information:------------------------------- \n");
					vty_out(vty,"wtpRadCurrID:  %-5d  \t\t\t\t",(sub_radio->wtpRadCurrID));
					vty_out(vty,"wtpRadLocalID:  %-5d  \n",sub_radio->wtpRadLocalID);
					vty_out(vty,"wtpCurSendPower:  %-5d  \t\t",sub_radio->wtpCurSendPower);
					vty_out(vty,"wtpRecvPower:  %-5d  \n",sub_radio->wtpRecvPower);

					vty_out(vty,"wtpCurConfChannel:  %-5d	\t",sub_radio->wtpCurConfChannel);
					vty_out(vty,"radio_type:  %-5d	\n",sub_radio->radio_type);
					vty_out(vty,"wtpTerminalConRate:  %-5d	\t",sub_radio->wtpTerminalConRate);
					vty_out(vty,"wtpconfigBeaconFrameBlank:  %-5d	\n",sub_radio->wtpconfigBeaconFrameBlank);
				}
			}
			vty_out(vty,"========================================================================== \n");
		}

		else if (ret == WID_DBUS_ERROR){
			cli_syslog_info("<error> failed get reply.\n");
		}
		else if(ret == WTP_ID_NOT_EXIST){
			vty_out(vty,"<error> There is no WTP now.\n");
		}
		else{
			vty_out(vty,"<error> ret = %d\n",ret);
		}
		dcli_free_wtp_RadioStatsInfo(WtpHead);
#endif
	}

	if(vty->node == VIEW_NODE){
		//for remote hansi info
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 0;
			
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,0,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}

		hansi_parameter:
				WtpHead = show_RadioStatsInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &wtp_num, &ret);
				
				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"hansi %d-%d\n",slot_id,profile);
				vty_out(vty,"-----------------------------------------------------------------------------\n");
				if((WtpHead!=NULL)&&(ret == 0)){
					vty_out(vty,"WTPNum:%-5d  \n",wtp_num);
					vty_out(vty,"========================================================================== \n");
					WtpShowNode = NULL;
					for (i = 0; i < wtp_num; i++) { 
						if(WtpShowNode == NULL)
							WtpShowNode = WtpHead->RadioStatsInfo_list;
						else 
							WtpShowNode = WtpShowNode->next;
			
						if(WtpShowNode == NULL)
							break;
			
						vty_out(vty,"	 ========================WTPInformation============================ 	\n");
						vty_out(vty,"WTPID:   %-5d	\t\t\t\t",WtpShowNode->wtpCurrID);
						vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
						WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
						WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
						
						vty_out(vty,"wtp_radio_num:   %-5d	\t\t\t",WtpShowNode->wtp_radio_num);
						vty_out(vty,"wtpPowerManage:   %-5d  \n",WtpShowNode->wtpPowerManage);
						vty_out(vty,"wtpSampleTime:   %-5d	\t\t\t",WtpShowNode->wtpSampleTime);
						vty_out(vty,"\n");
						
						vty_out(vty,"asd_radio_num: %d\n",WtpShowNode->wtp_radio_num);
						vty_out(vty,"-------------------------------------------------------------------------\n");
						
						struct Sub_RadioStatsInfo *sub_radio = NULL;
						for(j=0;j<WtpShowNode->wtp_radio_num;j++){
							if(sub_radio == NULL)
								sub_radio = WtpShowNode->Sub_RadioStatsInfo_head;
							else 
								sub_radio = sub_radio->next;
			
							if(sub_radio == NULL){
								vty_out(vty,"break\n");
								break;
							}
							
							vty_out(vty,"------------------------radio information:------------------------------- \n");
							vty_out(vty,"wtpRadCurrID:	%-5d  \t\t\t\t",(sub_radio->wtpRadCurrID));
							vty_out(vty,"wtpRadLocalID:  %-5d  \n",sub_radio->wtpRadLocalID);
							vty_out(vty,"wtpCurSendPower:  %-5d  \t\t",sub_radio->wtpCurSendPower);
							vty_out(vty,"wtpRecvPower:	%-5d  \n",sub_radio->wtpRecvPower);
			
							vty_out(vty,"wtpCurConfChannel:  %-5d	\t",sub_radio->wtpCurConfChannel);
							vty_out(vty,"radio_type:  %-5d	\n",sub_radio->radio_type);
							vty_out(vty,"wtpTerminalConRate:  %-5d	\t",sub_radio->wtpTerminalConRate);
							vty_out(vty,"wtpconfigBeaconFrameBlank:  %-5d	\n",sub_radio->wtpconfigBeaconFrameBlank);
						}
					}
				}
			
				else if (ret == WID_DBUS_ERROR){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == WTP_ID_NOT_EXIST){
					vty_out(vty,"<error> There is no WTP now.\n");
				}
				else{
					vty_out(vty,"<error> ret = %d\n",ret);
				}
				dcli_free_wtp_RadioStatsInfo(WtpHead);
				vty_out(vty,"==============================================================================\n");
				if(argc == 2){
					return CMD_SUCCESS;
				}
			}
		}

		//for local hansi info
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 1;
			
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,1,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}
		
			local_hansi_parameter:
				WtpHead = show_RadioStatsInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &wtp_num, &ret);
				
				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"local hansi %d-%d\n",slot_id,profile);
				vty_out(vty,"-----------------------------------------------------------------------------\n");
				if((WtpHead!=NULL)&&(ret == 0)){
					vty_out(vty,"WTPNum:%-5d  \n",wtp_num);
					vty_out(vty,"========================================================================== \n");
					WtpShowNode = NULL;
					for (i = 0; i < wtp_num; i++) { 
						if(WtpShowNode == NULL)
							WtpShowNode = WtpHead->RadioStatsInfo_list;
						else 
							WtpShowNode = WtpShowNode->next;
			
						if(WtpShowNode == NULL)
							break;
			
						vty_out(vty,"	 ========================WTPInformation============================ 	\n");
						vty_out(vty,"WTPID:   %-5d	\t\t\t\t",WtpShowNode->wtpCurrID);
						vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
						WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
						WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
						
						vty_out(vty,"wtp_radio_num:   %-5d	\t\t\t",WtpShowNode->wtp_radio_num);
						vty_out(vty,"wtpPowerManage:   %-5d  \n",WtpShowNode->wtpPowerManage);
						vty_out(vty,"wtpSampleTime:   %-5d	\t\t\t",WtpShowNode->wtpSampleTime);
						vty_out(vty,"\n");
						
						vty_out(vty,"asd_radio_num: %d\n",WtpShowNode->wtp_radio_num);
						vty_out(vty,"-------------------------------------------------------------------------\n");
						
						struct Sub_RadioStatsInfo *sub_radio = NULL;
						for(j=0;j<WtpShowNode->wtp_radio_num;j++){
							if(sub_radio == NULL)
								sub_radio = WtpShowNode->Sub_RadioStatsInfo_head;
							else 
								sub_radio = sub_radio->next;
			
							if(sub_radio == NULL){
								vty_out(vty,"break\n");
								break;
							}
							
							vty_out(vty,"------------------------radio information:------------------------------- \n");
							vty_out(vty,"wtpRadCurrID:	%-5d  \t\t\t\t",(sub_radio->wtpRadCurrID));
							vty_out(vty,"wtpRadLocalID:  %-5d  \n",sub_radio->wtpRadLocalID);
							vty_out(vty,"wtpCurSendPower:  %-5d  \t\t",sub_radio->wtpCurSendPower);
							vty_out(vty,"wtpRecvPower:	%-5d  \n",sub_radio->wtpRecvPower);
			
							vty_out(vty,"wtpCurConfChannel:  %-5d	\t",sub_radio->wtpCurConfChannel);
							vty_out(vty,"radio_type:  %-5d	\n",sub_radio->radio_type);
							vty_out(vty,"wtpTerminalConRate:  %-5d	\t",sub_radio->wtpTerminalConRate);
							vty_out(vty,"wtpconfigBeaconFrameBlank:  %-5d	\n",sub_radio->wtpconfigBeaconFrameBlank);
						}
					}
				}
			
				else if (ret == WID_DBUS_ERROR){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == WTP_ID_NOT_EXIST){
					vty_out(vty,"<error> There is no WTP now.\n");
				}
				else{
					vty_out(vty,"<error> ret = %d\n",ret);
				}
				dcli_free_wtp_RadioStatsInfo(WtpHead);
				vty_out(vty,"==============================================================================\n");
				if(argc == 2){
					return CMD_SUCCESS;
				}
				}
			}
		}
	
	return CMD_SUCCESS;
}
/*add for showing wtp radio config information 20100524 nl table 14*/
DEFUN(show_all_wtp_radio_config_information_func,
	  show_all_wtp_radio_config_information_cmd,
	  "show the radio config of all_wtp [remote] [local] [PARAMETER]",
	  SHOW_STR
	  "radio config\n"
	  "radio config\n"
	  "Display radio config information of all wtps\n"
	  "List wtp radio config information\n"
	  "by wtp display radio config information\n"
	  "'remote' or 'local' hansi\n"
	  "'remote' or 'local' hansi\n"
	  "slotid-instid\n"
	 )
{
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	struct WtpConfigRadioInfo *WtpHead = NULL;
	struct WtpConfigRadioInfo *WtpShowNode = NULL;
	int ret=0;
	int i=0;
	int j=0;
	int k=0;
	int profile = 0;
	int instRun = 0;
	int flag = 0;
	unsigned int wtp_num = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	
	if((argc == 1)||(argc == 3)){
		vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
		return CMD_SUCCESS;
	}
	if(argc == 2){
		if (!strcmp(argv[0],"remote")){
			localid = 0;
		}else if(!strcmp(argv[0],"local")){
			localid = 1;
		}else{
			vty_out(vty,"parameter should be 'remote' or 'local'\n");
			return CMD_SUCCESS;
		}
		
		if((!strcmp(argv[0],"remote"))&&(!strcmp(argv[1],"local"))){
			vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
			return CMD_SUCCESS;
		}
		
		ret = parse_slot_hansi_id((char*)argv[1],&slot_id,&profile);
		if(ret != WID_DBUS_SUCCESS){
			slot_id = HostSlotId;
			flag = 1;
			ret = parse_int_ID((char*)argv[1], &profile);
			if(ret != WID_DBUS_SUCCESS){
				if(ret == WID_ILLEGAL_INPUT){
					vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
				}
				else{
					vty_out(vty,"<error> unknown id format\n");
				}
				return CMD_WARNING;
			}	
		}
		if(distributFag == 0){
			if(slot_id != 0){
				vty_out(vty,"<error> slot id should be 0\n");
				return CMD_WARNING;
			}	
		}else if(flag == 1){
			slot_id = HostSlotId;
		}
		if(slot_id >= MAX_SLOT_NUM || slot_id < 0){
			vty_out(vty,"<error> slot id should be 1 to %d\n",MAX_SLOT_NUM-1);
			return CMD_WARNING;
		}	
		if(profile >= MAX_INSTANCE || profile == 0){
			vty_out(vty,"<error> hansi id should be 1 to %d\n",MAX_INSTANCE-1);
			return CMD_WARNING;
		}
		instRun = dcli_hmd_hansi_is_running(vty,slot_id,localid,profile);
		if (INSTANCE_NO_CREATED == instRun) {
			vty_out(vty,"<error> the instance %s %d-%d is not running\n",((localid == 1)?"local-hansi":"hansi"),slot_id,profile);
			return CMD_WARNING;
		}
		
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		if(localid == 0)
			goto hansi_parameter;
		else if(localid == 1)
			goto local_hansi_parameter; 
	}

	if(vty->node != VIEW_NODE){
		WtpHead = show_WtpConfigRadioInfo_of_all_wtp(index,localid,dcli_dbus_connection, &wtp_num, &ret);
		
		if((WtpHead!=NULL)&&(ret == 0)){
			vty_out(vty,"WTPNum:%-5d  \n",wtp_num);
			vty_out(vty,"==============================================================================\n");
			for (i = 0; i < wtp_num; i++) {	
				if(WtpShowNode == NULL)
					WtpShowNode = WtpHead->WtpConfigRadioInfo_list;
				else 
					WtpShowNode = WtpShowNode->next;

				if(WtpShowNode == NULL)
					break;

				vty_out(vty,"    ========================WTPInformation============================     \n");
				vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
				vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
				WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
				WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
				
				vty_out(vty,"wtp_radio_num:   %-5d  \t\t\t",WtpShowNode->wtp_radio_num);
				vty_out(vty,"\n");
				vty_out(vty,"-------------------------------------------------------------------------\n");
				
				struct Sub_WtpConfigRadioInfo *sub_radio = NULL;
				for(j=0;j<WtpShowNode->wtp_radio_num;j++){
					
					if(sub_radio == NULL)
						sub_radio = WtpShowNode->Sub_WtpConfigRadioInfo_head;
					else 
						sub_radio = sub_radio->next;

					if(sub_radio == NULL){
						vty_out(vty,"break\n");
						break;
					}
					
					vty_out(vty,"------------------------radio information:------------------------------- \n");
					vty_out(vty,"wtpRadCurrID:    %-5d  \t\t",(sub_radio->wtpRadCurrID));
					vty_out(vty,"wtpRadLocalID:     %-5d  \n",sub_radio->wtpRadLocalID);

					vty_out(vty,"radioType:       %-5d  \t\t",(sub_radio->radioType));
					vty_out(vty,"radioSpeed:        %-5d  \n",sub_radio->radioSpeed);
					
					vty_out(vty,"radioBeacon:     %-5d  \t\t",(sub_radio->radioBeacon));
					vty_out(vty,"radioBeaf:         %-5d  \n",sub_radio->radioBeaf);
					vty_out(vty,"radioDtim:       %-5d  \t\t",(sub_radio->radioDtim));
					vty_out(vty,"radioRTS:          %-5d  \n",sub_radio->radioRTS);

					vty_out(vty,"radioLeadCode:   %-5d  \t\t",(sub_radio->radioLeadCode));
					vty_out(vty,"radioShortRetry:   %-5d  \n",sub_radio->radioShortRetry);
					vty_out(vty,"radioLongRetry:  %-5d  \t\t",(sub_radio->radioLongRetry));
					vty_out(vty,"radioService:      %-5d  \n",sub_radio->radioService);

					vty_out(vty,"radioMaxSpeed:   %-5d  \t\t",(sub_radio->radioMaxSpeed));
					vty_out(vty,"radioMaxFlow:      %-5d  \n",sub_radio->radioMaxFlow);
					vty_out(vty,"radioBindQos:    %-5d  \t\t",(sub_radio->radioBindQos));
					vty_out(vty,"radioDelbindQos:   %-5d  \n",sub_radio->radioDelbindQos);
				
					vty_out(vty,"ampdu state:     %s\t\t\t",(sub_radio->AmpduAble == 1)?"enable":"disable");
					vty_out(vty,"amsdu state:       %s\n",(sub_radio->AmsduAble == 1)?"enable":"disable");
					vty_out(vty,"pureN Mixed:     %s\t\t\t",(sub_radio->Mixed_Greenfield == 1)?"pureN":"Mixed");
					vty_out(vty,"guard interval:    %s\n",(sub_radio->guardinterval == 1)?"400ns":"800ns");
					switch(sub_radio->cwmode)
					{
						case 0:
							vty_out(vty,"cwmode:	         ht20\n");
							break;
						case 1:
							vty_out(vty,"cwmode:	         ht20/40\n");
							break;
						case 2:
							vty_out(vty,"cwmode:	         ht40\n");
							break;
						default:	//error
							break;
					}
					vty_out(vty,"mcs: ");//qiuchen change
					for(i = 0; i < sub_radio->mcs_count; i ++){
						vty_out(vty," %d, ", sub_radio->mcs_list[i]);
					}
					vty_out(vty,"\n");

					vty_out(vty,"radioWlanNum:    %-5d  \n",sub_radio->radioWlanNum);
					for(k=0;k< sub_radio->radioWlanNum;k++){
						vty_out(vty,"Wlan:  %-5d  \n",sub_radio->radioBindWlan[k]);
					}
					
					vty_out(vty,"Radio Type:	 ");
					int flag_an = 0;int flag_gn = 0;
					if(sub_radio->Radio_Type != 0){				
						vty_out(vty,"11");			

						if(((sub_radio->Radio_Type&IEEE80211_11A) > 0)
							&&((sub_radio->Radio_Type&IEEE80211_11N) > 0)
							&&((sub_radio->Radio_Type&IEEE80211_11AN) > 0)
							&&(!(sub_radio->Radio_Type&IEEE80211_11B))
							&&(!(sub_radio->Radio_Type&IEEE80211_11G)))
						{
							vty_out(vty,"a/an");
						}				
						else if(((sub_radio->Radio_Type&IEEE80211_11GN) > 0)
							&&((sub_radio->Radio_Type&IEEE80211_11N)> 0)
							&&((sub_radio->Radio_Type&IEEE80211_11G)>0)
							&&(!(sub_radio->Radio_Type&IEEE80211_11B))
							&&(!(sub_radio->Radio_Type&IEEE80211_11A)))
						{	
							vty_out(vty,"g/gn");
						}	
						else
						{
							if((sub_radio->Radio_Type&IEEE80211_11A) > 0)
								vty_out(vty,"a");
							if((sub_radio->Radio_Type&IEEE80211_11B) > 0)
								vty_out(vty,"b");
							if((sub_radio->Radio_Type&IEEE80211_11G) > 0)
								vty_out(vty,"g");
							if((sub_radio->Radio_Type&IEEE80211_11N) > 0)
								vty_out(vty,"n");	
						}
						vty_out(vty, "\n");
					}
					
					vty_out(vty,"radio work role:		");
					if (sub_radio->radio_work_role == 1) {
						vty_out(vty, "clint\n");
					} else if (sub_radio->radio_work_role == 2) {
						vty_out(vty, "other\n");
					} else if (sub_radio->radio_work_role == 6) {
						vty_out(vty, "AP\n");
					} else if (sub_radio->radio_work_role == 9) {
						vty_out(vty, "MESH\n");
					} else {
						vty_out(vty, "unknown\n");
					}
					vty_out(vty, "radio channel use rate:		%d\n", sub_radio->radio_channel_use_rate);
					vty_out(vty, "radio channel change counter:	%d\n", sub_radio->radio_channel_change_counter);
					vty_out(vty, "radio channel width:		%d\n", sub_radio->radio_channel_width);
					vty_out(vty, "radio noise:			%d\n", sub_radio->radio_noise);
				}
			}
			vty_out(vty,"========================================================================== \n");
		}

		else if (ret == WID_DBUS_ERROR){
			vty_out(vty,"<error> failed get reply.\n");
		}
		else if(ret == WTP_ID_NOT_EXIST){
			vty_out(vty,"<error> There is no WTP now.\n");
		}
		else{
			vty_out(vty,"<error> ret = %d\n",ret);
		}

		dcli_free_WtpConfigRadioInfo(WtpHead);
	}

	if(vty->node == VIEW_NODE){
		//for remote hansi info
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 0;
			
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,0,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}

		hansi_parameter:
				WtpHead = show_WtpConfigRadioInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &wtp_num, &ret);
				
				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"hansi %d-%d\n",slot_id,profile);
				vty_out(vty,"-----------------------------------------------------------------------------\n");
				if((WtpHead!=NULL)&&(ret == 0)){
					vty_out(vty,"WTPNum:%-5d  \n",wtp_num);			
					vty_out(vty,"==============================================================================\n");
					WtpShowNode = NULL;
					for (i = 0; i < wtp_num; i++) {	
						if(WtpShowNode == NULL)
							WtpShowNode = WtpHead->WtpConfigRadioInfo_list;
						else 
							WtpShowNode = WtpShowNode->next;

						if(WtpShowNode == NULL)
							break;

						vty_out(vty,"    ========================WTPInformation============================     \n");
						vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
						vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
						WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
						WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
						
						vty_out(vty,"wtp_radio_num:   %-5d  \t\t\t",WtpShowNode->wtp_radio_num);
						vty_out(vty,"\n");
						vty_out(vty,"-------------------------------------------------------------------------\n");
						
						struct Sub_WtpConfigRadioInfo *sub_radio = NULL;
						for(j=0;j<WtpShowNode->wtp_radio_num;j++){
							
							if(sub_radio == NULL)
								sub_radio = WtpShowNode->Sub_WtpConfigRadioInfo_head;
							else 
								sub_radio = sub_radio->next;

							if(sub_radio == NULL){
								vty_out(vty,"break\n");
								break;
							}
							
							vty_out(vty,"------------------------radio information:------------------------------- \n");
							vty_out(vty,"wtpRadCurrID:    %-5d  \t\t",(sub_radio->wtpRadCurrID));
							vty_out(vty,"wtpRadLocalID:     %-5d  \n",sub_radio->wtpRadLocalID);

							vty_out(vty,"radioType:       %-5d  \t\t",(sub_radio->radioType));
							vty_out(vty,"radioSpeed:        %-5d  \n",sub_radio->radioSpeed);
							
							vty_out(vty,"radioBeacon:     %-5d  \t\t",(sub_radio->radioBeacon));
							vty_out(vty,"radioBeaf:         %-5d  \n",sub_radio->radioBeaf);
							vty_out(vty,"radioDtim:       %-5d  \t\t",(sub_radio->radioDtim));
							vty_out(vty,"radioRTS:          %-5d  \n",sub_radio->radioRTS);

							vty_out(vty,"radioLeadCode:   %-5d  \t\t",(sub_radio->radioLeadCode));
							vty_out(vty,"radioShortRetry:   %-5d  \n",sub_radio->radioShortRetry);
							vty_out(vty,"radioLongRetry:  %-5d  \t\t",(sub_radio->radioLongRetry));
							vty_out(vty,"radioService:      %-5d  \n",sub_radio->radioService);

							vty_out(vty,"radioMaxSpeed:   %-5d  \t\t",(sub_radio->radioMaxSpeed));
							vty_out(vty,"radioMaxFlow:      %-5d  \n",sub_radio->radioMaxFlow);
							vty_out(vty,"radioBindQos:    %-5d  \t\t",(sub_radio->radioBindQos));
							vty_out(vty,"radioDelbindQos:   %-5d  \n",sub_radio->radioDelbindQos);
			
							vty_out(vty,"ampdu state:     %s\t\t\t",(sub_radio->AmpduAble == 1)?"enable":"disable");
							vty_out(vty,"amsdu state:       %s\n",(sub_radio->AmsduAble == 1)?"enable":"disable");
							vty_out(vty,"pureN Mixed:     %s\t\t\t",(sub_radio->Mixed_Greenfield == 1)?"pureN":"Mixed");
							vty_out(vty,"guard interval:    %s\n",(sub_radio->guardinterval == 1)?"400ns":"800ns");
							switch(sub_radio->cwmode)
							{
								case 0:
									vty_out(vty,"cwmode:	         ht20\n");
									break;
								case 1:
									vty_out(vty,"cwmode:	         ht20/40\n");
									break;
								case 2:
									vty_out(vty,"cwmode:	         ht40\n");
									break;
								default:	//error
									break;
							}
							vty_out(vty,"mcs: ");//qiuchen change
							for(i = 0; i < sub_radio->mcs_count; i ++){
								vty_out(vty,"%d, ", sub_radio->mcs_list[i]);
							}
							vty_out(vty,"\n");
							
							vty_out(vty,"radioWlanNum:    %-5d  \n",sub_radio->radioWlanNum);
							for(k=0;k< sub_radio->radioWlanNum;k++){
								vty_out(vty,"Wlan:  %-5d  \n",sub_radio->radioBindWlan[k]);
							}

							vty_out(vty,"Radio Type:	 ");
							int flag_an = 0;int flag_gn = 0;
							if(sub_radio->Radio_Type != 0){				
								vty_out(vty,"11");			

								if(((sub_radio->Radio_Type&IEEE80211_11A) > 0)
									&&((sub_radio->Radio_Type&IEEE80211_11N) > 0)
									&&((sub_radio->Radio_Type&IEEE80211_11AN) > 0)
									&&(!(sub_radio->Radio_Type&IEEE80211_11B))
									&&(!(sub_radio->Radio_Type&IEEE80211_11G)))
								{
									vty_out(vty,"a/an");
								}				
								else if(((sub_radio->Radio_Type&IEEE80211_11GN) > 0)
									&&((sub_radio->Radio_Type&IEEE80211_11N)> 0)
									&&((sub_radio->Radio_Type&IEEE80211_11G)>0)
									&&(!(sub_radio->Radio_Type&IEEE80211_11B))
									&&(!(sub_radio->Radio_Type&IEEE80211_11A)))
								{	
									vty_out(vty,"g/gn");
								}	
								else
								{
									if((sub_radio->Radio_Type&IEEE80211_11A) > 0)
										vty_out(vty,"a");
									if((sub_radio->Radio_Type&IEEE80211_11B) > 0)
										vty_out(vty,"b");
									if((sub_radio->Radio_Type&IEEE80211_11G) > 0)
										vty_out(vty,"g");
									if((sub_radio->Radio_Type&IEEE80211_11N) > 0)
										vty_out(vty,"n");	
								}
								vty_out(vty, "\n");
							}
						}
					}
				}

				else if (ret == WID_DBUS_ERROR){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == WTP_ID_NOT_EXIST){
					vty_out(vty,"<error> There is no WTP now.\n");
				}
				else{
					vty_out(vty,"<error> ret = %d\n",ret);
				}

				dcli_free_WtpConfigRadioInfo(WtpHead);
				vty_out(vty,"==============================================================================\n");
				if(argc == 2){
					return CMD_SUCCESS;
				}
			}
		}
		
		//for local hansi info
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 1;
			
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,1,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}
		
			local_hansi_parameter:
			WtpHead = show_WtpConfigRadioInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &wtp_num, &ret);
			
			vty_out(vty,"==============================================================================\n");
			vty_out(vty,"local hansi %d-%d\n",slot_id,profile);
			vty_out(vty,"-----------------------------------------------------------------------------\n");
			if((WtpHead!=NULL)&&(ret == 0)){
				vty_out(vty,"WTPNum:%-5d  \n",wtp_num);
				vty_out(vty,"==============================================================================\n");
				WtpShowNode = NULL;
				for (i = 0; i < wtp_num; i++) {	
					if(WtpShowNode == NULL)
						WtpShowNode = WtpHead->WtpConfigRadioInfo_list;
					else 
						WtpShowNode = WtpShowNode->next;

					if(WtpShowNode == NULL)
						break;

					vty_out(vty,"    ========================WTPInformation============================     \n");
					vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
					vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
					WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
					WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
					
					vty_out(vty,"wtp_radio_num:   %-5d  \t\t\t",WtpShowNode->wtp_radio_num);
					vty_out(vty,"\n");
					vty_out(vty,"-------------------------------------------------------------------------\n");
					
					struct Sub_WtpConfigRadioInfo *sub_radio = NULL;
					for(j=0;j<WtpShowNode->wtp_radio_num;j++){
						
						if(sub_radio == NULL)
							sub_radio = WtpShowNode->Sub_WtpConfigRadioInfo_head;
						else 
							sub_radio = sub_radio->next;

						if(sub_radio == NULL){
							vty_out(vty,"break\n");
							break;
						}
						
						vty_out(vty,"------------------------radio information:------------------------------- \n");
						vty_out(vty,"wtpRadCurrID:    %-5d  \t\t",(sub_radio->wtpRadCurrID));
						vty_out(vty,"wtpRadLocalID:     %-5d  \n",sub_radio->wtpRadLocalID);

						vty_out(vty,"radioType:       %-5d  \t\t",(sub_radio->radioType));
						vty_out(vty,"radioSpeed:        %-5d  \n",sub_radio->radioSpeed);
						
						vty_out(vty,"radioBeacon:     %-5d  \t\t",(sub_radio->radioBeacon));
						vty_out(vty,"radioBeaf:         %-5d  \n",sub_radio->radioBeaf);
						vty_out(vty,"radioDtim:       %-5d  \t\t",(sub_radio->radioDtim));
						vty_out(vty,"radioRTS:          %-5d  \n",sub_radio->radioRTS);

						vty_out(vty,"radioLeadCode:   %-5d  \t\t",(sub_radio->radioLeadCode));
						vty_out(vty,"radioShortRetry:   %-5d  \n",sub_radio->radioShortRetry);
						vty_out(vty,"radioLongRetry:  %-5d  \t\t",(sub_radio->radioLongRetry));
						vty_out(vty,"radioService:      %-5d  \n",sub_radio->radioService);

						vty_out(vty,"radioMaxSpeed:   %-5d  \t\t",(sub_radio->radioMaxSpeed));
						vty_out(vty,"radioMaxFlow:      %-5d  \n",sub_radio->radioMaxFlow);
						vty_out(vty,"radioBindQos:    %-5d  \t\t",(sub_radio->radioBindQos));
						vty_out(vty,"radioDelbindQos:   %-5d  \n",sub_radio->radioDelbindQos);
		
						vty_out(vty,"ampdu state:     %s\t\t\t",(sub_radio->AmpduAble == 1)?"enable":"disable");
						vty_out(vty,"amsdu state:       %s\n",(sub_radio->AmsduAble == 1)?"enable":"disable");
						vty_out(vty,"pureN Mixed:     %s\t\t\t",(sub_radio->Mixed_Greenfield == 1)?"pureN":"Mixed");
						vty_out(vty,"guard interval:    %s\n",(sub_radio->guardinterval == 1)?"400ns":"800ns");						
						switch(sub_radio->cwmode)
						{
							case 0:
								vty_out(vty,"cwmode:	         ht20\n");
								break;
							case 1:
								vty_out(vty,"cwmode:	         ht20/40\n");
								break;
							case 2:
								vty_out(vty,"cwmode:	         ht40\n");
								break;
							default:	//error
								break;
						}
						vty_out(vty,"mcs: ");//qiuchen change
						for(i = 0; i < sub_radio->mcs_count; i ++){
							vty_out(vty,"%d, ", sub_radio->mcs_list[i]);
						}
						vty_out(vty,"\n");
					
						vty_out(vty,"radioWlanNum:  %-5d  \n",sub_radio->radioWlanNum);
						for(k=0;k< sub_radio->radioWlanNum;k++){
							vty_out(vty,"Wlan:  %-5d  \n",sub_radio->radioBindWlan[k]);
						}

						vty_out(vty,"Radio Type:	 ");
						int flag_an = 0;int flag_gn = 0;
						if(sub_radio->Radio_Type != 0){				
							vty_out(vty,"11");			

							if(((sub_radio->Radio_Type&IEEE80211_11A) > 0)
								&&((sub_radio->Radio_Type&IEEE80211_11N) > 0)
								&&((sub_radio->Radio_Type&IEEE80211_11AN) > 0)
								&&(!(sub_radio->Radio_Type&IEEE80211_11B))
								&&(!(sub_radio->Radio_Type&IEEE80211_11G)))
							{
								vty_out(vty,"a/an");
							}				
							else if(((sub_radio->Radio_Type&IEEE80211_11GN) > 0)
								&&((sub_radio->Radio_Type&IEEE80211_11N)> 0)
								&&((sub_radio->Radio_Type&IEEE80211_11G)>0)
								&&(!(sub_radio->Radio_Type&IEEE80211_11B))
								&&(!(sub_radio->Radio_Type&IEEE80211_11A)))
							{	
								vty_out(vty,"g/gn");
							}	
							else
							{
								if((sub_radio->Radio_Type&IEEE80211_11A) > 0)
									vty_out(vty,"a");
								if((sub_radio->Radio_Type&IEEE80211_11B) > 0)
									vty_out(vty,"b");
								if((sub_radio->Radio_Type&IEEE80211_11G) > 0)
									vty_out(vty,"g");
								if((sub_radio->Radio_Type&IEEE80211_11N) > 0)
									vty_out(vty,"n");	
							}
							vty_out(vty, "\n");
						}
					}
				}
			}

			else if (ret == WID_DBUS_ERROR){
				cli_syslog_info("<error> failed get reply.\n");
			}
			else if(ret == WTP_ID_NOT_EXIST){
				vty_out(vty,"<error> There is no WTP now.\n");
			}
			else{
				vty_out(vty,"<error> ret = %d\n",ret);
			}

			dcli_free_WtpConfigRadioInfo(WtpHead);
			vty_out(vty,"==============================================================================\n");
			if(argc == 2){
				return CMD_SUCCESS;
			}
			}
		}
	}
	return CMD_SUCCESS;
}

/*add  for showting wtp user link information table 15*/
DEFUN(show_all_wtp_user_link_information_func,
	  show_all_wtp_user_link_information_cmd,
	  "show the user link information of all_wtp [remote] [local] [PARAMETER]",
	  SHOW_STR
	  "user link information\n"
	  "user link information\n"
	  "Display user link information of all wtps\n"
	  "List wtp user link information\n"
	  "List wtp user link information\n"
	  "by wtp display user link information\n"
	  "'remote' or 'local' hansi\n"
	  "'remote' or 'local' hansi\n"
	  "slotid-instid\n"
	 )
{
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	struct UsrLinkInfo *WtpHead = NULL;
	struct UsrLinkInfo *WtpShowNode = NULL;
	int ret=0;
	int i=0;
	unsigned int num = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	int profile = 0;
	int instRun = 0;
	int flag = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	if((argc == 1)||(argc == 3)){
		vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
		return CMD_SUCCESS;
	}
	if(argc == 2){
		if (!strcmp(argv[0],"remote")){
			localid = 0;
		}else if(!strcmp(argv[0],"local")){
			localid = 1;
		}else{
			vty_out(vty,"parameter should be 'remote' or 'local'\n");
			return CMD_SUCCESS;
		}
		
		if((!strcmp(argv[0],"remote"))&&(!strcmp(argv[1],"local"))){
			vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
			return CMD_SUCCESS;
		}
		
		ret = parse_slot_hansi_id((char*)argv[1],&slot_id,&profile);
		if(ret != WID_DBUS_SUCCESS){
			slot_id = HostSlotId;
			flag = 1;
			ret = parse_int_ID((char*)argv[1], &profile);
			if(ret != WID_DBUS_SUCCESS){
				if(ret == WID_ILLEGAL_INPUT){
					vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
				}
				else{
					vty_out(vty,"<error> unknown id format\n");
				}
				return CMD_WARNING;
			}	
		}
		if(distributFag == 0){
			if(slot_id != 0){
				vty_out(vty,"<error> slot id should be 0\n");
				return CMD_WARNING;
			}	
		}else if(flag == 1){
			slot_id = HostSlotId;
		}
		if(slot_id >= MAX_SLOT_NUM || slot_id < 0){
			vty_out(vty,"<error> slot id should be 1 to %d\n",MAX_SLOT_NUM-1);
			return CMD_WARNING;
		}	
		if(profile >= MAX_INSTANCE || profile == 0){
			vty_out(vty,"<error> hansi id should be 1 to %d\n",MAX_INSTANCE-1);
			return CMD_WARNING;
		}
		instRun = dcli_hmd_hansi_is_running(vty,slot_id,localid,profile);
		if (INSTANCE_NO_CREATED == instRun) {
			vty_out(vty,"<error> the instance %s %d-%d is not running\n",((localid == 1)?"local-hansi":"hansi"),slot_id,profile);
			return CMD_WARNING;
		}
		
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		if(localid == 0)
			goto hansi_parameter;
		else if(localid == 1)
			goto local_hansi_parameter; 
	}
	
	if(vty->node != VIEW_NODE){
		WtpHead = show_UsrLinkInfo_of_all_wtp(index,localid,dcli_dbus_connection, &num, &ret);

		if((WtpHead!=NULL)&&(ret == 0)){
			vty_out(vty,"WTPNum:%-5d  \n",num);
			vty_out(vty,"========================================================================== \n");
			for (i = 0; i < num; i++) {	
				if(WtpShowNode == NULL)
					WtpShowNode = WtpHead->UsrLinkInfo_list;
				else 
					WtpShowNode = WtpShowNode->next;

				if(WtpShowNode == NULL)
					break;
				
				vty_out(vty,"WTPID:%-5d  \n",WtpShowNode->wtpCurrID);
				
				vty_out(vty,"WTP MAC:  %s ",WtpShowNode->wtpMacAddr);
				vty_out(vty,"%02X:%02X:%02X:%02X:%02X:%02X \t\t",
				WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
				WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);

				vty_out(vty,"wtpReasonInvalidFailLinkTimes:%d  \n",WtpShowNode->wtpReasonInvalidFailLinkTimes);
				vty_out(vty,"wtpReasonTimeOutFailLinkTimes:%d  \t\t\t",WtpShowNode->wtpReasonTimeOutFailLinkTimes);
				vty_out(vty,"wtpReasonRefuseFailLinkTimes:%d  \n",WtpShowNode->wtpReasonRefuseFailLinkTimes);
				vty_out(vty,"wtpReasonOthersFailLinkTimes:%d  \t\t\t",WtpShowNode->wtpReasonOthersFailLinkTimes);

				vty_out(vty,"wtpSolutionLinksVerifyLinkTimes:%d  \n",WtpShowNode->wtpSolutionLinksVerifyLinkTimes);
				vty_out(vty,"wtpReasonUsrLeaveVerfiyLinkTimes:%d  \t\t\t",WtpShowNode->wtpReasonUsrLeaveVerfiyLinkTimes);
				vty_out(vty,"wtpReasonLackAbilityVerifyLinkTimes:%d  \n",WtpShowNode->wtpReasonLackAbilityVerifyLinkTimes);
				vty_out(vty,"wtpReasonExceptionVerifyLinkTimes:%d  \t\t\t",WtpShowNode->wtpReasonExceptionVerifyLinkTimes);
				
				vty_out(vty,"wtpReasonOtherVerfyLinkTimes:%d  \n",WtpShowNode->wtpReasonOtherVerfyLinkTimes);
				vty_out(vty,"wtpStaOnlineTime:%d  \t\t\t",WtpShowNode->wtpStaOnlineTime);
				vty_out(vty,"wtpStaNewTotalOnlineTime:%lld  \n",WtpShowNode->wtpStaNewTotalOnlineTime);
				
				vty_out(vty,"-------------------------------------------------------------------------\n");
				
			}
			
			vty_out(vty,"========================================================================== \n");
		
		}

		else if (ret == ASD_DBUS_ERROR){
			cli_syslog_info("<error> failed get reply.\n");
		}
		else if(ret == ASD_WTP_NOT_EXIST){
			vty_out(vty,"<error> There is no WTP now.\n");
		}
		else{
			vty_out(vty,"<error> ret = %d\n",ret);
		}

		dcli_free_UsrLinkInfo(WtpHead);
	}


	if(vty->node == VIEW_NODE){
		//for remote hansi info
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 0;
			
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,0,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}

		hansi_parameter:
				WtpHead = show_UsrLinkInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &num, &ret);

				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"hansi %d-%d\n",slot_id,profile);
				vty_out(vty,"-----------------------------------------------------------------------------\n");
				if((WtpHead!=NULL)&&(ret == 0)){
					vty_out(vty,"WTPNum:%-5d  \n",num);
					vty_out(vty,"========================================================================== \n");
					WtpShowNode = NULL;
					for (i = 0; i < num; i++) {	
						if(WtpShowNode == NULL)
							WtpShowNode = WtpHead->UsrLinkInfo_list;
						else 
							WtpShowNode = WtpShowNode->next;

						if(WtpShowNode == NULL)
							break;
						
						vty_out(vty,"WTPID:%-5d  \n",WtpShowNode->wtpCurrID);
						
						vty_out(vty,"WTP MAC:  %s ",WtpShowNode->wtpMacAddr);
						vty_out(vty,"%02X:%02X:%02X:%02X:%02X:%02X \t\t",
						WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
						WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);

						vty_out(vty,"wtpReasonInvalidFailLinkTimes:%d  \n",WtpShowNode->wtpReasonInvalidFailLinkTimes);
						vty_out(vty,"wtpReasonTimeOutFailLinkTimes:%d  \t\t\t",WtpShowNode->wtpReasonTimeOutFailLinkTimes);
						vty_out(vty,"wtpReasonRefuseFailLinkTimes:%d  \n",WtpShowNode->wtpReasonRefuseFailLinkTimes);
						vty_out(vty,"wtpReasonOthersFailLinkTimes:%d  \t\t\t",WtpShowNode->wtpReasonOthersFailLinkTimes);

						vty_out(vty,"wtpSolutionLinksVerifyLinkTimes:%d  \n",WtpShowNode->wtpSolutionLinksVerifyLinkTimes);
						vty_out(vty,"wtpReasonUsrLeaveVerfiyLinkTimes:%d  \t\t\t",WtpShowNode->wtpReasonUsrLeaveVerfiyLinkTimes);
						vty_out(vty,"wtpReasonLackAbilityVerifyLinkTimes:%d  \n",WtpShowNode->wtpReasonLackAbilityVerifyLinkTimes);
						vty_out(vty,"wtpReasonExceptionVerifyLinkTimes:%d  \t\t\t",WtpShowNode->wtpReasonExceptionVerifyLinkTimes);
						
						vty_out(vty,"wtpReasonOtherVerfyLinkTimes:%d  \n",WtpShowNode->wtpReasonOtherVerfyLinkTimes);
						vty_out(vty,"wtpStaOnlineTime:%d  \t\t\t",WtpShowNode->wtpStaOnlineTime);
						vty_out(vty,"wtpStaNewTotalOnlineTime:%lld  \n",WtpShowNode->wtpStaNewTotalOnlineTime);
						
						vty_out(vty,"-------------------------------------------------------------------------\n");
						
					}
				}

				else if (ret == ASD_DBUS_ERROR){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == ASD_WTP_NOT_EXIST){
					vty_out(vty,"<error> There is no WTP now.\n");
				}
				else{
					vty_out(vty,"<error> ret = %d\n",ret);
				}

				dcli_free_UsrLinkInfo(WtpHead);
				vty_out(vty,"==============================================================================\n");
				if(argc == 2){
					return CMD_SUCCESS;
				}
			}
		}

	//for local hansi info
	for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		localid = 1;
		
		for (profile = 1; profile < MAX_INSTANCE; profile++) 
		{
			instRun = dcli_hmd_hansi_is_running(vty,slot_id,1,profile);
			if (INSTANCE_NO_CREATED == instRun) {
				continue;
			}
	
		local_hansi_parameter:
			WtpHead = show_UsrLinkInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &num, &ret);

			vty_out(vty,"==============================================================================\n");
			vty_out(vty,"local hansi %d-%d\n",slot_id,profile);
			vty_out(vty,"-----------------------------------------------------------------------------\n");
			if((WtpHead!=NULL)&&(ret == 0)){
				vty_out(vty,"WTPNum:%-5d  \n",num);
				vty_out(vty,"========================================================================== \n");
				WtpShowNode = NULL;
				for (i = 0; i < num; i++) {	
					if(WtpShowNode == NULL)
						WtpShowNode = WtpHead->UsrLinkInfo_list;
					else 
						WtpShowNode = WtpShowNode->next;

					if(WtpShowNode == NULL)
						break;
					
					vty_out(vty,"WTPID:%-5d  \n",WtpShowNode->wtpCurrID);
					
					vty_out(vty,"WTP MAC:  %s ",WtpShowNode->wtpMacAddr);
					vty_out(vty,"%02X:%02X:%02X:%02X:%02X:%02X \t\t",
					WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
					WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);

					vty_out(vty,"wtpReasonInvalidFailLinkTimes:%d  \n",WtpShowNode->wtpReasonInvalidFailLinkTimes);
					vty_out(vty,"wtpReasonTimeOutFailLinkTimes:%d  \t\t\t",WtpShowNode->wtpReasonTimeOutFailLinkTimes);
					vty_out(vty,"wtpReasonRefuseFailLinkTimes:%d  \n",WtpShowNode->wtpReasonRefuseFailLinkTimes);
					vty_out(vty,"wtpReasonOthersFailLinkTimes:%d  \t\t\t",WtpShowNode->wtpReasonOthersFailLinkTimes);

					vty_out(vty,"wtpSolutionLinksVerifyLinkTimes:%d  \n",WtpShowNode->wtpSolutionLinksVerifyLinkTimes);
					vty_out(vty,"wtpReasonUsrLeaveVerfiyLinkTimes:%d  \t\t\t",WtpShowNode->wtpReasonUsrLeaveVerfiyLinkTimes);
					vty_out(vty,"wtpReasonLackAbilityVerifyLinkTimes:%d  \n",WtpShowNode->wtpReasonLackAbilityVerifyLinkTimes);
					vty_out(vty,"wtpReasonExceptionVerifyLinkTimes:%d  \t\t\t",WtpShowNode->wtpReasonExceptionVerifyLinkTimes);
					
					vty_out(vty,"wtpReasonOtherVerfyLinkTimes:%d  \n",WtpShowNode->wtpReasonOtherVerfyLinkTimes);
					vty_out(vty,"wtpStaOnlineTime:%d  \t\t\t",WtpShowNode->wtpStaOnlineTime);
					vty_out(vty,"wtpStaNewTotalOnlineTime:%lld  \n",WtpShowNode->wtpStaNewTotalOnlineTime);
					
					vty_out(vty,"-------------------------------------------------------------------------\n");
					
				}
			}

			else if (ret == ASD_DBUS_ERROR){
				cli_syslog_info("<error> failed get reply.\n");
			}
			else if(ret == ASD_WTP_NOT_EXIST){
				vty_out(vty,"<error> There is no WTP now.\n");
			}
			else{
				vty_out(vty,"<error> ret = %d\n",ret);
			}

			dcli_free_UsrLinkInfo(WtpHead);
			vty_out(vty,"==============================================================================\n");
			if(argc == 2){
				return CMD_SUCCESS;
			}
			}
		}
	}

	return CMD_SUCCESS;
}

/*add for showing wtp Wired IfStats information by nl 20100526 table 16*/
DEFUN(show_all_wtp_wired_ifstats_information_func,
	  show_all_wtp_wired_ifstats_information_cmd,
	  "show the wired_ifstats information_of all_wtp [remote] [local] [PARAMETER]",
	  SHOW_STR
	  "wired_ifstats information\n"
	  "Display  wired ifstats information of all wtps\n"
	  "List wtp wired ifstats information\n"
	  "by wtp display  wired ifstats information\n"
	  "'remote' or 'local' hansi\n"
	  "'remote' or 'local' hansi\n"
	  "slotid-instid\n"
	 )
{
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	struct WtpWiredIfStatsInfo *WtpHead = NULL;
	struct WtpWiredIfStatsInfo *WtpShowNode = NULL;
	struct WiredIfStatsInfo *EthNode = NULL;
	int ret=0;
	int i=0;
	int j=0;
	int profile = 0;
	int instRun = 0;
	int flag = 0;
	unsigned int num = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	if((argc == 1)||(argc == 3)){
		vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
		return CMD_SUCCESS;
	}
	if(argc == 2){
		if (!strcmp(argv[0],"remote")){
			localid = 0;
		}else if(!strcmp(argv[0],"local")){
			localid = 1;
		}else{
			vty_out(vty,"parameter should be 'remote' or 'local'\n");
			return CMD_SUCCESS;
		}
		
		if((!strcmp(argv[0],"remote"))&&(!strcmp(argv[1],"local"))){
			vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
			return CMD_SUCCESS;
		}
		
		ret = parse_slot_hansi_id((char*)argv[1],&slot_id,&profile);
		if(ret != WID_DBUS_SUCCESS){
			slot_id = HostSlotId;
			flag = 1;
			ret = parse_int_ID((char*)argv[1], &profile);
			if(ret != WID_DBUS_SUCCESS){
				if(ret == WID_ILLEGAL_INPUT){
					vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
				}
				else{
					vty_out(vty,"<error> unknown id format\n");
				}
				return CMD_WARNING;
			}	
		}
		if(distributFag == 0){
			if(slot_id != 0){
				vty_out(vty,"<error> slot id should be 0\n");
				return CMD_WARNING;
			}	
		}else if(flag == 1){
			slot_id = HostSlotId;
		}
		if(slot_id >= MAX_SLOT_NUM || slot_id < 0){
			vty_out(vty,"<error> slot id should be 1 to %d\n",MAX_SLOT_NUM-1);
			return CMD_WARNING;
		}	
		if(profile >= MAX_INSTANCE || profile == 0){
			vty_out(vty,"<error> hansi id should be 1 to %d\n",MAX_INSTANCE-1);
			return CMD_WARNING;
		}
		instRun = dcli_hmd_hansi_is_running(vty,slot_id,localid,profile);
		if (INSTANCE_NO_CREATED == instRun) {
			vty_out(vty,"<error> the instance %s %d-%d is not running\n",((localid == 1)?"local-hansi":"hansi"),slot_id,profile);
			return CMD_WARNING;
		}
		
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		if(localid == 0)
			goto hansi_parameter;
		else if(localid == 1)
			goto local_hansi_parameter; 
	}
	
	if(vty->node != VIEW_NODE){
		WtpHead = show_WtpWiredIfStatsInfo_of_all_wtp(index,localid,dcli_dbus_connection, &num, &ret);

		if((WtpHead!=NULL)&&(ret == 0)){
			vty_out(vty,"WTPNum:%-5d  \n",num);
			vty_out(vty,"========================================================================== \n");
			for (i = 0; i < num; i++) {	
				if(WtpShowNode == NULL)
					WtpShowNode = WtpHead->WtpWiredIfStatsInfo_list;
				else 
					WtpShowNode = WtpShowNode->next;

				if(WtpShowNode == NULL)
					break;
				
				vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
				
				vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
				WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
				WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);

				vty_out(vty,"wtpWireIfNum:%d  \n",WtpShowNode->wtpWireIfNum);

				EthNode = WtpShowNode->EthInfo;
				
				for(j=0;j<WtpShowNode->wtpWireIfNum;j++){
				    if(EthNode == NULL) 
				        break;
				    
	 				vty_out(vty,"\nwtpIfIndex:%d  \n",EthNode->wtpIfIndex);
	 				vty_out(vty,"wtpWiredififUpDwnTimes:%d  \n",EthNode->wtpWiredififUpDwnTimes);

	 				vty_out(vty,"wtpWiredifInUcastPkts:%u  \n",EthNode->wtpWiredifInUcastPkts);
	    			vty_out(vty,"wtpWiredififInNUcastPkts:%u  \t\t\t",EthNode->wtpWiredififInNUcastPkts);
	    			vty_out(vty,"wtpWiredififInPkts:%u  \n",EthNode->wtpWiredififInPkts);
	    			vty_out(vty,"wtpWiredififInDiscardPkts:%u  \t\t\t",EthNode->wtpWiredififInDiscardPkts);		//a4

	    			vty_out(vty,"wtpWiredififInErrors:%u  \n",EthNode->wtpWiredififInErrors);
	    			vty_out(vty,"wtpWiredififOutUcastPkts:%u  \t\t\t",EthNode->wtpWiredififOutUcastPkts);
	    			vty_out(vty,"wtpWiredififOutNUcastPkts:%u  \n",EthNode->wtpWiredififOutNUcastPkts);
	    			vty_out(vty,"wtpWiredififOutPkts:%u  \t\t\t",EthNode->wtpWiredififOutPkts);					//a8

	    			vty_out(vty,"wtpWiredififOutDiscardPkts:%u  \n",EthNode->wtpWiredififOutDiscardPkts);
	    			vty_out(vty,"wtpWiredififOutErrors:%u  \t\t\t",EthNode->wtpWiredififOutErrors);
	    			vty_out(vty,"wtpWiredififInDataOctets:%llu  \n",EthNode->wtpWiredififInOctets);
	    			vty_out(vty,"wtpWiredififOutDataOctets:%llu  \t\t\t",EthNode->wtpWiredififOutOctets);				//a12
	    			
	    			vty_out(vty,"rx_sum_bytes:%llu  \n",EthNode->rx_sum_bytes);
	    			vty_out(vty,"tx_sum_bytes:%llu  \n",EthNode->tx_sum_bytes);				//a14
	    			
	    			vty_out(vty,"wtpWiredifInBcastPkts:%u  \t\t\t",EthNode->wtpWiredifInBcastPkts);
					vty_out(vty,"wtpWiredifOutBcastPkts:%u  \n",EthNode->wtpWiredifOutBcastPkts);

	    			EthNode = EthNode->next;
				}
				
				vty_out(vty,"-------------------------------------------------------------------------\n");
			}
			vty_out(vty,"========================================================================== \n");
		}

		else if (ret == WID_DBUS_ERROR){
			cli_syslog_info("<error> failed get reply.\n");
		}
		else if(ret == WTP_ID_NOT_EXIST){
			vty_out(vty,"<error> There is no WTP now.\n");
		}
		else{
			vty_out(vty,"<error> ret = %d\n",ret);
		}
		dcli_free_wtp_WiredIfStats_Info(WtpHead);
	}

	if(vty->node == VIEW_NODE){
		//for remote hansi info
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 0;
			
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,0,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}

		hansi_parameter:
				WtpHead = show_WtpWiredIfStatsInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &num, &ret);

				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"hansi %d-%d\n",slot_id,profile);
				vty_out(vty,"-----------------------------------------------------------------------------\n");
				if((WtpHead!=NULL)&&(ret == 0)){
					vty_out(vty,"WTPNum:%-5d  \n",num);
					vty_out(vty,"========================================================================== \n");
					WtpShowNode = NULL;
					for (i = 0; i < num; i++) {	
						if(WtpShowNode == NULL)
							WtpShowNode = WtpHead->WtpWiredIfStatsInfo_list;
						else 
							WtpShowNode = WtpShowNode->next;

						if(WtpShowNode == NULL)
							break;
						
						vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
						
						vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
						WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
						WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);

						vty_out(vty,"wtpWireIfNum:%d  \n",WtpShowNode->wtpWireIfNum);

						EthNode = WtpShowNode->EthInfo;
						
						for(j=0;j<WtpShowNode->wtpWireIfNum;j++){
						    if(EthNode == NULL) 
						        break;
						    
			 				vty_out(vty,"\nwtpIfIndex:%d  \n",EthNode->wtpIfIndex);
			 				vty_out(vty,"wtpWiredififUpDwnTimes:%d  \n",EthNode->wtpWiredififUpDwnTimes);

			 				vty_out(vty,"wtpWiredifInUcastPkts:%u  \n",EthNode->wtpWiredifInUcastPkts);
			    			vty_out(vty,"wtpWiredififInNUcastPkts:%u  \t\t\t",EthNode->wtpWiredififInNUcastPkts);
			    			vty_out(vty,"wtpWiredififInPkts:%u  \n",EthNode->wtpWiredififInPkts);
			    			vty_out(vty,"wtpWiredififInDiscardPkts:%u  \t\t\t",EthNode->wtpWiredififInDiscardPkts);		//a4

			    			vty_out(vty,"wtpWiredififInErrors:%u  \n",EthNode->wtpWiredififInErrors);
			    			vty_out(vty,"wtpWiredififOutUcastPkts:%u  \t\t\t",EthNode->wtpWiredififOutUcastPkts);
			    			vty_out(vty,"wtpWiredififOutNUcastPkts:%u  \n",EthNode->wtpWiredififOutNUcastPkts);
			    			vty_out(vty,"wtpWiredififOutPkts:%u  \t\t\t",EthNode->wtpWiredififOutPkts);					//a8

			    			vty_out(vty,"wtpWiredififOutDiscardPkts:%u  \n",EthNode->wtpWiredififOutDiscardPkts);
			    			vty_out(vty,"wtpWiredififOutErrors:%u  \t\t\t",EthNode->wtpWiredififOutErrors);
			    			vty_out(vty,"wtpWiredififInDataOctets:%llu  \n",EthNode->wtpWiredififInOctets);
			    			vty_out(vty,"wtpWiredififOutDataOctets:%llu  \t\t\t",EthNode->wtpWiredififOutOctets);				//a12
			    			
			    			vty_out(vty,"rx_sum_bytes:%llu  \n",EthNode->rx_sum_bytes);
			    			vty_out(vty,"tx_sum_bytes:%llu  \n",EthNode->tx_sum_bytes);				//a14
			    			
			    			vty_out(vty,"wtpWiredifInBcastPkts:%u  \t\t\t",EthNode->wtpWiredifInBcastPkts);
							vty_out(vty,"wtpWiredifOutBcastPkts:%u  \n",EthNode->wtpWiredifOutBcastPkts);

			    			EthNode = EthNode->next;
						}
						
						vty_out(vty,"-------------------------------------------------------------------------\n");
					}
				}

				else if (ret == WID_DBUS_ERROR){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == WTP_ID_NOT_EXIST){
					vty_out(vty,"<error> There is no WTP now.\n");
				}
				else{
					vty_out(vty,"<error> ret = %d\n",ret);
				}
				dcli_free_wtp_WiredIfStats_Info(WtpHead);
				vty_out(vty,"==============================================================================\n");
				if(argc == 2){
					return CMD_SUCCESS;
				}
			}
		}

	//for local hansi info
	for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		localid = 1;
		
		for (profile = 1; profile < MAX_INSTANCE; profile++) 
		{
			instRun = dcli_hmd_hansi_is_running(vty,slot_id,1,profile);
			if (INSTANCE_NO_CREATED == instRun) {
				continue;
			}
	
		local_hansi_parameter:
			WtpHead = show_WtpWiredIfStatsInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &num, &ret);

			vty_out(vty,"==============================================================================\n");
			vty_out(vty,"local hansi %d-%d\n",slot_id,profile);
			vty_out(vty,"-----------------------------------------------------------------------------\n");
			if((WtpHead!=NULL)&&(ret == 0)){
				vty_out(vty,"WTPNum:%-5d  \n",num);
				vty_out(vty,"========================================================================== \n");
				WtpShowNode = NULL;
				for (i = 0; i < num; i++) {	
					if(WtpShowNode == NULL)
						WtpShowNode = WtpHead->WtpWiredIfStatsInfo_list;
					else 
						WtpShowNode = WtpShowNode->next;

					if(WtpShowNode == NULL)
						break;
					
					vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
					
					vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
					WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
					WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);

					vty_out(vty,"wtpWireIfNum:%d  \n",WtpShowNode->wtpWireIfNum);

					EthNode = WtpShowNode->EthInfo;
					
					for(j=0;j<WtpShowNode->wtpWireIfNum;j++){
					    if(EthNode == NULL) 
					        break;
					    
		 				vty_out(vty,"\nwtpIfIndex:%d  \n",EthNode->wtpIfIndex);
		 				vty_out(vty,"wtpWiredififUpDwnTimes:%d  \n",EthNode->wtpWiredififUpDwnTimes);

		 				vty_out(vty,"wtpWiredifInUcastPkts:%u  \n",EthNode->wtpWiredifInUcastPkts);
		    			vty_out(vty,"wtpWiredififInNUcastPkts:%u  \t\t\t",EthNode->wtpWiredififInNUcastPkts);
		    			vty_out(vty,"wtpWiredififInPkts:%u  \n",EthNode->wtpWiredififInPkts);
		    			vty_out(vty,"wtpWiredififInDiscardPkts:%u  \t\t\t",EthNode->wtpWiredififInDiscardPkts);		//a4

		    			vty_out(vty,"wtpWiredififInErrors:%u  \n",EthNode->wtpWiredififInErrors);
		    			vty_out(vty,"wtpWiredififOutUcastPkts:%u  \t\t\t",EthNode->wtpWiredififOutUcastPkts);
		    			vty_out(vty,"wtpWiredififOutNUcastPkts:%u  \n",EthNode->wtpWiredififOutNUcastPkts);
		    			vty_out(vty,"wtpWiredififOutPkts:%u  \t\t\t",EthNode->wtpWiredififOutPkts);					//a8

		    			vty_out(vty,"wtpWiredififOutDiscardPkts:%u  \n",EthNode->wtpWiredififOutDiscardPkts);
		    			vty_out(vty,"wtpWiredififOutErrors:%u  \t\t\t",EthNode->wtpWiredififOutErrors);
		    			vty_out(vty,"wtpWiredififInDataOctets:%llu  \n",EthNode->wtpWiredififInOctets);
		    			vty_out(vty,"wtpWiredififOutDataOctets:%llu  \t\t\t",EthNode->wtpWiredififOutOctets);				//a12
		    			
		    			vty_out(vty,"rx_sum_bytes:%llu  \n",EthNode->rx_sum_bytes);
		    			vty_out(vty,"tx_sum_bytes:%llu  \n",EthNode->tx_sum_bytes);				//a14
		    			
		    			vty_out(vty,"wtpWiredifInBcastPkts:%u  \t\t\t",EthNode->wtpWiredifInBcastPkts);
						vty_out(vty,"wtpWiredifOutBcastPkts:%u  \n",EthNode->wtpWiredifOutBcastPkts);

		    			EthNode = EthNode->next;
					}
					
					vty_out(vty,"-------------------------------------------------------------------------\n");
				}
			}

			else if (ret == WID_DBUS_ERROR){
				cli_syslog_info("<error> failed get reply.\n");
			}
			else if(ret == WTP_ID_NOT_EXIST){
				vty_out(vty,"<error> There is no WTP now.\n");
			}
			else{
				vty_out(vty,"<error> ret = %d\n",ret);
			}
			dcli_free_wtp_WiredIfStats_Info(WtpHead);
			vty_out(vty,"==============================================================================\n");
			if(argc == 2){
				return CMD_SUCCESS;
			}
			}
		}
	}
	
	return CMD_SUCCESS;
}

/*add for showing wtp Wireless IfStats information by nl 20100526 table 17*/
DEFUN(show_all_wtp_wireless_ifstats_information_func,
		show_all_wtp_wireless_if_information_cmd,
	  "show the wireless_ifstats information_of all_wtp [remote] [local] [PARAMETER]",
	  SHOW_STR
	  "wireless_ifstats information\n"
	  "Display  wireless ifstats information of all wtps\n"
	  "List wtp wireless ifstats information\n"
	  "by wtp display  wireless ifstats information\n"
	  "'remote' or 'local' hansi\n"
	  "'remote' or 'local' hansi\n"
	  "slotid-instid\n"
	 )
{
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	struct WtpWirelessIfInfo *WtpHead = NULL;
	struct WtpWirelessIfInfo *WtpShowNode = NULL;
	int ret=0;
	int i=0;
	int j=0;
	int k=0;
	int profile = 0;
	int instRun = 0;
	int flag = 0;
	unsigned int num = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	
	if((argc == 1)||(argc == 3)){
		vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
		return CMD_SUCCESS;
	}
	if(argc == 2){
		if (!strcmp(argv[0],"remote")){
			localid = 0;
		}else if(!strcmp(argv[0],"local")){
			localid = 1;
		}else{
			vty_out(vty,"parameter should be 'remote' or 'local'\n");
			return CMD_SUCCESS;
		}
		
		if((!strcmp(argv[0],"remote"))&&(!strcmp(argv[1],"local"))){
			vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
			return CMD_SUCCESS;
		}
		
		ret = parse_slot_hansi_id((char*)argv[1],&slot_id,&profile);
		if(ret != WID_DBUS_SUCCESS){
			slot_id = HostSlotId;
			flag = 1;
			ret = parse_int_ID((char*)argv[1], &profile);
			if(ret != WID_DBUS_SUCCESS){
				if(ret == WID_ILLEGAL_INPUT){
					vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
				}
				else{
					vty_out(vty,"<error> unknown id format\n");
				}
				return CMD_WARNING;
			}	
		}
		if(distributFag == 0){
			if(slot_id != 0){
				vty_out(vty,"<error> slot id should be 0\n");
				return CMD_WARNING;
			}	
		}else if(flag == 1){
			slot_id = HostSlotId;
		}
		if(slot_id >= MAX_SLOT_NUM || slot_id < 0){
			vty_out(vty,"<error> slot id should be 1 to %d\n",MAX_SLOT_NUM-1);
			return CMD_WARNING;
		}	
		if(profile >= MAX_INSTANCE || profile == 0){
			vty_out(vty,"<error> hansi id should be 1 to %d\n",MAX_INSTANCE-1);
			return CMD_WARNING;
		}
		instRun = dcli_hmd_hansi_is_running(vty,slot_id,localid,profile);
		if (INSTANCE_NO_CREATED == instRun) {
			vty_out(vty,"<error> the instance %s %d-%d is not running\n",((localid == 1)?"local-hansi":"hansi"),slot_id,profile);
			return CMD_WARNING;
		}
		
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		if(localid == 0)
			goto hansi_parameter;
		else if(localid == 1)
			goto local_hansi_parameter; 
	}
	
	if(vty->node != VIEW_NODE){
		WtpHead = show_WtpWirelessIfStatsInfo_of_all_wtp(index,localid,dcli_dbus_connection, &num, &ret);

		if((WtpHead!=NULL)&&(ret == 0)){
			vty_out(vty,"WTPNum:%-5d  \n",num);
			vty_out(vty,"========================================================================== \n");
			for (i = 0; i < num; i++) {	
				if(WtpShowNode == NULL)
					WtpShowNode = WtpHead->WtpWirelessIfInfo_list;
				else 
					WtpShowNode = WtpShowNode->next;

				if(WtpShowNode == NULL)
					break;
				
				vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
				
				vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
				WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
				WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);

				vty_out(vty,"wtpWirelessIfPwrAttRange:%d  \t\t\t",WtpShowNode->wtpWirelessIfPwrAttRange);
				vty_out(vty,"wtpWirelessIfAntennaGain:%d  \n",WtpShowNode->wtpWirelessIfAntennaGain);
				vty_out(vty,"wtpWirelessIfMaxStationNumPermitted:%d  \t",WtpShowNode->wtpWirelessIfMaxStationNumPermitted);
				vty_out(vty,"wtpWirelessIfMaxTxPwrLvl:%d  \n",WtpShowNode->wtpWirelessIfMaxTxPwrLvl);		//a4
				
				vty_out(vty,"wifi_num:   %-5d	\n",WtpShowNode->wifi_num);
				
				struct Sub_WtpWirelessIfInfo *sub_radio = NULL;
				for(j=0;j<WtpShowNode->wifi_num;j++){
					if(sub_radio == NULL)
						sub_radio = WtpShowNode->Sub_WtpWirelessIfInfo_head;
					else 
						sub_radio = sub_radio->next;

					if(sub_radio == NULL){
						vty_out(vty,"break\n");
						break;
					}
					
					vty_out(vty,"------------------------radio information:------------------------------- \n");
					vty_out(vty,"wtpWirelessIfIndex:  %-5d  \t\t\t\t",(sub_radio->wtpWirelessIfIndex));
					vty_out(vty,"g_radio_id:  %-5d  \n",sub_radio->g_radio_id);
					vty_out(vty,"radio_has_bss:  %-5d  \t\t\t\t\t",(sub_radio->radio_has_bss));
					vty_out(vty,"wtpWirelessIfType:  %-5d  \n",sub_radio->wtpWirelessIfType);
					
					vty_out(vty,"wtpWirelessIfSpeed:  %0.1f  \t\t\t\t",(sub_radio->wtpWirelessIfSpeed)/10.0);
					vty_out(vty,"wtpWirelessIfAdminStatus:  %-5d  \n",sub_radio->wtpWirelessIfAdminStatus);
					vty_out(vty,"wtpWirelessIfOperStatus:  %-5d  \t\t\t",(sub_radio->wtpWirelessIfOperStatus));
					vty_out(vty,"wtpWirelessIfLastChange:  %-5u  \n",sub_radio->wtpWirelessIfLastChange);

					vty_out(vty,"wtpWirelessIfRadioChannelAutoSelectEnable:  %-5d  \t",(sub_radio->wtpWirelessIfRadioChannelAutoSelectEnable));
					vty_out(vty,"wtpWirelessIfRadioChannelConfig:  %-5d  \n",sub_radio->wtpWirelessIfRadioChannelConfig);
					vty_out(vty,"wtpWirelessIfDiversitySelectionRx:  %-5d  \t\t",(sub_radio->wtpWirelessIfDiversitySelectionRx));
					vty_out(vty,"wtpWirelessIfCurrRadioModeSupport:  ");
					if(sub_radio->wtpWirelessIfCurrRadioModeSupport!=0)
					{
						vty_out(vty,"11");
						/*fengwenchao modify begin  20111109 for GM*/
						int flag_an = 0;int flag_gn = 0;

						if(((sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11A) > 0)
							&&((sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11N)> 0)
							&&((sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11AN)>0)
							&&(!(sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11B))
							&&(!(sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11G)))
						{	
							vty_out(vty,"a/an");
						}
						else if(((sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11GN) > 0)
							&&((sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11N)> 0)
							&&((sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11G)>0)
							&&(!(sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11B))
							&&(!(sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11A)))
						{	
							vty_out(vty,"g/gn");
						}						
						else
						{
							if((sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11A) > 0)
								vty_out(vty,"a");
							if((sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11B) > 0)
								vty_out(vty,"b");
							if((sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11G) > 0)
								vty_out(vty,"g");				
							if((sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11N) > 0)
								vty_out(vty,"n");
						}
						/*fengwenchao modify  end*/
					}
					vty_out(vty,"\n");
					vty_out(vty,"wtpWirelessIfPwrAttValue:  %-5d  \t\t\t",(sub_radio->wtpWirelessIfPwrAttValue));
					vty_out(vty,"wtpWirelessIfPowerMgmtEnable:  %-5d  \n",sub_radio->wtpWirelessIfPowerMgmtEnable);
					vty_out(vty,"wtpWirelessIfTxPwrStep: %-5d \t\t\t",sub_radio->wtpWirelessIfTxPwrStep);

					vty_out(vty,"WTP wtpWirelessIfDescr:  %02X:%02X:%02X:%02X:%02X:%02X \n",
												sub_radio->wtpWirelessIfPhysAddress[0],sub_radio->wtpWirelessIfPhysAddress[1],
												sub_radio->wtpWirelessIfPhysAddress[2],sub_radio->wtpWirelessIfPhysAddress[3],
												sub_radio->wtpWirelessIfPhysAddress[4],sub_radio->wtpWirelessIfPhysAddress[5]);

					vty_out(vty,"wtpWirelessIfTransmitSpeedConfig: \n");
					for(k=0;k<sub_radio->surport_rate_num;k++){
						vty_out(vty,"%0.1f ",sub_radio->wtpWirelessIfTransmitSpeedConfig[k]/10.0);
					}
					vty_out(vty,"\n  ");
				}

				vty_out(vty,"-------------------------------------------------------------------------\n");
			}
			vty_out(vty,"========================================================================== \n");
		}

		else if (ret == WID_DBUS_ERROR){
			cli_syslog_info("<error> failed get reply.\n");
		}
		else if(ret == WTP_ID_NOT_EXIST){
			vty_out(vty,"<error> There is no WTP now.\n");
		}
		else{
			vty_out(vty,"<error> ret = %d\n",ret);
		}
		dcli_free_wtp_WtpWirelessIf_Info(WtpHead);
	}

	if(vty->node == VIEW_NODE){
		//for remote hansi info
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 0;
			
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,0,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}

		hansi_parameter:
				WtpHead = show_WtpWirelessIfStatsInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &num, &ret);

				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"hansi %d-%d\n",slot_id,profile);
				vty_out(vty,"-----------------------------------------------------------------------------\n");
				if((WtpHead!=NULL)&&(ret == 0)){
					vty_out(vty,"WTPNum:%-5d  \n",num);
					vty_out(vty,"========================================================================== \n");
					WtpShowNode = NULL;
					for (i = 0; i < num; i++) {	
						if(WtpShowNode == NULL)
							WtpShowNode = WtpHead->WtpWirelessIfInfo_list;
						else 
							WtpShowNode = WtpShowNode->next;

						if(WtpShowNode == NULL)
							break;
						
						vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
						
						vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
						WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
						WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);

						vty_out(vty,"wtpWirelessIfPwrAttRange:%d  \t\t\t",WtpShowNode->wtpWirelessIfPwrAttRange);
						vty_out(vty,"wtpWirelessIfAntennaGain:%d  \n",WtpShowNode->wtpWirelessIfAntennaGain);
						vty_out(vty,"wtpWirelessIfMaxStationNumPermitted:%d  \t",WtpShowNode->wtpWirelessIfMaxStationNumPermitted);
						vty_out(vty,"wtpWirelessIfMaxTxPwrLvl:%d  \n",WtpShowNode->wtpWirelessIfMaxTxPwrLvl);		//a4
						
						vty_out(vty,"wifi_num:   %-5d	\n",WtpShowNode->wifi_num);
						
						struct Sub_WtpWirelessIfInfo *sub_radio = NULL;
						for(j=0;j<WtpShowNode->wifi_num;j++){
							if(sub_radio == NULL)
								sub_radio = WtpShowNode->Sub_WtpWirelessIfInfo_head;
							else 
								sub_radio = sub_radio->next;

							if(sub_radio == NULL){
								vty_out(vty,"break\n");
								break;
							}
							
							vty_out(vty,"------------------------radio information:------------------------------- \n");
							vty_out(vty,"wtpWirelessIfIndex:  %-5d  \t\t\t\t",(sub_radio->wtpWirelessIfIndex));
							vty_out(vty,"g_radio_id:  %-5d  \n",sub_radio->g_radio_id);
							vty_out(vty,"radio_has_bss:  %-5d  \t\t\t\t\t",(sub_radio->radio_has_bss));
							vty_out(vty,"wtpWirelessIfType:  %-5d  \n",sub_radio->wtpWirelessIfType);
							
							vty_out(vty,"wtpWirelessIfSpeed:  %0.1f  \t\t\t\t",(sub_radio->wtpWirelessIfSpeed)/10.0);
							vty_out(vty,"wtpWirelessIfAdminStatus:  %-5d  \n",sub_radio->wtpWirelessIfAdminStatus);
							vty_out(vty,"wtpWirelessIfOperStatus:  %-5d  \t\t\t",(sub_radio->wtpWirelessIfOperStatus));
							vty_out(vty,"wtpWirelessIfLastChange:  %-5u  \n",sub_radio->wtpWirelessIfLastChange);

							vty_out(vty,"wtpWirelessIfRadioChannelAutoSelectEnable:  %-5d  \t",(sub_radio->wtpWirelessIfRadioChannelAutoSelectEnable));
							vty_out(vty,"wtpWirelessIfRadioChannelConfig:  %-5d  \n",sub_radio->wtpWirelessIfRadioChannelConfig);
							vty_out(vty,"wtpWirelessIfDiversitySelectionRx:  %-5d  \t\t",(sub_radio->wtpWirelessIfDiversitySelectionRx));
							vty_out(vty,"wtpWirelessIfCurrRadioModeSupport:  ");
							if(sub_radio->wtpWirelessIfCurrRadioModeSupport!=0)
							{
								vty_out(vty,"11");
								/*fengwenchao modify begin  20111109 for GM*/
								int flag_an = 0;int flag_gn = 0;

								if(((sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11A) > 0)
									&&((sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11N)> 0)
									&&((sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11AN)>0)
									&&(!(sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11B))
									&&(!(sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11G)))
								{	
									vty_out(vty,"a/an");
								}
								else if(((sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11GN) > 0)
									&&((sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11N)> 0)
									&&((sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11G)>0)
									&&(!(sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11B))
									&&(!(sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11A)))
								{	
									vty_out(vty,"g/gn");
								}						
								else
								{
									if((sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11A) > 0)
										vty_out(vty,"a");
									if((sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11B) > 0)
										vty_out(vty,"b");
									if((sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11G) > 0)
										vty_out(vty,"g");				
									if((sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11N) > 0)
										vty_out(vty,"n");
								}
								/*fengwenchao modify  end*/
							}
							vty_out(vty,"\n");
							vty_out(vty,"wtpWirelessIfPwrAttValue:  %-5d  \t\t\t",(sub_radio->wtpWirelessIfPwrAttValue));
							vty_out(vty,"wtpWirelessIfPowerMgmtEnable:  %-5d  \n",sub_radio->wtpWirelessIfPowerMgmtEnable);
							vty_out(vty,"wtpWirelessIfTxPwrStep: %-5d \t\t\t",sub_radio->wtpWirelessIfTxPwrStep);

							vty_out(vty,"WTP wtpWirelessIfDescr:  %02X:%02X:%02X:%02X:%02X:%02X \n",
														sub_radio->wtpWirelessIfPhysAddress[0],sub_radio->wtpWirelessIfPhysAddress[1],
														sub_radio->wtpWirelessIfPhysAddress[2],sub_radio->wtpWirelessIfPhysAddress[3],
														sub_radio->wtpWirelessIfPhysAddress[4],sub_radio->wtpWirelessIfPhysAddress[5]);

							vty_out(vty,"wtpWirelessIfTransmitSpeedConfig: \n");
							for(k=0;k<sub_radio->surport_rate_num;k++){
								vty_out(vty,"%0.1f ",sub_radio->wtpWirelessIfTransmitSpeedConfig[k]/10.0);
							}
							vty_out(vty,"\n  ");
						}

						vty_out(vty,"-------------------------------------------------------------------------\n");
					}
				}

				else if (ret == WID_DBUS_ERROR){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == WTP_ID_NOT_EXIST){
					vty_out(vty,"<error> There is no WTP now.\n");
				}
				else{
					vty_out(vty,"<error> ret = %d\n",ret);
				}
				dcli_free_wtp_WtpWirelessIf_Info(WtpHead);
				vty_out(vty,"==============================================================================\n");
				if(argc == 2){
					return CMD_SUCCESS;
				}
			}
		}

	//for local hansi info
	for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		localid = 1;
		
		for (profile = 1; profile < MAX_INSTANCE; profile++) 
		{
			instRun = dcli_hmd_hansi_is_running(vty,slot_id,1,profile);
			if (INSTANCE_NO_CREATED == instRun) {
				continue;
			}
	
		local_hansi_parameter:
			WtpHead = show_WtpWirelessIfStatsInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &num, &ret);

			vty_out(vty,"==============================================================================\n");
			vty_out(vty,"local hansi %d-%d\n",slot_id,profile);
			vty_out(vty,"-----------------------------------------------------------------------------\n");
			if((WtpHead!=NULL)&&(ret == 0)){
				vty_out(vty,"WTPNum:%-5d  \n",num);
				vty_out(vty,"========================================================================== \n");
				WtpShowNode = NULL;
				for (i = 0; i < num; i++) {	
					if(WtpShowNode == NULL)
						WtpShowNode = WtpHead->WtpWirelessIfInfo_list;
					else 
						WtpShowNode = WtpShowNode->next;

					if(WtpShowNode == NULL)
						break;
					
					vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
					
					vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
					WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
					WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);

					vty_out(vty,"wtpWirelessIfPwrAttRange:%d  \t\t\t",WtpShowNode->wtpWirelessIfPwrAttRange);
					vty_out(vty,"wtpWirelessIfAntennaGain:%d  \n",WtpShowNode->wtpWirelessIfAntennaGain);
					vty_out(vty,"wtpWirelessIfMaxStationNumPermitted:%d  \t",WtpShowNode->wtpWirelessIfMaxStationNumPermitted);
					vty_out(vty,"wtpWirelessIfMaxTxPwrLvl:%d  \n",WtpShowNode->wtpWirelessIfMaxTxPwrLvl);		//a4
					
					vty_out(vty,"wifi_num:   %-5d	\n",WtpShowNode->wifi_num);
					
					struct Sub_WtpWirelessIfInfo *sub_radio = NULL;
					for(j=0;j<WtpShowNode->wifi_num;j++){
						if(sub_radio == NULL)
							sub_radio = WtpShowNode->Sub_WtpWirelessIfInfo_head;
						else 
							sub_radio = sub_radio->next;

						if(sub_radio == NULL){
							vty_out(vty,"break\n");
							break;
						}
						
						vty_out(vty,"------------------------radio information:------------------------------- \n");
						vty_out(vty,"wtpWirelessIfIndex:  %-5d  \t\t\t\t",(sub_radio->wtpWirelessIfIndex));
						vty_out(vty,"g_radio_id:  %-5d  \n",sub_radio->g_radio_id);
						vty_out(vty,"radio_has_bss:  %-5d  \t\t\t\t\t",(sub_radio->radio_has_bss));
						vty_out(vty,"wtpWirelessIfType:  %-5d  \n",sub_radio->wtpWirelessIfType);
						
						vty_out(vty,"wtpWirelessIfSpeed:  %0.1f  \t\t\t\t",(sub_radio->wtpWirelessIfSpeed)/10.0);
						vty_out(vty,"wtpWirelessIfAdminStatus:  %-5d  \n",sub_radio->wtpWirelessIfAdminStatus);
						vty_out(vty,"wtpWirelessIfOperStatus:  %-5d  \t\t\t",(sub_radio->wtpWirelessIfOperStatus));
						vty_out(vty,"wtpWirelessIfLastChange:  %-5u  \n",sub_radio->wtpWirelessIfLastChange);

						vty_out(vty,"wtpWirelessIfRadioChannelAutoSelectEnable:  %-5d  \t",(sub_radio->wtpWirelessIfRadioChannelAutoSelectEnable));
						vty_out(vty,"wtpWirelessIfRadioChannelConfig:  %-5d  \n",sub_radio->wtpWirelessIfRadioChannelConfig);
						vty_out(vty,"wtpWirelessIfDiversitySelectionRx:  %-5d  \t\t",(sub_radio->wtpWirelessIfDiversitySelectionRx));
						vty_out(vty,"wtpWirelessIfCurrRadioModeSupport:  ");
						if(sub_radio->wtpWirelessIfCurrRadioModeSupport!=0)
						{
							vty_out(vty,"11");
							/*fengwenchao modify begin  20111109 for GM*/
							int flag_an = 0;int flag_gn = 0;

							if(((sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11A) > 0)
								&&((sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11N)> 0)
								&&((sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11AN)>0)
								&&(!(sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11B))
								&&(!(sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11G)))
							{	
								vty_out(vty,"a/an");
							}
							else if(((sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11GN) > 0)
								&&((sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11N)> 0)
								&&((sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11G)>0)
								&&(!(sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11B))
								&&(!(sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11A)))
							{	
								vty_out(vty,"g/gn");
							}						
							else
							{
								if((sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11A) > 0)
									vty_out(vty,"a");
								if((sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11B) > 0)
									vty_out(vty,"b");
								if((sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11G) > 0)
									vty_out(vty,"g");				
								if((sub_radio->wtpWirelessIfCurrRadioModeSupport&IEEE80211_11N) > 0)
									vty_out(vty,"n");
							}
							/*fengwenchao modify  end*/
						}
						vty_out(vty,"\n");
						vty_out(vty,"wtpWirelessIfPwrAttValue:  %-5d  \t\t\t",(sub_radio->wtpWirelessIfPwrAttValue));
						vty_out(vty,"wtpWirelessIfPowerMgmtEnable:  %-5d  \n",sub_radio->wtpWirelessIfPowerMgmtEnable);
						vty_out(vty,"wtpWirelessIfTxPwrStep: %-5d \t\t\t",sub_radio->wtpWirelessIfTxPwrStep);

						vty_out(vty,"WTP wtpWirelessIfDescr:  %02X:%02X:%02X:%02X:%02X:%02X \n",
													sub_radio->wtpWirelessIfPhysAddress[0],sub_radio->wtpWirelessIfPhysAddress[1],
													sub_radio->wtpWirelessIfPhysAddress[2],sub_radio->wtpWirelessIfPhysAddress[3],
													sub_radio->wtpWirelessIfPhysAddress[4],sub_radio->wtpWirelessIfPhysAddress[5]);

						vty_out(vty,"wtpWirelessIfTransmitSpeedConfig: \n");
						for(k=0;k<sub_radio->surport_rate_num;k++){
							vty_out(vty,"%0.1f ",sub_radio->wtpWirelessIfTransmitSpeedConfig[k]/10.0);
						}
						vty_out(vty,"\n  ");
					}

					vty_out(vty,"-------------------------------------------------------------------------\n");
				}
			}

			else if (ret == WID_DBUS_ERROR){
				cli_syslog_info("<error> failed get reply.\n");
			}
			else if(ret == WTP_ID_NOT_EXIST){
				vty_out(vty,"<error> There is no WTP now.\n");
			}
			else{
				vty_out(vty,"<error> ret = %d\n",ret);
			}
			dcli_free_wtp_WtpWirelessIf_Info(WtpHead);
			vty_out(vty,"==============================================================================\n");
			if(argc == 2){
				return CMD_SUCCESS;
			}
			}
		}
	}
	
	return CMD_SUCCESS;
}
/*add for showing NewWtpWirelessIfInfo 20100603 by nl b18*/
DEFUN(show_all_wtp_new_wtp_wireless_ifinfo_information_func,
	  show_all_wtp_new_wtp_wireless_ifinfo_information_cmd,
	  "show the all new wireless_if information [remote] [local] [PARAMETER]",
	  SHOW_STR
	  "new wireless_if info\n"
	  "new wireless_if info\n"
	  "Display new wireless ifinformation of all wtps\n"
	  "List wtp new wireless  information\n"
	  "by wtp display new wireless ifinformation\n"
	  "'remote' or 'local' hansi\n"
	  "'remote' or 'local' hansi\n"
	  "slotid-instid\n"
	 )
{
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	struct NewWtpWirelessIfInfo *RadioHead = NULL;
	struct NewWtpWirelessIfInfo *RadioShowNode = NULL;
	int ret=0;
	int i=0;
	int j=0;
	int profile = 0;
	int instRun = 0;
	int flag = 0;
	unsigned int radio_num = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	
	if((argc == 1)||(argc == 3)){
		vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
		return CMD_SUCCESS;
	}
	if(argc == 2){
		if (!strcmp(argv[0],"remote")){
			localid = 0;
		}else if(!strcmp(argv[0],"local")){
			localid = 1;
		}else{
			vty_out(vty,"parameter should be 'remote' or 'local'\n");
			return CMD_SUCCESS;
		}
		
		if((!strcmp(argv[0],"remote"))&&(!strcmp(argv[1],"local"))){
			vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
			return CMD_SUCCESS;
		}
		
		ret = parse_slot_hansi_id((char*)argv[1],&slot_id,&profile);
		if(ret != WID_DBUS_SUCCESS){
			slot_id = HostSlotId;
			flag = 1;
			ret = parse_int_ID((char*)argv[1], &profile);
			if(ret != WID_DBUS_SUCCESS){
				if(ret == WID_ILLEGAL_INPUT){
					vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
				}
				else{
					vty_out(vty,"<error> unknown id format\n");
				}
				return CMD_WARNING;
			}	
		}
		if(distributFag == 0){
			if(slot_id != 0){
				vty_out(vty,"<error> slot id should be 0\n");
				return CMD_WARNING;
			}	
		}else if(flag == 1){
			slot_id = HostSlotId;
		}
		if(slot_id >= MAX_SLOT_NUM || slot_id < 0){
			vty_out(vty,"<error> slot id should be 1 to %d\n",MAX_SLOT_NUM-1);
			return CMD_WARNING;
		}	
		if(profile >= MAX_INSTANCE || profile == 0){
			vty_out(vty,"<error> hansi id should be 1 to %d\n",MAX_INSTANCE-1);
			return CMD_WARNING;
		}
		instRun = dcli_hmd_hansi_is_running(vty,slot_id,localid,profile);
		if (INSTANCE_NO_CREATED == instRun) {
			vty_out(vty,"<error> the instance %s %d-%d is not running\n",((localid == 1)?"local-hansi":"hansi"),slot_id,profile);
			return CMD_WARNING;
		}
		
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		if(localid == 0)
			goto hansi_parameter;
		else if(localid == 1)
			goto local_hansi_parameter; 
	}
	
	if(vty->node != VIEW_NODE){
		RadioHead = show_NewWtpWirelessIfInfo_of_all_wtp(index,localid,dcli_dbus_connection, &radio_num, &ret);
		
		if((RadioHead!=NULL)&&(ret == 0)){
			vty_out(vty,"radio_num:%-5d  \n",radio_num);
			vty_out(vty,"========================================================================== \n");
			for (i = 0; i < radio_num; i++) {	
				if(RadioShowNode == NULL)
					RadioShowNode = RadioHead->NewWtpWirelessIfInfo_list;
				else 
					RadioShowNode = RadioShowNode->next;

				if(RadioShowNode == NULL)
					break;

				vty_out(vty,"    -----------------------RadioInformation----------------     \n");
				vty_out(vty,"WTPID:   %-5d  \t\t\t\t",RadioShowNode->wtpCurrID);
				vty_out(vty,"NewapWirelessIfIndex:   %-5d  \n",RadioShowNode->NewapWirelessIfIndex);
				vty_out(vty,"wtpRadCurrID:   %-5d  \t\t\t\t",RadioShowNode->wtpRadCurrID);
				vty_out(vty,"wtpRadLocalID:   %-5d  \n",RadioShowNode->wtpRadLocalID);
				
				vty_out(vty,"NewwtpWirelessIfBeaconIntvl:   %-5d  \t\t",RadioShowNode->NewwtpWirelessIfBeaconIntvl);
				vty_out(vty,"NewwtpWirelessIfDtimIntvl:   %-5d  \n",RadioShowNode->NewwtpWirelessIfDtimIntvl);
				vty_out(vty,"NewwtpWirelessIfShtRetryThld:   %-5d  \t\t",RadioShowNode->NewwtpWirelessIfShtRetryThld);
				vty_out(vty,"NewwtpWirelessIfLongRetryThld:   %-5d  \n",RadioShowNode->NewwtpWirelessIfLongRetryThld);
				
				vty_out(vty,"NewwtpWirelessIfMaxRxLifetime:   %-5d  \t",RadioShowNode->NewwtpWirelessIfMaxRxLifetime);
				vty_out(vty,"NewWtpPreambleLen:   %-5d  \n",RadioShowNode->NewWtpPreambleLen);
				vty_out(vty,"NewRtsThreshold:   %-5d  \t\t\t",RadioShowNode->NewRtsThreshold);
				vty_out(vty,"NewFragThreshlod:   %-5d  \n",RadioShowNode->NewFragThreshlod);

				vty_out(vty,"wtpWiredIfInMulticastPkts:   %-5d	\t",RadioShowNode->wtpWiredIfInMulticastPkts);
				vty_out(vty,"wtpWiredIfOutMulticastPkts:   %-5d	\n",RadioShowNode->wtpWiredIfOutMulticastPkts);
				vty_out(vty,"wtpWirelessIfMaxRxLifetime:	%-5d  \n",RadioShowNode->wtpWirelessIfMaxRxLifetime);
				
				vty_out(vty,"-------------------------------------------------------------------------\n");
				
			}
			vty_out(vty,"========================================================================== \n");
		}

		else if (ret == WID_DBUS_ERROR){
			cli_syslog_info("<error> failed get reply.\n");
		}
		else if(ret == WTP_ID_NOT_EXIST){
			vty_out(vty,"<error> There is no WTP now.\n");
		}
		else{
			vty_out(vty,"<error> ret = %d\n",ret);
		}

		dcli_free_NewWtpWirelessIfInfo(RadioHead);
	}

	if(vty->node == VIEW_NODE){
		//for remote hansi info
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 0;
			
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,0,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}

		hansi_parameter:
				RadioHead = show_NewWtpWirelessIfInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &radio_num, &ret);
				
				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"hansi %d-%d\n",slot_id,profile);
				vty_out(vty,"-----------------------------------------------------------------------------\n");
				if((RadioHead!=NULL)&&(ret == 0)){
					vty_out(vty,"radio_num:%-5d  \n",radio_num);
					vty_out(vty,"========================================================================== \n");
					RadioShowNode = NULL;
					for (i = 0; i < radio_num; i++) {	
						if(RadioShowNode == NULL)
							RadioShowNode = RadioHead->NewWtpWirelessIfInfo_list;
						else 
							RadioShowNode = RadioShowNode->next;

						if(RadioShowNode == NULL)
							break;

						vty_out(vty,"    -----------------------RadioInformation----------------     \n");
						vty_out(vty,"WTPID:   %-5d  \t\t\t\t",RadioShowNode->wtpCurrID);
						vty_out(vty,"NewapWirelessIfIndex:   %-5d  \n",RadioShowNode->NewapWirelessIfIndex);
						vty_out(vty,"wtpRadCurrID:   %-5d  \t\t\t\t",RadioShowNode->wtpRadCurrID);
						vty_out(vty,"wtpRadLocalID:   %-5d  \n",RadioShowNode->wtpRadLocalID);
						
						vty_out(vty,"NewwtpWirelessIfBeaconIntvl:   %-5d  \t\t",RadioShowNode->NewwtpWirelessIfBeaconIntvl);
						vty_out(vty,"NewwtpWirelessIfDtimIntvl:   %-5d  \n",RadioShowNode->NewwtpWirelessIfDtimIntvl);
						vty_out(vty,"NewwtpWirelessIfShtRetryThld:   %-5d  \t\t",RadioShowNode->NewwtpWirelessIfShtRetryThld);
						vty_out(vty,"NewwtpWirelessIfLongRetryThld:   %-5d  \n",RadioShowNode->NewwtpWirelessIfLongRetryThld);
						
						vty_out(vty,"NewwtpWirelessIfMaxRxLifetime:   %-5d  \t",RadioShowNode->NewwtpWirelessIfMaxRxLifetime);
						vty_out(vty,"NewWtpPreambleLen:   %-5d  \n",RadioShowNode->NewWtpPreambleLen);
						vty_out(vty,"NewRtsThreshold:   %-5d  \t\t\t",RadioShowNode->NewRtsThreshold);
						vty_out(vty,"NewFragThreshlod:   %-5d  \n",RadioShowNode->NewFragThreshlod);

						vty_out(vty,"wtpWiredIfInMulticastPkts:   %-5d	\t",RadioShowNode->wtpWiredIfInMulticastPkts);
						vty_out(vty,"wtpWiredIfOutMulticastPkts:   %-5d	\n",RadioShowNode->wtpWiredIfOutMulticastPkts);
						vty_out(vty,"wtpWirelessIfMaxRxLifetime:	%-5d  \n",RadioShowNode->wtpWirelessIfMaxRxLifetime);
						
						vty_out(vty,"-------------------------------------------------------------------------\n");
						
					}
				}

				else if (ret == WID_DBUS_ERROR){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == WTP_ID_NOT_EXIST){
					vty_out(vty,"<error> There is no WTP now.\n");
				}
				else{
					vty_out(vty,"<error> ret = %d\n",ret);
				}

				dcli_free_NewWtpWirelessIfInfo(RadioHead);
				vty_out(vty,"==============================================================================\n");
				if(argc == 2){
					return CMD_SUCCESS;
				}
			}
		}

	//for local hansi info
	for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		localid = 1;
		
		for (profile = 1; profile < MAX_INSTANCE; profile++) 
		{
			instRun = dcli_hmd_hansi_is_running(vty,slot_id,1,profile);
			if (INSTANCE_NO_CREATED == instRun) {
				continue;
			}
	
		local_hansi_parameter:
			RadioHead = show_NewWtpWirelessIfInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &radio_num, &ret);
			
			vty_out(vty,"==============================================================================\n");
			vty_out(vty,"local hansi %d-%d\n",slot_id,profile);
			vty_out(vty,"-----------------------------------------------------------------------------\n");
			if((RadioHead!=NULL)&&(ret == 0)){
				vty_out(vty,"radio_num:%-5d  \n",radio_num);
				vty_out(vty,"========================================================================== \n");
				RadioShowNode = NULL;
				for (i = 0; i < radio_num; i++) {	
					if(RadioShowNode == NULL)
						RadioShowNode = RadioHead->NewWtpWirelessIfInfo_list;
					else 
						RadioShowNode = RadioShowNode->next;

					if(RadioShowNode == NULL)
						break;

					vty_out(vty,"    -----------------------RadioInformation----------------     \n");
					vty_out(vty,"WTPID:   %-5d  \t\t\t\t",RadioShowNode->wtpCurrID);
					vty_out(vty,"NewapWirelessIfIndex:   %-5d  \n",RadioShowNode->NewapWirelessIfIndex);
					vty_out(vty,"wtpRadCurrID:   %-5d  \t\t\t\t",RadioShowNode->wtpRadCurrID);
					vty_out(vty,"wtpRadLocalID:   %-5d  \n",RadioShowNode->wtpRadLocalID);
					
					vty_out(vty,"NewwtpWirelessIfBeaconIntvl:   %-5d  \t\t",RadioShowNode->NewwtpWirelessIfBeaconIntvl);
					vty_out(vty,"NewwtpWirelessIfDtimIntvl:   %-5d  \n",RadioShowNode->NewwtpWirelessIfDtimIntvl);
					vty_out(vty,"NewwtpWirelessIfShtRetryThld:   %-5d  \t\t",RadioShowNode->NewwtpWirelessIfShtRetryThld);
					vty_out(vty,"NewwtpWirelessIfLongRetryThld:   %-5d  \n",RadioShowNode->NewwtpWirelessIfLongRetryThld);
					
					vty_out(vty,"NewwtpWirelessIfMaxRxLifetime:   %-5d  \t",RadioShowNode->NewwtpWirelessIfMaxRxLifetime);
					vty_out(vty,"NewWtpPreambleLen:   %-5d  \n",RadioShowNode->NewWtpPreambleLen);
					vty_out(vty,"NewRtsThreshold:   %-5d  \t\t\t",RadioShowNode->NewRtsThreshold);
					vty_out(vty,"NewFragThreshlod:   %-5d  \n",RadioShowNode->NewFragThreshlod);

					vty_out(vty,"wtpWiredIfInMulticastPkts:   %-5d	\t",RadioShowNode->wtpWiredIfInMulticastPkts);
					vty_out(vty,"wtpWiredIfOutMulticastPkts:   %-5d	\n",RadioShowNode->wtpWiredIfOutMulticastPkts);
					vty_out(vty,"wtpWirelessIfMaxRxLifetime:	%-5d  \n",RadioShowNode->wtpWirelessIfMaxRxLifetime);
					
					vty_out(vty,"-------------------------------------------------------------------------\n");
					
				}
			}

			else if (ret == WID_DBUS_ERROR){
				cli_syslog_info("<error> failed get reply.\n");
			}
			else if(ret == WTP_ID_NOT_EXIST){
				vty_out(vty,"<error> There is no WTP now.\n");
			}
			else{
				vty_out(vty,"<error> ret = %d\n",ret);
			}

			dcli_free_NewWtpWirelessIfInfo(RadioHead);
			vty_out(vty,"==============================================================================\n");
			if(argc == 2){
				return CMD_SUCCESS;
			}
			}
		}
	}

	return CMD_SUCCESS;
}

/*add for showing wtp newwirelessifstats information b19*/
DEFUN(show_all_wtp_new_wirelessifstats_information_func,
	  show_all_wtp_new_wirelessifstats_information_cmd,
	  "show the new wirelessifstats information of all_wtp",
	  SHOW_STR
	  "Display new wirelessifstats of all wtps\n"
	  "List wtp new wirelessifstats information\n"
	  "by wtp display new wirelessifstats information\n"
	 )
{
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	struct NewWtpWirelessIfstatsInfo *WtpHead = NULL;
	struct NewWtpWirelessIfstatsInfo *WtpShowNode = NULL;
	int ret=0;
	int i=0;
	int j=0;
	int k=0;
	unsigned int wtp_num = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	
	WtpHead = show_New_wirelessifstatsInfo_info_of_all_wtp(index,localid,dcli_dbus_connection, &wtp_num, &ret);
	
#if 1
	if((WtpHead!=NULL)&&(ret == 0)){
		vty_out(vty,"WTPNum:%-5d  \n",wtp_num);
		vty_out(vty,"========================================================================== \n");
		for (i = 0; i < wtp_num; i++) {	
			if(WtpShowNode == NULL)
				WtpShowNode = WtpHead->NewWtpWirelessIfstatsInfo_list;
			else 
				WtpShowNode = WtpShowNode->next;

			if(WtpShowNode == NULL)
				break;

			vty_out(vty,"    ========================WTPInformation============================     \n");
			vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
			vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
			WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
			WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
			
			vty_out(vty,"wtp_radio_num:   %-5d  \t\t\t",WtpShowNode->wtp_radio_num);
			vty_out(vty,"wifi snr max:   %-5d  \n",WtpShowNode->wirelessIfHighestRxSignalStrength);
			vty_out(vty,"wifi snr avg:   %-5d  \t\t\t\t",WtpShowNode->wirelessIfAvgRxSignalStrength);
			if(WtpShowNode->wirelessIfLowestRxSignalStrength == 100){
				vty_out(vty,"wifi snr min:	0\n");
			}
			else{
				vty_out(vty,"wifi snr min:	%d\n",WtpShowNode->wirelessIfLowestRxSignalStrength);
			}
			
			vty_out(vty,"TxDataPkts:   %-5d  \t\t\t\t",WtpShowNode->wirelessIfTxDataPkts);
			vty_out(vty,"RxDataPkts:   %-5d  \n",WtpShowNode->wirelessIfRxDataPkts);
			vty_out(vty,"UplinkDataOctets:   %-5llu  \t\t\t",WtpShowNode->wirelessIfUplinkDataOctets);
			
			vty_out(vty,"DwlinkDataOctets:   %-5llu  \n",WtpShowNode->wirelessIfDwlinkDataOctets);
			vty_out(vty,"ChStatsPhyErrPkts:   %-5d  \t\t\t",WtpShowNode->wirelessIfChStatsPhyErrPkts);
			vty_out(vty,"ChStatsMacFcsErrPkts:   %-5d  \n",WtpShowNode->wirelessIfChStatsMacFcsErrPkts);
			
			vty_out(vty,"ChStatsMacMicErrPkts:   %-5d  \t\t\t",WtpShowNode->wirelessIfChStatsMacMicErrPkts);
			vty_out(vty,"ChStatsMacDecryptErrPkts:   %-5d  \n",WtpShowNode->wirelessIfChStatsMacDecryptErrPkts);
			vty_out(vty,"ChStatsFrameErrorCnt:   %-5d  \t\t\t",WtpShowNode->wirelessIfChStatsFrameErrorCnt);

			vty_out(vty,"TxSignalPkts:	 %-5d  \n",WtpShowNode->wirelessIfTxSignalPkts);
			vty_out(vty,"RxSignalPkts:	 %-5d  \t\t\t",WtpShowNode->wirelessIfRxSignalPkts);
			vty_out(vty,"ChStatsFrameRetryCnt:	 %-5d  \n",WtpShowNode->wirelessIfChStatsFrameRetryCnt);
			vty_out(vty,"ChStatsDwlinkTotRetryPkts:	 %-5d  \t",WtpShowNode->wirelessIfChStatsDwlinkTotRetryPkts);
			vty_out(vty,"asd_radio_num: %d\n",WtpShowNode->asd_radio_num);
			vty_out(vty,"-------------------------------------------------------------------------\n");
			
			struct NewWtpWirelessIfstatsInfo_radio *sub_radio = NULL;
			for(j=0;j<WtpShowNode->wtp_radio_num;j++){
				if(sub_radio == NULL)
					sub_radio = WtpShowNode->NewWtpWirelessIfstatsInfo_radio_head;
				else 
					sub_radio = sub_radio->next;

				if(sub_radio == NULL){
					vty_out(vty,"break\n");
					break;
				}
				
				vty_out(vty,"------------------------radio information:------------------------------- \n");
				vty_out(vty,"local_radioid:  %-5d  \t\t\t\t",(sub_radio->wtpWirelessIfIndex+1));
				vty_out(vty,"UpdownTimes:  %-5d  \n",sub_radio->wirelessIfUpdownTimes);

				vty_out(vty,"ChStatsUplinkUniFrameCnt:  %-5llu  \t\t",sub_radio->wirelessIfChStatsUplinkUniFrameCnt);
				vty_out(vty,"ChStatsDwlinkUniFrameCnt:  %-5llu  \n",sub_radio->wirelessIfChStatsDwlinkUniFrameCnt);
				vty_out(vty,"UpChStatsFrameNonUniFrameCnt:  %-5d  \t\t",sub_radio->wirelessIfUpChStatsFrameNonUniFrameCnt);
				vty_out(vty,"DownChStatsFrameNonUniFrameCnt:  %-5d  \n",sub_radio->wirelessIfDownChStatsFrameNonUniFrameCnt);

				vty_out(vty,"wirelessIfRxMgmtFrameCnt:  %-5d	\t",sub_radio->wirelessIfRxMgmtFrameCnt);
				vty_out(vty,"wirelessIfRxCtrlFrameCnt:  %-5d	\n",sub_radio->wirelessIfRxCtrlFrameCnt);
				vty_out(vty,"wirelessIfRxDataFrameCnt:  %-5d	\t",sub_radio->wirelessIfRxDataFrameCnt);
				vty_out(vty,"wirelessIfRxAuthenFrameCnt:  %-5d	\n",sub_radio->wirelessIfRxAuthenFrameCnt);
				vty_out(vty,"wirelessIfRxAssociateFrameCnt:  %-5d	\t",sub_radio->wirelessIfRxAssociateFrameCnt);
				
				vty_out(vty,"wirelessIfTxMgmtFrameCnt:  %-5d	\n",sub_radio->wirelessIfTxMgmtFrameCnt);
				vty_out(vty,"wirelessIfTxCtrlFrameCnt:  %-5d	\t",sub_radio->wirelessIfTxCtrlFrameCnt);
				vty_out(vty,"wirelessIfTxDataFrameCnt:  %-5d	\n",sub_radio->wirelessIfTxDataFrameCnt);
				vty_out(vty,"wirelessIfTxAuthenFrameCnt:  %-5d	\t",sub_radio->wirelessIfTxAuthenFrameCnt);
				vty_out(vty,"wirelessIfTxAssociateFrameCnt:  %-5d	\n",sub_radio->wirelessIfTxAssociateFrameCnt);
				
				vty_out(vty,"wirelessIfChStatsNumStations:  %-5d	\n",sub_radio->wirelessIfChStatsNumStations);
				
				vty_out(vty,"radioWlanNum:  %-5d  \n",sub_radio->radioWlanNum);
				for(k=0;k< sub_radio->radioWlanNum;k++){
					vty_out(vty,"Wlan:  %-5d  \n",sub_radio->radioBindWlan[k]);
				}
			}
		}
		vty_out(vty,"========================================================================== \n");
	}

	else if (ret == WID_DBUS_ERROR){
		cli_syslog_info("<error> failed get reply.\n");
	}
	else if(ret == WTP_ID_NOT_EXIST){
		vty_out(vty,"<error> There is no WTP now.\n");
	}
	else{
		vty_out(vty,"<error> ret = %d\n",ret);
	}

	dcli_free_new_wtp_wireless_ifstats_Info(WtpHead);
#endif
	return CMD_SUCCESS;
}

/*add for table 29 ,dot11RogueAPTable : showing wtp RogueAPInfo  by nl 20100610 b20*/
DEFUN(show_all_wtp_rogue_ap_info_information_func,
		show_all_wtp_rogue_ap_info_information_cmd,
	  "show the rogue_ap information_of all_wtp [remote] [local] [PARAMETER]",
	  SHOW_STR
	  "rogue_ap information\n"
	  "Display  rogue ap information of all wtps\n"
	  "List wtp rogue ap information\n"
	  "by wtp display  rogue ap information\n"
	  "'remote' or 'local' hansi\n"
	  "'remote' or 'local' hansi\n"
	  "slotid-instid\n"
	 )
{
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	struct RogueAPInfo *WtpHead = NULL;
	struct RogueAPInfo *WtpShowNode = NULL;
	int ret=0;
	int i=0;
	int j=0;
	int profile = 0;
	int instRun = 0;
	int flag = 0;
	unsigned int num = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	
	if((argc == 1)||(argc == 3)){
		vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
		return CMD_SUCCESS;
	}
	if(argc == 2){
		if (!strcmp(argv[0],"remote")){
			localid = 0;
		}else if(!strcmp(argv[0],"local")){
			localid = 1;
		}else{
			vty_out(vty,"parameter should be 'remote' or 'local'\n");
			return CMD_SUCCESS;
		}
		
		if((!strcmp(argv[0],"remote"))&&(!strcmp(argv[1],"local"))){
			vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
			return CMD_SUCCESS;
		}
		
		ret = parse_slot_hansi_id((char*)argv[1],&slot_id,&profile);
		if(ret != WID_DBUS_SUCCESS){
			slot_id = HostSlotId;
			flag = 1;
			ret = parse_int_ID((char*)argv[1], &profile);
			if(ret != WID_DBUS_SUCCESS){
				if(ret == WID_ILLEGAL_INPUT){
					vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
				}
				else{
					vty_out(vty,"<error> unknown id format\n");
				}
				return CMD_WARNING;
			}	
		}
		if(distributFag == 0){
			if(slot_id != 0){
				vty_out(vty,"<error> slot id should be 0\n");
				return CMD_WARNING;
			}	
		}else if(flag == 1){
			slot_id = HostSlotId;
		}
		if(slot_id >= MAX_SLOT_NUM || slot_id < 0){
			vty_out(vty,"<error> slot id should be 1 to %d\n",MAX_SLOT_NUM-1);
			return CMD_WARNING;
		}	
		if(profile >= MAX_INSTANCE || profile == 0){
			vty_out(vty,"<error> hansi id should be 1 to %d\n",MAX_INSTANCE-1);
			return CMD_WARNING;
		}
		instRun = dcli_hmd_hansi_is_running(vty,slot_id,localid,profile);
		if (INSTANCE_NO_CREATED == instRun) {
			vty_out(vty,"<error> the instance %s %d-%d is not running\n",((localid == 1)?"local-hansi":"hansi"),slot_id,profile);
			return CMD_WARNING;
		}
		
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		if(localid == 0)
			goto hansi_parameter;
		else if(localid == 1)
			goto local_hansi_parameter; 
	}

	if(vty->node != VIEW_NODE){
		WtpHead = show_RogueAPInfo_of_all_wtp(index,localid,dcli_dbus_connection, &num, &ret);

		if((WtpHead!=NULL)&&(ret == 0)){
			vty_out(vty,"WTPNum:%-5d  \n",num);
			vty_out(vty,"========================================================================== \n");
			
			for (i = 0; i < num; i++) {	
				if(WtpShowNode == NULL)
					WtpShowNode = WtpHead->RogueAPInfo_list;
				else 
					WtpShowNode = WtpShowNode->next;

				if(WtpShowNode == NULL){
					vty_out(vty,"break    ");
					break;
				}
				vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
				vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
				WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
				WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
				vty_out(vty,"rogue_ap_num:   %-5d  \n",WtpShowNode->rogue_ap_num);

				vty_out(vty,"-------------------------------------------------------------------------\n");
				vty_out(vty,"%-17s %-4s %-7s %-4s %-5s %-7s %-5s %-12s %-10s\n","mac","rate","channel","rssi","noise","bea_int","capab","essid","ie_info");

				struct Sub_RogueAPInfo *sub_node = NULL;
				for(j=0;j<WtpShowNode->rogue_ap_num;j++){
								
					if(sub_node == NULL)
						sub_node = WtpShowNode->Sub_RogueAPInfo_head;
					else 
						sub_node = sub_node->next;

					if(sub_node == NULL){
						vty_out(vty,"break\n");
						break;
					}
					
					vty_out(vty,"%02X:%02X:%02X:%02X:%02X:%02X %-4d %-7d %-4d %-5d %-7d %-5d %-12s %-9s\n",\
					sub_node->rogueAPMac[0],sub_node->rogueAPMac[1],sub_node->rogueAPMac[2],\
					sub_node->rogueAPMac[3],sub_node->rogueAPMac[4],sub_node->rogueAPMac[5],\
					sub_node->rogueAPRate,sub_node->rogueAPChannel,sub_node->rogueAPRssi,\
					sub_node->rogueAPNoise,sub_node->rogueAPBeaconInterval,\
					sub_node->rogueAPCapability,sub_node->rogueAPEssid,sub_node->rogueAPElemInfo);
				}
				
				vty_out(vty,"-------------------------------------------------------------------------\n");
				
				sub_node = NULL;

				for(j=0;j<WtpShowNode->rogue_ap_num;j++){
					if(sub_node == NULL)
						sub_node = WtpShowNode->Sub_RogueAPInfo_head;
					else 
						sub_node = sub_node->next;

					if(sub_node == NULL){
						vty_out(vty,"break\n");
						break;
					}

					vty_out(vty,"------------------------rogue ap information:------------------------------- \n");
					vty_out(vty,"WTP BSSID:  %02X:%02X:%02X:%02X:%02X:%02X \n",
					sub_node->rogueAPMac[0],sub_node->rogueAPMac[1],
					sub_node->rogueAPMac[2],sub_node->rogueAPMac[3],
					sub_node->rogueAPMac[4],sub_node->rogueAPMac[5]);
					vty_out(vty,"rogueAPIndex:  %-5d  \n",sub_node->rogueAPIndex);
					vty_out(vty,"rogueAPRate:  %-5d  \t\t\t\t",(sub_node->rogueAPRate));
					vty_out(vty,"rogueAPChannel:  %-5d  \n",sub_node->rogueAPChannel);
					
					vty_out(vty,"rogueAPRssi:  %-5d  \t\t\t\t",(sub_node->rogueAPRssi));
					vty_out(vty,"rogueAPNoise:  %-5d  \n",sub_node->rogueAPNoise);
					vty_out(vty,"rogueAPBeaconInterval:  %-5d  \t\t\t",(sub_node->rogueAPBeaconInterval));
					vty_out(vty,"rogueAPCapability:  %-5d  \n",sub_node->rogueAPCapability);

					vty_out(vty,"rogueAPEssid:  %-7s  \t\t\t",(sub_node->rogueAPEssid));
					vty_out(vty,"rogueAPElemInfo:  %s  \n",sub_node->rogueAPElemInfo);
					vty_out(vty,"\n  ");
				}
				sub_node = NULL;
				vty_out(vty,"-------------------------------------------------------------------------\n");
			}
			vty_out(vty,"========================================================================== \n");
		}

		else if (ret == WID_DBUS_ERROR){
			cli_syslog_info("<error> failed get reply.\n");
		}
		else if(ret == WTP_ID_NOT_EXIST){
			vty_out(vty,"<error> There is no WTP now.\n");
		}
		else if(ret == WID_AP_SCANNING_DISABLE){
			vty_out(vty,"<error> ap scanning disable ,please enable it.\n");
		}
		else if(ret == WTP_NO_NEIGHBORAP){
			vty_out(vty,"<error> no ap has neighbor ap.\n");
		}
		else{
			vty_out(vty,"<error> ret = %d\n",ret);
		}
		
		dcli_free_wtp_RogueAPInfo_Info(WtpHead);
	}

	if(vty->node == VIEW_NODE){
		//for remote hansi info
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 0;
			
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,0,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}

		hansi_parameter:
				WtpHead = show_RogueAPInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &num, &ret);

				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"hansi %d-%d\n",slot_id,profile);
				vty_out(vty,"-----------------------------------------------------------------------------\n");
				if((WtpHead!=NULL)&&(ret == 0)){
					vty_out(vty,"WTPNum:%-5d  \n",num);
					vty_out(vty,"========================================================================== \n");
					
					WtpShowNode = NULL;
					for (i = 0; i < num; i++) {	
						if(WtpShowNode == NULL)
							WtpShowNode = WtpHead->RogueAPInfo_list;
						else 
							WtpShowNode = WtpShowNode->next;

						if(WtpShowNode == NULL){
							break;
						}
						vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
						vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
						WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
						WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
						vty_out(vty,"rogue_ap_num:   %-5d  \n",WtpShowNode->rogue_ap_num);

						vty_out(vty,"-------------------------------------------------------------------------\n");
						vty_out(vty,"%-17s %-4s %-7s %-4s %-5s %-7s %-5s %-12s %-10s\n","mac","rate","channel","rssi","noise","bea_int","capab","essid","ie_info");

						struct Sub_RogueAPInfo *sub_node = NULL;
						for(j=0;j<WtpShowNode->rogue_ap_num;j++){
										
							if(sub_node == NULL)
								sub_node = WtpShowNode->Sub_RogueAPInfo_head;
							else 
								sub_node = sub_node->next;

							if(sub_node == NULL){
								vty_out(vty,"break\n");
								break;
							}
							
							vty_out(vty,"%02X:%02X:%02X:%02X:%02X:%02X %-4d %-7d %-4d %-5d %-7d %-5d %-12s %-9s\n",\
							sub_node->rogueAPMac[0],sub_node->rogueAPMac[1],sub_node->rogueAPMac[2],\
							sub_node->rogueAPMac[3],sub_node->rogueAPMac[4],sub_node->rogueAPMac[5],\
							sub_node->rogueAPRate,sub_node->rogueAPChannel,sub_node->rogueAPRssi,\
							sub_node->rogueAPNoise,sub_node->rogueAPBeaconInterval,\
							sub_node->rogueAPCapability,sub_node->rogueAPEssid,sub_node->rogueAPElemInfo);
						}
						
						vty_out(vty,"-------------------------------------------------------------------------\n");
						
						sub_node = NULL;

						for(j=0;j<WtpShowNode->rogue_ap_num;j++){
							if(sub_node == NULL)
								sub_node = WtpShowNode->Sub_RogueAPInfo_head;
							else 
								sub_node = sub_node->next;

							if(sub_node == NULL){
								vty_out(vty,"break\n");
								break;
							}

							vty_out(vty,"------------------------rogue ap information:------------------------------- \n");
							vty_out(vty,"WTP BSSID:  %02X:%02X:%02X:%02X:%02X:%02X \n",
							sub_node->rogueAPMac[0],sub_node->rogueAPMac[1],
							sub_node->rogueAPMac[2],sub_node->rogueAPMac[3],
							sub_node->rogueAPMac[4],sub_node->rogueAPMac[5]);
							vty_out(vty,"rogueAPIndex:  %-5d  \n",sub_node->rogueAPIndex);
							vty_out(vty,"rogueAPRate:  %-5d  \t\t\t\t",(sub_node->rogueAPRate));
							vty_out(vty,"rogueAPChannel:  %-5d  \n",sub_node->rogueAPChannel);
							
							vty_out(vty,"rogueAPRssi:  %-5d  \t\t\t\t",(sub_node->rogueAPRssi));
							vty_out(vty,"rogueAPNoise:  %-5d  \n",sub_node->rogueAPNoise);
							vty_out(vty,"rogueAPBeaconInterval:  %-5d  \t\t\t",(sub_node->rogueAPBeaconInterval));
							vty_out(vty,"rogueAPCapability:  %-5d  \n",sub_node->rogueAPCapability);

							vty_out(vty,"rogueAPEssid:  %-7s  \t\t\t",(sub_node->rogueAPEssid));
							vty_out(vty,"rogueAPElemInfo:  %s  \n",sub_node->rogueAPElemInfo);
							vty_out(vty,"\n  ");
						}
						sub_node = NULL;
						vty_out(vty,"-------------------------------------------------------------------------\n");
					}
				}

				else if (ret == WID_DBUS_ERROR){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == WTP_ID_NOT_EXIST){
					vty_out(vty,"<error> There is no WTP now.\n");
				}
				else if(ret == WID_AP_SCANNING_DISABLE){
					vty_out(vty,"<error> ap scanning disable ,please enable it.\n");
				}
				else if(ret == WTP_NO_NEIGHBORAP){
					vty_out(vty,"<error> no ap has neighbor ap.\n");
				}
				else{
					vty_out(vty,"<error> ret = %d\n",ret);
				}
				
				dcli_free_wtp_RogueAPInfo_Info(WtpHead);
				vty_out(vty,"==============================================================================\n");
				if(argc == 2){
					return CMD_SUCCESS;
				}
			}
		}

	//for local hansi info
	for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		localid = 1;
		
		for (profile = 1; profile < MAX_INSTANCE; profile++) 
		{
			instRun = dcli_hmd_hansi_is_running(vty,slot_id,1,profile);
			if (INSTANCE_NO_CREATED == instRun) {
				continue;
			}
	
		local_hansi_parameter:
			WtpHead = show_RogueAPInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &num, &ret);

			vty_out(vty,"==============================================================================\n");
			vty_out(vty,"local hansi %d-%d\n",slot_id,profile);
			vty_out(vty,"-----------------------------------------------------------------------------\n");
			if((WtpHead!=NULL)&&(ret == 0)){
				vty_out(vty,"WTPNum:%-5d  \n",num);
				vty_out(vty,"========================================================================== \n");
				
				WtpShowNode = NULL;
				for (i = 0; i < num; i++) {	
					if(WtpShowNode == NULL)
						WtpShowNode = WtpHead->RogueAPInfo_list;
					else 
						WtpShowNode = WtpShowNode->next;

					if(WtpShowNode == NULL){
						break;
					}
					vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
					vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
					WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
					WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
					vty_out(vty,"rogue_ap_num:   %-5d  \n",WtpShowNode->rogue_ap_num);

					vty_out(vty,"-------------------------------------------------------------------------\n");
					vty_out(vty,"%-17s %-4s %-7s %-4s %-5s %-7s %-5s %-12s %-10s\n","mac","rate","channel","rssi","noise","bea_int","capab","essid","ie_info");

					struct Sub_RogueAPInfo *sub_node = NULL;
					for(j=0;j<WtpShowNode->rogue_ap_num;j++){
									
						if(sub_node == NULL)
							sub_node = WtpShowNode->Sub_RogueAPInfo_head;
						else 
							sub_node = sub_node->next;

						if(sub_node == NULL){
							vty_out(vty,"break\n");
							break;
						}
						
						vty_out(vty,"%02X:%02X:%02X:%02X:%02X:%02X %-4d %-7d %-4d %-5d %-7d %-5d %-12s %-9s\n",\
						sub_node->rogueAPMac[0],sub_node->rogueAPMac[1],sub_node->rogueAPMac[2],\
						sub_node->rogueAPMac[3],sub_node->rogueAPMac[4],sub_node->rogueAPMac[5],\
						sub_node->rogueAPRate,sub_node->rogueAPChannel,sub_node->rogueAPRssi,\
						sub_node->rogueAPNoise,sub_node->rogueAPBeaconInterval,\
						sub_node->rogueAPCapability,sub_node->rogueAPEssid,sub_node->rogueAPElemInfo);
					}
					
					vty_out(vty,"-------------------------------------------------------------------------\n");
					
					sub_node = NULL;

					for(j=0;j<WtpShowNode->rogue_ap_num;j++){
						if(sub_node == NULL)
							sub_node = WtpShowNode->Sub_RogueAPInfo_head;
						else 
							sub_node = sub_node->next;

						if(sub_node == NULL){
							vty_out(vty,"break\n");
							break;
						}

						vty_out(vty,"------------------------rogue ap information:------------------------------- \n");
						vty_out(vty,"WTP BSSID:  %02X:%02X:%02X:%02X:%02X:%02X \n",
						sub_node->rogueAPMac[0],sub_node->rogueAPMac[1],
						sub_node->rogueAPMac[2],sub_node->rogueAPMac[3],
						sub_node->rogueAPMac[4],sub_node->rogueAPMac[5]);
						vty_out(vty,"rogueAPIndex:  %-5d  \n",sub_node->rogueAPIndex);
						vty_out(vty,"rogueAPRate:  %-5d  \t\t\t\t",(sub_node->rogueAPRate));
						vty_out(vty,"rogueAPChannel:  %-5d  \n",sub_node->rogueAPChannel);
						
						vty_out(vty,"rogueAPRssi:  %-5d  \t\t\t\t",(sub_node->rogueAPRssi));
						vty_out(vty,"rogueAPNoise:  %-5d  \n",sub_node->rogueAPNoise);
						vty_out(vty,"rogueAPBeaconInterval:  %-5d  \t\t\t",(sub_node->rogueAPBeaconInterval));
						vty_out(vty,"rogueAPCapability:  %-5d  \n",sub_node->rogueAPCapability);

						vty_out(vty,"rogueAPEssid:  %-7s  \t\t\t",(sub_node->rogueAPEssid));
						vty_out(vty,"rogueAPElemInfo:  %s  \n",sub_node->rogueAPElemInfo);
						vty_out(vty,"\n  ");
					}
					sub_node = NULL;
					vty_out(vty,"-------------------------------------------------------------------------\n");
				}
			}

			else if (ret == WID_DBUS_ERROR){
				cli_syslog_info("<error> failed get reply.\n");
			}
			else if(ret == WTP_ID_NOT_EXIST){
				vty_out(vty,"<error> There is no WTP now.\n");
			}
			else if(ret == WID_AP_SCANNING_DISABLE){
				vty_out(vty,"<error> ap scanning disable ,please enable it.\n");
			}
			else if(ret == WTP_NO_NEIGHBORAP){
				vty_out(vty,"<error> no ap has neighbor ap.\n");
			}
			else{
				vty_out(vty,"<error> ret = %d\n",ret);
			}
			
			dcli_free_wtp_RogueAPInfo_Info(WtpHead);
			vty_out(vty,"==============================================================================\n");
			if(argc == 2){
				return CMD_SUCCESS;
			}
			}
		}
	}
	
	return CMD_SUCCESS;
}
DEFUN(show_ath_statistics_info_of_all_wtp_func,
	show_ath_statistics_info_of_all_wtp_cmd,
	"show ath statistcs information of all wtp",
	"show ath statistcs information of all wtp\n")
{
	struct WtpAthStatisticInfo * WtpHead = NULL;
	struct WtpAthStatisticInfo * WtpNode = NULL;

	int ret =0;
	unsigned int wtp_num=0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index=0;
	
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	WtpHead = show_ath_statistics_info_of_all_wtp(index,localid,dcli_dbus_connection,&wtp_num,&ret);

	if(WtpHead && (ret==0)){
		WtpNode=WtpHead;
		vty_out(vty,"WTP NUMS : %d \n",wtp_num);
		vty_out(vty,"=================================================================\n");
		while(WtpNode){
			vty_out(vty,"-----------------------------------------------------------------\n");
			vty_out(vty,"wtpCurrID:%d \n",WtpNode->wtpCurrID);
			vty_out(vty,"wtpMacAddr:%s \n",WtpNode->wtpMacAddr);
			vty_out(vty,"wtpwirelessifindex:%d \n",WtpNode->wtpwirelessifindex);
			vty_out(vty,"wlanid:%d \n",WtpNode->wlanid);
			vty_out(vty,"wirelessIfUpdownTimes:%u \n",WtpNode->wirelessIfUpdownTimes);
			vty_out(vty,"wirelessIfTxSignalPkts:%u \n",WtpNode->wirelessIfTxSignalPkts);
			vty_out(vty,"wirelessIfRxSignalPkts:%u \n",WtpNode->wirelessIfRxSignalPkts);
			
			vty_out(vty,"wirelessIfTxDataPkts:%u \n",WtpNode->wirelessIfTxDataPkts);
			vty_out(vty,"wirelessIfRxDataPkts:%u \n",WtpNode->wirelessIfRxDataPkts);
			vty_out(vty,"wirelessIfUplinkDataOctets:%llu \n",WtpNode->wirelessIfUplinkDataOctets);  //fengwenchao change  %d to %llu 0
			vty_out(vty,"wirelessIfDwlinkDataOctets:%llu \n",WtpNode->wirelessIfDwlinkDataOctets);  //fengwenchao change  %d to %llu 0
			vty_out(vty,"wirelessIfChStatsDwlinkTotRetryPkts:%u \n",WtpNode->wirelessIfChStatsDwlinkTotRetryPkts);
			vty_out(vty,"wirelessIfChStatsFrameRetryCnt:%u \n",WtpNode->wirelessIfChStatsFrameRetryCnt);

			vty_out(vty,"wirelessifUplinkUniPktCnt:%u \n",WtpNode->wirelessifUplinkUniPktCnt);
			vty_out(vty,"wirelessifDwlinkUniPktCnt:%u \n",WtpNode->wirelessifDwlinkUniPktCnt);
			vty_out(vty,"wirelessifUpNonUniPktCnt:%u \n",WtpNode->wirelessifUpNonUniPktCnt);
			vty_out(vty,"wirelessifDownNonUniPktCnt:%u \n",WtpNode->wirelessifDownNonUniPktCnt);
			vty_out(vty,"wirelessIfUplinkTotFrameCnt:%llu \n",WtpNode->wirelessIfUplinkTotFrameCnt);
			vty_out(vty,"wirelessIfDwlinkTotFrameCnt:%llu \n",WtpNode->wirelessIfDwlinkTotFrameCnt);
			vty_out(vty,"wirelessifFrameFragRate:%u \n",WtpNode->wirelessifFrameFragRate);

			vty_out(vty,"wirelessifRxCtrlFrameCnt:%u \n",WtpNode->wirelessifRxCtrlFrameCnt);
			vty_out(vty,"wirelessifRxDataFrameCnt:%u \n",WtpNode->wirelessifRxDataFrameCnt);
			vty_out(vty,"wirelessifRxAuthenFrameCnt:%u \n",WtpNode->wirelessifRxAuthenFrameCnt);
			vty_out(vty,"wirelessifRxAssociateFrameCnt:%u \n",WtpNode->wirelessifRxAssociateFrameCnt);
			vty_out(vty,"wirelessIfRxMgmtFrameCnt:%u \n",WtpNode->wirelessIfRxMgmtFrameCnt);//zhaoruijia,0902,  
			vty_out(vty,"wirelessifTxCtrlFrameCnt:%u \n",WtpNode->wirelessifTxCtrlFrameCnt);

			vty_out(vty,"wirelessifTxDataFrameCnt:%u \n",WtpNode->wirelessifTxDataFrameCnt);
			
			vty_out(vty,"wirelessIfTxMgmtFrameCnt:%u \n",WtpNode->wirelessIfTxMgmtFrameCnt);//zhaoruijia,0902,
			vty_out(vty,"wirelessifTxAuthenFrameCnt:%u \n",WtpNode->wirelessifTxAuthenFrameCnt);
			vty_out(vty,"wirelessifTxAssociateFrameCnt:%u \n",WtpNode->wirelessifTxAssociateFrameCnt);		
			vty_out(vty,"wirelessIfSuccAssociatedNum:%u \n",WtpNode->wirelessIfSuccAssociatedNum);
			vty_out(vty,"wirelessIfAssociatedUserNum:%u \n",WtpNode->wirelessIfAssociatedUserNum);
			vty_out(vty,"wirelessifNumStations:%u \n",WtpNode->wirelessifNumStations);
			vty_out(vty,"wirelessifUplinkCtrlOctets:%u \n",WtpNode->wirelessifUplinkCtrlOctets);
			vty_out(vty,"wirelessifDownlinkCtrlOctets:%u \n",WtpNode->wirelessifDownlinkCtrlOctets);

			vty_out(vty,"wirelessIfChStatsMacFcsErrPkts:%u \n",WtpNode->wirelessIfChStatsMacFcsErrPkts);
			vty_out(vty,"wirelessIfChStatsMacMicErrPkts:%u \n",WtpNode->wirelessIfChStatsMacMicErrPkts);
			vty_out(vty,"wirelessIfChStatsMacDecryptErrPkts:%u \n",WtpNode->wirelessIfChStatsMacDecryptErrPkts);
			vty_out(vty,"wirelessIfChStatsFrameErrorCnt:%u \n",WtpNode->wirelessIfChStatsFrameErrorCnt);

			vty_out(vty,"wirelessIfChStatsPhyErrPkts:%u \n",WtpNode->wirelessIfChStatsPhyErrPkts);	//fengwenchao add 20101228	
			vty_out(vty,"wirelessIfAvgRxSignalStrength:%-5g \n",WtpNode->wirelessIfAvgRxSignalStrength);	 //fengwenchao add	 AP
			vty_out(vty,"wirelessIfHighestRxSignalStrength:%-5d \n",WtpNode->wirelessIfHighestRxSignalStrength2); //fengwenchao add   AP
			vty_out(vty,"wirelessIfLowestRxSignalStrength:%-15d \n",WtpNode->wirelessIfLowestRxSignalStrength2);  //fengwenchao add   AP


			WtpNode=WtpNode->next;
			}
		dcli_free_WtpAthStatisticInfo(WtpHead);
		vty_out(vty,"=================================================================\n");
		}
	else if(ret == 0 && WtpHead == NULL){
		vty_out(vty,"<error> there is no ath interface\n");
		}
	else if(ret == WID_DBUS_ERROR ||ret == ASD_DBUS_ERROR){
		vty_out(vty,"<error> dbus failed get reply.\n");
		}
	else if(ret == WTP_ID_NOT_EXIST){
		vty_out(vty,"<error> WID can't find wtp\n");
		}
	else if(ret == ASD_BSS_NOT_EXIST){
		vty_out(vty,"<error> ASD can't find bss\n");
		}
	else{
		vty_out(vty,"<error> ret = %d \n",ret);
		}
	return CMD_SUCCESS;
}

/*add for showing table dot11SecurityMechTable :SecurityMechInfo  20100618 by nl b21*/
DEFUN(show_all_wtp_security_mech_information_func,
	  show_all_wtp_security_mech_information_cmd,
	  "show the security basic_information of_all_wtp [remote] [local] [PARAMETER]",
	  SHOW_STR
	  "security basic info\n"
	  "Display security basic information of all wtps\n"
	  "List security basic information\n"
	  "by wtp display security basic information\n"
	  "'remote' or 'local' hansi\n"
	  "'remote' or 'local' hansi\n"
	  "slotid-instid\n"
	 )
{
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	struct SecurityMechInfo *WtpHead = NULL;
	struct SecurityMechInfo *WtpShowNode = NULL;
	int ret=0;
	int i=0;
	int j=0;
	int profile = 0;
	int instRun = 0;
	int flag = 0;
	unsigned int wtp_num = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	
	if((argc == 1)||(argc == 3)){
		vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
		return CMD_SUCCESS;
	}
	if(argc == 2){
		if (!strcmp(argv[0],"remote")){
			localid = 0;
		}else if(!strcmp(argv[0],"local")){
			localid = 1;
		}else{
			vty_out(vty,"parameter should be 'remote' or 'local'\n");
			return CMD_SUCCESS;
		}
		
		if((!strcmp(argv[0],"remote"))&&(!strcmp(argv[1],"local"))){
			vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
			return CMD_SUCCESS;
		}
		
		ret = parse_slot_hansi_id((char*)argv[1],&slot_id,&profile);
		if(ret != WID_DBUS_SUCCESS){
			slot_id = HostSlotId;
			flag = 1;
			ret = parse_int_ID((char*)argv[1], &profile);
			if(ret != WID_DBUS_SUCCESS){
				if(ret == WID_ILLEGAL_INPUT){
					vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
				}
				else{
					vty_out(vty,"<error> unknown id format\n");
				}
				return CMD_WARNING;
			}	
		}
		if(distributFag == 0){
			if(slot_id != 0){
				vty_out(vty,"<error> slot id should be 0\n");
				return CMD_WARNING;
			}	
		}else if(flag == 1){
			slot_id = HostSlotId;
		}
		if(slot_id >= MAX_SLOT_NUM || slot_id < 0){
			vty_out(vty,"<error> slot id should be 1 to %d\n",MAX_SLOT_NUM-1);
			return CMD_WARNING;
		}	
		if(profile >= MAX_INSTANCE || profile == 0){
			vty_out(vty,"<error> hansi id should be 1 to %d\n",MAX_INSTANCE-1);
			return CMD_WARNING;
		}
		instRun = dcli_hmd_hansi_is_running(vty,slot_id,localid,profile);
		if (INSTANCE_NO_CREATED == instRun) {
			vty_out(vty,"<error> the instance %s %d-%d is not running\n",((localid == 1)?"local-hansi":"hansi"),slot_id,profile);
			return CMD_WARNING;
		}
		
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		if(localid == 0)
			goto hansi_parameter;
		else if(localid == 1)
			goto local_hansi_parameter; 
	}

	if(vty->node != VIEW_NODE){
		WtpHead = show_SecurityMechInfo_of_all_wtp(index,localid,dcli_dbus_connection, &wtp_num, &ret);
		
		if((WtpHead!=NULL)&&(ret == 0)){
				struct Sub_SecurityMechInfo *sub_wlan = NULL;
				vty_out(vty,"WTPNum:%-5d  \n",wtp_num);
				vty_out(vty,"========================================================================== \n");
				for (i = 0; i < wtp_num; i++) { 
					if(WtpShowNode == NULL)
						WtpShowNode = WtpHead->SecurityMechInfo_list;
					else 
						WtpShowNode = WtpShowNode->next;
		
					if(WtpShowNode == NULL)
						break;
									
					vty_out(vty,"   ***********************WTPInformation************************* 	\n");
					vty_out(vty,"WTPID:   %-5d	\n",WtpShowNode->wtpCurrID);
					vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
					WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
					WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
					
					vty_out(vty,"wlan_num: %d\n",WtpShowNode->wlan_num);
		
					for(j=0;j<WtpShowNode->wlan_num;j++){
						if(sub_wlan == NULL)
							sub_wlan = WtpShowNode->Sub_SecurityMechInfo_head;
						else 
							sub_wlan = sub_wlan->next;
		
						if(sub_wlan == NULL){
							vty_out(vty,"break\n");
							break;
						}

						vty_out(vty,"------------------------wlan information------------------------------- \n");
						vty_out(vty,"wlanSecID:  %-5d  \t\t\t",(sub_wlan->wlanSecID));
						vty_out(vty,"wlanCurrID:  %-5d  \n",sub_wlan->wlanCurrID);
						vty_out(vty,"SecurMechID:	%-5d	\t\t",sub_wlan->wtpWirelessSecurMechID);
						vty_out(vty,"SecurMechType:	%-5d	\n",sub_wlan->wtpWirelessSecurMechType);
						
						vty_out(vty,"SecurMechEncryType:	%-5d	\t",sub_wlan->wtpWirelessSecurMechEncryType);
						vty_out(vty,"SecurMechKeyInputType:  %-5d	\n",sub_wlan->wtpWirelessSecurMechKeyInputType);
						vty_out(vty,"SecurMechName:  %-5s	\t\t",sub_wlan->wtpWirelessSecurMechName);
						vty_out(vty,"SecurMechSecurPolicyKey:%-5s	\n",sub_wlan->wtpWirelessSecurMechSecurPolicyKey);
						vty_out(vty,"\n");
					}
					vty_out(vty,"-------------------------------------------------------------------------\n");
		
				}
				vty_out(vty,"========================================================================== \n");
			}
		
		else if (ret == ASD_DBUS_ERROR){
			cli_syslog_info("<error> failed get reply.\n");
		}
		else if(ret == ASD_WTP_NOT_EXIST){
			vty_out(vty,"<error> There is no WTP now.\n");
		}
		else{
			vty_out(vty,"<error> ret = %d\n",ret);
		}

		dcli_free_SecurityMechInfo(WtpHead);
	}	

	if(vty->node == VIEW_NODE){
		//for remote hansi info
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 0;
			
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,0,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}

		hansi_parameter:
				WtpHead = show_SecurityMechInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &wtp_num, &ret);
				
				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"hansi %d-%d\n",slot_id,profile);
				vty_out(vty,"-----------------------------------------------------------------------------\n");
				if((WtpHead!=NULL)&&(ret == 0)){
						struct Sub_SecurityMechInfo *sub_wlan = NULL;
						vty_out(vty,"WTPNum:%-5d  \n",wtp_num);
						vty_out(vty,"========================================================================== \n");
						WtpShowNode = NULL;
						for (i = 0; i < wtp_num; i++) { 
							if(WtpShowNode == NULL)
								WtpShowNode = WtpHead->SecurityMechInfo_list;
							else 
								WtpShowNode = WtpShowNode->next;
				
							if(WtpShowNode == NULL)
								break;
											
							vty_out(vty,"   ***********************WTPInformation************************* 	\n");
							vty_out(vty,"WTPID:   %-5d	\n",WtpShowNode->wtpCurrID);
							vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
							WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
							WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
							
							vty_out(vty,"wlan_num: %d\n",WtpShowNode->wlan_num);
				
							for(j=0;j<WtpShowNode->wlan_num;j++){
								if(sub_wlan == NULL)
									sub_wlan = WtpShowNode->Sub_SecurityMechInfo_head;
								else 
									sub_wlan = sub_wlan->next;
				
								if(sub_wlan == NULL){
									vty_out(vty,"break\n");
									break;
								}

								vty_out(vty,"------------------------wlan information------------------------------- \n");
								vty_out(vty,"wlanSecID:  %-5d  \t\t\t",(sub_wlan->wlanSecID));
								vty_out(vty,"wlanCurrID:  %-5d  \n",sub_wlan->wlanCurrID);
								vty_out(vty,"SecurMechID:	%-5d	\t\t",sub_wlan->wtpWirelessSecurMechID);
								vty_out(vty,"SecurMechType:	%-5d	\n",sub_wlan->wtpWirelessSecurMechType);
								
								vty_out(vty,"SecurMechEncryType:	%-5d	\t",sub_wlan->wtpWirelessSecurMechEncryType);
								vty_out(vty,"SecurMechKeyInputType:  %-5d	\n",sub_wlan->wtpWirelessSecurMechKeyInputType);
								vty_out(vty,"SecurMechName:  %-5s	\t\t",sub_wlan->wtpWirelessSecurMechName);
								vty_out(vty,"SecurMechSecurPolicyKey:%-5s	\n",sub_wlan->wtpWirelessSecurMechSecurPolicyKey);
								vty_out(vty,"\n");
							}
							vty_out(vty,"-------------------------------------------------------------------------\n");
				
						}
					}
				
				else if (ret == ASD_DBUS_ERROR){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == ASD_WTP_NOT_EXIST){
					vty_out(vty,"<error> There is no WTP now.\n");
				}
				else{
					vty_out(vty,"<error> ret = %d\n",ret);
				}

				dcli_free_SecurityMechInfo(WtpHead);
				vty_out(vty,"==============================================================================\n");
				if(argc == 2){
					return CMD_SUCCESS;
				}
			}
		}

	//for local hansi info
	for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		localid = 1;
		
		for (profile = 1; profile < MAX_INSTANCE; profile++) 
		{
			instRun = dcli_hmd_hansi_is_running(vty,slot_id,1,profile);
			if (INSTANCE_NO_CREATED == instRun) {
				continue;
			}
	
		local_hansi_parameter:
			WtpHead = show_SecurityMechInfo_of_all_wtp(profile,localid,dcli_dbus_connection, &wtp_num, &ret);
			
			vty_out(vty,"==============================================================================\n");
			vty_out(vty,"local hansi %d-%d\n",slot_id,profile);
			vty_out(vty,"-----------------------------------------------------------------------------\n");
			if((WtpHead!=NULL)&&(ret == 0)){
					struct Sub_SecurityMechInfo *sub_wlan = NULL;
					vty_out(vty,"WTPNum:%-5d  \n",wtp_num);
					vty_out(vty,"========================================================================== \n");
					WtpShowNode = NULL;
					for (i = 0; i < wtp_num; i++) { 
						if(WtpShowNode == NULL)
							WtpShowNode = WtpHead->SecurityMechInfo_list;
						else 
							WtpShowNode = WtpShowNode->next;
			
						if(WtpShowNode == NULL)
							break;
										
						vty_out(vty,"   ***********************WTPInformation************************* 	\n");
						vty_out(vty,"WTPID:   %-5d	\n",WtpShowNode->wtpCurrID);
						vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
						WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
						WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);
						
						vty_out(vty,"wlan_num: %d\n",WtpShowNode->wlan_num);
			
						for(j=0;j<WtpShowNode->wlan_num;j++){
							if(sub_wlan == NULL)
								sub_wlan = WtpShowNode->Sub_SecurityMechInfo_head;
							else 
								sub_wlan = sub_wlan->next;
			
							if(sub_wlan == NULL){
								vty_out(vty,"break\n");
								break;
							}

							vty_out(vty,"------------------------wlan information------------------------------- \n");
							vty_out(vty,"wlanSecID:  %-5d  \t\t\t",(sub_wlan->wlanSecID));
							vty_out(vty,"wlanCurrID:  %-5d  \n",sub_wlan->wlanCurrID);
							vty_out(vty,"SecurMechID:	%-5d	\t\t",sub_wlan->wtpWirelessSecurMechID);
							vty_out(vty,"SecurMechType:	%-5d	\n",sub_wlan->wtpWirelessSecurMechType);
							
							vty_out(vty,"SecurMechEncryType:	%-5d	\t",sub_wlan->wtpWirelessSecurMechEncryType);
							vty_out(vty,"SecurMechKeyInputType:  %-5d	\n",sub_wlan->wtpWirelessSecurMechKeyInputType);
							vty_out(vty,"SecurMechName:  %-5s	\t\t",sub_wlan->wtpWirelessSecurMechName);
							vty_out(vty,"SecurMechSecurPolicyKey:%-5s	\n",sub_wlan->wtpWirelessSecurMechSecurPolicyKey);
							vty_out(vty,"\n");
						}
						vty_out(vty,"-------------------------------------------------------------------------\n");
			
					}
				}
			
			else if (ret == ASD_DBUS_ERROR){
				cli_syslog_info("<error> failed get reply.\n");
			}
			else if(ret == ASD_WTP_NOT_EXIST){
				vty_out(vty,"<error> There is no WTP now.\n");
			}
			else{
				vty_out(vty,"<error> ret = %d\n",ret);
			}

			dcli_free_SecurityMechInfo(WtpHead);
			vty_out(vty,"==============================================================================\n");
			if(argc == 2){
				return CMD_SUCCESS;
			}
			}
		}
	}

	return CMD_SUCCESS;
}
/*add for showing wtp Wired IfStats information by nl 20100526 b22*/
DEFUN(show_all_wtp_information_func,
	  show_all_wtp_information_cmd,
	  "show the wtp information_of all_wtp [remote] [local] [PARAMETER]",
	  SHOW_STR
	  "wtp information\n"
	  "Display  wtp information of all wtps\n"
	  "List wtp information\n"
	  "by wtp display wtp information\n"
	  "'remote' or 'local' hansi\n"
	  "'remote' or 'local' hansi\n"
	  "slotid-instid\n"
	 )
{
	//DBusConnection *dbus_connection = dcli_dbus_connection;
	
	struct WtpInfor *WtpHead = NULL;
	struct WtpInfor *WtpShowNode = NULL;
	int ret=0;
	int i=0;
	int j=0;
	unsigned int num = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	int profile = 0;
	int instRun = 0;
	int flag = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	if((argc == 1)||(argc == 3)){
		vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
		return CMD_SUCCESS;
	}
	if(argc == 2){
		if (!strcmp(argv[0],"remote")){
			localid = 0;
		}else if(!strcmp(argv[0],"local")){
			localid = 1;
		}else{
			vty_out(vty,"parameter should be 'remote' or 'local'\n");
			return CMD_SUCCESS;
		}
		
		if((!strcmp(argv[0],"remote"))&&(!strcmp(argv[1],"local"))){
			vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
			return CMD_SUCCESS;
		}
		
		ret = parse_slot_hansi_id((char*)argv[1],&slot_id,&profile);
		if(ret != WID_DBUS_SUCCESS){
			slot_id = HostSlotId;
			flag = 1;
			ret = parse_int_ID((char*)argv[1], &profile);
			if(ret != WID_DBUS_SUCCESS){
				if(ret == WID_ILLEGAL_INPUT){
					vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
				}
				else{
					vty_out(vty,"<error> unknown id format\n");
				}
				return CMD_WARNING;
			}	
		}
		if(distributFag == 0){
			if(slot_id != 0){
				vty_out(vty,"<error> slot id should be 0\n");
				return CMD_WARNING;
			}	
		}else if(flag == 1){
			slot_id = HostSlotId;
		}
		if(slot_id >= MAX_SLOT_NUM || slot_id < 0){
			vty_out(vty,"<error> slot id should be 1 to %d\n",MAX_SLOT_NUM-1);
			return CMD_WARNING;
		}	
		if(profile >= MAX_INSTANCE || profile == 0){
			vty_out(vty,"<error> hansi id should be 1 to %d\n",MAX_INSTANCE-1);
			return CMD_WARNING;
		}
		instRun = dcli_hmd_hansi_is_running(vty,slot_id,localid,profile);
		if (INSTANCE_NO_CREATED == instRun) {
			vty_out(vty,"<error> the instance %s %d-%d is not running\n",((localid == 1)?"local-hansi":"hansi"),slot_id,profile);
			return CMD_WARNING;
		}
		
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		if(localid == 0)
			goto hansi_parameter;
		else if(localid == 1)
			goto local_hansi_parameter; 
	}
	
	if(vty->node != VIEW_NODE){
		WtpHead = show_infor_of_all_wtp(index,localid,dcli_dbus_connection, &num, &ret);

		if((WtpHead!=NULL)&&(ret == 0)){
			vty_out(vty,"WTPNum:%-5d  \n",num);
			vty_out(vty,"========================================================================== \n");
			for (i = 0; i < num; i++) {	
				if(WtpShowNode == NULL)
					WtpShowNode = WtpHead->WtpInfor_list;
				else 
					WtpShowNode = WtpShowNode->next;

				if(WtpShowNode == NULL)
					break;
				
				vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
				
				vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
				WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
				WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);

				vty_out(vty,"acc_tms:%d  \n",WtpShowNode->acc_tms);											//e1
				vty_out(vty,"auth_tms:%d  \t\t\t\t\t",WtpShowNode->auth_tms);
				vty_out(vty,"repauth_tms:%d  \n",WtpShowNode->repauth_tms);									//e3
				
				vty_out(vty,"auth_success_num:%d  \n",WtpShowNode->auth_success_num);						//b1
				vty_out(vty,"auth_fail_num:%d  \t\t\t\t",WtpShowNode->auth_fail_num);
				vty_out(vty,"auth_invalid_num:%d  \n",WtpShowNode->auth_invalid_num);
				vty_out(vty,"auth_timeout_num:%d  \t\t\t\t",WtpShowNode->auth_timeout_num);					//b4
				vty_out(vty,"auth_refused_num:%d  \n",WtpShowNode->auth_refused_num);						//b5
				vty_out(vty,"auth_others_num:%d  \t\t\t\t",WtpShowNode->auth_others_num);
				vty_out(vty,"assoc_req_num:%d  \n",WtpShowNode->assoc_req_num);
				vty_out(vty,"assoc_resp_num:%d  \t\t\t\t",WtpShowNode->assoc_resp_num);						//b8

				vty_out(vty,"assoc_invalid_num:%d  \n",WtpShowNode->assoc_invalid_num);						//b9
				vty_out(vty,"assoc_timeout_num:%d  \t\t\t\t",WtpShowNode->assoc_timeout_num);
				vty_out(vty,"assoc_refused_num:%d  \n",WtpShowNode->assoc_refused_num);
				vty_out(vty,"assoc_others_num:%d	\t\t\t",WtpShowNode->assoc_others_num);					//b12
				vty_out(vty,"reassoc_request_num:%d  \n",WtpShowNode->reassoc_request_num);					//b13
				vty_out(vty,"reassoc_success_num:%d  \t\t\t\t",WtpShowNode->reassoc_success_num);
				vty_out(vty,"reassoc_invalid_num:%d  \n",WtpShowNode->reassoc_invalid_num);
				vty_out(vty,"reassoc_timeout_num:%d	\t\t\t",WtpShowNode->reassoc_timeout_num);				//b16

				/////////////////////////////////////////////////////////////////////////////////////////////
				vty_out(vty,"reassoc_refused_num:%d  \n",WtpShowNode->reassoc_refused_num);					//b17
				vty_out(vty,"reassoc_others_num:%d  \t\t\t\t",WtpShowNode->reassoc_others_num);
				vty_out(vty,"identify_request_num:%d  \n",WtpShowNode->identify_request_num);
				vty_out(vty,"identify_success_num:%d	\t\t\t",WtpShowNode->identify_success_num);			//b20
				vty_out(vty,"abort_key_error_num:%d  \n",WtpShowNode->abort_key_error_num);					//b21
				vty_out(vty,"abort_invalid_num:%d  \t\t\t\t",WtpShowNode->abort_invalid_num);
				vty_out(vty,"abort_timeout_num:%d  \n",WtpShowNode->abort_timeout_num);
				vty_out(vty,"abort_refused_num:%d	\t\t\t",WtpShowNode->abort_refused_num);				//b24

				vty_out(vty,"abort_others_num:%d  \n",WtpShowNode->abort_others_num);						//b25
				vty_out(vty,"deauth_request_num:%d  \t\t\t\t",WtpShowNode->deauth_request_num);
				vty_out(vty,"deauth_user_leave_num:%d  \n",WtpShowNode->deauth_user_leave_num);
				vty_out(vty,"deauth_ap_unable_num:%d	\t\t\t",WtpShowNode->deauth_ap_unable_num);			//b28
				vty_out(vty,"deauth_abnormal_num:%d  \n",WtpShowNode->deauth_abnormal_num);					//b29
				vty_out(vty,"deauth_others_num:%d  \t\t\t\t",WtpShowNode->deauth_others_num);
				vty_out(vty,"disassoc_request_num:%d  \n",WtpShowNode->disassoc_request_num);
				vty_out(vty,"disassoc_user_leave_num:%d	\t\t",WtpShowNode->disassoc_user_leave_num);		//b32

				vty_out(vty,"disassoc_ap_unable_num:%d  \n",WtpShowNode->disassoc_ap_unable_num);			//b33
				vty_out(vty,"disassoc_abnormal_num:%d  \t\t\t",WtpShowNode->disassoc_abnormal_num);
				vty_out(vty,"disassoc_others_num:%d  \n",WtpShowNode->disassoc_others_num);					//b35

				vty_out(vty,"rx_mgmt_pkts:%d  \n",WtpShowNode->rx_mgmt_pkts);								//c1
				vty_out(vty,"tx_mgmt_pkts:%d  \t\t\t\t",WtpShowNode->tx_mgmt_pkts);
				vty_out(vty,"rx_ctrl_pkts:%d  \n",WtpShowNode->rx_ctrl_pkts);
				vty_out(vty,"tx_ctrl_pkts:%d	\t\t\t\t",WtpShowNode->tx_ctrl_pkts);							//c4
				vty_out(vty,"rx_data_pkts:%d  \n",WtpShowNode->rx_data_pkts);								//c5
				vty_out(vty,"tx_data_pkts:%d  \t\t\t\t",WtpShowNode->tx_data_pkts);
				vty_out(vty,"rx_auth_pkts:%d  \n",WtpShowNode->rx_auth_pkts);
				vty_out(vty,"tx_auth_pkts:%d	\t\t\t\t",WtpShowNode->tx_auth_pkts);							//c8

				vty_out(vty,"num_assoc_failure:%d  \n",WtpShowNode->num_assoc_failure);						//z1

				vty_out(vty,"rx_assoc_norate:%d  \t\t\t\t",WtpShowNode->rx_assoc_norate);								
				vty_out(vty,"rx_assoc_capmismatch:%d  \n",WtpShowNode->rx_assoc_capmismatch);
				vty_out(vty,"assoc_invaild:%d  \t\t\t\t",WtpShowNode->assoc_invaild);
				vty_out(vty,"reassoc_deny:%d	\n",WtpShowNode->reassoc_deny);						

				vty_out(vty,"wtp_total_online_time:%llu	\t\t\t",WtpShowNode->wtp_total_online_time);		//a1a2
				vty_out(vty,"assoc_success_num:%u	\n",WtpShowNode->assoc_success_num);

				//mahz add 2011.5.5
				vty_out(vty,"-----------------------------\n");
				vty_out(vty,"WTP History Record:\n");
				vty_out(vty,"-------------------\n");
				vty_out(vty,"History User Request Times:          %u\n",WtpShowNode->usr_auth_tms_record);
				vty_out(vty,"History Wtp Response Times:          %u\n",WtpShowNode->ac_rspauth_tms_record);
				vty_out(vty,"History Auth Fail Times:             %u\n",WtpShowNode->auth_fail_record);
				vty_out(vty,"History Auth Success Times:          %u\n",WtpShowNode->auth_success_record);
				vty_out(vty,"History Assoc Request Times:         %u\n",WtpShowNode->num_assoc_record);
				vty_out(vty,"History Reassoc Request Times:       %u\n",WtpShowNode->num_reassoc_record);
				vty_out(vty,"History Assoc Failed Times:          %u\n",WtpShowNode->num_assoc_failure_record);
				vty_out(vty,"History Reassoc Failed Times:        %u\n",WtpShowNode->num_reassoc_failure_record);
				vty_out(vty,"History Assoc Success Times:         %u\n",WtpShowNode->assoc_success_record);
				vty_out(vty,"History Reassoc Success Times:       %u\n",WtpShowNode->reassoc_success_record);
				vty_out(vty,"History Total Assoc Request Times:   %u\n",WtpShowNode->assoc_req_record);
				vty_out(vty,"History Total Assoc Response Times:  %u\n",WtpShowNode->assoc_resp_record);
				vty_out(vty,"History WTP Total Flow:              %llu (KB)\n",WtpShowNode->total_ap_flow_record);
				//
				vty_out(vty,"\n------------------------------------------------------------------------\n");
			}
			vty_out(vty,"========================================================================== \n");
		}

		else if (ret == WID_DBUS_ERROR){
			cli_syslog_info("<error> failed get reply.\n");
		}
		else if(ret == WTP_ID_NOT_EXIST){
			vty_out(vty,"<error> There is no WTP now.\n");
		}
		else{
			vty_out(vty,"<error> ret = %d\n",ret);
		}
		dcli_free_WtpInfo(WtpHead);
	}

	if(vty->node == VIEW_NODE){
		//for remote hansi info
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 0;
			
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,0,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}

		hansi_parameter:
				WtpHead = show_infor_of_all_wtp(profile,localid,dcli_dbus_connection, &num, &ret);

				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"hansi %d-%d\n",slot_id,profile);
				vty_out(vty,"-----------------------------------------------------------------------------\n");
				if((WtpHead!=NULL)&&(ret == 0)){
					vty_out(vty,"WTPNum:%-5d  \n",num);
					vty_out(vty,"========================================================================== \n");
					WtpShowNode = NULL;
					for (i = 0; i < num; i++) {	
						if(WtpShowNode == NULL)
							WtpShowNode = WtpHead->WtpInfor_list;
						else 
							WtpShowNode = WtpShowNode->next;

						if(WtpShowNode == NULL)
							break;
						
						vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
						
						vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
						WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
						WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);

						vty_out(vty,"acc_tms:%d  \n",WtpShowNode->acc_tms);											//e1
						vty_out(vty,"auth_tms:%d  \t\t\t\t\t",WtpShowNode->auth_tms);
						vty_out(vty,"repauth_tms:%d  \n",WtpShowNode->repauth_tms);									//e3
						
						vty_out(vty,"auth_success_num:%d  \n",WtpShowNode->auth_success_num);						//b1
						vty_out(vty,"auth_fail_num:%d  \t\t\t\t",WtpShowNode->auth_fail_num);
						vty_out(vty,"auth_invalid_num:%d  \n",WtpShowNode->auth_invalid_num);
						vty_out(vty,"auth_timeout_num:%d  \t\t\t\t",WtpShowNode->auth_timeout_num);					//b4
						vty_out(vty,"auth_refused_num:%d  \n",WtpShowNode->auth_refused_num);						//b5
						vty_out(vty,"auth_others_num:%d  \t\t\t\t",WtpShowNode->auth_others_num);
						vty_out(vty,"assoc_req_num:%d  \n",WtpShowNode->assoc_req_num);
						vty_out(vty,"assoc_resp_num:%d  \t\t\t\t",WtpShowNode->assoc_resp_num);						//b8

						vty_out(vty,"assoc_invalid_num:%d  \n",WtpShowNode->assoc_invalid_num);						//b9
						vty_out(vty,"assoc_timeout_num:%d  \t\t\t\t",WtpShowNode->assoc_timeout_num);
						vty_out(vty,"assoc_refused_num:%d  \n",WtpShowNode->assoc_refused_num);
						vty_out(vty,"assoc_others_num:%d	\t\t\t",WtpShowNode->assoc_others_num);					//b12
						vty_out(vty,"reassoc_request_num:%d  \n",WtpShowNode->reassoc_request_num);					//b13
						vty_out(vty,"reassoc_success_num:%d  \t\t\t\t",WtpShowNode->reassoc_success_num);
						vty_out(vty,"reassoc_invalid_num:%d  \n",WtpShowNode->reassoc_invalid_num);
						vty_out(vty,"reassoc_timeout_num:%d	\t\t\t",WtpShowNode->reassoc_timeout_num);				//b16

						vty_out(vty,"reassoc_refused_num:%d  \n",WtpShowNode->reassoc_refused_num);					//b17
						vty_out(vty,"reassoc_others_num:%d  \t\t\t\t",WtpShowNode->reassoc_others_num);
						vty_out(vty,"identify_request_num:%d  \n",WtpShowNode->identify_request_num);
						vty_out(vty,"identify_success_num:%d	\t\t\t",WtpShowNode->identify_success_num);			//b20
						vty_out(vty,"abort_key_error_num:%d  \n",WtpShowNode->abort_key_error_num);					//b21
						vty_out(vty,"abort_invalid_num:%d  \t\t\t\t",WtpShowNode->abort_invalid_num);
						vty_out(vty,"abort_timeout_num:%d  \n",WtpShowNode->abort_timeout_num);
						vty_out(vty,"abort_refused_num:%d	\t\t\t",WtpShowNode->abort_refused_num);				//b24

						vty_out(vty,"abort_others_num:%d  \n",WtpShowNode->abort_others_num);						//b25
						vty_out(vty,"deauth_request_num:%d  \t\t\t\t",WtpShowNode->deauth_request_num);
						vty_out(vty,"deauth_user_leave_num:%d  \n",WtpShowNode->deauth_user_leave_num);
						vty_out(vty,"deauth_ap_unable_num:%d	\t\t\t",WtpShowNode->deauth_ap_unable_num);			//b28
						vty_out(vty,"deauth_abnormal_num:%d  \n",WtpShowNode->deauth_abnormal_num);					//b29
						vty_out(vty,"deauth_others_num:%d  \t\t\t\t",WtpShowNode->deauth_others_num);
						vty_out(vty,"disassoc_request_num:%d  \n",WtpShowNode->disassoc_request_num);
						vty_out(vty,"disassoc_user_leave_num:%d	\t\t",WtpShowNode->disassoc_user_leave_num);		//b32

						vty_out(vty,"disassoc_ap_unable_num:%d  \n",WtpShowNode->disassoc_ap_unable_num);			//b33
						vty_out(vty,"disassoc_abnormal_num:%d  \t\t\t",WtpShowNode->disassoc_abnormal_num);
						vty_out(vty,"disassoc_others_num:%d  \n",WtpShowNode->disassoc_others_num);					//b35

						vty_out(vty,"rx_mgmt_pkts:%d  \n",WtpShowNode->rx_mgmt_pkts);								//c1
						vty_out(vty,"tx_mgmt_pkts:%d  \t\t\t\t",WtpShowNode->tx_mgmt_pkts);
						vty_out(vty,"rx_ctrl_pkts:%d  \n",WtpShowNode->rx_ctrl_pkts);
						vty_out(vty,"tx_ctrl_pkts:%d	\t\t\t\t",WtpShowNode->tx_ctrl_pkts);							//c4
						vty_out(vty,"rx_data_pkts:%d  \n",WtpShowNode->rx_data_pkts);								//c5
						vty_out(vty,"tx_data_pkts:%d  \t\t\t\t",WtpShowNode->tx_data_pkts);
						vty_out(vty,"rx_auth_pkts:%d  \n",WtpShowNode->rx_auth_pkts);
						vty_out(vty,"tx_auth_pkts:%d	\t\t\t\t",WtpShowNode->tx_auth_pkts);							//c8

						vty_out(vty,"num_assoc_failure:%d  \n",WtpShowNode->num_assoc_failure);						//z1

						vty_out(vty,"rx_assoc_norate:%d  \t\t\t\t",WtpShowNode->rx_assoc_norate);								
						vty_out(vty,"rx_assoc_capmismatch:%d  \n",WtpShowNode->rx_assoc_capmismatch);
						vty_out(vty,"assoc_invaild:%d  \t\t\t\t",WtpShowNode->assoc_invaild);
						vty_out(vty,"reassoc_deny:%d	\n",WtpShowNode->reassoc_deny);						

						vty_out(vty,"wtp_total_online_time:%llu	\t\t\t",WtpShowNode->wtp_total_online_time);		//a1a2
						vty_out(vty,"assoc_success_num:%u	\n",WtpShowNode->assoc_success_num);

						//mahz add 2011.5.5
						vty_out(vty,"-----------------------------\n");
						vty_out(vty,"WTP History Record:\n");
						vty_out(vty,"-------------------\n");
						vty_out(vty,"History User Request Times:          %u\n",WtpShowNode->usr_auth_tms_record);
						vty_out(vty,"History Wtp Response Times:          %u\n",WtpShowNode->ac_rspauth_tms_record);
						vty_out(vty,"History Auth Fail Times:             %u\n",WtpShowNode->auth_fail_record);
						vty_out(vty,"History Auth Success Times:          %u\n",WtpShowNode->auth_success_record);
						vty_out(vty,"History Assoc Request Times:         %u\n",WtpShowNode->num_assoc_record);
						vty_out(vty,"History Reassoc Request Times:       %u\n",WtpShowNode->num_reassoc_record);
						vty_out(vty,"History Assoc Failed Times:          %u\n",WtpShowNode->num_assoc_failure_record);
						vty_out(vty,"History Reassoc Failed Times:        %u\n",WtpShowNode->num_reassoc_failure_record);
						vty_out(vty,"History Assoc Success Times:         %u\n",WtpShowNode->assoc_success_record);
						vty_out(vty,"History Reassoc Success Times:       %u\n",WtpShowNode->reassoc_success_record);
						vty_out(vty,"History Total Assoc Request Times:   %u\n",WtpShowNode->assoc_req_record);
						vty_out(vty,"History Total Assoc Response Times:  %u\n",WtpShowNode->assoc_resp_record);
						vty_out(vty,"History WTP Total Flow:              %llu (KB)\n",WtpShowNode->total_ap_flow_record);
						//
						vty_out(vty,"\n------------------------------------------------------------------------\n");
					}
				}

				else if (ret == WID_DBUS_ERROR){
					cli_syslog_info("<error> failed get reply.\n");
				}
				else if(ret == WTP_ID_NOT_EXIST){
					vty_out(vty,"<error> There is no WTP now.\n");
				}
				else{
					vty_out(vty,"<error> ret = %d\n",ret);
				}
				dcli_free_WtpInfo(WtpHead);
				vty_out(vty,"==============================================================================\n");
				if(argc == 2){
					return CMD_SUCCESS;
				}
			}
		}

	//for local hansi info
	for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		localid = 1;
		
		for (profile = 1; profile < MAX_INSTANCE; profile++) 
		{
			instRun = dcli_hmd_hansi_is_running(vty,slot_id,1,profile);
			if (INSTANCE_NO_CREATED == instRun) {
				continue;
			}
	
		local_hansi_parameter:
			WtpHead = show_infor_of_all_wtp(profile,localid,dcli_dbus_connection, &num, &ret);

			vty_out(vty,"==============================================================================\n");
			vty_out(vty,"local hansi %d-%d\n",slot_id,profile);
			vty_out(vty,"-----------------------------------------------------------------------------\n");
			if((WtpHead!=NULL)&&(ret == 0)){
				vty_out(vty,"WTPNum:%-5d  \n",num);
				vty_out(vty,"========================================================================== \n");
				WtpShowNode = NULL;
				for (i = 0; i < num; i++) {	
					if(WtpShowNode == NULL)
						WtpShowNode = WtpHead->WtpInfor_list;
					else 
						WtpShowNode = WtpShowNode->next;

					if(WtpShowNode == NULL)
						break;
					
					vty_out(vty,"WTPID:   %-5d  \t\t\t\t",WtpShowNode->wtpCurrID);
					
					vty_out(vty,"WTP MAC:  %02X:%02X:%02X:%02X:%02X:%02X \n",
					WtpShowNode->wtpMacAddr[0],WtpShowNode->wtpMacAddr[1],WtpShowNode->wtpMacAddr[2],
					WtpShowNode->wtpMacAddr[3],WtpShowNode->wtpMacAddr[4],WtpShowNode->wtpMacAddr[5]);

					vty_out(vty,"acc_tms:%d  \n",WtpShowNode->acc_tms);											//e1
					vty_out(vty,"auth_tms:%d  \t\t\t\t\t",WtpShowNode->auth_tms);
					vty_out(vty,"repauth_tms:%d  \n",WtpShowNode->repauth_tms);									//e3
					
					vty_out(vty,"auth_success_num:%d  \n",WtpShowNode->auth_success_num);						//b1
					vty_out(vty,"auth_fail_num:%d  \t\t\t\t",WtpShowNode->auth_fail_num);
					vty_out(vty,"auth_invalid_num:%d  \n",WtpShowNode->auth_invalid_num);
					vty_out(vty,"auth_timeout_num:%d  \t\t\t\t",WtpShowNode->auth_timeout_num);					//b4
					vty_out(vty,"auth_refused_num:%d  \n",WtpShowNode->auth_refused_num);						//b5
					vty_out(vty,"auth_others_num:%d  \t\t\t\t",WtpShowNode->auth_others_num);
					vty_out(vty,"assoc_req_num:%d  \n",WtpShowNode->assoc_req_num);
					vty_out(vty,"assoc_resp_num:%d  \t\t\t\t",WtpShowNode->assoc_resp_num);						//b8

					vty_out(vty,"assoc_invalid_num:%d  \n",WtpShowNode->assoc_invalid_num);						//b9
					vty_out(vty,"assoc_timeout_num:%d  \t\t\t\t",WtpShowNode->assoc_timeout_num);
					vty_out(vty,"assoc_refused_num:%d  \n",WtpShowNode->assoc_refused_num);
					vty_out(vty,"assoc_others_num:%d	\t\t\t",WtpShowNode->assoc_others_num);					//b12
					vty_out(vty,"reassoc_request_num:%d  \n",WtpShowNode->reassoc_request_num);					//b13
					vty_out(vty,"reassoc_success_num:%d  \t\t\t\t",WtpShowNode->reassoc_success_num);
					vty_out(vty,"reassoc_invalid_num:%d  \n",WtpShowNode->reassoc_invalid_num);
					vty_out(vty,"reassoc_timeout_num:%d	\t\t\t",WtpShowNode->reassoc_timeout_num);				//b16

					vty_out(vty,"reassoc_refused_num:%d  \n",WtpShowNode->reassoc_refused_num);					//b17
					vty_out(vty,"reassoc_others_num:%d  \t\t\t\t",WtpShowNode->reassoc_others_num);
					vty_out(vty,"identify_request_num:%d  \n",WtpShowNode->identify_request_num);
					vty_out(vty,"identify_success_num:%d	\t\t\t",WtpShowNode->identify_success_num);			//b20
					vty_out(vty,"abort_key_error_num:%d  \n",WtpShowNode->abort_key_error_num);					//b21
					vty_out(vty,"abort_invalid_num:%d  \t\t\t\t",WtpShowNode->abort_invalid_num);
					vty_out(vty,"abort_timeout_num:%d  \n",WtpShowNode->abort_timeout_num);
					vty_out(vty,"abort_refused_num:%d	\t\t\t",WtpShowNode->abort_refused_num);				//b24

					vty_out(vty,"abort_others_num:%d  \n",WtpShowNode->abort_others_num);						//b25
					vty_out(vty,"deauth_request_num:%d  \t\t\t\t",WtpShowNode->deauth_request_num);
					vty_out(vty,"deauth_user_leave_num:%d  \n",WtpShowNode->deauth_user_leave_num);
					vty_out(vty,"deauth_ap_unable_num:%d	\t\t\t",WtpShowNode->deauth_ap_unable_num);			//b28
					vty_out(vty,"deauth_abnormal_num:%d  \n",WtpShowNode->deauth_abnormal_num);					//b29
					vty_out(vty,"deauth_others_num:%d  \t\t\t\t",WtpShowNode->deauth_others_num);
					vty_out(vty,"disassoc_request_num:%d  \n",WtpShowNode->disassoc_request_num);
					vty_out(vty,"disassoc_user_leave_num:%d	\t\t",WtpShowNode->disassoc_user_leave_num);		//b32

					vty_out(vty,"disassoc_ap_unable_num:%d  \n",WtpShowNode->disassoc_ap_unable_num);			//b33
					vty_out(vty,"disassoc_abnormal_num:%d  \t\t\t",WtpShowNode->disassoc_abnormal_num);
					vty_out(vty,"disassoc_others_num:%d  \n",WtpShowNode->disassoc_others_num);					//b35

					vty_out(vty,"rx_mgmt_pkts:%d  \n",WtpShowNode->rx_mgmt_pkts);								//c1
					vty_out(vty,"tx_mgmt_pkts:%d  \t\t\t\t",WtpShowNode->tx_mgmt_pkts);
					vty_out(vty,"rx_ctrl_pkts:%d  \n",WtpShowNode->rx_ctrl_pkts);
					vty_out(vty,"tx_ctrl_pkts:%d	\t\t\t\t",WtpShowNode->tx_ctrl_pkts);							//c4
					vty_out(vty,"rx_data_pkts:%d  \n",WtpShowNode->rx_data_pkts);								//c5
					vty_out(vty,"tx_data_pkts:%d  \t\t\t\t",WtpShowNode->tx_data_pkts);
					vty_out(vty,"rx_auth_pkts:%d  \n",WtpShowNode->rx_auth_pkts);
					vty_out(vty,"tx_auth_pkts:%d	\t\t\t\t",WtpShowNode->tx_auth_pkts);							//c8

					vty_out(vty,"num_assoc_failure:%d  \n",WtpShowNode->num_assoc_failure);						//z1

					vty_out(vty,"rx_assoc_norate:%d  \t\t\t\t",WtpShowNode->rx_assoc_norate);								
					vty_out(vty,"rx_assoc_capmismatch:%d  \n",WtpShowNode->rx_assoc_capmismatch);
					vty_out(vty,"assoc_invaild:%d  \t\t\t\t",WtpShowNode->assoc_invaild);
					vty_out(vty,"reassoc_deny:%d	\n",WtpShowNode->reassoc_deny);						

					vty_out(vty,"wtp_total_online_time:%llu	\t\t\t",WtpShowNode->wtp_total_online_time);		//a1a2
					vty_out(vty,"assoc_success_num:%u	\n",WtpShowNode->assoc_success_num);

					//mahz add 2011.5.5
					vty_out(vty,"-----------------------------\n");
					vty_out(vty,"WTP History Record:\n");
					vty_out(vty,"-------------------\n");
					vty_out(vty,"History User Request Times:          %u\n",WtpShowNode->usr_auth_tms_record);
					vty_out(vty,"History Wtp Response Times:          %u\n",WtpShowNode->ac_rspauth_tms_record);
					vty_out(vty,"History Auth Fail Times:             %u\n",WtpShowNode->auth_fail_record);
					vty_out(vty,"History Auth Success Times:          %u\n",WtpShowNode->auth_success_record);
					vty_out(vty,"History Assoc Request Times:         %u\n",WtpShowNode->num_assoc_record);
					vty_out(vty,"History Reassoc Request Times:       %u\n",WtpShowNode->num_reassoc_record);
					vty_out(vty,"History Assoc Failed Times:          %u\n",WtpShowNode->num_assoc_failure_record);
					vty_out(vty,"History Reassoc Failed Times:        %u\n",WtpShowNode->num_reassoc_failure_record);
					vty_out(vty,"History Assoc Success Times:         %u\n",WtpShowNode->assoc_success_record);
					vty_out(vty,"History Reassoc Success Times:       %u\n",WtpShowNode->reassoc_success_record);
					vty_out(vty,"History Total Assoc Request Times:   %u\n",WtpShowNode->assoc_req_record);
					vty_out(vty,"History Total Assoc Response Times:  %u\n",WtpShowNode->assoc_resp_record);
					vty_out(vty,"History WTP Total Flow:              %llu (KB)\n",WtpShowNode->total_ap_flow_record);
					//
					vty_out(vty,"\n------------------------------------------------------------------------\n");
				}
			}

			else if (ret == WID_DBUS_ERROR){
				cli_syslog_info("<error> failed get reply.\n");
			}
			else if(ret == WTP_ID_NOT_EXIST){
				vty_out(vty,"<error> There is no WTP now.\n");
			}
			else{
				vty_out(vty,"<error> ret = %d\n",ret);
			}
			dcli_free_WtpInfo(WtpHead);
			vty_out(vty,"==============================================================================\n");
			if(argc == 2){
				return CMD_SUCCESS;
			}
			}
		}
	}

	return CMD_SUCCESS;
}
/*xdw add for show ap network information of all wtp, 20101215*/
DEFUN(show_all_wtp_network_info_cmd_func,
	  show_all_wtp_network_info_cmd,
	  "show ap network information of all wtp [remote] [local] [PARAMETER]",
	  SHOW_STR
	  "Display wtp network information of all wtps\n"
	  "ap network information\n"
	  "network information\n"
	  "of all wtp\n"
	  "of all wtp\n"
	  "of all wtp\n"
	  "'remote' or 'local' hansi\n"
	  "'remote' or 'local' hansi\n"
	  "slotid-instid\n"
	 )
{	
	//DBusConnection *dbus_connection = dcli_dbus_connection;

	struct WtpNetworkInfo *WtpHead = NULL;
	struct WtpNetworkInfo *WtpShowNode = NULL;
	int ret = 0;
	int retval = 0;
	int i = 0;
	int profile = 0;
	int instRun = 0;
	int flag = 0;
	unsigned int num = 0;
	
	char ip[WTP_WTP_IP_LEN+1];
	
	unsigned char mygatewayBuf[DCLIAC_BUF_LEN] = {0};	
	unsigned char *mygatewayPtr = mygatewayBuf;

	unsigned char myfstdnsBuf[DCLIAC_BUF_LEN] = {0};	
	unsigned char *myfstdnsPtr = myfstdnsBuf;

	unsigned char mysnddnsBuf[DCLIAC_BUF_LEN] = {0};	
	unsigned char *mysnddnsPtr = mysnddnsBuf;	

	unsigned char mymaskBuf[DCLIAC_BUF_LEN] = {0};	
	unsigned char *mymaskPtr = mymaskBuf;

	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	if((argc == 1)||(argc == 3)){
		vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
		return CMD_SUCCESS;
	}
	if(argc == 2){
		if (!strcmp(argv[0],"remote")){
			localid = 0;
		}else if(!strcmp(argv[0],"local")){
			localid = 1;
		}else{
			vty_out(vty,"parameter should be 'remote' or 'local'\n");
			return CMD_SUCCESS;
		}
		
		if((!strcmp(argv[0],"remote"))&&(!strcmp(argv[1],"local"))){
			vty_out(vty,"<error>input parameter should be 'remote SLOTID-INSTID' or 'local SLOTID-INSTID'\n");
			return CMD_SUCCESS;
		}
		
		ret = parse_slot_hansi_id((char*)argv[1],&slot_id,&profile);
		if(ret != WID_DBUS_SUCCESS){
			slot_id = HostSlotId;
			flag = 1;
			ret = parse_int_ID((char*)argv[1], &profile);
			if(ret != WID_DBUS_SUCCESS){
				if(ret == WID_ILLEGAL_INPUT){
					vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
				}
				else{
					vty_out(vty,"<error> unknown id format\n");
				}
				return CMD_WARNING;
			}	
		}
		if(distributFag == 0){
			if(slot_id != 0){
				vty_out(vty,"<error> slot id should be 0\n");
				return CMD_WARNING;
			}	
		}else if(flag == 1){
			slot_id = HostSlotId;
		}
		if(slot_id >= MAX_SLOT_NUM || slot_id < 0){
			vty_out(vty,"<error> slot id should be 1 to %d\n",MAX_SLOT_NUM-1);
			return CMD_WARNING;
		}	
		if(profile >= MAX_INSTANCE || profile == 0){
			vty_out(vty,"<error> hansi id should be 1 to %d\n",MAX_INSTANCE-1);
			return CMD_WARNING;
		}
		instRun = dcli_hmd_hansi_is_running(vty,slot_id,localid,profile);
		if (INSTANCE_NO_CREATED == instRun) {
			vty_out(vty,"<error> the instance %s %d-%d is not running\n",((localid == 1)?"local-hansi":"hansi"),slot_id,profile);
			return CMD_WARNING;
		}
		
		ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		if(localid == 0)
			goto hansi_parameter;
		else if(localid == 1)
			goto local_hansi_parameter; 
	}

	if(vty->node != VIEW_NODE){
		WtpHead = show_all_wtp_network_info(index,localid,dcli_dbus_connection, &num, &ret);
		
		if((WtpHead!=NULL)&&(ret == 0)){
			vty_out(vty,"WTPNum:%-5u  \n",num);
			for (i = 0; i < num; i++){	
				if(WtpShowNode == NULL)
					WtpShowNode = WtpHead->WtpNetworkInfo_list;
				else 
					WtpShowNode = WtpShowNode->next;
				if(WtpShowNode == NULL)
					break;	
				
				memset(mygatewayBuf,0,DCLIAC_BUF_LEN);
				memset(myfstdnsBuf,0,DCLIAC_BUF_LEN);
				memset(mysnddnsBuf,0,DCLIAC_BUF_LEN);
				memset(mymaskBuf,0,DCLIAC_BUF_LEN);
				retval = ip_long2str(WtpShowNode->ap_gateway,&mygatewayPtr);
	          	retval = ip_long2str(WtpShowNode->ap_mask_new,&mymaskPtr);
			    retval = ip_long2str(WtpShowNode->ap_dnsfirst,&myfstdnsPtr);
		        retval = ip_long2str(WtpShowNode->ap_dnssecend,&mysnddnsPtr);		

	        	retval = wtp_check_wtp_ip_addr(ip,WtpShowNode->WTPIP);
				vty_out(vty,"==============================WTP Information=================================\n");
				vty_out(vty,"WTPID \t\t%u\n",WtpShowNode->WTPID);
				vty_out(vty,"WTPMAC \t\t%02X:%02X:%02X:%02X:%02X:%02X\n",WtpShowNode->WTPMAC[0],WtpShowNode->WTPMAC[1],\
				WtpShowNode->WTPMAC[2],WtpShowNode->WTPMAC[3],WtpShowNode->WTPMAC[4],WtpShowNode->WTPMAC[5]);
				if(0 == retval){
	            	vty_out(vty,"ipaddr \t\t%s\n",WtpShowNode->WTPIP);
	            }
	            else{
	            	vty_out(vty,"ipaddr \t\t%s\n",ip);
	            }
				vty_out(vty,"netmask \t\t%s\n",mymaskBuf);
				vty_out(vty,"gateway \t\t%s\n",mygatewayBuf);
				vty_out(vty,"fstdns \t\t%s\n",myfstdnsBuf);
				vty_out(vty,"snddns \t\t%s\n",mysnddnsBuf);
			}
		}
		else{
			vty_out(vty,"<error> ret = %d\n",ret);
		}
		dcli_free_WtpNetworkInfo(WtpHead);
	}

	if(vty->node == VIEW_NODE){
		//for remote hansi info
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 0;
			
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,0,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}

		hansi_parameter:
				WtpHead = show_all_wtp_network_info(profile,localid,dcli_dbus_connection, &num, &ret);
				
				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"hansi %d-%d\n",slot_id,profile);
				vty_out(vty,"-----------------------------------------------------------------------------\n");
				if((WtpHead!=NULL)&&(ret == 0)){
					WtpShowNode = NULL;
					vty_out(vty,"WTPNum:%-5u  \n",num);
					for (i = 0; i < num; i++){	
						if(WtpShowNode == NULL)
							WtpShowNode = WtpHead->WtpNetworkInfo_list;
						else 
							WtpShowNode = WtpShowNode->next;
						if(WtpShowNode == NULL)
							break;	
						
						memset(mygatewayBuf,0,DCLIAC_BUF_LEN);
						memset(myfstdnsBuf,0,DCLIAC_BUF_LEN);
						memset(mysnddnsBuf,0,DCLIAC_BUF_LEN);
						memset(mymaskBuf,0,DCLIAC_BUF_LEN);
						retval = ip_long2str(WtpShowNode->ap_gateway,&mygatewayPtr);
			          	retval = ip_long2str(WtpShowNode->ap_mask_new,&mymaskPtr);
					    retval = ip_long2str(WtpShowNode->ap_dnsfirst,&myfstdnsPtr);
				        retval = ip_long2str(WtpShowNode->ap_dnssecend,&mysnddnsPtr);		

			        	retval = wtp_check_wtp_ip_addr(ip,WtpShowNode->WTPIP);
						vty_out(vty,"==============================WTP Information=================================\n");
						vty_out(vty,"WTPID \t\t%u\n",WtpShowNode->WTPID);
						vty_out(vty,"WTPMAC \t\t%02X:%02X:%02X:%02X:%02X:%02X\n",WtpShowNode->WTPMAC[0],WtpShowNode->WTPMAC[1],\
						WtpShowNode->WTPMAC[2],WtpShowNode->WTPMAC[3],WtpShowNode->WTPMAC[4],WtpShowNode->WTPMAC[5]);
						if(0 == retval){
			            	vty_out(vty,"ipaddr \t\t%s\n",WtpShowNode->WTPIP);
			            }
			            else{
			            	vty_out(vty,"ipaddr \t\t%s\n",ip);
			            }
						vty_out(vty,"netmask \t\t%s\n",mymaskBuf);
						vty_out(vty,"gateway \t\t%s\n",mygatewayBuf);
						vty_out(vty,"fstdns \t\t%s\n",myfstdnsBuf);
						vty_out(vty,"snddns \t\t%s\n",mysnddnsBuf);
					}
				}
				else{
					vty_out(vty,"<error> ret = %d\n",ret);
				}
				dcli_free_WtpNetworkInfo(WtpHead);
				vty_out(vty,"==============================================================================\n");
				if(argc == 2){
					return CMD_SUCCESS;
				}
			}
		}

		//for local hansi info
		for(slot_id = 1;slot_id < MAX_SLOT_NUM;slot_id++){			
			ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
			localid = 1;
			
			for (profile = 1; profile < MAX_INSTANCE; profile++) 
			{
				instRun = dcli_hmd_hansi_is_running(vty,slot_id,1,profile);
				if (INSTANCE_NO_CREATED == instRun) {
					continue;
				}
		
			local_hansi_parameter:
				WtpHead = show_all_wtp_network_info(profile,localid,dcli_dbus_connection, &num, &ret);
				
				vty_out(vty,"==============================================================================\n");
				vty_out(vty,"local hansi %d-%d\n",slot_id,profile);
				vty_out(vty,"-----------------------------------------------------------------------------\n");
				if((WtpHead!=NULL)&&(ret == 0)){
					WtpShowNode = NULL;
					vty_out(vty,"WTPNum:%-5u  \n",num);
					for (i = 0; i < num; i++){	
						if(WtpShowNode == NULL)
							WtpShowNode = WtpHead->WtpNetworkInfo_list;
						else 
							WtpShowNode = WtpShowNode->next;
						if(WtpShowNode == NULL)
							break;	
						
						memset(mygatewayBuf,0,DCLIAC_BUF_LEN);
						memset(myfstdnsBuf,0,DCLIAC_BUF_LEN);
						memset(mysnddnsBuf,0,DCLIAC_BUF_LEN);
						memset(mymaskBuf,0,DCLIAC_BUF_LEN);
						retval = ip_long2str(WtpShowNode->ap_gateway,&mygatewayPtr);
			          	retval = ip_long2str(WtpShowNode->ap_mask_new,&mymaskPtr);
					    retval = ip_long2str(WtpShowNode->ap_dnsfirst,&myfstdnsPtr);
				        retval = ip_long2str(WtpShowNode->ap_dnssecend,&mysnddnsPtr);		

			        	retval = wtp_check_wtp_ip_addr(ip,WtpShowNode->WTPIP);
						vty_out(vty,"==============================WTP Information=================================\n");
						vty_out(vty,"WTPID \t\t%u\n",WtpShowNode->WTPID);
						vty_out(vty,"WTPMAC \t\t%02X:%02X:%02X:%02X:%02X:%02X\n",WtpShowNode->WTPMAC[0],WtpShowNode->WTPMAC[1],\
						WtpShowNode->WTPMAC[2],WtpShowNode->WTPMAC[3],WtpShowNode->WTPMAC[4],WtpShowNode->WTPMAC[5]);
						if(0 == retval){
			            	vty_out(vty,"ipaddr \t\t%s\n",WtpShowNode->WTPIP);
			            }
			            else{
			            	vty_out(vty,"ipaddr \t\t%s\n",ip);
			            }
						vty_out(vty,"netmask \t\t%s\n",mymaskBuf);
						vty_out(vty,"gateway \t\t%s\n",mygatewayBuf);
						vty_out(vty,"fstdns \t\t%s\n",myfstdnsBuf);
						vty_out(vty,"snddns \t\t%s\n",mysnddnsBuf);
					}
				}
				else{
					vty_out(vty,"<error> ret = %d\n",ret);
				}
				dcli_free_WtpNetworkInfo(WtpHead);
				vty_out(vty,"==============================================================================\n");
				if(argc == 2){
					return CMD_SUCCESS;
				}
			}
		}
	}

	return CMD_SUCCESS;
}
/*for not showting quit wtp infor*/
DEFUN(set_hide_quit_wtp_func,
		set_hide_quit_wtp_cmd,
		"set offline wtp statistics (enable|disable)",
		CONFIG_STR
		"set offline wtp switch\n"
		"set offline wtp switch\n"
	)
{
	int ret;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

	int policy = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	
	if (!strcmp(argv[0],"enable")){
		policy = 0;	
	}
	else if (!strcmp(argv[0],"disable")){
		policy = 1;	
	}
	else{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}

	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_HIDE_QUIT_WTP_INFOR_IN_MIB_SHOWING);
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&policy,						
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);

	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

		if(ret == 0){
			vty_out(vty," Set offline wtp statistics successfully .\n");
		}
		else if(ret == SWITCH_HAS_ALREADY_SETTED){
			vty_out(vty," The offline wtp statistics has already in %s! \n",( policy == 0 ? "enable":"disable"));
		}
		else
			vty_out(vty,"<error>  %d\n",ret);
	dbus_message_unref(reply);
	
	return CMD_SUCCESS;	
}

/* set trap filter percent 
** eg. input 10,  10% of the trap will be hided,
**      90% will be shown to user.
** zhangshu append at 2010-08-24 
*/
DEFUN(set_trap_ignore_wtp_func,
		set_trap_ignore_wtp_cmd,
		"set wtp trap ignore percent VALUE",
		"set trap ignore\n"
		"WTP service\n"
	)
{
    int ret;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	
	unsigned int wtpid;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	
	if((vty->node == CONFIG_NODE)||(vty->node == ENABLE_NODE))
	{
		wtpid = 0;
	}else if(vty->node == WTP_NODE)
	{
		wtpid = (unsigned int)vty->index;
	}
	
	if ( NULL == argv[0] ) {
		vty_out(vty,"<error> input patameter error!\n");
		return CMD_SUCCESS;
	}
	int i = 0;
	for( i = 0; i < strlen(argv[0]); i++ ){
	    if(argv[0][i] < '0' || argv[0][i] > '9'){
	        vty_out(vty,"<error> input patameter must be number!\n");
		    return CMD_SUCCESS;
	    }
	}
    int trap_percent = atoi(argv[0]);
    if( trap_percent > 100 || trap_percent < 0 ){
        vty_out(vty,"<error> input patameter must between 0 and 100!\n");
		return CMD_SUCCESS;
    }
    
    if(vty->node == CONFIG_NODE){
        index = 0;
    }else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

    ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);

    query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SET_WTP_TRAP_IGNORE_PERCENT);
	dbus_error_init(&err);

	dbus_message_append_args(query,
	                    DBUS_TYPE_UINT32,&wtpid,
						DBUS_TYPE_UINT32,&trap_percent,						
						DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);

	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

		if(ret == 0){
			vty_out(vty," Set trap ignore percent successfully .\n");
		}
		else
			vty_out(vty,"<error>  %d\n",ret);
	dbus_message_unref(reply);

    return CMD_SUCCESS;
}

/* zhangshu append  2010-08-21 */
DEFUN(show_hide_quit_wtp_func,
		show_hide_quit_wtp_cmd,
		"show offline wtp status",
		SHOW_STR
		"offline wtp status\n"
		"offline wtp status\n"
	)
{
	int ret;
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	
	int switch_val =0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;

	if(vty->node == CONFIG_NODE){
        index = 0;
    }else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SHOW_HIDE_QUIT_WTP_INFOR_IN_MIB_SHOWING);
	
	dbus_error_init(&err);
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	dbus_message_unref(query);

	if (NULL == reply) {
		cli_syslog_info("<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			cli_syslog_info("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == WID_DBUS_SUCCESS)
	{	
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&switch_val);

		if(1 == switch_val)
			vty_out(vty,"offline wtp status is disable.\n");
		else if(0 == switch_val)
			vty_out(vty,"offline wtp status is enable.\n");
			//vty_out(vty," hide_quit_wtp_in is %s.\n",(switch_val ==1?"enable":"disable"));
		else 
			vty_out(vty,"<error> the value of hide_quit_wtp_in is invalid.\n");
	}
	else
		vty_out(vty,"<error>  %d\n",ret);
	
	dbus_message_unref(reply);
	
	return CMD_SUCCESS;	
}

DEFUN(show_wtp_running_config_cmd_func,
	  show_wtp_running_config_cmd,
	  "show wtp running-config [WTPID]",
	  "wtp running-config\n"
	  "wtp running-config\n"
	  "show wtp id\n"
	 )
{
	int ret = 0;
	int wtpid = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	if(vty->node == WTP_NODE){
		index = 0;			
		wtpid = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = (int)vty->index; 		
		wtpid = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = (int)vty->index; 		
		wtpid = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if((vty->node == CONFIG_NODE)||(vty->node == ENABLE_NODE)||(vty->node == VIEW_NODE)){
		index = 0;			
		wtpid = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		wtpid = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		wtpid = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

	if (1 == argc) {
		wtpid = strtoul((char *)argv[0], NULL, 10);
		if ((wtpid < 0) ||(wtpid >= WTP_NUM))
		{
			vty_out(vty,"%% Invalid wtp id: %s !", argv[0]);
			return CMD_WARNING;
		}
	}
	
	int wtp_max_num = WTP_NUM;
	char *showRunningCfg = NULL;
	ret = show_wtp_running_config(index,localid,wtpid,dcli_dbus_connection,wtp_max_num, &showRunningCfg);

	if (ret == 0 && showRunningCfg != NULL)
	{
		vty_out(vty, "%s", showRunningCfg);
		free(showRunningCfg);
	}
	else if(ret == -1){
		printf("<error> failed get reply.\n");
	}
	else if(ret != 0)
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
	
	return CMD_SUCCESS;			
}

/*	zhaoruijia,translate set neighbor_same_channelrssithreshold to 1.3*/	

DEFUN(set_wtp_trap_neighbor_same_channelrssithreshold_cmd_func,
	  set_wtp_trap_neighbor_same_channelrssithreshold_cmd,
	  "set wtp (neighborchannelrssi|samechannelrssi) threshold VALUE",
	  CONFIG_STR
	  "wtp neighborchannelrssi or samechannelrssi trap threshold information\n"
	  "wtp trap\n"
	  "wtp neighborchannelrssi samechannelrssi\n")
	{
			DBusMessage *query, *reply; 
			DBusMessageIter  iter;
			DBusError err;
			int value;
			int ret = WID_DBUS_SUCCESS;
			int policy = 0;
			unsigned int wtp_id = 0;
			char BUSNAME[PATH_LEN];
	        char OBJPATH[PATH_LEN];
	        char INTERFACE[PATH_LEN];
			int localid = 1;
			int slot_id = HostSlotId;
			int index = 0;
			
			/*if(vty->node == WTP_NODE){
				wtp_id = (unsigned int)vty->index;
				if(wtp_id > WTP_NUM-1)
					{
                       vty_out(vty,"<error>wtp id is invalid\n");
				       return CMD_SUCCESS;
				    }
			}
			else if((vty->node == CONFIG_NODE)){
				wtp_id = 0;
			}*/
			if(vty->node == HANSI_NODE){
				index = vty->index;
				localid = vty->local;
				slot_id = vty->slotindex;
			}else if(vty->node == LOCAL_HANSI_NODE){
				index = vty->index;
				localid = vty->local;
				slot_id = vty->slotindex;
			}
			else if(vty->node ==  HANSI_WTP_NODE)
			{
				index = vty->index;
				wtp_id= (unsigned int)vty->index_sub;
				localid = vty->local;
				slot_id = vty->slotindex;
			}else if(vty->node ==  LOCAL_HANSI_WTP_NODE)
			{
				index = vty->index;
				wtp_id= (unsigned int)vty->index_sub;
				localid = vty->local;
				slot_id = vty->slotindex;
			}

			
			if (!strcmp(argv[0],"neighborchannelrssi"))
			{
				policy = 1; 
			}
			else if (!strcmp(argv[0],"samechannelrssi"))
			{
				policy = 2; 
			}
			
		   else
			{
				vty_out(vty,"<error> input patameter only with 'neighborchannelrssi' or 'samechannelrssi'\n");
				return CMD_SUCCESS;
			}
          
          
          ret = parse_signedint_ID((char*)argv[1],&value);
		 

		  if(ret != WID_DBUS_SUCCESS){

				vty_out(vty,"<error> unknown id format\n");
				return CMD_SUCCESS;
		  }
		  if (value < -120 || value > 0)//fengwenchao modify 20120406 for AXSSZFI-792
		  {	
			 	vty_out(vty,"<error> input patameter should be -120 to 0\n");
			 	return CMD_SUCCESS;
		  }
         DBusConnection *dcli_dbus_connection = NULL;
		  ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		  ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
          ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	      ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);

			query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_SET_NEIGHBOR_SAME_CHANNELRSSI_THRESHOLD);
			dbus_error_init(&err);
			dbus_message_append_args(query,
									 DBUS_TYPE_UINT32,&wtp_id,
									 DBUS_TYPE_UINT32,&policy,
									 DBUS_TYPE_UINT32,&value,
									 DBUS_TYPE_INVALID);
			reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
			dbus_message_unref(query);
			if (NULL == reply)
			{
				cli_syslog_info("<error> failed get reply.\n");
				if (dbus_error_is_set(&err))
				{
					cli_syslog_info("%s raised: %s",err.name,err.message);
					dbus_error_free_for_dcli(&err);
				}
				return CMD_SUCCESS;
			}
			dbus_message_iter_init(reply,&iter);
			dbus_message_iter_get_basic(&iter,&ret);
			if(ret == 0)
			{
				vty_out(vty," set ap %s threshold %s successfully\n",argv[0],argv[1]);
			}	
			else if (ret == WTP_NOT_IN_RUN_STATE)
			{
				vty_out(vty,"<error> wtp id does not run\n");
			}
			else
			{
				vty_out(vty,"<error>  %d\n",ret);
			}
			dbus_message_unref(reply);
			return CMD_SUCCESS; 		
}
/*	zhaoruijia,translate set neighbor_same_channelrssithreshold to 1.3,end*/	

DEFUN(show_wlan_radio_information_func,
         show_wlan_radio_information_cmd,
         "show wlan radio information",
         SHOW_STR
         ){

         struct WtpWlanRadioInfo* WtpHead = NULL;
	struct WtpWlanRadioInfo* WtpNode = NULL;
	int ret = 0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	unsigned int wlan_num = 0;
	if(vty->node == CONFIG_NODE){
		index = 0;			
	}
	else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);

			WtpHead = show_Wlan_Radio_Info_of_all_Wtp(dcli_dbus_connection,&wlan_num,&ret,index,localid);

			if((WtpHead!=NULL)&&(ret == 0)){
				WtpNode=WtpHead;
				vty_out(vty,"wlan_num:%-5d  \n",wlan_num);
				vty_out(vty,"========================================================================== \n");
				while(WtpNode){
					 vty_out(vty,"-------------------------------------------------------------------------\n");
					 vty_out(vty,"wlanCurrID:			            %d\n",WtpNode->wlanid);
				     vty_out(vty,"WlanradioRecvSpeed:			    %d\n",WtpNode->WlanradioRecvSpeed );
				     vty_out(vty,"WlanradioSendSpeed:			    %d\n",WtpNode->WlanradioSendSpeed );
					 vty_out(vty,"-------------------------------------------------------------------------\n");
					 WtpNode=WtpNode->next;
              }
			 vty_out(vty,"========================================================================== \n");
             dcli_free_wtp_wlan_radio_info_head(WtpHead);
			}
			else if(ret==WLAN_ID_NOT_EXIST){
				vty_out(vty,"<error> there is no wlan\n");
				}
			else if(ret==MALLOC_ERROR){
                vty_out(vty,"<error> Malloc Error\n");
			    }
			return CMD_SUCCESS;


}
DEFUN (add_black_white_oui_mac_func,
		  add_black_white_oui_mac_cmd,
		  "add (black|white) oui_mac MAC",
		  "add a new oui_mac\n"
		  "add a black oui_mac to blackouilist.xml\n"
		  "add a whilte oui_mac to whiteouilist.xml\n"
		  "oui_mac eg:1B:2C:7D\n"
		  "oui_mac eg:1B:2C:7D\n"
 )
{
   unsigned int ret=0;
   unsigned int ouiXmlType=0; //1--blacklist 2--whitelist
   int localid = 1;
   int slot_id = HostSlotId;
   unsigned int index = 0;
   unsigned char oui_mac[OUI_LEN] = {0};
   if((strcmp(argv[0],"black")==0)||(tolower(argv[0][0]) == 'b')){
         ouiXmlType = 1;
   }
   else if((strcmp(argv[0],"white")==0)||(tolower(argv[0][0]) == 'w')){
         ouiXmlType = 2;
   	}
   else{
		vty_out(vty,"<error> input patameter should only be 'black/white' or 'b/w' \n");
		return CMD_SUCCESS;
	}
   ret = wid_parse_oui_mac_addr((char*)argv[1],oui_mac);
   if(ret != 0){
       	vty_out(vty,"<error> Unknown oui_mac addr format.\n");
		return CMD_FAILURE;
   }
   if(vty->node == HIDDENDEBUG_NODE){
       index = 0;
   }
   DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
   dcli_add_black_white_oui_mac(index,localid,&ret,oui_mac,ouiXmlType,dcli_dbus_connection);
   if(ret == 0){
       vty_out(vty,"add %s oui_mac %s successful!\n",argv[0],argv[1]);
   }
   else if(ret == WID_ADD_BLACK_WHITE_OUI_MAC_ERR)
   	  vty_out(vty,"add %s oui_mac %s failed\n",argv[0],argv[1]);
   return CMD_SUCCESS;
 }
DEFUN (del_black_white_oui_mac_func,
		  del_black_white_oui_mac_cmd,
		  "del (black|white) oui_mac MAC",
		  "del a new oui_mac\n"
		  "del a black oui_mac from blackouilist.xml\n"
		  "del a whilte oui_mac from whiteouilist.xml\n"
		  "oui_mac eg:1B:2C:7D\n"
		  "oui_mac eg:1B:2C:7D\n"
 )
{
   unsigned int ret=0;
   unsigned int ouiXmlType=0; //1--blacklist 2--whitelist
   int localid = 1;
   int slot_id = HostSlotId;
   unsigned int index = 0;
   unsigned char oui_mac[OUI_LEN] = {0};
   if((strcmp(argv[0],"black")==0)||(tolower(argv[0][0]) == 'b')){
         ouiXmlType = 1;
   }
   else if((strcmp(argv[0],"white")==0)||(tolower(argv[0][0]) == 'w')){
         ouiXmlType = 2;
   	}
   else{
		vty_out(vty,"<error> input patameter should only be 'black/white' or 'b/w' \n");
		return CMD_SUCCESS;
	}
   ret = wid_parse_oui_mac_addr((char*)argv[1],oui_mac);
   if(ret != 0){
       	vty_out(vty,"<error> Unknown oui_mac addr format.\n");
		return CMD_FAILURE;
   }
   if(vty->node == HIDDENDEBUG_NODE){
       index = 0;
   }
   DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
   dcli_del_black_white_oui_mac(index,localid,&ret,oui_mac,ouiXmlType,dcli_dbus_connection);
   if(ret == 0){
       vty_out(vty,"del %s oui_mac %s successful!\n",argv[0],argv[1]);
   }
   else if(ret == WID_DEL_BLACK_WHITE_OUI_MAC_ERR)
   	   vty_out(vty,"del %s oui_mac %s failed\n",argv[0],argv[1]);
   return CMD_SUCCESS;
 }
DEFUN(show_black_white_oui_list_func,
	     show_black_white_oui_list_cmd,
	     "show (black|white) oui_info list",
	     SHOW_STR
	     "show oui info which from blackouilist.xml\n"
	     "show oui info which from whiteouilist.xml\n"
	     "the oui_info from blackouilist.xml or whiteouilist.xml\n"
	     "blackouilist.xml or whiteouilist.xml list\n"
)
{
   unsigned int ret=0;
   unsigned int ouiXmlType=0; //1--blacklist 2--whitelist
   int localid = 1;
   int slot_id = HostSlotId;
   unsigned int index = 0;
   int i = 0;
   WtpOUIInfo *ouiInfoList = NULL;
   WtpOUIInfo *ouiInfoShowList = NULL;
   if((strcmp(argv[0],"black")==0)||(tolower(argv[0][0]) == 'b')){
         ouiXmlType = 1;
   }
   else if((strcmp(argv[0],"white")==0)||(tolower(argv[0][0]) == 'w')){
         ouiXmlType = 2;
   	}
   else{
		vty_out(vty,"<error> input patameter should only be 'black/white' or 'b/w' \n");
		return CMD_SUCCESS;
	}
   if(vty->node == HIDDENDEBUG_NODE){
       index = 0;
   }
   DBusConnection *dcli_dbus_connection = NULL;
   ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
   dcli_show_black_white_oui_info_list(index,localid,&ret,ouiXmlType,&ouiInfoList,dcli_dbus_connection);
   vty_out(vty,"%s Oui List:\n",(ouiXmlType == 1)?"Black":"White");
   vty_out(vty,"Oui_Num  %-8d\n",(ouiInfoList!=NULL)?ouiInfoList->oui_num:0);
   vty_out(vty,"========================================================================== \n");
   vty_out(vty,"%-6s %-9s\n","OUI_ID","OUI_MAC");
   if((ouiInfoList!=NULL)&&(ret==0)){
	for(i=0;i<ouiInfoList->oui_num;i++){
   	    if(ouiInfoShowList == NULL){
            ouiInfoShowList = ouiInfoList->oui_list;
		}
		else{
		    ouiInfoShowList = ouiInfoShowList->next;
		}
		if(ouiInfoShowList == NULL)
			break;
		vty_out(vty,"%-6d %02X:%02X:%02X\n",i+1,
			                                  ouiInfoShowList->oui_mac[0],
			                                  ouiInfoShowList->oui_mac[1],
			                                  ouiInfoShowList->oui_mac[2]);
   	}
   }
   vty_out(vty,"========================================================================== \n");
   dcli_free_oui_info_list(ouiInfoList);
   return CMD_SUCCESS;
}
DEFUN(update_black_white_oui_info_func,
	     update_black_white_oui_info_cmd,
	     "update (black|white) oui_info list",
	     "update info\n"
	     "update blackouilist.xml\n"
	     "update whiteouilist.xml\n"
	     "the oui_info from blackouilist.xml or whiteouilist.xml\n"
	     "blackouilist.xml or whiteouilist.xml list\n"
)
	{
	   unsigned int ret=0;
	   unsigned int ouiXmlType=0; //1--blacklist 2--whitelist
	   int localid = 1;
	   int slot_id = HostSlotId;
	   unsigned int index = 0;
	   if((strcmp(argv[0],"black")==0)||(tolower(argv[0][0]) == 'b')){
			 ouiXmlType = 1;
	   }
	   else if((strcmp(argv[0],"white")==0)||(tolower(argv[0][0]) == 'w')){
			 ouiXmlType = 2;
		}
	   else{
			vty_out(vty,"<error> input patameter should only be 'black/white' or 'b/w' \n");
			return CMD_SUCCESS;
		}
	   if(vty->node == HIDDENDEBUG_NODE){
		   index = 0;
	   }
	   DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	   dcli_update_black_white_oui_info_list(index,localid,&ret,ouiXmlType,dcli_dbus_connection);
	   if(ret == 0){
		   vty_out(vty,"update %s oui_info list successful!\n",argv[0]);
	   }
	   else {
		   vty_out(vty,"update %s oui_info list failed\n",argv[0]);
	   	}
	   return CMD_SUCCESS;
	 }
DEFUN(use_black_white_none_oui_policy_func,
	     use_black_white_none_oui_policy_cmd,
	     "use (black|white|none) oui_policy",
	     "use\n"
	     "none oui policy\n"
	     "black oui policy\n"
	     "white oui policy\n"
	     "dont use oui policy\n"
	     "oui poicy\n"
)
	{
		   unsigned int ret=0;
		   unsigned int ouiPolicyType=0; //1--blacklist 2--whitelist
		   int localid = 1;
		   int slot_id = HostSlotId;
		   unsigned int index = 0;
		   if((strcmp(argv[0],"none")==0)||(tolower(argv[0][0]) == 'n')){
				 ouiPolicyType = 0;
			}
	       else if((strcmp(argv[0],"black")==0)||(tolower(argv[0][0]) == 'b')){
				 ouiPolicyType = 1;
		   }
		   else if((strcmp(argv[0],"white")==0)||(tolower(argv[0][0]) == 'w')){
				 ouiPolicyType = 2;
			}
		   else{
				vty_out(vty,"<error> input patameter should only be 'black/white/none' or 'b/w/n' \n");
				return CMD_SUCCESS;
			}
		   if(vty->node == HIDDENDEBUG_NODE){
			   index = 0;
		   }
		   DBusConnection *dcli_dbus_connection = NULL;
		   ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
		   dcli_use_black_white_none_oui_policy(index,localid,&ret,ouiPolicyType,dcli_dbus_connection);
		   if(ret == 0){
			   vty_out(vty,"use %s oui_policy successful!\n",argv[0]);
		   }
		   else {
			   vty_out(vty,"use %s oui_policy  failed\n",argv[0]);
		  	}
		   return CMD_SUCCESS;
		 }
DEFUN(show_oui_policy_func,
	     show_oui_policy_cmd,
	     "show oui policy",
	     SHOW_STR
	     "Organizationally unique identifier\n"
	     "Organizationally unique identifier policy\n"
)
{
    	 unsigned int ret=0;
	 int localid = 1;
	 int slot_id = HostSlotId;
    	 unsigned int index = 0;
	  unsigned int ouiPolicyType=0;
	 if(vty->node == HIDDENDEBUG_NODE){
			   index = 0;
	  }
	 DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	 dcli_show_oui_policy(index,localid,&ret,&ouiPolicyType,dcli_dbus_connection);
	 vty_out(vty,"====================================================\n");
     vty_out(vty,"Oui Policy Type:%s\n",(ouiPolicyType==0)?"none":((ouiPolicyType==1)?"black":"white"));
	 vty_out(vty,"====================================================\n");
	 return CMD_SUCCESS;
}
/*fengwenchao add 20110329 for dot11WtpStatisticsTable , dot11WtpChannelTable*/
DEFUN(show_statistcs_information_of_all_wtp_whole_cmd_func,
	     show_statistcs_information_of_all_wtp_whole_cmd,
	     "show statistcs information of all wtp whole",
	     SHOW_STR
	     "statistcs information of all wtp\n"
)
{
	struct WtpAthStatisticInfo * WtpHead = NULL;
	struct WtpAthStatisticInfo * WtpNode = NULL;

	int ret =0;
	unsigned int wtp_num=0;
	int localid = 1;
	int slot_id = HostSlotId;
	int index=0;
	
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	
	WtpHead = show_statistcs_information_of_all_wtp_whole(index,localid,dcli_dbus_connection,&wtp_num,&ret);
	
	if(WtpHead && (ret==0))
	{
		WtpNode=WtpHead;
		vty_out(vty,"WTP NUMS : %d \n",wtp_num);
		vty_out(vty,"=================================================================\n");
		while(WtpNode)
		{
			vty_out(vty,"-----------------------------------------------------------------\n");
			vty_out(vty,"wtpCurrID:  %d \n",WtpNode->wtpCurrID);
			vty_out(vty,"wtpMacAddr:  %s \n",WtpNode->wtpMacAddr);
			//vty_out(vty,"wtpRxPacketLossRate:  %d \n",WtpNode->wtpRxPacketLossRate);
			//vty_out(vty,"wtpTxPacketLossRate:  %d \n",WtpNode->wtpTxPacketLossRate);
			vty_out(vty,"wtpTotalRx_Drop:  %d \n",WtpNode->wtpTotalRx_Drop);
			vty_out(vty,"wtpTotalTx_Drop:  %d \n",WtpNode->wtpTotalTx_Drop);
			vty_out(vty,"wtpTotalRx_Pkt:  %d \n",WtpNode->wtpTotalRx_Pkt);
			vty_out(vty,"wtpTotalTx_Pkt:  %d \n",WtpNode->wtpTotalTx_Pkt);
			vty_out(vty,"wtpDownBandwidthUtilization:  %d \n",WtpNode->wtpDownBandwidthUtilization);
			vty_out(vty,"wtpUpBandwidthUtilization:  %d \n",WtpNode->wtpUpBandwidthUtilization);
			vty_out(vty,"wtpReceiveRate:  %d \n",WtpNode->wtpReceiveRate);
			vty_out(vty,"wtpSendRate:  %d \n",WtpNode->wtpSendRate);
			vty_out(vty,"wtpPathPhyErrPack:  %d \n",WtpNode->ast_rx_phyerr);
			vty_out(vty,"tx_packets:  %d \n",WtpNode->tx_packets);
			vty_out(vty,"tx_errors:  %d \n",WtpNode->tx_errors);
			vty_out(vty,"tx_retry:  %d \n",WtpNode->tx_retry);
			vty_out(vty,"wtpSignalPathOfTerm:  %d \n",WtpNode->sta_num);
			vty_out(vty,"wtpMonitorTime:  %d \n",WtpNode->monitor_time);
			vty_out(vty,"wtpExtensionUsed:  %d \n",WtpNode->wtpExtensionUsed);       //fengwenchao add 20110503 for dot11WtpExtensionTable
			vty_out(vty,"wtpFloodAttackTimes:  %d \n",WtpNode->wtpFloodAttackTimes);       //fengwenchao add 20110503 for dot11WtpWidStatisticsTable
			vty_out(vty,"wtpSpoofingAttackTimes:  %d \n",WtpNode->wtpSpoofingAttackTimes);       //fengwenchao add 20110503 for dot11WtpWidStatisticsTable
			vty_out(vty,"wtpWeakIVAttackTimes:  %d \n",WtpNode->wtpWeakIVAttackTimes);       //fengwenchao add 20110503 for dot11WtpWidStatisticsTable
			vty_out(vty,"BssIDTatolNum:  %d \n",WtpNode->BssIDTatolNum);       //fengwenchao add 20110503 for dot11WtpBssIDNumTable

			WtpNode=WtpNode->next;
		}
		dcli_free_WtpAthStatisticInfo(WtpHead);
		vty_out(vty,"=================================================================\n");		
	}
	else if(ret == 0 && WtpHead == NULL)
	{
		vty_out(vty,"<error> there is no ath interface\n");
	}
	else if(ret == WID_DBUS_ERROR ||ret == ASD_DBUS_ERROR)
	{
		vty_out(vty,"<error> dbus failed get reply.\n");
	}
	else if(ret == WTP_ID_NOT_EXIST)
	{
		vty_out(vty,"<error> WID can't find wtp\n");
	}
	else
	{
		vty_out(vty,"<error> ret = %d \n",ret);
	}	
	return CMD_SUCCESS;
}
/*fengwenchao add end*/
/*fengwenchao add for GM-3*/
DEFUN(set_ap_heart_statistics_enable_func,
	  set_ap_heart_statistics_enable_cmd,
	  "set ap heart statistics switch (enable|disable)",
	  CONFIG_STR
	  "wtp config\n"
	  "wtp heart statistics information\n"
	  "wtp heart statistics information\n"
	  "wtp heart statistics information switch\n"
	  "enable|disable\n"
	 )
{
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID = 0;
    	unsigned char policy = 0;
	int ret;	
	
	if (!strcmp(argv[0],"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[0],"disable"))
	{
		policy = 0;	
	}
	else
	{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;		
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_METHOD_SET_AP_HEART_STATISTICS_SWITCH);
																		
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_EXTENSION_INFOMATION_SWITCH);*/
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_BYTE,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		vty_out(vty,"<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			vty_out(vty,"%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty," set wtp %d heart statistics switch %s successfully\n",WTPID,argv[0]);
	}
	else if (ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	
	return CMD_SUCCESS;			
}

DEFUN(set_ap_heart_statistics_collect_time_func,
	  set_ap_heart_statistics_collect_time_cmd,
	  "set ap heart statistics collect time TIME",
	  CONFIG_STR
	  "wtp config\n"
	  "wtp heart statistics information\n"
	  "wtp heart statistics information\n"
	  "wtp heart statistics information switch\n"
	  "reportinterval\n"
	 )
{
	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID = 0;
    	unsigned char policy = 0;
	int ret,ret1;
	
    	unsigned int time = 0;
	
	ret1 = parse_int_ID((char*)argv[0], &time);
	if(ret1 != WID_DBUS_SUCCESS){
            if(ret1 == WID_ILLEGAL_INPUT){
            	vty_out(vty,"<error> illegal input:Input exceeds the maximum value of the parameter type \n");
            }
			else{
			vty_out(vty,"<error> unknown id format\n");
			}
			return CMD_SUCCESS;
	}	
	if(time > 32767 || time == 0){   
		vty_out(vty,"<error> ap heart statistics reportinterval error\n");
		return CMD_SUCCESS;
	}
	int localid = 1;
	int slot_id = HostSlotId;

	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_METHOD_SET_AP_HEART_STATISTICS_COLLECT_TIME);
																			
/*	query = dbus_message_new_method_call(WID_DBUS_BUSNAME,WID_DBUS_WTP_OBJPATH,\
						WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_EXTENSION_INFOMATION_SWITCH);*/
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							DBUS_TYPE_UINT32,&time,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		vty_out(vty,"<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			vty_out(vty,"%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		vty_out(vty," set wtp %d heart statistics collect time %s successfully\n",WTPID,argv[0]);
	}
	else if (ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else if(ret == WID_DBUS_ERROR)
		vty_out(vty,"<error> heart statistics swtich is enable,please disable it first \n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	
	return CMD_SUCCESS;			
}
/*fengwenchao add end*/

DEFUN(show_conflict_wtp_list_cmd_func,
	     show_conflict_wtp_list_cmd,
	     "show conflict wtp list",
	     SHOW_STR
	     "show conflict wtp list\n"
	     "show conflict wtp list\n"
)
{
	unsigned int ret=0;
	int localid = 1;
	int slot_id = HostSlotId;
	unsigned int index = 0;
	struct conflict_wtp_info *conflict_wtp;
	if(vty->node == CONFIG_NODE){
		index = 0;
	}else if(vty->node == HANSI_NODE){
		index = (int)vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	
	struct ConflictWtp *tmp_node = NULL;
	struct conflict_wtp_info *list_node = NULL;

	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	dcli_show_conflict_wtp_list(index,localid,&ret,&conflict_wtp,dcli_dbus_connection);
	vty_out(vty,"==============================================================================\n");
	list_node = conflict_wtp;
	vty_out(vty,"%-12s,%-16s.\n","conflict mac","conflict id list");
	while(list_node){
		vty_out(vty,"%02X:%02X:%02X:%02X:%02X:%02X  \n",list_node->wtpmac[0],list_node->wtpmac[1],list_node->wtpmac[2],list_node->wtpmac[3],list_node->wtpmac[4],list_node->wtpmac[5]);
		tmp_node = list_node->wtpindexInfo;
		while(tmp_node){
			if(tmp_node->next){
				vty_out(vty,"%d,",tmp_node->wtpindex);
			}else{
				vty_out(vty,"%d.",tmp_node->wtpindex);
			}
			tmp_node = tmp_node->next;
		}
		vty_out(vty,"\n------------------------------------------------------------------------------\n");
		list_node = list_node->next;
	}
	vty_out(vty,"==============================================================================\n");
				
	conflict_wtp_list_free(conflict_wtp);
	return CMD_SUCCESS;
}

//weichao add for set ap password
DEFUN(set_ap_username_password_func,
	  set_ap_username_password_cmd,
	  "set ap username admin password PASSWORD",
	  "Set command\n"
	  "Set ap\n"
	  "Username\n"
	  "The user name, admin \n"
	  "Password\n"
	  "The user password, password length is 5-32\n"
	 )
{
	int ret,ret1;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;

	int length = 0;
	int wtpid = 0 ;
	char *name = "admin";
	char *passwd = NULL;
	
	/*length = strlen(argv[0]);
	if(length > 32 )
	{
		vty_out(vty,"<error> the username length should be 1 to 32!\n");
		return CMD_SUCCESS;
	}
	name = (char*)malloc(length+1);
	if(name == NULL)
		return;
	memset(name , 0 ,length+1);
	memcpy(name,argv[0],length);*/
	length = strlen(argv[0]);
	if(length < 5 ||length > 32)
	{
		vty_out(vty,"<error> the password length should be 5 to 32!\n");
		return CMD_SUCCESS;
	}
	passwd = (char *)malloc(length+1);
	if(passwd == NULL)
		return CMD_SUCCESS; 
	memset(passwd , 0,length+1);
	memcpy(passwd,argv[0],length);
	
	int localid = 1;
	int slot_id = HostSlotId;
	unsigned int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		wtpid = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		wtpid = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		wtpid = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	else if(vty->node == HANSI_NODE){
		index = vty->index;
		wtpid = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index; 		
		wtpid = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_USERNAME_PASSWORD);
			
	dbus_error_init(&err);
	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&wtpid,	
							 DBUS_TYPE_STRING,&name,
							 DBUS_TYPE_STRING,&passwd,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		vty_out(vty,"<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			vty_out(vty,"%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		free(passwd);

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == WID_DBUS_SUCCESS)
	{
		if(wtpid > 0)
			vty_out(vty,"set wtp %d username and password  successfully\n",wtpid);
		else
			vty_out(vty,"set wtp all username and password  successfully\n");
	}
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	//free(name);
	//name = NULL;
	free(passwd);
	passwd = NULL;
	return CMD_SUCCESS;			
}
//weichao add for sta deauth report
DEFUN(set_sta_deauth_message_enable_func,
	  set_sta_deauth_message_enable_cmd,
	  "set sta deauth message report switch (enable|disable)",
	  CONFIG_STR
	  "wtp config\n"
	  "sta deauth message\n"
	  "sta deauth message\n"
	  "sta deauth message report switch\n"
	  "enable|disable\n"
	 )
{
	int ret;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID = 0;
    int policy = 0;
	
	if (!strcmp(argv[0],"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[0],"disable"))
	{
		policy = 0;	
	}
	else
	{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}
	
	int localid = 1;
	int slot_id = HostSlotId;
	unsigned int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	else if(vty->node == HANSI_NODE){
		index = vty->index;
		WTPID = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index; 		
		WTPID = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_STA_DEAUTH_MESSAGE_REPORT_SWITCH);
		
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		vty_out(vty,"<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			vty_out(vty,"%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		if(WTPID == 0)
			vty_out(vty,"set all wtp sta deauth message report switch %s successfully\n",argv[0]);
		else
			vty_out(vty," set wtp %d sta deauth message report  switch %s successfully\n",WTPID,argv[0]);
	}
	else if (ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else if (ret == WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp id does not run\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	
	return CMD_SUCCESS;			
}
//weichao add 
DEFUN(set_ap_report_sta_detail_information_enable_func,
	  	set_ap_report_sta_detail_information_enable_cmd,
		  "set ap report sta detail information switch (enable|disable)",
		  CONFIG_STR
		  "wtp config\n"
		  "sta report message\n"
		  "sta report flow message\n"
		  "report all sta  message\n"
		  "switch"
		  "enable|disable\n"
	 )
{
	int ret;

	DBusMessage *query, *reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int WTPID = 0;
    	int policy = 0;
	
	if (!strcmp(argv[0],"enable"))
	{
		policy = 1;	
	}
	else if (!strcmp(argv[0],"disable"))
	{
		policy = 0;	
	}
	else
	{
		vty_out(vty,"<error> input patameter only with 'enable' or 'disable'\n");
		return CMD_SUCCESS;
	}
	
	int localid = 1;
	int slot_id = HostSlotId;
	unsigned int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	if(vty->node == WTP_NODE){
		index = 0;			
		WTPID = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}else if(vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index; 		
		WTPID = (int)vty->index_sub;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	else if(vty->node == HANSI_NODE){
		index = vty->index;
		WTPID = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	else if(vty->node == LOCAL_HANSI_NODE){
		index = vty->index; 		
		WTPID = 0;
		localid = vty->local;
		slot_id = vty->slotindex;
	}
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_STA_ALL_FLOW_INFORMATION_REPORT_SWITCH);
		
	dbus_error_init(&err);


	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&WTPID,
							 DBUS_TYPE_UINT32,&policy,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply)
	{
		vty_out(vty,"<error> failed get reply.\n");
		if (dbus_error_is_set(&err))
		{
			vty_out(vty,"%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		

		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);

	if(ret == 0)
	{
		if(WTPID == 0)
			vty_out(vty,"set all wtp sta report all flow information switch %s successfully\n",argv[0]);
		else
			vty_out(vty," set wtp %d sta report all flow information switch %s successfully\n",WTPID,argv[0]);
	}
	else if (ret == WTP_ID_NOT_EXIST)
		vty_out(vty,"<error> wtp id does not exist\n");
	else if (ret == WTP_NOT_IN_RUN_STATE)
		vty_out(vty,"<error> wtp id does not run\n");
	else
	{
		vty_out(vty,"<error>  %d\n",ret);
	}
		
	dbus_message_unref(reply);

	
	return CMD_SUCCESS;			
}
DEFUN(set_wtp_5g_able_cmd_func,
		set_wtp_5g_able_cmd,
		"set ap 5g switch (enable|disable)",
		"Set command\n"
		"set radio\n"
		"based bss\n"
		"switch\n"
		"default disable"
)
{
	int ret = 0 ; 
	DBusMessage *query,*reply;
	DBusError err;
	DBusMessageIter iter;
	unsigned int wtpid = 0 ; 
	unsigned char type = 0 ; 
	unsigned int wlan_id = 0; 
	unsigned char wlanid = 0 ;
	
	if(!strcmp(argv[0],"enable"))
	{
		type = 1; 
	}
	else if(!strcmp(argv[0],"disable"))
	{
		type = 0 ; 
	}
	dbus_error_init(&err);
	
	int index = 0;
	int localid = 1;
   	 int slot_id = HostSlotId;
	if(vty->node == WTP_NODE){
		index = 0;			
		wtpid = (int)vty->index;
	}else if(vty->node == HANSI_WTP_NODE){
		index = vty->index; 
		localid = vty->local;
		slot_id = vty->slotindex;
		wtpid = (int)vty->index_sub;
	}else if (vty->node == LOCAL_HANSI_WTP_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
		wtpid = (int)vty->index_sub;
    }else if (vty->node == LOCAL_HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
		wtpid = 0;
    }else if (vty->node == HANSI_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
		wtpid = 0;
    }else if (vty->node == CONFIG_NODE){
		index = vty->index;
		localid = vty->local;
		slot_id = vty->slotindex;
		wtpid = 0;
    }
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_WTP_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_WTP_METHOD_5G_SWITH);
	dbus_message_append_args(query,
					DBUS_TYPE_BYTE,&wlanid,
					DBUS_TYPE_UINT32,&wtpid,
					DBUS_TYPE_BYTE,&type,
					DBUS_TYPE_INVALID);
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,-1, &err);
		
	dbus_message_unref(query);
	
	if (NULL == reply) {
		vty_out(vty,"<error> failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			vty_out(vty,"%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}
	
	dbus_message_iter_init(reply,&iter);
	dbus_message_iter_get_basic(&iter,&ret);
	if(WID_DBUS_SUCCESS == ret )
		vty_out(vty,"set wtp(%d) 5g switch %s successfully!\n",wtpid,argv[0]);
	else if(ret==WID_DBUS_ERROR)
		vty_out(vty,"operation fail! .\n");
	else if(ret == WTP_ID_NOT_EXIST)	  
		vty_out(vty,"WTP %d is not exsit.\n",wtpid);
	else if(ret == WID_SINGLE_RADIO)
		vty_out(vty,"WTP %d is single Radio.",wtpid);
	else
		vty_out(vty,"<error>%d\n",ret);
	dbus_message_unref(reply);
	return CMD_SUCCESS;
}

/* Huangleilei copy from 1.3.18, 20130610 */
DEFUN(wtp_set_web_report_ap_snr_range_cmd_func,
	  wtp_set_web_report_ap_snr_range_cmd,
	  "set web-report ap-snr-range MAXSNR MINSNR",
	  WTP_SET
	  "web report config\n"
	  "ap snr value range\n"
	  "max snr value,range(-120~-10)\n"
	  "max snr value,range(-120~-10)\n"
	 )
{
	DBusMessage *query = NULL, *reply = NULL;
	DBusError err;
	DBusMessageIter	iter;
	int ret = 0;
	int max_snr = 0;
	int min_snr = 0;	
	int index = 0;
	int localid = 1;
   	int slot_id = HostSlotId;
	char BUSNAME[PATH_LEN] = {0};
	char OBJPATH[PATH_LEN] = {0};
	char INTERFACE[PATH_LEN] = {0};
	
	ret = parse_int_value(argv[0], &max_snr);
	if (WID_DBUS_SUCCESS != ret)
	{
		vty_out(vty,"%% unknown id format %d\n",max_snr);
		return CMD_SUCCESS;
	}

	ret = parse_int_value(argv[1], &min_snr);
	if (WID_DBUS_SUCCESS != ret)
	{
		vty_out(vty,"%% unknown id format %d\n",min_snr);
		return CMD_SUCCESS;
	}
	
	if ((AP_SNR_MAX < max_snr) || (AP_SNR_MIN > max_snr))
	{
		vty_out(vty,"%% input max snr should be <-120~-10>\n");
		return CMD_SUCCESS;
	}
	if ((AP_SNR_MAX < min_snr) || (AP_SNR_MIN > min_snr))
	{
		vty_out(vty,"%% input min snr should be <-120~-10>\n");
		return CMD_SUCCESS;
	}
	if(min_snr >= max_snr)
	{
		vty_out(vty,"%% input max snr should be greater than min snr\n");
		return CMD_SUCCESS;		
	}

	switch(vty->node)
	{
		case CONFIG_NODE:
			index = 0;
			localid = vty->local;
			slot_id = vty->slotindex;
			break;
		case HANSI_NODE:
			index = vty->index;
			localid = vty->local;
			slot_id = vty->slotindex;
			break;
		default:
			vty_out(vty, "this node type was not supported\n");
			return CMD_SUCCESS;
			break;
	}

	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection, slot_id, distributFag);

	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	
	query = dbus_message_new_method_call(BUSNAME, OBJPATH, INTERFACE,
											WID_DBUS_CONF_METHOD_SET_WEB_REPORT_SNR_RANGE);	

	dbus_error_init(&err);
	
	dbus_message_append_args(query,
							 DBUS_TYPE_INT32, &max_snr,
							 DBUS_TYPE_INT32, &min_snr,
							 DBUS_TYPE_INVALID);
	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection, query, -1, &err);	
	dbus_message_unref(query);
	if (NULL == reply) 
	{
		vty_out(vty,"%% failed get reply.\n");
		if (dbus_error_is_set(&err)) 
		{
			vty_out(vty,"%s raised: %s", err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return CMD_SUCCESS;
	}	

	dbus_message_iter_init(reply, &iter);
	dbus_message_iter_get_basic(&iter, &ret);
	dbus_message_unref(reply);

	switch (ret)
	{
		case WID_DBUS_SUCCESS:
			vty_out(vty, "command oprate successfully\n");
			break;
		case VALUE_OUT_OF_RANGE:
			vty_out(vty, "<error> the range value you inputted was out of we accept\n");
			break;
		case MIN_LARGER_THAN_MAX:
			vty_out(vty, "<error> the min [%c] is larger than the max [%c] you inputted\n", argv[1], argv[0]);
			break;
		default :
			vty_out(vty,"<error> other unknow error happend: %d\n", ret);
			break;
	}
	
	return CMD_SUCCESS;
}

int dcli_wtp_show_running_config_start(struct vty*vty) {	
	char *showStr = NULL,*cursor = NULL,ch = 0,tmpBuf[SHOWRUN_PERLINE_SIZE] = {0};
	DBusMessage *query, *reply;
	DBusError err;
	int res1 = 0, res2 = 0;
	char *tmp = NULL;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	index = 0;
	char buf[128] = {0};
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_WTP_SHOW_RUNNING_CONFIG_START);
	/*query = dbus_message_new_method_call(
							WID_DBUS_BUSNAME,		\
							WID_DBUS_OBJPATH , \
							WID_DBUS_INTERFACE ,		\
							WID_DBUS_CONF_METHOD_WTP_SHOW_RUNNING_CONFIG_START);*/

	dbus_error_init(&err);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,300000, &err);  //fengwenchao change "-1" to 300000 for TESTBED-7,20111213

	dbus_message_unref(query);
	if (NULL == reply) {
		//printf("show wtp config failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			//printf("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return 1;
	}

	if (dbus_message_get_args ( reply, &err,
					DBUS_TYPE_STRING, &showStr,
					DBUS_TYPE_INVALID)) 
	{
		char _tmpstr[64];
		memset(_tmpstr,0,64);
		sprintf(_tmpstr,BUILDING_MOUDLE,"WTP1");
		vtysh_add_show_string(_tmpstr);
		vtysh_add_show_string(showStr);
		dcli_config_write(showStr,1,slot_id,index,0,0);
		dbus_message_unref(reply);
	} 
	else 
	{
		//printf("Failed get args.\n");
		if (dbus_error_is_set(&err)) 
		{
			//printf("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		dbus_message_unref(reply);
		return 1;
	}


	
	res1 = dcli_wtp_list_show_running_config(vty);
	res2 = dcli_bss_list_show_running_config(vty); 
	sprintf(buf,"show interface wireless_config local %d 0",slot_id);
	tmp = vtysh_client_config_wireless_interface (&vtysh_client[0], buf);
	if(tmp != NULL){
		vtysh_add_show_string_parse(tmp);
		dcli_config_write(tmp,1,slot_id,index,0,0);
		XFREE(MTYPE_TMP, tmp);
		tmp = NULL;
	}
	return res1||res2;	
}


#if 1
int dcli_wtp_show_running_config_end(struct vty*vty) {	
	char *showStr = NULL,*cursor = NULL,ch = 0,tmpBuf[SHOWRUN_PERLINE_SIZE] = {0};
	DBusMessage *query, *reply;
	DBusError err;
	int localid = 1;
	int slot_id = HostSlotId;
	int index = 0;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	index = 0;
	char * tmp = NULL;
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_WTP_SHOW_RUNNING_CONFIG_END);
	/*query = dbus_message_new_method_call(
							WID_DBUS_BUSNAME,		\
							WID_DBUS_OBJPATH , \
							WID_DBUS_INTERFACE ,		\
							WID_DBUS_CONF_METHOD_WTP_SHOW_RUNNING_CONFIG_END);*/

	dbus_error_init(&err);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,300000, &err); //fengwenchao change "-1" to 300000 for TESTBED-7,20111213

	dbus_message_unref(query);
	if (NULL == reply) {
		//printf("show wtp config failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			//printf("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return 1;
	}

	if (dbus_message_get_args ( reply, &err,
					DBUS_TYPE_STRING, &showStr,
					DBUS_TYPE_INVALID)) 
	{
	
		char _tmpstr[64];
		memset(_tmpstr,0,64);
		sprintf(_tmpstr,BUILDING_MOUDLE,"WTP2");
		vtysh_add_show_string(_tmpstr);
		vtysh_add_show_string(showStr);
		dcli_config_write(showStr,1,slot_id,index,0,0);		
		dbus_message_unref(reply);
		
		tmp = dcli_dhcp_show_running_hansi_cfg(slot_id,index,1);
		if(tmp != NULL){
			if (0 != strlen(tmp)) {				
				vtysh_add_show_string(tmp);				
				dcli_config_write(tmp,1,slot_id,index,0,0); 	
			}
			free(tmp);
			tmp = NULL;
		}
		return 0;	
	} 
	else 
	{
		//printf("Failed get args.\n");
		if (dbus_error_is_set(&err)) 
		{
			//printf("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		dbus_message_unref(reply);
		return 1;	
	}

}
#endif

char* dcli_hansi_wtp_show_running_config_start(int localid ,int slot_id,int index) {	
	char *showStr = NULL,*cursor = NULL,ch = 0,tmpBuf[SHOWRUN_PERLINE_SIZE] = {0};
	DBusMessage *query, *reply;
	DBusError err;
	int res1 = 0, res2 = 0;
	char *tmp;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];	
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_WTP_SHOW_RUNNING_CONFIG_START);
	/*query = dbus_message_new_method_call(
							WID_DBUS_BUSNAME,		\
							WID_DBUS_OBJPATH , \
							WID_DBUS_INTERFACE ,		\
							WID_DBUS_CONF_METHOD_WTP_SHOW_RUNNING_CONFIG_START);*/

	dbus_error_init(&err);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,300000, &err); //fengwenchao change "-1" to 300000 for TESTBED-7,20111213

	dbus_message_unref(query);
	if (NULL == reply) {
		//printf("show wtp config failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			//printf("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return NULL;
	}

	if (dbus_message_get_args ( reply, &err,
					DBUS_TYPE_STRING, &showStr,
					DBUS_TYPE_INVALID)) 
	{
		tmp = (char *)malloc(strlen(showStr)+1);
		memset(tmp, 0, strlen(showStr)+1);
		memcpy(tmp,showStr,strlen(showStr));	
//		dcli_config_write(tmp,localid,slot_id,index,0,0);
		dbus_message_unref(reply);		
		return tmp;	
	} 
	else 
	{
		//printf("Failed get args.\n");
		if (dbus_error_is_set(&err)) 
		{
			//printf("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		dbus_message_unref(reply);
		return NULL;
	}
	
	return NULL;	
}

char* dcli_hansi_wtp_show_running_config_end(int localid, int slot_id,int index) {	
	char *showStr = NULL,*cursor = NULL,ch = 0,tmpBuf[SHOWRUN_PERLINE_SIZE] = {0};
	DBusMessage *query, *reply;
	DBusError err;
	char *tmp;
	char BUSNAME[PATH_LEN];
	char OBJPATH[PATH_LEN];
	char INTERFACE[PATH_LEN];
	DBusConnection *dcli_dbus_connection = NULL;
	ReInitDbusConnection(&dcli_dbus_connection,slot_id,distributFag);
	ReInitDbusPath_V2(localid,index,WID_DBUS_BUSNAME,BUSNAME);
	ReInitDbusPath_V2(localid,index,WID_DBUS_OBJPATH,OBJPATH);
	ReInitDbusPath_V2(localid,index,WID_DBUS_INTERFACE,INTERFACE);
	query = dbus_message_new_method_call(BUSNAME,OBJPATH,INTERFACE,WID_DBUS_CONF_METHOD_WTP_SHOW_RUNNING_CONFIG_END);
	/*query = dbus_message_new_method_call(
							WID_DBUS_BUSNAME,		\
							WID_DBUS_OBJPATH , \
							WID_DBUS_INTERFACE ,		\
							WID_DBUS_CONF_METHOD_WTP_SHOW_RUNNING_CONFIG_END);*/

	dbus_error_init(&err);

	reply = dbus_connection_send_with_reply_and_block (dcli_dbus_connection,query,300000, &err); //fengwenchao change "-1" to 300000 for TESTBED-7,20111213

	dbus_message_unref(query);
	if (NULL == reply) {
		//printf("show wtp config failed get reply.\n");
		if (dbus_error_is_set(&err)) {
			//printf("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		return NULL;
	}

	if (dbus_message_get_args ( reply, &err,
					DBUS_TYPE_STRING, &showStr,
					DBUS_TYPE_INVALID)) 
	{
	
		tmp = (char *)malloc(strlen(showStr)+1);
		memset(tmp, 0, strlen(showStr)+1);
		memcpy(tmp,showStr,strlen(showStr));	
//		dcli_config_write(showStr,localid,slot_id,index,0,0);
		dbus_message_unref(reply);
		return tmp; 
	} 
	else 
	{
		//printf("Failed get args.\n");
		if (dbus_error_is_set(&err)) 
		{
			//printf("%s raised: %s",err.name,err.message);
			dbus_error_free_for_dcli(&err);
		}
		dbus_message_unref(reply);
		return NULL;	
	}

}



void dcli_wtp_init(void) {
#if 0
	install_node(&wtp_node,dcli_wtp_show_running_config_start);
	install_node(&wtp_node1,dcli_wtp_show_running_config_end);
	install_default(WTP_NODE);


 	//install_node(&ap_group_wtp_node,NULL);
	//install_default(HANSI_AP_GROUP_WTP_NODE);
	
	//install_node(&ap_group_node,NULL);
	//install_default(AP_GROUP_WTP_NODE);

	//install_node(&hansi_ap_group_node,NULL);
	//install_default(HANSI_AP_GROUP_NODE);

	//install_node(&ap_group_wtp_node,NULL);
	//	install_default(AP_GROUP_WTP_NODE);
	
	/************************************************AP_GROUP_NODE**************************************************/
 	install_element(AP_GROUP_WTP_NODE,&config_wtp_service_cmd);
	install_element(AP_GROUP_WTP_NODE,&wtp_apply_wlan_cmd);
	install_element(AP_GROUP_WTP_NODE,&wtp_apply_interface_cmd);
	install_element(AP_GROUP_WTP_NODE,&wtp_disable_wlan_cmd);
	install_element(AP_GROUP_WTP_NODE,&wtp_enable_wlan_cmd);
	install_element(AP_GROUP_WTP_NODE,&set_ap_if_info_report_enable_cmd);
	install_element(AP_GROUP_WTP_NODE,&set_ap_if_info_reportinterval_cmd);
	install_element(AP_GROUP_WTP_NODE,&wtp_triger_num_cmd);
	install_element(AP_GROUP_WTP_NODE,&wtp_flow_triger_cmd);
	install_element(AP_GROUP_WTP_NODE,&set_ap_max_throughout_cmd);
	install_element(AP_GROUP_WTP_NODE,&set_ap_sta_infomation_reportinterval_cmd);  /*   WC     */
	install_element(AP_GROUP_WTP_NODE,&set_ap_sta_infomation_report_enable_cmd);
	install_element(AP_GROUP_WTP_NODE,&set_ap_igmp_snoop_cmd);
	install_element(AP_GROUP_WTP_NODE,&set_ap_dos_def_cmd);
	install_element(AP_GROUP_WTP_NODE,&set_ap_l2_isolation_cmd);
	install_element(AP_GROUP_WTP_NODE,&set_ap_extension_infomation_reportinterval_cmd);
	install_element(AP_GROUP_WTP_NODE,&set_ap_if_updown_cmd);
	install_element(AP_GROUP_WTP_NODE,&set_ap_if_eth_rate_cmd);
	install_element(AP_GROUP_WTP_NODE,&set_ap_sta_wapi_info_reportinterval_cmd);
	install_element(AP_GROUP_WTP_NODE,&set_ap_sta_wapi_info_report_enable_cmd);
	install_element(AP_GROUP_WTP_NODE,&set_wtp_trap_switch_cmd);
	install_element(AP_GROUP_WTP_NODE,&set_wtp_sta_info_report_enable_cmd);
	install_element(AP_GROUP_WTP_NODE,&set_wtp_dhcp_snooping_enable_cmd);
	install_element(AP_GROUP_WTP_NODE,&set_ap_networkaddr_command_cmd);
	install_element(AP_GROUP_WTP_NODE,&set_wtp_sn_cmd);
	install_element(AP_GROUP_WTP_NODE,&clear_wtp_img_cmd);
	install_element(AP_GROUP_WTP_NODE,&update_wtp_img_cmd);
	install_element(AP_GROUP_WTP_NODE,&set_ap_reboot_cmd);
	install_element(AP_GROUP_WTP_NODE,&set_ap_config_update_cmd);
	install_element(AP_GROUP_WTP_NODE,&set_ac_ap_ntp_cmd);
	install_element(AP_GROUP_WTP_NODE,&get_wtp_bss_pkt_info_cmd);
	install_element(AP_GROUP_WTP_NODE,&set_ap_terminal_distrub_infomation_sta_num_cmd);
	install_element(AP_GROUP_WTP_NODE,&set_ap_terminal_distrub_infomation_pkt_cmd);    /*  1*/
	install_element(AP_GROUP_WTP_NODE,&set_ap_terminal_distrub_infomation_switch_cmd);
	install_element(AP_GROUP_WTP_NODE,&set_ap_extension_infomation_enable_cmd);
	install_element(AP_GROUP_WTP_NODE,&set_wtp_wtpname_cmd);
	install_element(AP_GROUP_WTP_NODE,&set_wtp_netid_cmd);
	install_element(AP_GROUP_WTP_NODE,&set_ap_channel_disturb_trap_cmd);
	install_element(AP_GROUP_WTP_NODE,&set_wtp_location_cmd);
	install_element(AP_GROUP_WTP_NODE,&set_ap_extension_command_cmd);
	install_element(AP_GROUP_WTP_NODE,&tcpdump_ap_extension_command_cmd);
	install_element(AP_GROUP_WTP_NODE,&wtp_max_sta_cmd);
#endif
	/************************************************AP_GROUP_NODE_END**************************************************/
	/************************************************HANSI_AP_GROUP_NODE**************************************************/
 	install_element(HANSI_AP_GROUP_WTP_NODE,&config_wtp_service_cmd);
 	install_element(HANSI_AP_GROUP_WTP_NODE,&wtp_apply_wlan_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&wtp_apply_interface_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&wtp_disable_wlan_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&wtp_enable_wlan_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_ap_if_info_report_enable_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_ap_if_info_reportinterval_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&wtp_triger_num_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&wtp_flow_triger_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_ap_max_throughout_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_ap_sta_infomation_reportinterval_cmd);  /*   WC  */
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_ap_sta_infomation_report_enable_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_ap_igmp_snoop_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_ap_dos_def_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_ap_l2_isolation_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_ap_extension_infomation_reportinterval_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_ap_if_updown_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_ap_if_eth_rate_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_ap_sta_wapi_info_reportinterval_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_ap_sta_wapi_info_report_enable_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_wtp_trap_switch_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_wtp_seqnum_switch_cmd); /*wcl add*/
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_wtp_sta_info_report_enable_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_wtp_dhcp_snooping_enable_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_ap_networkaddr_command_cmd);
	//install_element(HANSI_AP_GROUP_WTP_NODE,&set_wtp_sn_cmd); /*wcl modify*/
	install_element(HANSI_AP_GROUP_WTP_NODE,&clear_wtp_img_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&update_wtp_img_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_ap_reboot_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_ap_config_update_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_ac_ap_ntp_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&get_wtp_bss_pkt_info_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_ap_terminal_distrub_infomation_sta_num_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_ap_terminal_distrub_infomation_pkt_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_ap_terminal_distrub_infomation_switch_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_ap_extension_infomation_enable_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_wtp_wtpname_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_wtp_netid_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_ap_channel_disturb_trap_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_wtp_location_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_ap_extension_command_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&set_ap_option60_parameter_cmd);//hjw add
	install_element(HANSI_AP_GROUP_WTP_NODE,&tcpdump_ap_extension_command_cmd);
	install_element(HANSI_AP_GROUP_WTP_NODE,&wtp_max_sta_cmd);
	/************************************************HANSI_AP_GROUP_NODE_END**************************************************/
	/************************************************LOCAL_HANSI_AP_GROUP_WTP_NODE**************************************************/
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&config_wtp_service_cmd);
 	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&wtp_apply_wlan_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&wtp_apply_interface_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&wtp_disable_wlan_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&wtp_enable_wlan_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_ap_if_info_report_enable_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_ap_if_info_reportinterval_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&wtp_triger_num_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&wtp_flow_triger_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_ap_max_throughout_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_ap_sta_infomation_reportinterval_cmd);  /*   WC  */
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_ap_sta_infomation_report_enable_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_ap_igmp_snoop_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_ap_dos_def_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_ap_l2_isolation_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_ap_extension_infomation_reportinterval_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_ap_if_updown_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_ap_if_eth_rate_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_ap_sta_wapi_info_reportinterval_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_ap_sta_wapi_info_report_enable_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_wtp_trap_switch_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_wtp_seqnum_switch_cmd); /*wcl add*/
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_wtp_sta_info_report_enable_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_wtp_dhcp_snooping_enable_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_ap_networkaddr_command_cmd);
	//install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_wtp_sn_cmd);  /*wcl modify*/
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&clear_wtp_img_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&update_wtp_img_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_ap_reboot_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_ap_config_update_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_ac_ap_ntp_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&get_wtp_bss_pkt_info_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_ap_terminal_distrub_infomation_sta_num_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_ap_terminal_distrub_infomation_pkt_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_ap_terminal_distrub_infomation_switch_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_ap_extension_infomation_enable_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_wtp_wtpname_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_wtp_netid_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_ap_channel_disturb_trap_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_wtp_location_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_ap_extension_command_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&set_ap_option60_parameter_cmd);//hjw add
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&tcpdump_ap_extension_command_cmd);
	install_element(LOCAL_HANSI_AP_GROUP_WTP_NODE,&wtp_max_sta_cmd);

	install_element(CONFIG_NODE,&download_ap_image_cmd);/*added by weiay 20081021*/
	install_element(CONFIG_NODE,&download_certificate_image_cmd);
	/************************************************LOCAL_HANSI_AP_GROUP_WTP_NODE_END**************************************************/

	/************************************************VIEW_NODE**************************************************/
	install_element(VIEW_NODE,&show_wtp_list_new_cmd);												/*a4*/
	install_element(VIEW_NODE,&show_wtp_cmd);														/*a2*/
	install_element(VIEW_NODE,&show_ac_access_wtp_info_cmd);										/*a13*/
	install_element(VIEW_NODE,&show_all_wtp_basic_information_cmd);									/*b1*/
	install_element(VIEW_NODE,&show_all_wtp_collect_information_cmd);								/*b2*/
	install_element(VIEW_NODE,&show_all_wtp_para_information_cmd);									/*b3*/
	install_element(VIEW_NODE,&show_all_wtp_wirelessifstats_information_cmd);						/*b9*/
	install_element(VIEW_NODE,&show_all_wtp_device_information_cmd);								/*b4*/
	install_element(VIEW_NODE,&show_all_wtp_data_pkts_information_cmd);								/*b5*/
	install_element(VIEW_NODE,&show_all_wtp_stats_information_cmd);									/*b6*/
	install_element(VIEW_NODE,&show_all_wlan_stats_information_cmd);								/*b7*/
	install_element(VIEW_NODE,&show_all_wlan_ssid_stats_information_cmd);							/*b8*/
	install_element(VIEW_NODE,&show_all_wtp_user_link_information_cmd);								/*b15*/
	install_element(VIEW_NODE,&show_all_wtp_wireless_if_information_cmd);							/*b17*/
	install_element(VIEW_NODE,&show_all_wtp_information_cmd);										/*b22*/
	install_element(VIEW_NODE,&show_all_wtp_new_wtp_wireless_ifinfo_information_cmd);				/*b18*/
	install_element(VIEW_NODE,&show_all_wtp_eth_port_information_cmd);								/*b12*/
	install_element(VIEW_NODE,&show_all_wtp_ifname_information_cmd);								/*b10*/
	install_element(VIEW_NODE,&show_all_wtp_radio_config_information_cmd);							/*b14*/
	install_element(VIEW_NODE,&show_all_wtp_the_radio_para_information_cmd);						/*b11*/
	install_element(VIEW_NODE,&show_all_wtp_radio_stats_information_cmd);							/*b13*/
	install_element(VIEW_NODE,&show_all_wtp_rogue_ap_info_information_cmd);							/*b20*/
	install_element(VIEW_NODE,&show_all_wtp_security_mech_information_cmd);							/*b21*/
	install_element(VIEW_NODE,&show_all_wtp_wired_ifstats_information_cmd);							/*b16*/
	install_element(VIEW_NODE,&show_wtp_list_by_state_cmd);
	install_element(VIEW_NODE,&show_all_wtp_network_info_cmd);
#if 0
	install_element(VIEW_NODE,&show_wtp_model_infor_cmd);											/*a1*/
	install_element(VIEW_NODE,&show_wtp_cmd);														/*a2*/
	install_element(VIEW_NODE,&show_wtp_list_cmd);													/*a3*/
	install_element(VIEW_NODE,&show_wtp_list_new_cmd);												/*a4*/
	install_element(VIEW_NODE,&show_wtp_model_list_cmd);											/*a5*/
	install_element(VIEW_NODE,&show_wtp_list_byinterface_cmd);										//xiaodawei add, 20110301
	install_element(VIEW_NODE,&show_wtp_list_by_mac_cmd);											/*a6*/
	install_element(VIEW_NODE,&show_wtp_list_by_state_cmd);											/*a7*/
	install_element(VIEW_NODE,&show_wtp_list_by_ip_cmd);											/*a8*/
	install_element(VIEW_NODE,&show_wtp_list_by_macex_cmd);											/*a9*/
	install_element(VIEW_NODE,&show_ap_version_cmd);												/*a10*/
	
	install_element(VIEW_NODE,&show_ap_echotimer_cmd);												/*a11*/
	install_element(VIEW_NODE,&show_ap_wids_set_cmd);												/*a12*/
	install_element(VIEW_NODE,&show_ac_access_wtp_info_cmd);										/*a13*/
	install_element(VIEW_NODE,&show_update_wtp_list);												/*a14*/
	install_element(VIEW_NODE,&show_wtp_running_config_cmd);											/*a18*/
	install_element(VIEW_NODE,&wtp_show_ap_update_config);											/*a15*/
	install_element(VIEW_NODE,&show_update_fail_wtp_list);											/*a16*/
	install_element(VIEW_NODE,&show_old_ap_img_data_cmd);											/*a17*/
	install_element(VIEW_NODE,&show_ap_trap_rogue_ap_ter_cpu_mem_threshold_cmd);					/*a18*/
	/*========================MIB optimize BEGIN=============================*/
	/*for mib information showting by nl 20100702*/
	install_element(VIEW_NODE,&show_all_wtp_basic_information_cmd);									/*b1*/
	install_element(VIEW_NODE,&show_all_wtp_collect_information_cmd);								/*b2*/
	install_element(VIEW_NODE,&show_all_wtp_para_information_cmd);									/*b3*/
	install_element(VIEW_NODE,&show_all_wtp_device_information_cmd);								/*b4*/
	install_element(VIEW_NODE,&show_all_wtp_stats_information_cmd);									/*b6*/
	install_element(VIEW_NODE,&show_all_wtp_wirelessifstats_information_cmd);						/*b9*/
	install_element(VIEW_NODE,&show_all_wtp_data_pkts_information_cmd);								/*b5*/
	install_element(VIEW_NODE,&show_all_wlan_stats_information_cmd);								/*b7*/
	install_element(VIEW_NODE,&show_all_wlan_ssid_stats_information_cmd);							/*b8*/
	install_element(VIEW_NODE,&show_all_wtp_ifname_information_cmd);								/*b10*/

	install_element(VIEW_NODE,&show_all_wtp_the_radio_para_information_cmd);						/*b11*/
	install_element(VIEW_NODE,&show_all_wtp_eth_port_information_cmd);								/*b12*/
	install_element(VIEW_NODE,&show_all_wtp_radio_stats_information_cmd);							/*b13*/
	install_element(VIEW_NODE,&show_all_wtp_radio_config_information_cmd);							/*b14*/
	install_element(VIEW_NODE,&show_all_wtp_user_link_information_cmd);								/*b15*/
	install_element(VIEW_NODE,&show_all_wtp_wired_ifstats_information_cmd);							/*b16*/
	install_element(VIEW_NODE,&show_all_wtp_wireless_if_information_cmd);							/*b17*/
	install_element(VIEW_NODE,&show_all_wtp_new_wtp_wireless_ifinfo_information_cmd);				/*b18*/
	install_element(VIEW_NODE,&show_all_wtp_new_wirelessifstats_information_cmd);					/*b19*/
	install_element(VIEW_NODE,&show_all_wtp_rogue_ap_info_information_cmd);							/*b20*/
	
	install_element(VIEW_NODE,&show_all_wtp_security_mech_information_cmd);							/*b21*/
	install_element(VIEW_NODE,&show_all_wtp_information_cmd);										/*b22*/
	install_element(VIEW_NODE,&show_all_wtp_network_info_cmd);/*xdw add for show ap network info of all wtp, 20101215*/
	
	/**********************************************ENABLE_NODE***********************************************/
	install_element(ENABLE_NODE,&show_wtp_list_cmd);												/*a1*/
	install_element(ENABLE_NODE,&show_wtp_cmd);														/*a2*/
	install_element(ENABLE_NODE,&show_wtp_model_infor_cmd);											/*a3*/
	install_element(ENABLE_NODE,&show_wtp_list_new_cmd);											/*a4*/
	install_element(ENABLE_NODE,&show_wtp_model_list_cmd);											/*a5*/
	install_element(ENABLE_NODE,&show_wtp_list_byinterface_cmd);										//xiaodawei add, 20110301
	install_element(ENABLE_NODE,&show_wtp_list_by_mac_cmd);											/*a6*/
	install_element(ENABLE_NODE,&show_wtp_list_by_state_cmd);										/*a7*/
	install_element(ENABLE_NODE,&show_wtp_list_by_ip_cmd);											/*a8*/
	install_element(ENABLE_NODE,&show_wtp_list_by_macex_cmd);										/*a9*/
	install_element(ENABLE_NODE,&show_ap_version_cmd);												/*a10*/
	
	install_element(ENABLE_NODE,&show_ap_echotimer_cmd);											/*a11*/
	install_element(ENABLE_NODE,&show_ap_wids_set_cmd);												/*a12*/
	install_element(ENABLE_NODE,&show_ac_access_wtp_info_cmd);										/*a13*/
	install_element(ENABLE_NODE,&show_update_wtp_list);												/*a14*/
	install_element(ENABLE_NODE,&show_wtp_running_config_cmd);											/*a18*/
	install_element(ENABLE_NODE,&wtp_show_ap_update_config);										/*a15*/
	install_element(ENABLE_NODE,&show_update_fail_wtp_list);										/*a16*/
	install_element(ENABLE_NODE,&show_old_ap_img_data_cmd);											/*a17*/
	install_element(ENABLE_NODE,&show_ap_trap_rogue_ap_ter_cpu_mem_threshold_cmd);					/*a18*/
	/*========================MIB optimize BEGIN=============================*/
	/*for mib information showting by nl 20100702*/
	install_element(ENABLE_NODE,&show_all_wtp_basic_information_cmd);							/*b1*/
	install_element(ENABLE_NODE,&show_all_wtp_collect_information_cmd);							/*b2*/
	install_element(ENABLE_NODE,&show_all_wtp_para_information_cmd);							/*b3*/
	install_element(ENABLE_NODE,&show_all_wtp_device_information_cmd);							/*b4*/
	install_element(ENABLE_NODE,&show_all_wtp_stats_information_cmd);							/*b6*/
	install_element(ENABLE_NODE,&show_all_wtp_wirelessifstats_information_cmd);					/*b9*/
	install_element(ENABLE_NODE,&show_all_wtp_data_pkts_information_cmd);						/*b5*/
	install_element(ENABLE_NODE,&show_all_wlan_stats_information_cmd);							/*b7*/
	install_element(ENABLE_NODE,&show_all_wlan_ssid_stats_information_cmd);						/*b8*/
	install_element(ENABLE_NODE,&show_all_wtp_ifname_information_cmd);							/*b10*/

	install_element(ENABLE_NODE,&show_all_wtp_the_radio_para_information_cmd);					/*b11*/
	install_element(ENABLE_NODE,&show_all_wtp_eth_port_information_cmd);						/*b12*/
	install_element(ENABLE_NODE,&show_all_wtp_radio_stats_information_cmd);						/*b13*/
	install_element(ENABLE_NODE,&show_all_wtp_radio_config_information_cmd);					/*b14*/
	install_element(ENABLE_NODE,&show_all_wtp_user_link_information_cmd);						/*b15*/
	install_element(ENABLE_NODE,&show_all_wtp_wired_ifstats_information_cmd);					/*b16*/
	install_element(ENABLE_NODE,&show_all_wtp_wireless_if_information_cmd);						/*b17*/
	install_element(ENABLE_NODE,&show_all_wtp_new_wtp_wireless_ifinfo_information_cmd);			/*b18*/
	install_element(ENABLE_NODE,&show_all_wtp_new_wirelessifstats_information_cmd);				/*b19*/
	install_element(ENABLE_NODE,&show_all_wtp_rogue_ap_info_information_cmd);					/*b20*/
	
	install_element(ENABLE_NODE,&show_all_wtp_security_mech_information_cmd);					/*b21*/
	install_element(ENABLE_NODE,&show_all_wtp_information_cmd);									/*b22*/
	install_element(ENABLE_NODE,&show_all_wtp_network_info_cmd);/*xdw add for show ap network info of all wtp, 20101215*/
	/*----------------liuzhenhua--- add ---begin--------------------*/
	install_element(ENABLE_NODE,&show_all_wtp_terminal_information_cmd);/*lzh add 20100517*/		/*b23*/
	install_element(ENABLE_NODE,&show_all_wtp_wlan_data_pkts_information_cmd);					/*b24*/
	install_element(ENABLE_NODE,&show_all_wtp_station_information_cmd);							/*b25*/
	/*----------------liuzhenhua--- add ---end--------------------*/
	/*========================MIB optimize END=============================*/
	
	/************************************************CONFIG_NODE**************************************************/
	install_element(CONFIG_NODE,&show_wtp_model_infor_cmd);											/*a1*/
	install_element(CONFIG_NODE,&show_wtp_cmd);														/*a2*/
	install_element(CONFIG_NODE,&show_wtp_list_cmd);												/*a3*/
	install_element(CONFIG_NODE,&show_wtp_list_new_cmd);											/*a4*/
	install_element(CONFIG_NODE,&show_wtp_model_list_cmd);											/*a5*/
	install_element(CONFIG_NODE,&show_wtp_list_byinterface_cmd);									//xiaodawei add, 20110301
	install_element(CONFIG_NODE,&show_wtp_list_by_mac_cmd);											/*a6*/
	install_element(CONFIG_NODE,&show_wtp_list_by_state_cmd);										/*a7*/
	install_element(CONFIG_NODE,&show_wtp_list_by_ip_cmd);											/*a8*/
	install_element(CONFIG_NODE,&show_wtp_list_by_macex_cmd);										/*a9*/
	install_element(CONFIG_NODE,&show_ap_version_cmd);												/*a10*/
	
	install_element(CONFIG_NODE,&show_ap_echotimer_cmd);											/*a11*/
	install_element(CONFIG_NODE,&show_ap_wids_set_cmd);												/*a12*/
	install_element(CONFIG_NODE,&show_ac_access_wtp_info_cmd);										/*a13*/
	install_element(CONFIG_NODE,&show_update_wtp_list);												/*a14*/
	install_element(CONFIG_NODE,&show_wtp_running_config_cmd);											/*a18*/
	install_element(CONFIG_NODE,&wtp_show_ap_update_config);										/*a15*/
	install_element(CONFIG_NODE,&show_update_fail_wtp_list);										/*a16*/
	install_element(CONFIG_NODE,&show_old_ap_img_data_cmd);											/*a17*/
	install_element(CONFIG_NODE,&show_ap_trap_rogue_ap_ter_cpu_mem_threshold_cmd);					/*a18*/

	/*========================MIB optimize BEGIN=============================*/
	/*for mib information showting by nl 20100702*/
	install_element(CONFIG_NODE,&show_all_wtp_basic_information_cmd);							/*b1*/
	install_element(CONFIG_NODE,&show_all_wtp_collect_information_cmd);							/*b2*/
	install_element(CONFIG_NODE,&show_all_wtp_para_information_cmd);							/*b3*/
	install_element(CONFIG_NODE,&show_all_wtp_device_information_cmd);							/*b4*/
	install_element(CONFIG_NODE,&show_all_wtp_stats_information_cmd);							/*b6*/
	install_element(CONFIG_NODE,&show_all_wtp_wirelessifstats_information_cmd);					/*b9*/
	install_element(CONFIG_NODE,&show_all_wtp_data_pkts_information_cmd);						/*b5*/
	install_element(CONFIG_NODE,&show_all_wlan_stats_information_cmd);							/*b7*/
	install_element(CONFIG_NODE,&show_all_wlan_ssid_stats_information_cmd);						/*b8*/
	install_element(CONFIG_NODE,&show_all_wtp_ifname_information_cmd);							/*b10*/

	install_element(CONFIG_NODE,&show_all_wtp_the_radio_para_information_cmd);					/*b11*/
	install_element(CONFIG_NODE,&show_all_wtp_eth_port_information_cmd);						/*b12*/
	install_element(CONFIG_NODE,&show_all_wtp_radio_stats_information_cmd);						/*b13*/
	install_element(CONFIG_NODE,&show_all_wtp_radio_config_information_cmd);					/*b14*/
	install_element(CONFIG_NODE,&show_all_wtp_user_link_information_cmd);						/*b15*/
	install_element(CONFIG_NODE,&show_all_wtp_wired_ifstats_information_cmd);					/*b16*/
	install_element(CONFIG_NODE,&show_all_wtp_wireless_if_information_cmd);						/*b17*/
	install_element(CONFIG_NODE,&show_all_wtp_new_wtp_wireless_ifinfo_information_cmd);			/*b18*/
	install_element(CONFIG_NODE,&show_all_wtp_new_wirelessifstats_information_cmd);				/*b19*/
	install_element(CONFIG_NODE,&show_all_wtp_rogue_ap_info_information_cmd);					/*b20*/
	
	install_element(CONFIG_NODE,&show_all_wtp_security_mech_information_cmd);					/*b21*/
	install_element(CONFIG_NODE,&show_all_wtp_information_cmd);									/*b22*/
	install_element(CONFIG_NODE,&show_all_wtp_network_info_cmd);/*xdw add for show ap network info of all wtp, 20101215*/
	install_element(CONFIG_NODE,&set_hide_quit_wtp_cmd);										/*for showing requirment*/		
	install_element(CONFIG_NODE,&set_trap_ignore_wtp_cmd); /*zhangshu add 2010-08-24 */
	install_element(CONFIG_NODE,&show_hide_quit_wtp_cmd);  /*zhangshu add 2010-08-21 */
	/*----------------liuzhenhua--- add ---begin--------------------*/
	install_element(CONFIG_NODE,&show_all_wtp_terminal_information_cmd);/*lzh add 20100517*/		/*b23*/
	install_element(CONFIG_NODE,&show_all_wtp_wlan_data_pkts_information_cmd);					/*b24*/
	install_element(CONFIG_NODE,&show_all_wtp_station_information_cmd);							/*b25*/
	install_element(CONFIG_NODE,&show_ath_statistics_info_of_all_wtp_cmd);
	/*----------------liuzhenhua--- add ---end--------------------*/
	install_element(CONFIG_NODE,&show_all_wtp_station_statistic_information_cmd);	//mahz add 2011.11.9 for GuangZhou Mobile
	install_element(CONFIG_NODE,&show_ac_sta_information_cmd);						//mahz add 2011.11.10 
	/*========================MIB optimize END=============================*/
	
	//install_element(CONFIG_NODE,&create_wtp_cmd);	  //fengwenchao comment 20110412
	install_element(CONFIG_NODE,&diag_wtp_list_bywtpid_cmd);
	install_element(CONFIG_NODE,&diag_wtp_list_bywlanid_cmd);
	install_element(CONFIG_NODE,&btrace_wtp_list_bywtpid_cmd);
	install_element(CONFIG_NODE,&btrace_wtp_list_bywlanid_cmd);
	install_element(CONFIG_NODE,&diag_wtp_list_cmd);
	install_element(CONFIG_NODE,&btrace_wtp_list_cmd);
	
	install_element(CONFIG_NODE,&create_wtp_bymac_cmd);	
	install_element(CONFIG_NODE,&delete_wtp_cmd);
	install_element(CONFIG_NODE,&config_wtp_cmd);
	install_element(CONFIG_NODE,&wtp_set_ap_model_version_path_cmd);/*xm 08/08/29*/
	install_element(CONFIG_NODE,&delete_model_cmd);
	install_element(CONFIG_NODE,&set_ap_connect_check_cmd);
	install_element(CONFIG_NODE,&set_ap_echotimer_cmd);
	install_element(CONFIG_NODE,&set_ap_cpu_collect_time_cmd);
	install_element(CONFIG_NODE,&download_ap_image_cmd);/*added by weiay 20081021*/
	install_element(CONFIG_NODE,&download_certificate_image_cmd);
	install_element(CONFIG_NODE,&uplink_detect_cmd);
	install_element(CONFIG_NODE,&check_download_ap_image_cmd);
	install_element(CONFIG_NODE,&check_download_wapi_cert_cmd);
	install_element(CONFIG_NODE,&set_ap_wids_set_cmd);

	install_element(CONFIG_NODE,&clean_ac_access_wtp_info_cmd);
	//install_element(CONFIG_NODE,&old_ap_img_data_cmd);
	install_element(CONFIG_NODE,&set_ap_reboot_all_cmd);
	install_element(CONFIG_NODE,&set_ap_reboot_by_wlanid_cmd);
	install_element(CONFIG_NODE,&set_ap_reboot_by_interface_cmd);
	install_element(CONFIG_NODE,&set_ap_reboot_by_model_cmd);
	install_element(CONFIG_NODE,&set_ap_reboot_by_list_cmd);
	install_element(CONFIG_NODE,&wtp_set_ap_update_config);
	install_element(CONFIG_NODE,&bind_ap_model_with_file_config);	/*mahz add for ap upgrade automatically*/
	install_element(CONFIG_NODE,&wtp_set_ap_update_base_model_config);
	install_element(CONFIG_NODE,&show_model_tar_file_bind_info);
	install_element(CONFIG_NODE,&delete_model_bind_info_config);
	install_element(CONFIG_NODE,&wtp_clear_ap_one_model_update_config);
	install_element(CONFIG_NODE,&show_detail_model_tar_file_bind_info);
	install_element(CONFIG_NODE,&wtp_set_ap_update_count_config);
	install_element(CONFIG_NODE,&wtp_set_ap_update_control_config);
	install_element(CONFIG_NODE,&show_ap_upgrade_result_info);
	
	install_element(CONFIG_NODE,&wtp_clear_ap_update_config);
	install_element(CONFIG_NODE,&optional_update_wtp_img_cmd);
	install_element(CONFIG_NODE,&optional_clear_wtp_img_cmd);

	install_element(CONFIG_NODE,&clear_update_fail_wtp_cmd);
	install_element(CONFIG_NODE,&set_wtp_list_dhcp_snooping_enable_cmd);
	install_element(CONFIG_NODE,&set_wtp_list_sta_info_report_enable_cmd);
	install_element(CONFIG_NODE,&set_wtp_trap_threshold_cmd);
	
  /*zhaoruijia,tranlate  neighbor_channel_interference to 1.3,start*/
	install_element(CONFIG_NODE,&set_wtp_trap_neighbor_same_channelrssithreshold_cmd);

    install_element(CONFIG_NODE,&show_wlan_radio_information_cmd);
	install_element(CONFIG_NODE,&show_wtp_config_of_all_cmd);      //fengwenchao add  20101223
	install_element(CONFIG_NODE,&show_all_wlan_ssid_stats_information_of_all_radio_cmd);  //fengwenchao add 20110112
	install_element(CONFIG_NODE,&show_wtp_list_by_model_cmd);      //fengwenchao add  20110303
	install_element(CONFIG_NODE,&show_wtp_list_by_version_cmd);    //fengwenchao add 20110314
	install_element(CONFIG_NODE,&show_statistcs_information_of_all_wtp_whole_cmd);  //fengwenchao add 20110330
	install_element(CONFIG_NODE, &wtp_set_web_report_ap_snr_range_cmd);			/* Huangleilei copy from 1.3.18, 20130610 */
	
	/************************************************WTP_NODE**************************************************/
	install_element(WTP_NODE,&wtp_apply_interface_cmd);
	install_element(WTP_NODE,&set_trap_ignore_wtp_cmd);  /*zhangshu add 2010-08-24 */
	//install_element(WTP_NODE,&wtp_apply_ipv6interface_cmd);
	install_element(WTP_NODE,&wtp_apply_wlan_cmd);
	install_element(WTP_NODE,&config_wtp_service_cmd);
	install_element(WTP_NODE,&wtp_delete_wlan_cmd);/*20080701*/
	install_element(WTP_NODE,&wtp_enable_wlan_cmd);
	install_element(WTP_NODE,&wtp_disable_wlan_cmd);
	
	install_element(WTP_NODE,&wtp_max_sta_cmd); /*xm add 08/12/03*/
	install_element(WTP_NODE,&wtp_flow_triger_cmd);/*xm add 08/12/03*/
	install_element(WTP_NODE,&wtp_triger_num_cmd); 
	install_element(WTP_NODE,&set_ap_max_throughout_cmd);
	install_element(WTP_NODE,&set_ap_extension_command_cmd);
	install_element(WTP_NODE,&tcpdump_ap_extension_command_cmd);
	install_element(WTP_NODE,&set_ap_ipaddr_command_cmd);
	install_element(WTP_NODE,&show_wtp_runtime_cmd);
	install_element(WTP_NODE,&show_wtp_netid_cmd);
	install_element(WTP_NODE,&set_wtp_location_cmd);
	install_element(WTP_NODE,&show_wtp_location_cmd);
	install_element(WTP_NODE,&set_ap_channel_disturb_trap_cmd);
	install_element(WTP_NODE,&set_wtp_netid_cmd);

	/* zhangshu add for wtp_terminal_distrub_information cmd ,2010-10-08 */
	install_element(WTP_NODE,&set_ap_terminal_distrub_infomation_switch_cmd);
	install_element(WTP_NODE,&set_ap_terminal_distrub_infomation_pkt_cmd);
	install_element(WTP_NODE,&set_ap_terminal_distrub_infomation_sta_num_cmd);
	
	/*install_element(WTP_NODE,&show_wtp_extension_information_cmd);*/
	install_element(WTP_NODE,&show_wtp_sample_throughput_information_cmd);
	install_element(WTP_NODE,&set_wtp_wtpname_cmd);
	install_element(WTP_NODE,&show_wtp_wlan_vlan_information_cmd);
	install_element(WTP_NODE,&set_ap_extension_infomation_enable_cmd);
	install_element(WTP_NODE,&set_ap_extension_infomation_reportinterval_cmd);
	
	/**************for sample value begin*******************/
	install_element(CONFIG_NODE,&set_ap_moment_infomation_reportinterval_cmd); /*wtp moment report interval by nl 2010-08-18*/
	install_element(CONFIG_NODE,&show_ap_moment_information_reportinterval_cmd); /*wtp moment report interval by nl 2010-08-21*/
	install_element(CONFIG_NODE,&set_ap_routine_infomation_reportinterval_cmd); /*wtp routine report interval by nl 2010-08-18*/
	install_element(CONFIG_NODE,&set_ap_sample_infomation_reportinterval_cmd); /*wtp routine report interval by nl 2010-08-18*/
	install_element(WTP_NODE,&set_ap_moment_infomation_enable_cmd);/*wtp moment report interval by nl 2010-08-18*/
	install_element(CONFIG_NODE,&set_ap_moment_infomation_enable_cmd);/*wtp moment report interval by nl 2010-08-18*/
	/**************for sample value end*******************/

	/*install_element(WTP_NODE,&show_wtp_extension_information_v2_cmd);
	//install_element(WTP_NODE,&show_wtp_ethernet_interface_information_cmd);*/
	install_element(WTP_NODE,&set_ap_l2_isolation_cmd);
	install_element(WTP_NODE,&set_ap_dos_def_cmd);
	install_element(WTP_NODE,&set_ap_igmp_snoop_cmd);
	install_element(WTP_NODE,&show_ap_mib_information_cmd);
	install_element(WTP_NODE,&show_wtp_extension_information_v3_cmd);
	install_element(WTP_NODE,&show_wtp_extension_information_v4_cmd);
	install_element(WTP_NODE,&show_ap_cm_statistics_cmd);
	install_element(WTP_NODE,&set_ap_sta_infomation_report_enable_cmd);
	install_element(WTP_NODE,&set_ap_sta_infomation_reportinterval_cmd);
	install_element(WTP_NODE,&set_ap_if_info_report_enable_cmd);
	install_element(WTP_NODE,&set_ap_if_info_reportinterval_cmd);
	install_element(WTP_NODE,&set_ap_if_updown_cmd);
	install_element(WTP_NODE,&set_ap_if_eth_rate_cmd);	
	install_element(WTP_NODE,&show_ap_if_info_cmd);
	install_element(WTP_NODE,&show_wtp_bss_pkt_info_cmd);
	install_element(WTP_NODE,&get_wtp_bss_pkt_info_cmd);
	install_element(WTP_NODE,&show_wtp_radio_pkt_info_cmd);
	install_element(WTP_NODE,&show_wtp_eth_pkt_info_cmd);
	install_element(WTP_NODE,&show_wtp_wifi_snr_cmd);
	install_element(WTP_NODE,&set_ac_ap_ntp_cmd);
	install_element(WTP_NODE,&set_ap_config_update_cmd);
	install_element(WTP_NODE,&show_wtp_max_power_base_model_cmd);
	install_element(WTP_NODE,&set_ap_reboot_cmd);
	
	install_element(WTP_NODE,&show_wtp_model_code_version_cmd);
	install_element(WTP_NODE,&update_wtp_img_cmd);
	install_element(WTP_NODE,&clear_wtp_img_cmd);
	install_element(WTP_NODE,&set_wtp_sn_cmd);
	install_element(WTP_NODE,&set_ap_networkaddr_command_cmd);
	install_element(WTP_NODE,&set_wtp_dhcp_snooping_enable_cmd);
	install_element(WTP_NODE,&set_wtp_sta_info_report_enable_cmd);
	install_element(WTP_NODE,&set_wtp_trap_threshold_cmd);
	install_element(WTP_NODE,&show_ap_trap_rogue_ap_ter_cpu_mem_threshold_cmd);
	install_element(WTP_NODE,&set_ap_heart_statistics_enable_cmd);  //fengwenchao add 20111130 for GM-3
	install_element(WTP_NODE,&set_ap_heart_statistics_collect_time_cmd); //fengwenchao add 20111130 for GM-3
	install_element(WTP_NODE,&set_wtp_trap_switch_cmd);
	install_element(WTP_NODE,&set_ap_connect_check_cmd);
	install_element(WTP_NODE,&set_ap_echotimer_cmd);
	install_element(WTP_NODE,&set_ap_cpu_collect_time_cmd);
	install_element(WTP_NODE,&set_ap_sta_wapi_info_report_enable_cmd);	
	install_element(WTP_NODE,&set_ap_sta_wapi_info_reportinterval_cmd);
	install_element(WTP_NODE,&show_wtp_running_config_cmd);
    install_element(WTP_NODE,&set_sta_deauth_message_enable_cmd);
	install_element(WTP_NODE,&set_ap_report_sta_detail_information_enable_cmd);
  /*zhaoruijia,tranlate  neighbor_channel_interference to 1.3,start*/
	install_element(WTP_NODE,&set_wtp_trap_neighbor_same_channelrssithreshold_cmd);
 	install_element(WTP_NODE,&show_wtp_radio_pkt_info_tunnel_cmd);
	install_element(WTP_NODE,&set_wtp_trap_collect_cmd);
	install_element(WTP_NODE,&set_ap_if_eth_mtu_cmd);    //fengwenchao add 20110126
	install_element(WTP_NODE,&set_wid_rogue_danger_unsafe_attack_trap_state_cmd);  //fengwenchao add 20110221

#endif


  
	
	/************************************************HANSI_NODE**************************************************/
			install_node(&hansi_wtp_node,NULL,"HANSI_WTP_NODE");
			install_default(HANSI_WTP_NODE);
			install_node(&local_hansi_wtp_node,NULL,"LOCAL_HANSI_WTP_NODE");
			install_default(LOCAL_HANSI_WTP_NODE);
			
			install_element(HANSI_NODE,&show_wtp_model_infor_cmd);
			install_element(HANSI_NODE,&show_wtp_cmd);
			install_element(HANSI_NODE,&show_wtp_list_cmd);
			install_element(HANSI_NODE,&show_wtp_list_new_cmd);
		    install_element(HANSI_NODE,&show_wtp_model_list_cmd);
			install_element(HANSI_NODE,&show_wtp_list_byinterface_cmd);										//xiaodawei add, 20110301
			install_element(HANSI_NODE,&show_wtp_list_by_mac_cmd);
			install_element(HANSI_NODE,&show_wtp_list_by_state_cmd);
			install_element(HANSI_NODE,&show_wtp_list_by_ip_cmd);
			install_element(HANSI_NODE,&show_wtp_list_by_macex_cmd);
			install_element(HANSI_NODE,&show_ap_version_cmd);
			
			install_element(HANSI_NODE,&show_ap_echotimer_cmd);
			install_element(HANSI_NODE,&show_ap_wids_set_cmd);
			install_element(HANSI_NODE,&show_dhcp_flooding_status_cmd);
			install_element(HANSI_NODE,&set_dhcp_flooding_status_cmd);
			install_element(HANSI_NODE,&show_ac_access_wtp_info_cmd);
			install_element(HANSI_NODE,&show_ap_trap_rogue_ap_ter_cpu_mem_threshold_cmd);
			install_element(HANSI_NODE,&wtp_show_ap_update_config);
			install_element(HANSI_NODE,&show_update_wtp_list);
			install_element(HANSI_NODE,&show_wtp_running_config_cmd);											/*a18*/
			install_element(HANSI_NODE,&show_update_fail_wtp_list);
			install_element(HANSI_NODE,&show_old_ap_img_data_cmd);
			
			install_element(HANSI_NODE,&diag_wtp_list_bywtpid_cmd);
			install_element(HANSI_NODE,&diag_wtp_list_bywlanid_cmd);
			install_element(HANSI_NODE,&btrace_wtp_list_bywtpid_cmd);
			install_element(HANSI_NODE,&btrace_wtp_list_bywlanid_cmd);

			install_element(HANSI_NODE,&diag_wtp_list_cmd);
			install_element(HANSI_NODE,&btrace_wtp_list_cmd);

			//install_element(HANSI_NODE,&create_wtp_cmd);	//fengwenchao comment 20110412
			install_element(HANSI_NODE,&create_wtp_bymac_cmd); 
			install_element(HANSI_NODE,&delete_wtp_cmd);
			install_element(HANSI_NODE,&config_wtp_cmd);
			install_element(HANSI_NODE,&wtp_set_ap_model_version_path_cmd);/*xm 08/08/29*/
			install_element(HANSI_NODE,&delete_model_cmd);
			install_element(HANSI_NODE,&set_ap_connect_check_cmd);
			install_element(HANSI_NODE,&set_ap_echotimer_cmd);
			install_element(HANSI_NODE,&set_ap_cpu_collect_time_cmd);
			install_element(HANSI_NODE,&download_ap_image_cmd);/*added by weiay 20081021*/
			install_element(HANSI_NODE,&download_certificate_image_cmd);
			install_element(HANSI_NODE,&uplink_detect_cmd);
			install_element(HANSI_NODE,&check_download_ap_image_cmd);
			install_element(HANSI_NODE,&check_download_wapi_cert_cmd);
			install_element(HANSI_NODE,&set_ap_wids_set_cmd);

			install_element(HANSI_NODE,&clean_ac_access_wtp_info_cmd);
			install_element(HANSI_NODE,&old_ap_img_data_cmd);
			install_element(HANSI_NODE,&set_wtp_trap_threshold_cmd);
			install_element(HANSI_NODE,&set_ap_reboot_all_cmd);
			install_element(HANSI_NODE,&set_ap_reboot_by_wlanid_cmd);
			install_element(HANSI_NODE,&set_ap_reboot_by_interface_cmd);
			install_element(HANSI_NODE,&set_ap_reboot_by_model_cmd);
			install_element(HANSI_NODE,&set_ap_reboot_by_list_cmd);
			//install_element(HANSI_NODE,&wtp_set_ap_update_config); //fengwenchao comment 20121129 for axsszfi-1251
			install_element(HANSI_NODE,&wtp_clear_ap_update_config);
			install_element(HANSI_NODE,&optional_update_wtp_img_cmd);
			install_element(HANSI_NODE,&optional_clear_wtp_img_cmd);
			install_element(HANSI_NODE,&clear_update_fail_wtp_cmd);
			install_element(HANSI_NODE,&set_wtp_list_dhcp_snooping_enable_cmd);
			install_element(HANSI_NODE,&set_wtp_list_sta_info_report_enable_cmd);
			install_element(HANSI_NODE,&show_wlan_radio_information_cmd);
			install_element(HANSI_NODE,&show_wtp_config_of_all_cmd);   	//fengwenchao add 20101223
			install_element(HANSI_NODE,&bind_ap_model_with_file_config);	/*mahz add for ap upgrade automatically*/
			install_element(HANSI_NODE,&wtp_set_ap_update_base_model_config);
			install_element(HANSI_NODE,&show_model_tar_file_bind_info);
			install_element(HANSI_NODE,&delete_model_bind_info_config);
			install_element(HANSI_NODE,&wtp_clear_ap_one_model_update_config);
			install_element(HANSI_NODE,&show_detail_model_tar_file_bind_info);
			install_element(HANSI_NODE,&wtp_set_ap_update_count_config);
			install_element(HANSI_NODE,&wtp_set_ap_update_control_config);
			install_element(HANSI_NODE,&show_ap_upgrade_result_info);
			
			install_element(HANSI_NODE,&show_all_wlan_ssid_stats_information_of_all_radio_cmd);  //fengwenchao add 20110112
			install_element(HANSI_NODE,&show_wtp_list_by_model_cmd);      //fengwenchao add  20110303
			install_element(HANSI_NODE,&show_wtp_list_by_version_cmd);    //fengwenchao add 20110314
			install_element(HANSI_NODE,&show_statistcs_information_of_all_wtp_whole_cmd);  //fengwenchao add 20110330
			install_element(HANSI_NODE,&set_wtp_trap_neighbor_same_channelrssithreshold_cmd); //fengwenchao add 20110923
			install_element(HANSI_NODE,&set_hide_quit_wtp_cmd);		/*wcl add for ONLINEBUG-117*/

			/**************for sample value begin*******************/
			install_element(HANSI_NODE,&set_ap_moment_infomation_reportinterval_cmd); /*wtp moment report interval by nl 2010-08-18*/
			install_element(HANSI_NODE,&show_ap_moment_information_reportinterval_cmd); /*wtp moment report interval by nl 2010-08-21*/
			install_element(HANSI_NODE,&set_ap_routine_infomation_reportinterval_cmd); /*wtp routine report interval by nl 2010-08-18*/
			install_element(HANSI_NODE,&set_ap_sample_infomation_reportinterval_cmd); /*wtp routine report interval by nl 2010-08-18*/
			install_element(HANSI_NODE,&set_ap_moment_infomation_enable_cmd);/*wtp moment report interval by nl 2010-08-18*/
			install_element(HANSI_NODE,&set_sta_deauth_message_enable_cmd);
			install_element(HANSI_NODE,&set_ap_report_sta_detail_information_enable_cmd);

			/**************for sample value end*******************/
			/**************for globle variable begin*******************/
			install_element(HANSI_NODE,&set_ap_if_info_report_enable_cmd); 
			install_element(HANSI_NODE,&set_ap_if_info_reportinterval_cmd);
			install_element(HANSI_NODE,&set_ap_sta_infomation_report_enable_cmd);
			install_element(HANSI_NODE,&set_ap_sta_infomation_reportinterval_cmd);  
			install_element(HANSI_NODE,&set_wtp_sta_info_report_enable_cmd);
			install_element(HANSI_NODE,&set_ap_extension_infomation_reportinterval_cmd);
			install_element(HANSI_NODE,&set_ap_if_eth_mtu_cmd);	
			install_element(HANSI_NODE,&set_ap_if_eth_rate_cmd);  
			install_element(HANSI_NODE,&set_ap_max_throughout_cmd);
			install_element(HANSI_NODE,&set_ap_sta_wapi_info_report_enable_cmd);	
			install_element(HANSI_NODE,&set_ap_sta_wapi_info_reportinterval_cmd);	
			install_element(HANSI_NODE,&set_ap_terminal_distrub_infomation_pkt_cmd);	 
			install_element(HANSI_NODE,&set_ap_terminal_distrub_infomation_sta_num_cmd);
			install_element(HANSI_NODE,&set_ap_terminal_distrub_infomation_switch_cmd);
			install_element(HANSI_NODE,&wtp_flow_triger_cmd);
			install_element(HANSI_NODE,&wtp_max_sta_cmd);
			install_element(HANSI_NODE,&set_ac_ap_ntp_cmd);
			install_element(HANSI_NODE,&set_wtp_dhcp_snooping_enable_cmd);
			install_element(HANSI_NODE,&set_ap_username_password_cmd);
			install_element(HANSI_NODE,&set_wtp_5g_able_cmd);
			install_element(HANSI_NODE, &wtp_set_web_report_ap_snr_range_cmd);		/* Huangleilei copy from 1.3.18, 20130610 */
			install_element(HANSI_NODE,&set_ap_longitude_latitude_cmd);
			
			install_element(HANSI_NODE,&set_ap_unauthorized_mac_switch_cmd);
			//install_element(HANSI_NODE,&set_ap_unauthorized_mac_reportinterval_cmd);

			install_element(HANSI_NODE,&set_ap_configure_error_switch_cmd);
			//install_element(HANSI_NODE,&set_ap_confiugre_error_reportinterval_cmd);

			install_element(HANSI_NODE,&set_ap_online_sta_full_switch_cmd);
			//install_element(HANSI_NODE,&set_ap_online_sta_full_reportinterval_cmd);

			install_element(HANSI_NODE,&set_ap_sta_flow_rx_tx_overflow_switch_cmd);
			//install_element(HANSI_NODE,&set_ap_sta_flow_rx_tx_overflow_reportinterval_cmd);
			install_element(HANSI_NODE,&set_ap_sta_flow_rx_tx_overflow_threshold_cmd);
			
			/**************for globle variable end*******************/
			/*********************************************HANSI_WTP_NODE***********************************************/
			install_element(HANSI_WTP_NODE,&set_ap_moment_infomation_enable_cmd);/*wtp moment report interval by nl 2010-08-18*/
			install_element(HANSI_WTP_NODE,&wtp_apply_interface_cmd);
			install_element(HANSI_WTP_NODE,&wtp_apply_wlan_cmd);
			install_element(HANSI_WTP_NODE,&config_wtp_service_cmd);
			install_element(HANSI_WTP_NODE,&wtp_delete_wlan_cmd);/*20080701*/
			install_element(HANSI_WTP_NODE,&wtp_enable_wlan_cmd);
			install_element(HANSI_WTP_NODE,&wtp_disable_wlan_cmd);			
			install_element(HANSI_WTP_NODE,&wtp_max_sta_cmd); /*xm add 08/12/03*/
			install_element(HANSI_WTP_NODE,&wtp_flow_triger_cmd);/*xm add 08/12/03*/
			install_element(HANSI_WTP_NODE,&wtp_triger_num_cmd); 
			install_element(HANSI_WTP_NODE,&set_ap_max_throughout_cmd);
			install_element(HANSI_WTP_NODE,&set_ap_extension_command_cmd);
			install_element(HANSI_WTP_NODE,&set_ap_option60_parameter_cmd);//hjw add
			install_element(HANSI_WTP_NODE,&set_ap_ipaddr_command_cmd);
			install_element(HANSI_WTP_NODE,&show_wtp_runtime_cmd);
			install_element(HANSI_WTP_NODE,&set_wtp_location_cmd);
			install_element(HANSI_WTP_NODE,&show_wtp_location_cmd);
			install_element(HANSI_WTP_NODE,&set_ap_channel_disturb_trap_cmd);
			install_element(HANSI_WTP_NODE,&set_wtp_netid_cmd);
			install_element(HANSI_WTP_NODE,&show_wtp_netid_cmd);

            /* zhangshu add for wtp_terminal_distrub_information cmd ,2010-10-08 */
        	install_element(HANSI_WTP_NODE,&set_ap_terminal_distrub_infomation_switch_cmd);
        	install_element(HANSI_WTP_NODE,&set_ap_terminal_distrub_infomation_pkt_cmd);
        	install_element(HANSI_WTP_NODE,&set_ap_terminal_distrub_infomation_sta_num_cmd);
	
			/*install_element(WTP_NODE,&show_wtp_extension_information_cmd);*/
			install_element(HANSI_WTP_NODE,&show_wtp_sample_throughput_information_cmd);
			install_element(HANSI_WTP_NODE,&set_wtp_trap_threshold_cmd);
			install_element(HANSI_WTP_NODE,&show_ap_trap_rogue_ap_ter_cpu_mem_threshold_cmd);
			install_element(HANSI_WTP_NODE,&set_wtp_trap_switch_cmd);
			install_element(HANSI_WTP_NODE,&set_wtp_seqnum_switch_cmd); /*wcl add*/
			install_element(HANSI_WTP_NODE,&set_wtp_wtpname_cmd);
			install_element(HANSI_WTP_NODE,&show_wtp_wlan_vlan_information_cmd);
			install_element(HANSI_WTP_NODE,&set_ap_extension_infomation_enable_cmd);
			install_element(HANSI_WTP_NODE,&set_ap_extension_infomation_reportinterval_cmd);
			install_element(HANSI_WTP_NODE,&set_ap_connect_check_cmd);
			install_element(HANSI_WTP_NODE,&set_ap_echotimer_cmd);
			install_element(HANSI_WTP_NODE,&set_ap_cpu_collect_time_cmd);
			/*install_element(WTP_NODE,&show_wtp_extension_information_v2_cmd);
			//install_element(WTP_NODE,&show_wtp_ethernet_interface_information_cmd);*/
			install_element(HANSI_WTP_NODE,&set_ap_l2_isolation_cmd);
			install_element(HANSI_WTP_NODE,&set_ap_dos_def_cmd);
			install_element(HANSI_WTP_NODE,&set_ap_igmp_snoop_cmd);
			install_element(HANSI_WTP_NODE,&show_ap_mib_information_cmd);
			install_element(HANSI_WTP_NODE,&show_wtp_extension_information_v3_cmd);
			install_element(HANSI_WTP_NODE,&show_wtp_extension_information_v4_cmd);
			install_element(HANSI_WTP_NODE,&show_ap_cm_statistics_cmd);
			install_element(HANSI_WTP_NODE,&set_ap_sta_infomation_report_enable_cmd);
			install_element(HANSI_WTP_NODE,&set_ap_sta_infomation_reportinterval_cmd);
			install_element(HANSI_WTP_NODE,&set_ap_if_info_report_enable_cmd);
			install_element(HANSI_WTP_NODE,&set_ap_if_info_reportinterval_cmd);
			install_element(HANSI_WTP_NODE,&set_ap_if_updown_cmd);
			install_element(HANSI_WTP_NODE,&set_ap_if_eth_rate_cmd);	
			install_element(HANSI_WTP_NODE,&show_ap_if_info_cmd);
			install_element(HANSI_WTP_NODE,&show_wtp_bss_pkt_info_cmd);
			install_element(HANSI_WTP_NODE,&get_wtp_bss_pkt_info_cmd);
			install_element(HANSI_WTP_NODE,&show_wtp_radio_pkt_info_cmd);
			install_element(HANSI_WTP_NODE,&show_wtp_eth_pkt_info_cmd);
			install_element(HANSI_WTP_NODE,&show_wtp_wifi_snr_cmd);
			install_element(HANSI_WTP_NODE,&set_ac_ap_ntp_cmd);
			install_element(HANSI_WTP_NODE,&set_ap_config_update_cmd);
			install_element(HANSI_WTP_NODE,&show_wtp_max_power_base_model_cmd);
			install_element(HANSI_WTP_NODE,&set_ap_reboot_cmd);
			install_element(HANSI_WTP_NODE,&set_ap_heart_statistics_enable_cmd);  //fengwenchao add 20111130 for GM-3
			install_element(HANSI_WTP_NODE,&set_ap_heart_statistics_collect_time_cmd); //fengwenchao add 20111130 for GM-3
			install_element(HANSI_WTP_NODE,&set_ap_sta_wapi_info_report_enable_cmd);	
			install_element(HANSI_WTP_NODE,&set_ap_sta_wapi_info_reportinterval_cmd);
			install_element(HANSI_WTP_NODE,&show_wtp_model_code_version_cmd);
			install_element(HANSI_WTP_NODE,&update_wtp_img_cmd);
			install_element(HANSI_WTP_NODE,&clear_wtp_img_cmd);
			//install_element(HANSI_WTP_NODE,&set_wtp_sn_cmd); /*wcl modify*/
			install_element(HANSI_WTP_NODE,&wtp_apply_ipv6interface_cmd);
			install_element(HANSI_WTP_NODE,&set_ap_networkaddr_command_cmd);
			install_element(HANSI_WTP_NODE,&set_wtp_dhcp_snooping_enable_cmd);
			install_element(HANSI_WTP_NODE,&set_wtp_sta_info_report_enable_cmd);
			install_element(HANSI_WTP_NODE,&show_wtp_running_config_cmd);
			install_element(HANSI_WTP_NODE,&show_wtp_radio_pkt_info_tunnel_cmd);
			install_element(HANSI_WTP_NODE,&set_wtp_trap_collect_cmd);
			install_element(HANSI_WTP_NODE,&set_ap_if_eth_mtu_cmd);	 //fengwenchao add 20110126
			install_element(HANSI_WTP_NODE,&set_wid_rogue_danger_unsafe_attack_trap_state_cmd);  //fengwenchao add 20110221
			install_element(HANSI_WTP_NODE,&set_sta_deauth_message_enable_cmd);
			install_element(HANSI_WTP_NODE,&set_ap_report_sta_detail_information_enable_cmd);
			install_element(HANSI_WTP_NODE,&set_wtp_trap_neighbor_same_channelrssithreshold_cmd); //fengwenchao add 20110923
			install_element(HANSI_WTP_NODE,&set_ap_username_password_cmd);
			install_element(HANSI_WTP_NODE,&set_wtp_5g_able_cmd);
			
			install_element(HANSI_WTP_NODE,&set_ap_longitude_latitude_cmd);

			install_element(HANSI_WTP_NODE,&trap_rx_tx_flow_overflow_cmd);
			//install_element(HANSI_WTP_NODE,&trap_temperature_cmd);
			
			
			install_element(HANSI_WTP_NODE, &set_ap_unauthorized_mac_switch_cmd);
			//install_element(HANSI_WTP_NODE,&set_ap_unauthorized_mac_reportinterval_cmd);

			install_element(HANSI_WTP_NODE, &set_ap_configure_error_switch_cmd);
			//install_element(HANSI_WTP_NODE, &set_ap_confiugre_error_reportinterval_cmd);
			install_element(HANSI_WTP_NODE, &set_ap_sta_flow_rx_tx_overflow_threshold_cmd);
			
			install_element(HANSI_WTP_NODE, &set_ap_online_sta_full_switch_cmd);
			//install_element(HANSI_WTP_NODE, &set_ap_online_sta_full_reportinterval_cmd);

			install_element(HANSI_WTP_NODE, &set_ap_sta_flow_rx_tx_overflow_switch_cmd);
			//install_element(HANSI_WTP_NODE, &set_ap_sta_flow_rx_tx_overflow_reportinterval_cmd);
			
			/********************************************MIB optimize BEGIN********************************************/
			/*for mib information showting by nl 20100702*/
			install_element(HANSI_NODE,&show_all_wtp_basic_information_cmd);							/*b1*/
			install_element(HANSI_NODE,&show_all_wtp_collect_information_cmd);							/*b2*/
			install_element(HANSI_NODE,&show_all_wtp_para_information_cmd);								/*b3*/
			install_element(HANSI_NODE,&show_all_wtp_device_information_cmd);							/*b4*/
			install_element(HANSI_NODE,&show_all_wtp_stats_information_cmd);							/*b6*/
			install_element(HANSI_NODE,&show_all_wtp_wirelessifstats_information_cmd);					/*b9*/
			install_element(HANSI_NODE,&show_all_wtp_data_pkts_information_cmd);						/*b5*/
			install_element(HANSI_NODE,&show_all_wlan_stats_information_cmd);							/*b7*/
			install_element(HANSI_NODE,&show_all_wlan_ssid_stats_information_cmd);						/*b8*/
			install_element(HANSI_NODE,&show_all_wtp_ifname_information_cmd);							/*b10*/
				
			install_element(HANSI_NODE,&show_all_wtp_the_radio_para_information_cmd);					/*b11*/
			install_element(HANSI_NODE,&show_all_wtp_eth_port_information_cmd);							/*b12*/
			install_element(HANSI_NODE,&show_all_wtp_radio_stats_information_cmd);						/*b13*/
			install_element(HANSI_NODE,&show_all_wtp_radio_config_information_cmd);						/*b14*/
			install_element(HANSI_NODE,&show_all_wtp_user_link_information_cmd);						/*b15*/
			install_element(HANSI_NODE,&show_all_wtp_wired_ifstats_information_cmd);					/*b16*/
			install_element(HANSI_NODE,&show_all_wtp_wireless_if_information_cmd);						/*b17*/
			install_element(HANSI_NODE,&show_all_wtp_new_wtp_wireless_ifinfo_information_cmd);			/*b18*/
			install_element(HANSI_NODE,&show_all_wtp_new_wirelessifstats_information_cmd);				/*b19*/
			install_element(HANSI_NODE,&show_all_wtp_rogue_ap_info_information_cmd);					/*b20*/
			
			install_element(HANSI_NODE,&show_all_wtp_security_mech_information_cmd);					/*b21*/
			install_element(HANSI_NODE,&show_all_wtp_information_cmd);									/*b22*/
			install_element(HANSI_NODE,&show_all_wtp_network_info_cmd);/*xdw add for show ap network info of all wtp, 20101215*/
			/*----------------liuzhenhua--- add ---begin--------------------*/
			install_element(HANSI_NODE,&show_all_wtp_terminal_information_cmd);/*lzh add 20100517*/		/*b23*/
			install_element(HANSI_NODE,&show_all_wtp_wlan_data_pkts_information_cmd);					/*b24*/
			install_element(HANSI_NODE,&show_all_wtp_station_information_cmd);							/*b25*/
			install_element(HANSI_NODE,&show_ath_statistics_info_of_all_wtp_cmd);
			install_element(HANSI_NODE,&show_all_wtp_station_statistic_information_cmd);	//mahz add 2011.11.9 for GuangZhou Mobile
			install_element(HANSI_NODE,&show_ac_sta_information_cmd);						//mahz add 2011.11.10 
			install_element(HANSI_NODE,&show_conflict_wtp_list_cmd);
			install_element(HIDDENDEBUG_NODE,&add_black_white_oui_mac_cmd);
			install_element(HIDDENDEBUG_NODE,&del_black_white_oui_mac_cmd);
			install_element(HIDDENDEBUG_NODE,&show_black_white_oui_list_cmd);
			install_element(HIDDENDEBUG_NODE,&update_black_white_oui_info_cmd);
			install_element(HIDDENDEBUG_NODE,&use_black_white_none_oui_policy_cmd);
			install_element(HIDDENDEBUG_NODE,&show_oui_policy_cmd);
			/*----------------liuzhenhua--- add ---end--------------------*/
			/********************************************MIB optimize END********************************************/

			/************************************************AP_GROUP_NODE**************************************************/
			//install_element(AP_GROUP_WTP_NODE,&config_wtp_service_cmd);


			/************************************************AP_GROUP_NODE_END**************************************************/
			/************************************************HANSI_AP_GROUP_NODE**************************************************/

			//install_element(HANSI_AP_GROUP_WTP_NODE,&config_wtp_service_cmd);


			/************************************************HANSI_AP_GROUP_NODE_END**************************************************/
			/***************************************************************************************/
			install_element(LOCAL_HANSI_NODE,&show_wtp_model_infor_cmd);
			install_element(LOCAL_HANSI_NODE,&show_wtp_cmd);
			install_element(LOCAL_HANSI_NODE,&show_wtp_list_cmd);
			install_element(LOCAL_HANSI_NODE,&show_wtp_list_new_cmd);
		    install_element(LOCAL_HANSI_NODE,&show_wtp_model_list_cmd);
			install_element(LOCAL_HANSI_NODE,&show_wtp_list_byinterface_cmd);										//xiaodawei add, 20110301
			install_element(LOCAL_HANSI_NODE,&show_wtp_list_by_mac_cmd);
			install_element(LOCAL_HANSI_NODE,&show_wtp_list_by_state_cmd);
			install_element(LOCAL_HANSI_NODE,&show_wtp_list_by_ip_cmd);
			install_element(LOCAL_HANSI_NODE,&show_wtp_list_by_macex_cmd);
			install_element(LOCAL_HANSI_NODE,&show_ap_version_cmd);
			
			install_element(LOCAL_HANSI_NODE,&show_ap_echotimer_cmd);
			install_element(LOCAL_HANSI_NODE,&show_ap_wids_set_cmd);
			install_element(LOCAL_HANSI_NODE,&show_ac_access_wtp_info_cmd);
			install_element(LOCAL_HANSI_NODE,&show_ap_trap_rogue_ap_ter_cpu_mem_threshold_cmd);
			install_element(LOCAL_HANSI_NODE,&wtp_show_ap_update_config);
			install_element(LOCAL_HANSI_NODE,&show_update_wtp_list);
			install_element(LOCAL_HANSI_NODE,&show_wtp_running_config_cmd);											/*a18*/
			install_element(LOCAL_HANSI_NODE,&show_update_fail_wtp_list);
			install_element(LOCAL_HANSI_NODE,&show_old_ap_img_data_cmd);
			
			install_element(LOCAL_HANSI_NODE,&diag_wtp_list_bywtpid_cmd);
			install_element(LOCAL_HANSI_NODE,&diag_wtp_list_bywlanid_cmd);
			install_element(LOCAL_HANSI_NODE,&btrace_wtp_list_bywtpid_cmd);
			install_element(LOCAL_HANSI_NODE,&btrace_wtp_list_bywlanid_cmd);

			install_element(LOCAL_HANSI_NODE,&diag_wtp_list_cmd);
			install_element(LOCAL_HANSI_NODE,&btrace_wtp_list_cmd);

			//install_element(LOCAL_HANSI_NODE,&create_wtp_cmd);	//fengwenchao comment 20110412
			install_element(LOCAL_HANSI_NODE,&create_wtp_bymac_cmd); 
			install_element(LOCAL_HANSI_NODE,&delete_wtp_cmd);
			install_element(LOCAL_HANSI_NODE,&config_wtp_cmd);
			install_element(LOCAL_HANSI_NODE,&wtp_set_ap_model_version_path_cmd);/*xm 08/08/29*/
			install_element(LOCAL_HANSI_NODE,&delete_model_cmd);
			install_element(LOCAL_HANSI_NODE,&set_ap_connect_check_cmd);
			install_element(LOCAL_HANSI_NODE,&set_ap_echotimer_cmd);
			install_element(LOCAL_HANSI_NODE,&set_ap_cpu_collect_time_cmd);
			install_element(LOCAL_HANSI_NODE,&download_ap_image_cmd);/*added by weiay 20081021*/
			install_element(LOCAL_HANSI_NODE,&download_certificate_image_cmd);
			install_element(LOCAL_HANSI_NODE,&uplink_detect_cmd);
			install_element(LOCAL_HANSI_NODE,&check_download_ap_image_cmd);
			install_element(LOCAL_HANSI_NODE,&check_download_wapi_cert_cmd);
			install_element(LOCAL_HANSI_NODE,&set_ap_wids_set_cmd);

			install_element(LOCAL_HANSI_NODE,&clean_ac_access_wtp_info_cmd);
			install_element(LOCAL_HANSI_NODE,&old_ap_img_data_cmd);
			install_element(LOCAL_HANSI_NODE,&set_wtp_trap_threshold_cmd);
			install_element(LOCAL_HANSI_NODE,&set_ap_reboot_all_cmd);
			install_element(LOCAL_HANSI_NODE,&set_ap_reboot_by_wlanid_cmd);
			install_element(LOCAL_HANSI_NODE,&set_ap_reboot_by_interface_cmd);
			install_element(LOCAL_HANSI_NODE,&set_ap_reboot_by_model_cmd);
			install_element(LOCAL_HANSI_NODE,&set_ap_reboot_by_list_cmd);
			//install_element(LOCAL_HANSI_NODE,&wtp_set_ap_update_config); //fengwenchao comment 20121129 for axsszfi-1251
			install_element(LOCAL_HANSI_NODE,&wtp_clear_ap_update_config);
			install_element(LOCAL_HANSI_NODE,&optional_update_wtp_img_cmd);
			install_element(LOCAL_HANSI_NODE,&optional_clear_wtp_img_cmd);
			install_element(LOCAL_HANSI_NODE,&clear_update_fail_wtp_cmd);
			install_element(LOCAL_HANSI_NODE,&set_wtp_list_dhcp_snooping_enable_cmd);
			install_element(LOCAL_HANSI_NODE,&set_wtp_list_sta_info_report_enable_cmd);
			install_element(LOCAL_HANSI_NODE,&show_wlan_radio_information_cmd);
			install_element(LOCAL_HANSI_NODE,&show_wtp_config_of_all_cmd);   	//fengwenchao add 20101223
			install_element(LOCAL_HANSI_NODE,&show_all_wlan_ssid_stats_information_of_all_radio_cmd);  //fengwenchao add 20110112
			install_element(LOCAL_HANSI_NODE,&show_wtp_list_by_model_cmd);      //fengwenchao add  20110303
			install_element(LOCAL_HANSI_NODE,&show_wtp_list_by_version_cmd);    //fengwenchao add 20110314
			install_element(LOCAL_HANSI_NODE,&show_statistcs_information_of_all_wtp_whole_cmd);  //fengwenchao add 20110330
			install_element(LOCAL_HANSI_NODE,&show_all_wtp_station_statistic_information_cmd);	//mahz add 2011.11.9 for GuangZhou Mobile
			install_element(LOCAL_HANSI_NODE,&show_ac_sta_information_cmd);						//mahz add 2011.11.10 
			install_element(LOCAL_HANSI_NODE,&set_hide_quit_wtp_cmd);		/*wcl add for ONLINEBUG-117*/
			install_element(LOCAL_HANSI_NODE,&bind_ap_model_with_file_config);	/*mahz add for ap upgrade automatically*/
			install_element(LOCAL_HANSI_NODE,&wtp_set_ap_update_base_model_config);
			install_element(LOCAL_HANSI_NODE,&show_model_tar_file_bind_info);
			install_element(LOCAL_HANSI_NODE,&delete_model_bind_info_config);
			install_element(LOCAL_HANSI_NODE,&wtp_clear_ap_one_model_update_config);
			install_element(LOCAL_HANSI_NODE,&show_detail_model_tar_file_bind_info);
			install_element(LOCAL_HANSI_NODE,&wtp_set_ap_update_count_config);
			install_element(LOCAL_HANSI_NODE,&wtp_set_ap_update_control_config);
			install_element(LOCAL_HANSI_NODE,&show_ap_upgrade_result_info);

			/**************for sample value begin*******************/
			install_element(LOCAL_HANSI_NODE,&set_ap_moment_infomation_reportinterval_cmd); /*wtp moment report interval by nl 2010-08-18*/
			install_element(LOCAL_HANSI_NODE,&show_ap_moment_information_reportinterval_cmd); /*wtp moment report interval by nl 2010-08-21*/
			install_element(LOCAL_HANSI_NODE,&set_ap_routine_infomation_reportinterval_cmd); /*wtp routine report interval by nl 2010-08-18*/
			install_element(LOCAL_HANSI_NODE,&set_ap_sample_infomation_reportinterval_cmd); /*wtp routine report interval by nl 2010-08-18*/
			install_element(LOCAL_HANSI_NODE,&set_ap_moment_infomation_enable_cmd);/*wtp moment report interval by nl 2010-08-18*/

			/**************for sample value end*******************/
			
			install_element(LOCAL_HANSI_NODE,&set_wtp_5g_able_cmd);
			install_element(LOCAL_HANSI_NODE,&show_conflict_wtp_list_cmd);
			install_element(LOCAL_HANSI_NODE,&set_wtp_trap_neighbor_same_channelrssithreshold_cmd); //fengwenchao add 20110923
			/*********************************************LOCAL_HANSI_WTP_NODE***********************************************/
			install_element(LOCAL_HANSI_WTP_NODE,&set_ap_moment_infomation_enable_cmd);/*wtp moment report interval by nl 2010-08-18*/
			install_element(LOCAL_HANSI_WTP_NODE,&wtp_apply_interface_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&wtp_apply_wlan_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&config_wtp_service_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&wtp_delete_wlan_cmd);/*20080701*/
			install_element(LOCAL_HANSI_WTP_NODE,&wtp_enable_wlan_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&wtp_disable_wlan_cmd);			
			install_element(LOCAL_HANSI_WTP_NODE,&wtp_max_sta_cmd); /*xm add 08/12/03*/
			install_element(LOCAL_HANSI_WTP_NODE,&wtp_flow_triger_cmd);/*xm add 08/12/03*/
			install_element(LOCAL_HANSI_WTP_NODE,&wtp_triger_num_cmd); 
			install_element(LOCAL_HANSI_WTP_NODE,&set_ap_max_throughout_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_ap_extension_command_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_ap_option60_parameter_cmd);//hjw add
			install_element(LOCAL_HANSI_WTP_NODE,&set_ap_ipaddr_command_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&show_wtp_runtime_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_wtp_location_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&show_wtp_location_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_ap_channel_disturb_trap_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_wtp_netid_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&show_wtp_netid_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_ap_heart_statistics_enable_cmd); //fengwenchao add 20111202 for GM-3
            /* zhangshu add for wtp_terminal_distrub_information cmd ,2010-10-08 */
        	install_element(LOCAL_HANSI_WTP_NODE,&set_ap_terminal_distrub_infomation_switch_cmd);
        	install_element(LOCAL_HANSI_WTP_NODE,&set_ap_terminal_distrub_infomation_pkt_cmd);
        	install_element(LOCAL_HANSI_WTP_NODE,&set_ap_terminal_distrub_infomation_sta_num_cmd);

			install_element(LOCAL_HANSI_WTP_NODE,&show_wtp_sample_throughput_information_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_wtp_trap_threshold_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&show_ap_trap_rogue_ap_ter_cpu_mem_threshold_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_wtp_trap_switch_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_wtp_seqnum_switch_cmd); /*wcl add*/
			install_element(LOCAL_HANSI_WTP_NODE,&set_wtp_wtpname_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&show_wtp_wlan_vlan_information_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_ap_extension_infomation_enable_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_ap_extension_infomation_reportinterval_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_ap_connect_check_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_ap_echotimer_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_ap_cpu_collect_time_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_ap_l2_isolation_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_ap_dos_def_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_ap_igmp_snoop_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&show_ap_mib_information_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&show_wtp_extension_information_v3_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&show_wtp_extension_information_v4_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&show_ap_cm_statistics_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_ap_sta_infomation_report_enable_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_ap_sta_infomation_reportinterval_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_ap_if_info_report_enable_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_ap_if_info_reportinterval_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_ap_if_updown_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_ap_if_eth_rate_cmd);	
			install_element(LOCAL_HANSI_WTP_NODE,&show_ap_if_info_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&show_wtp_bss_pkt_info_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&get_wtp_bss_pkt_info_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&show_wtp_radio_pkt_info_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&show_wtp_eth_pkt_info_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&show_wtp_wifi_snr_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_ac_ap_ntp_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_ap_config_update_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&show_wtp_max_power_base_model_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_ap_reboot_cmd);
			
			install_element(LOCAL_HANSI_WTP_NODE,&set_ap_sta_wapi_info_report_enable_cmd);	
			install_element(LOCAL_HANSI_WTP_NODE,&set_ap_sta_wapi_info_reportinterval_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&show_wtp_model_code_version_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&update_wtp_img_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&clear_wtp_img_cmd);
			//install_element(LOCAL_HANSI_WTP_NODE,&set_wtp_sn_cmd); /*wcl modify*/
			install_element(LOCAL_HANSI_WTP_NODE,&wtp_apply_ipv6interface_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_ap_networkaddr_command_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_wtp_dhcp_snooping_enable_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_wtp_sta_info_report_enable_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&show_wtp_running_config_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&show_wtp_radio_pkt_info_tunnel_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_wtp_trap_collect_cmd);
			install_element(LOCAL_HANSI_WTP_NODE,&set_ap_if_eth_mtu_cmd);	 //fengwenchao add 20110126
			install_element(LOCAL_HANSI_WTP_NODE,&set_wid_rogue_danger_unsafe_attack_trap_state_cmd);  //fengwenchao add 20110221
			install_element(LOCAL_HANSI_WTP_NODE,&set_wtp_trap_neighbor_same_channelrssithreshold_cmd); //fengwenchao add 20110923
			install_element(LOCAL_HANSI_WTP_NODE,&set_ap_heart_statistics_collect_time_cmd); //fengwenchao add 20111202 for GM-3
			install_element(LOCAL_HANSI_WTP_NODE,&set_ap_username_password_cmd);
			
			install_element(LOCAL_HANSI_WTP_NODE,&set_wtp_5g_able_cmd);
			/********************************************MIB optimize BEGIN********************************************/
			/*for mib information showting by nl 20100702*/
			install_element(LOCAL_HANSI_NODE,&show_all_wtp_basic_information_cmd);							/*b1*/
			install_element(LOCAL_HANSI_NODE,&show_all_wtp_collect_information_cmd);							/*b2*/
			install_element(LOCAL_HANSI_NODE,&show_all_wtp_para_information_cmd);								/*b3*/
			install_element(LOCAL_HANSI_NODE,&show_all_wtp_device_information_cmd);							/*b4*/
			install_element(LOCAL_HANSI_NODE,&show_all_wtp_stats_information_cmd);							/*b6*/
			install_element(LOCAL_HANSI_NODE,&show_all_wtp_wirelessifstats_information_cmd);					/*b9*/
			install_element(LOCAL_HANSI_NODE,&show_all_wtp_data_pkts_information_cmd);						/*b5*/
			install_element(LOCAL_HANSI_NODE,&show_all_wlan_stats_information_cmd);							/*b7*/
			install_element(LOCAL_HANSI_NODE,&show_all_wlan_ssid_stats_information_cmd);						/*b8*/
			install_element(LOCAL_HANSI_NODE,&show_all_wtp_ifname_information_cmd);							/*b10*/
				
			install_element(LOCAL_HANSI_NODE,&show_all_wtp_the_radio_para_information_cmd);					/*b11*/
			install_element(LOCAL_HANSI_NODE,&show_all_wtp_eth_port_information_cmd);							/*b12*/
			install_element(LOCAL_HANSI_NODE,&show_all_wtp_radio_stats_information_cmd);						/*b13*/
			install_element(LOCAL_HANSI_NODE,&show_all_wtp_radio_config_information_cmd);						/*b14*/
			install_element(LOCAL_HANSI_NODE,&show_all_wtp_user_link_information_cmd);						/*b15*/
			install_element(LOCAL_HANSI_NODE,&show_all_wtp_wired_ifstats_information_cmd);					/*b16*/
			install_element(LOCAL_HANSI_NODE,&show_all_wtp_wireless_if_information_cmd);						/*b17*/
			install_element(LOCAL_HANSI_NODE,&show_all_wtp_new_wtp_wireless_ifinfo_information_cmd);			/*b18*/
			install_element(LOCAL_HANSI_NODE,&show_all_wtp_new_wirelessifstats_information_cmd);				/*b19*/
			install_element(LOCAL_HANSI_NODE,&show_all_wtp_rogue_ap_info_information_cmd);					/*b20*/
			
			install_element(LOCAL_HANSI_NODE,&show_all_wtp_security_mech_information_cmd);					/*b21*/
			install_element(LOCAL_HANSI_NODE,&show_all_wtp_information_cmd);									/*b22*/
			install_element(LOCAL_HANSI_NODE,&show_all_wtp_network_info_cmd);/*xdw add for show ap network info of all wtp, 20101215*/
			/*----------------liuzhenhua--- add ---begin--------------------*/
			install_element(LOCAL_HANSI_NODE,&show_all_wtp_terminal_information_cmd);/*lzh add 20100517*/		/*b23*/
			install_element(LOCAL_HANSI_NODE,&show_all_wtp_wlan_data_pkts_information_cmd);					/*b24*/
			install_element(LOCAL_HANSI_NODE,&show_all_wtp_station_information_cmd);							/*b25*/
			install_element(LOCAL_HANSI_NODE,&show_ath_statistics_info_of_all_wtp_cmd);
			/***************************************************************/
			/**************for globle variable begin*******************/
			install_element(LOCAL_HANSI_NODE,&set_ap_if_info_report_enable_cmd); 
			install_element(LOCAL_HANSI_NODE,&set_ap_if_info_reportinterval_cmd);
			install_element(LOCAL_HANSI_NODE,&set_ap_sta_infomation_report_enable_cmd);
			install_element(LOCAL_HANSI_NODE,&set_ap_sta_infomation_reportinterval_cmd);  
			install_element(LOCAL_HANSI_NODE,&set_wtp_sta_info_report_enable_cmd);
			install_element(LOCAL_HANSI_NODE,&set_ap_extension_infomation_reportinterval_cmd);
			install_element(LOCAL_HANSI_NODE,&set_ap_if_eth_mtu_cmd);	
			install_element(LOCAL_HANSI_NODE,&set_ap_if_eth_rate_cmd);  
			install_element(LOCAL_HANSI_NODE,&set_ap_max_throughout_cmd);
			install_element(LOCAL_HANSI_NODE,&set_ap_sta_wapi_info_report_enable_cmd);	
			install_element(LOCAL_HANSI_NODE,&set_ap_sta_wapi_info_reportinterval_cmd);	
			install_element(LOCAL_HANSI_NODE,&set_ap_terminal_distrub_infomation_pkt_cmd);	 
			install_element(LOCAL_HANSI_NODE,&set_ap_terminal_distrub_infomation_sta_num_cmd);
			install_element(LOCAL_HANSI_NODE,&set_ap_terminal_distrub_infomation_switch_cmd);
			install_element(LOCAL_HANSI_NODE,&wtp_flow_triger_cmd);
			install_element(LOCAL_HANSI_NODE,&wtp_max_sta_cmd);
			install_element(LOCAL_HANSI_NODE,&set_ac_ap_ntp_cmd);
			install_element(LOCAL_HANSI_NODE,&set_wtp_dhcp_snooping_enable_cmd);
			install_element(LOCAL_HANSI_NODE,&set_ap_username_password_cmd);

			/**************for globle variable end*******************/
	return;

}

#endif
