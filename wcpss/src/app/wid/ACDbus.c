/*******************************************************************************
Copyright (C) Autelan Technology

This software file is owned and distributed by Autelan Technology 
********************************************************************************

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
********************************************************************************
* ACDbus.c
*
* MODIFY:
*		by <zhanglei@autelan.com> on 03/17/2008 revision <0.1>
*
* CREATOR:
*		chenb@autelan.com
*
* DESCRIPTION:
*		dbus message main routine for WID module.
*
*******************************************************************************/
#ifdef __cplusplus
	extern "C"
	{
#endif

#include <string.h>
#include <dbus/dbus.h>
#include <stdbool.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <time.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <dirent.h>
#include <net/if.h>

#include "CWAC.h"
#include "dbus/wcpss/ACDbusDef1.h"
#include "dbus/npd/npd_dbus_def.h"
#include "CWStevens.h"
#include "wcpss/waw.h"
#include "hmd/hmdpub.h"

#include "wcpss/wid/WID.h"
#include "wcpss/asd/asd.h"
#include "ACDbus_handler.h"
#include "ACDbus.h"
#include "ACBak.h"
#include "ACAccessCheck.h"
#include "ACUpdateManage.h"
#include "AC.h"
#include "dbus/hmd/HmdDbusPath.h"
#include "ACCheckReport.h"
#include "syslog.h"

static DBusConnection * wid_dbus_connection = NULL;
static DBusConnection * wid_dbus_connection2 = NULL;
static DBusConnection * wid_dbus_connection_t[THREAD_NUM];
int hide_quit_wtp_in_showting = 0;		/*for mib 20100720 by nl*/
#define RAND(a,b)	(rand()%((b)-(a))+(a))	//xiaodawei add, 20110318
#define DBUS_COUNT_NUM 	6
#define SENDER_LEN	20
#ifndef MAX_RADIO_NUM
#define MAX_RADIO_NUM 4
#endif

int	other_dbus_count = 0;
int dbus_count_switch = 0;
/***************for mib sample begin *******************/
unsigned short moment_report_interval = 30;		/*for mib 2010-08-17 by nl*/
unsigned char moment_report_switch = 0;			/*for mib 2010-08-17 by nl*/
unsigned short routine_report_interval = 50;	/*for mib 2010-08-17 by nl*/
unsigned int sample_infor_interval = 30;/*for mib 2010-08-17 by nl*/
int cpu_mem_collect_time = 300;/*lixiang change 3500 to 300*/
/*************for mib sample end *********************/
extern unsigned char gWIDLOGHN;
extern unsigned long gWID_AC_MANAGEMENT_IP;
extern unsigned int TUNNEL_STATISTICS_LOG_INTERVAL;
extern unsigned int RADIO_STATISTICS_LOG_INTERVAL;
static struct{
	char rname[20];
	int	count;
	int num;
	char *uname;
}dbus_count[] = {
	{
		"aw.snmpd",
		0,
		0,
		NULL,
	},
	{
		"aw.cli",
		0,
		0,
		NULL,
	},
	{
		"aw.ccgi",
		0,
		0,
		NULL,
	},
	{
		"aw.eag",
		0,
		0,
		NULL,
	},
	{
		"aw.traphelper",
		0,
		0,
		NULL,
	},	
	{
		"aw.vrrp2",
		0,
		0,
		NULL,
	}
};


extern CWBool AsdWsm_WTPOp(unsigned int WtpID,Operate op);
int wid_dbus_trap_show_wtp_runtime(unsigned int wtpindex);
int show_running_config_wtp(WID_WTP **WTP,int i,char *cursor,char **showStr,char *showStr_new,int *totalLen_T,int *str_len_T);
int CWDelBlackOuiInfoFromXml(unsigned char* oui_mac);
	
int parse_int_ID(char* str,unsigned int* ID){
	char *endptr = NULL;
	char c;
	c = str[0];
	if (c>='0'&&c<='9'){
		*ID= strtoul(str,&endptr,10);
		if((c=='0')&&(str[1]!='\0')){
			 return -1;
		}
		else if((endptr[0] == '\0')||(endptr[0] == '\n')){
			return 0;
		}
		else{
			return -1;
		}
	}
	else{
		return -1;
	}
}

int parse_radio_ifname(char* ptr,int *wtpid,int *radioid,int *wlanid)
{
	
    radio_ifname_state state = check_wtpid;
	char *str = NULL;
	str = ptr;
   
	while(1){
		switch(state){
			
		case check_wtpid: 
			
			*wtpid = strtoul(str,&str,10);
			
			if(*wtpid > 0 && *wtpid < 4095){
        		state=check_sub;
			}
			else state=check_fail;
			
			break;

		case check_sub: 
		
			if (PARSE_RADIO_IFNAME_SUB == str[0]){
		
				state = check_radioid;
				}
			else
				state = check_fail;
			break;

		case check_radioid: 
		
			*radioid = strtoul((char *)&(str[1]),&str,10);

			if(*radioid >= 0 && *radioid < 4){/*radioid range 0 1 2 3*/
        		state=check_point;
			}
			else state=check_fail;
			
			break;

		case check_point: 
		
			if (PARSE_RADIO_IFNAME_POINT == str[0]){
			
				state = check_wlanid;
				
				}
			else
				state = check_fail;
			break;
				
		case check_wlanid: 
		
			*wlanid = strtoul((char *)&(str[1]),&str,10);

			if(*wlanid > 0 && *wlanid < WLAN_NUM+1){
        		state=check_end;
			}
			else state=check_fail;
			
			break;
			
		
		
		case check_fail:
	
		
            return -1;
			break;

		case check_end: 
	
			if ('\0' == str[0]) {
				state = check_success;
				
				}
			else
				state = check_fail;
				break;
			
		case check_success: 
		
			return 0;
			break;
			
		default: break;
		}
		
		}
		
}

int parse_radio_ifname_v2(char* ptr,int *wtpid,int *radioid,int *wlanid,unsigned int *vrrid)
{
	
    radio_ifname_state state = check_vrrip;
	char *str = NULL;
	str = ptr;
   
	while(1){
		switch(state){
			
		case check_vrrip: 
			*vrrid = strtoul(str,&str,10);
			if(/**vrrid >=0 &&*/ *vrrid <= 16){
        		state=check_sub;
			}
			else state=check_fail;
			break;
		case check_wtpid: 
			*wtpid = strtoul((char *)&str[1],&str,10);
			if(*wtpid > 0 && *wtpid < 4095){
        		state=check_sub2;
			}
			else state=check_fail;
			
			break;
		case check_sub: 
		
			if (PARSE_RADIO_IFNAME_SUB == str[0]){
		
				state = check_wtpid;
			}
			else
				state = check_fail;
			break;

		case check_sub2: 
			if (PARSE_RADIO_IFNAME_SUB == str[0]){
		
				state = check_radioid;
				}
			else
				state = check_fail;
			break;

		case check_radioid: 
			*radioid = strtoul((char *)&(str[1]),&str,10);

			if(*radioid >= 0 && *radioid < 4){/*radioid range 0 1 2 3*/
        		state=check_point;
			}
			else state=check_fail;
			
			break;

		case check_point: 
			if (PARSE_RADIO_IFNAME_POINT == str[0]){
			
				state = check_wlanid;
				
				}
			else
				state = check_fail;
			break;
				
		case check_wlanid: 
			*wlanid = strtoul((char *)&(str[1]),&str,10);

			if(*wlanid > 0 && *wlanid < WLAN_NUM+1){
        		state=check_end;
			}
			else state=check_fail;
			
			break;
			
		
		
		case check_fail:
		
            return -1;
			break;

		case check_end: 
			if ('\0' == str[0]) {
				state = check_success;
				
				}
			else
				state = check_fail;
				break;
			
		case check_success: 
			return 0;
			break;
			
		default: break;
		}
		
		}
		
}

int parse_radio_ifname_v3(char* ptr,int *wtpid,int *radioid,int *wlanid,int *vrrid,int *slotid)
{
	
    radio_ifname_state state = check_slotid;
	char *str = NULL;
	str = ptr;
   
	while(1){
		switch(state){
		case check_slotid: 
			*slotid = strtoul(str,&str,10);
			if(*slotid >=0 && *slotid <= 16){
				state=check_sub;
			}
			else state=check_fail;
			break;			
		case check_vrrip: 
			*vrrid = strtoul((char *)&str[1],&str,10);
			if(*vrrid >=0 && *vrrid <= 16){
        		state=check_sub2;
			}
			else state=check_fail;
			break;
		case check_wtpid: 
			*wtpid = strtoul((char *)&str[1],&str,10);
			if(*wtpid > 0 && *wtpid < 4095){
        		state=check_sub3;
			}
			else state=check_fail;
			
			break;
		case check_sub: 
		
			if (PARSE_RADIO_IFNAME_SUB == str[0]){
		
				state = check_vrrip;
			}
			else
				state = check_fail;
			break;

		case check_sub2: 
			if (PARSE_RADIO_IFNAME_SUB == str[0]){
		
				state = check_wtpid;
				}
			else
				state = check_fail;
			break;
		case check_sub3: 
			if (PARSE_RADIO_IFNAME_SUB == str[0]){
		
				state = check_radioid;
				}
			else
				state = check_fail;
			break;

		case check_radioid: 
			*radioid = strtoul((char *)&(str[1]),&str,10);

			if(*radioid >= 0 && *radioid < 4){/*radioid range 0 1 2 3*/
        		state=check_point;
			}
			else state=check_fail;
			
			break;

		case check_point: 
			if (PARSE_RADIO_IFNAME_POINT == str[0]){
			
				state = check_wlanid;
				
				}
			else
				state = check_fail;
			break;
				
		case check_wlanid: 
			*wlanid = strtoul((char *)&(str[1]),&str,10);

			if(*wlanid > 0 && *wlanid < WLAN_NUM+1){
        		state=check_end;
			}
			else state=check_fail;
			
			break;
			
		
		
		case check_fail:
		
            return -1;
			break;

		case check_end: 
			if ('\0' == str[0]) {
				state = check_success;
				
				}
			else
				state = check_fail;
				break;
			
		case check_success: 
			return 0;
			break;
			
		default: break;
		}
		
		}
		
}

int parse_int_ve(char* str, unsigned int* slotid, unsigned int *vlanid, unsigned int *vlanid2,char *cid, unsigned int *port){ /*fengwenchao add "vlanid2" for axsszfi-1506*/
	char c;
	char *tmp = NULL;
	char *endptr = NULL;
	c = str[0];
	if (c>='0'&&c<='9'){
		*slotid= strtoul(str,&endptr,10);
		
		if(endptr[0] == '.'){
			tmp = endptr+1;
			*vlanid= strtoul(tmp,&endptr,10);
			/*fengwenchao modify 20130325 for axsszfi-1506 begin*/
			if(endptr[0] == '.')
			{
				tmp = endptr+1;
				*vlanid2 = strtoul(tmp,&endptr,10);
				if((endptr[0] != '\0')&&(endptr[0] != '\n'))
					return WID_UNKNOWN_ID;
			}
			else if((endptr[0] != '\0')&&(endptr[0] != '\n'))
				return WID_UNKNOWN_ID;
			/*fengwenchao modify end*/
			return 1;
		}
		else if((endptr[0] == 'f')||(endptr[0] == 's')){
			*cid = endptr[0];
			tmp = endptr+1;
			*port = strtoul(tmp,&endptr,10);
			/*fengwenchao modify 20130325 for axsszfi-1506 begin*/
			if(endptr[0] == '.'){
				tmp = endptr+1;
				*vlanid= strtoul(tmp,&endptr,10);
				if(endptr[0] == '.')
				{
					tmp = endptr+1;
					*vlanid2 = strtoul(tmp,&endptr,10);
					if((endptr[0] != '\0')&&(endptr[0] != '\n'))
						return WID_UNKNOWN_ID;
				}
				else if((endptr[0] != '\0')&&(endptr[0] != '\n'))
					return WID_UNKNOWN_ID;
				return 2;
			}
			else if((endptr[0] == '\0')||(endptr[0] == '\n'))
				return 2;
			/*fengwenchao modify end*/			
			return WID_UNKNOWN_ID;
		}
	}
	
	return WID_UNKNOWN_ID;
}

int check_ve_interface(char *ifname, char *name){
	
	int sockfd;
	unsigned int slotid = 0;
	unsigned int vlanid = 0;
	unsigned int vlanid2 = 0;//fengwenchao add 20130325 for axsszfi-1506
	unsigned int port = 0;
	char cpu = 'f';
	char *cpu_id = &cpu; 
	struct ifreq	ifr;
	if (0 != strncmp(ifname, "ve", 2)){
		sprintf(name,"%s",ifname);
		wid_syslog_debug_debug(WID_DBUS,"interface name is %s\n",name);
		return 0;
	}
	else{
		sockfd = socket(AF_INET, SOCK_DGRAM, 0);
		strncpy(ifr.ifr_name,ifname, sizeof(ifr.ifr_name)); 		
		
		if(parse_int_ve(ifname+2,&slotid,&vlanid,&vlanid2,cpu_id,&port)== 1)//fengwenchao add "vlanid2" for axsszfi-1506 
		{
			wid_syslog_debug_debug(WID_DBUS,"slotid = %d,vlanid = %d,vlanid2 = %d\n",slotid,vlanid,vlanid2); 
			wid_syslog_debug_debug(WID_DBUS,"cpu_id = %c,port = %d\n",*cpu_id,port); 

			if (ioctl(sockfd, SIOCGIFINDEX, &ifr) == -1){//bind to a interface 
				wid_syslog_debug_debug(WID_DBUS,"SIOCGIFINDEX error\n"); 

				//convert to new ve name
				/*fengwenchao modify "vlanid2" for axsszfi-1506 begin*/
				if(slotid < 10)
				{
					if(vlanid2  == 0)
						sprintf(name,"ve0%df1.%d",slotid,vlanid);
					else if(vlanid2  > 0)
						sprintf(name,"ve0%df1.%d.%d",slotid,vlanid,vlanid2);
				}
				else if(slotid >= 10)
				{	
					if(vlanid2  == 0)
						sprintf(name,"ve%df1.%d",slotid,vlanid);
					else if(vlanid2  > 0)
						sprintf(name,"ve%df1.%d.%d",slotid,vlanid,vlanid2);
				}
				/*fengwenchao modify end*/
				wid_syslog_debug_debug(WID_DBUS,"ve name is %s\n",name); 

				memset(ifr.ifr_name, 0, sizeof(ifr.ifr_name));
				strncpy(ifr.ifr_name,name, sizeof(ifr.ifr_name)); 		
				if (ioctl(sockfd, SIOCGIFINDEX, &ifr) == -1){//bind to a interface 
					wid_syslog_debug_debug(WID_DBUS,"SIOCGIFINDEX error\n"); 
					close(sockfd);
					return -1;	//the new ve interface doesn't exist
				}		
				close(sockfd);
				return 0;	//the new ve interface exists
			}
			else{
				sprintf(name,"%s",ifname);
				wid_syslog_debug_debug(WID_DBUS,"old ve name is %s\n",name); 
				close(sockfd);
				return 0;//the old ve interface exists
			}
		}
		else if(parse_int_ve(ifname+2,&slotid,&vlanid,&vlanid2,cpu_id,&port)== 2)//fengwenchao add "vlanid2" for axsszfi-1506
		{
			wid_syslog_debug_debug(WID_DBUS,"slotid = %d,vlanid = %d,vlanid2 = %d\n",slotid,vlanid,vlanid2); 
			wid_syslog_debug_debug(WID_DBUS,"cpu_id = %c,port = %d\n",*cpu_id,port); 

			if(vlanid == 0){
				if(slotid < 10)
					sprintf(name,"ve0%d%c%d",slotid,*cpu_id,port);
				else if(slotid >= 10)
					sprintf(name,"ve%d%c%d",slotid,*cpu_id,port);
			}
			else if(vlanid > 0){
				/*fengwenchao modify "vlanid2" for axsszfi-1506 begin*/
				if(slotid < 10)
				{
					if(vlanid2  == 0)
						sprintf(name,"ve0%d%c%d.%d",slotid,*cpu_id,port,vlanid);
					else if(vlanid2  > 0)
						sprintf(name,"ve0%d%c%d.%d.%d",slotid,*cpu_id,port,vlanid,vlanid2);
				}
				else if(slotid >= 10)
				{
					if(vlanid2  == 0)
						sprintf(name,"ve%d%c%d.%d",slotid,*cpu_id,port,vlanid);
					else if(vlanid2  > 0)
						sprintf(name,"ve%d%c%d.%d.%d",slotid,*cpu_id,port,vlanid,vlanid2);
				}
				/*fengwenchao modify end*/
			}
			wid_syslog_debug_debug(WID_DBUS,"ve name is %s\n",name); 
		
			memset(ifr.ifr_name, 0, sizeof(ifr.ifr_name));
			strncpy(ifr.ifr_name,name, sizeof(ifr.ifr_name));		
			if (ioctl(sockfd, SIOCGIFINDEX, &ifr) == -1){//bind to a interface 
				wid_syslog_debug_debug(WID_DBUS,"SIOCGIFINDEX error\n"); 
				close(sockfd);
				return -1;	//the new ve interface doesn't exist
			}		

			close(sockfd);
			return 0;	//the new ve interface exists
		}
		else{
			wid_syslog_debug_debug(WID_DBUS,"the ve name is wrong\n"); 
			close(sockfd);
			return -1;
		}
	}
		
}


DBusMessage * wid_dbus_interface_update_wtp_count(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	int type = 0;
	int num = 0;
	int num1 = 0;
	int flag = 0;
	int updateflag = 0;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								 DBUS_TYPE_UINT32, &type,
								 DBUS_TYPE_UINT32, &num,
								DBUS_TYPE_INVALID))){
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	CWThreadMutexLock(&ACLicense);
	if(type < glicensecount){
		if(g_wtp_count[type]->gmax_wtp_count > num)
		{
			if(g_wtp_count[type]->isShm == 0){
				num1 = g_wtp_count[type]->gmax_wtp_count - num;
				g_wtp_count[type]->gmax_wtp_count = num;
				//g_wtp_count[type]->gmax_wtp_count_assign = num;
				g_wtp_count[type]->isShm = 0;
				flag = g_wtp_count[type]->flag;
				if((flag != 0)&&(flag < glicensecount+1)){
					g_wtp_binding_count[flag]->gmax_wtp_count -= num1;
				}
				CWThreadMutexLock(&MasterBak);
				if(is_secondary == 0){
					update_license_req(wid_sock , (struct sockaddr_in *)&B_addr);
				}else if(is_secondary == 1){
					update_license_req(wid_bak_sock , (struct sockaddr_in *)&M_addr);
				}
				if(Lic_ip.isActive == 1){
					update_license_req(lic_active_fd , (struct sockaddr_in *)&Lic_bak_addr);
				}else if(Lic_ip.isActive == 2){//bak
					update_license_req(lic_bak_fd , (struct sockaddr_in *)&Lic_Active_addr);
				}
				CWThreadMutexUnlock(&MasterBak);
				wid_syslog_info("%s,%d,current lic is not shared,assign lic num(%d) less than cout g_wtp_count[%d]->gmax_wtp_count(%d).\n",__func__,__LINE__,num,type,g_wtp_count[type]->gmax_wtp_count);
			}else{//shared lice
				wid_syslog_warning("%s,%d,current lic is shared,assign lic num(%d) less than cout g_wtp_count[%d]->gmax_wtp_count(%d).\n",__func__,__LINE__,num,type,g_wtp_count[type]->gmax_wtp_count);
			}
		}else if(g_wtp_count[type]->gmax_wtp_count < num){
			num1 = num - g_wtp_count[type]->gmax_wtp_count;
			g_wtp_count[type]->gmax_wtp_count = num;
			//g_wtp_count[type]->gmax_wtp_count_assign = num;
			g_wtp_count[type]->isShm = 0;
			flag = g_wtp_count[type]->flag;
			if((flag != 0)&&(flag < glicensecount+1)){
				if(g_wtp_binding_count[flag] != NULL)
					g_wtp_binding_count[flag]->gmax_wtp_count += num1;
			}
			updateflag = 1;
			wid_syslog_info("%s,%d,assign lic num(%d) cout g_wtp_count[%d]->gmax_wtp_count(%d).\n",__func__,__LINE__,num,type,g_wtp_count[type]->gmax_wtp_count);
		}else{
			wid_syslog_warning("%s,%d,assign lic num(%d) == g_wtp_count[%d]->gmax_wtp_count(%d).\n",__func__,__LINE__,num,type,g_wtp_count[type]->gmax_wtp_count);
		}

		g_wtp_count[type]->gmax_wtp_count_assign = num;
		wid_syslog_info("%s,%d,new assign lic num(%d) update cout g_wtp_count[%d]->gmax_wtp_count_assign(%d).\n",__func__,__LINE__,num,type,g_wtp_count[type]->gmax_wtp_count_assign);
	}else{
		wid_syslog_warning("%s,%d,assign lic type(%d) larger than glicensecount(%d).\n",__func__,__LINE__,type,glicensecount);
	}
	CWThreadMutexUnlock(&ACLicense);
	if(updateflag == 1){
		CWThreadMutexLock(&MasterBak);
		if(is_secondary == 0){
			update_license(wid_sock , (struct sockaddr_in *)&B_addr);
		}else if(is_secondary == 1){
			update_license(wid_bak_sock , (struct sockaddr_in *)&M_addr);
		}
		if(Lic_ip.isActive == 1){
			update_license_req(lic_active_fd , (struct sockaddr_in *)&Lic_bak_addr);
		}else if(Lic_ip.isActive == 2){//bak
			update_license_req(lic_bak_fd , (struct sockaddr_in *)&Lic_Active_addr);
		}
		CWThreadMutexUnlock(&MasterBak);
	}

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	return reply;	
}



//xm add
DBusMessage * wid_dbus_interface_del_attack_ap_mac(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	unsigned char macaddr[ACDBUS_MAC_LEN];
	
	dbus_error_init(&err);	

	if (!(dbus_message_get_args ( msg, &err,
								 DBUS_TYPE_BYTE,  &macaddr[0],
								 DBUS_TYPE_BYTE,  &macaddr[1],
								 DBUS_TYPE_BYTE,  &macaddr[2],
								 DBUS_TYPE_BYTE,  &macaddr[3],
								 DBUS_TYPE_BYTE,  &macaddr[4],
								 DBUS_TYPE_BYTE,  &macaddr[5],
								DBUS_TYPE_INVALID))){
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	wid_del_attack_ap_mac(macaddr);

	//printf("mac :: %02X:%02X:%02X:%02X:%02X:%02X\n",macaddr[0],macaddr[1],macaddr[2],macaddr[3],macaddr[4],macaddr[5]);
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	
	
	wid_syslog_debug_debug(WID_DBUS,"del attack ap mac successfully\n");
	
	return reply;	

}


DBusMessage * wid_dbus_interface_add_attack_ap_mac(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	unsigned char macaddr[ACDBUS_MAC_LEN];
	
	dbus_error_init(&err);	

	if (!(dbus_message_get_args ( msg, &err,
								 DBUS_TYPE_BYTE,  &macaddr[0],
								 DBUS_TYPE_BYTE,  &macaddr[1],
								 DBUS_TYPE_BYTE,  &macaddr[2],
								 DBUS_TYPE_BYTE,  &macaddr[3],
								 DBUS_TYPE_BYTE,  &macaddr[4],
								 DBUS_TYPE_BYTE,  &macaddr[5],
								DBUS_TYPE_INVALID))){
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	wid_add_attack_ap_mac(macaddr);

	//printf("mac :: %02X:%02X:%02X:%02X:%02X:%02X\n",macaddr[0],macaddr[1],macaddr[2],macaddr[3],macaddr[4],macaddr[5]);
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	
	
	wid_syslog_debug_debug(WID_DBUS,"set attack ap mac successfully\n");
	
	return reply;	

}

DBusMessage * wid_dbus_interface_add_wids_mac(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	unsigned char macaddr[ACDBUS_MAC_LEN];
	int isadd = 1;
	
	dbus_error_init(&err);	

	if (!(dbus_message_get_args ( msg, &err,
								 DBUS_TYPE_BYTE,  &macaddr[0],
								 DBUS_TYPE_BYTE,  &macaddr[1],
								 DBUS_TYPE_BYTE,  &macaddr[2],
								 DBUS_TYPE_BYTE,  &macaddr[3],
								 DBUS_TYPE_BYTE,  &macaddr[4],
								 DBUS_TYPE_BYTE,  &macaddr[5],
								DBUS_TYPE_INVALID))){
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	wid_add_del_wids_mac(macaddr,isadd);
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	
	
	wid_syslog_debug_debug(WID_DEFAULT,"add wids mac successfully\n");
	
	return reply;	

}

DBusMessage * wid_dbus_interface_del_wids_mac(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	unsigned char macaddr[ACDBUS_MAC_LEN];
	int isadd = 0;
	
	dbus_error_init(&err);	

	if (!(dbus_message_get_args ( msg, &err,
								 DBUS_TYPE_BYTE,  &macaddr[0],
								 DBUS_TYPE_BYTE,  &macaddr[1],
								 DBUS_TYPE_BYTE,  &macaddr[2],
								 DBUS_TYPE_BYTE,  &macaddr[3],
								 DBUS_TYPE_BYTE,  &macaddr[4],
								 DBUS_TYPE_BYTE,  &macaddr[5],
								DBUS_TYPE_INVALID))){
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	wid_add_del_wids_mac(macaddr,isadd);
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	
	
	wid_syslog_debug_debug(WID_DEFAULT,"del wids mac successfully\n");
	
	return reply;	

}

DBusMessage * wid_dbus_interface_add_essid(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	char *essid;
	int ret = WID_DBUS_SUCCESS;

	dbus_error_init(&err);	

	if (!(dbus_message_get_args ( msg, &err,
								 DBUS_TYPE_STRING,&essid,
								DBUS_TYPE_INVALID))){
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	//printf("legal essid:\t%s\n",essid);

	wid_add_legal_essid(essid);

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	
	
	wid_syslog_debug_debug(WID_DBUS,"add legal essid successfully\n");
	
	return reply;	

}

DBusMessage * wid_dbus_interface_modify_essid(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	char *essid;
	char *essid_new;
	int ret = WID_DBUS_SUCCESS;

	dbus_error_init(&err);	

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_STRING,&essid,
							   	DBUS_TYPE_STRING,&essid_new,
								DBUS_TYPE_INVALID))){
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	printf("legal essid:\t%s\n",essid);
	printf("legal essid_new:\t%s\n",essid_new);
	ret = wid_modify_legal_essid(essid,essid_new);

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	
	
	wid_syslog_debug_debug(WID_DEFAULT,"modify legal essid successfully\n");
	
	return reply;	

}

DBusMessage * wid_dbus_interface_add_oui(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned char oui[ACDBUS_OUI_LEN];
	int ret = WID_DBUS_SUCCESS;

	dbus_error_init(&err);	

	if (!(dbus_message_get_args ( msg, &err,
								 DBUS_TYPE_BYTE,  &oui[0],
								 DBUS_TYPE_BYTE,  &oui[1],
								 DBUS_TYPE_BYTE,  &oui[2],
								DBUS_TYPE_INVALID))){
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	//printf("manufacturer OUI: %02X:%02X:%02X\n",oui[0],oui[1],oui[2]);

	wid_add_manufacturer_oui(oui);

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	
	
	wid_syslog_debug_debug(WID_DBUS,"add legal manufacturer successfully\n");
	
	return reply;		

}



DBusMessage * wid_dbus_interface_del_essid(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	char *essid;
	int ret = WID_DBUS_SUCCESS;

	dbus_error_init(&err);	

	if (!(dbus_message_get_args ( msg, &err,
								 DBUS_TYPE_STRING,&essid,
								DBUS_TYPE_INVALID))){
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	//printf("legal essid:\t%s\n",essid);

	wid_del_legal_essid(essid);

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	
	
	wid_syslog_debug_debug(WID_DBUS,"add legal essid successfully\n");
	
	return reply;	

}

DBusMessage * wid_dbus_interface_del_oui(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned char oui[ACDBUS_OUI_LEN];
	int ret = WID_DBUS_SUCCESS;

	dbus_error_init(&err);	

	if (!(dbus_message_get_args ( msg, &err,
								 DBUS_TYPE_BYTE,  &oui[0],
								 DBUS_TYPE_BYTE,  &oui[1],
								 DBUS_TYPE_BYTE,  &oui[2],
								DBUS_TYPE_INVALID))){
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	//printf("manufacturer OUI: %02X:%02X:%02X\n",oui[0],oui[1],oui[2]);

	wid_del_manufacturer_oui(oui);

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	
	
	wid_syslog_debug_debug(WID_DBUS,"add legal manufacturer successfully\n");
	
	return reply;		

}
#if 0
DBusMessage * wid_dbus_interface_wtp_add_del(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
//	printf("wid_dbus_interface_wtp_add_del\n");
	DBusMessage * reply;
	DBusMessageIter	 iter;
	unsigned char isAdd;
	char* WTPName;
	unsigned int WTPID;
	char* WTPSN;
	char *WTPModel; 
	int i = 1;
	unsigned int ret = WID_DBUS_SUCCESS;
	unsigned int ret2 = 0;
	int issn = 1;
	DBusError err;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&isAdd,
								DBUS_TYPE_STRING,&WTPName,
								DBUS_TYPE_UINT32,&WTPID,
								DBUS_TYPE_STRING,&WTPSN,
								DBUS_TYPE_STRING,&WTPModel,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(WTPID >= WTP_NUM)
		ret = WTP_ID_LARGE_THAN_MAX;
	else{
		if(isAdd){
			if(AC_WTP[WTPID] == NULL){

				/*for(i=1; i<WTP_NUM; i++)
				{
					if((AC_WTP[i] != NULL)&&(memcmp(AC_WTP[i]->WTPSN, WTPSN, strlen(WTPSN)) == 0))
					{
						ret = WTP_SN_BE_USED;
						break;
					}

				}*/
				if(ret != WTP_SN_BE_USED){
					ret = WID_CREATE_NEW_WTP(WTPName,WTPID,WTPSN,WTPModel,issn);
					if (ret == 0){
						AsdWsm_WTPOp(WTPID,WID_ADD);//xm add 08/12/04
					}
				}
			}else{
				ret = WTP_ID_BE_USED;
			}
		}
		else{
			if(AC_WTP[WTPID] == NULL){
				ret = WTP_ID_NOT_EXIST;
			}
			
			else{
				AsdWsm_WTPOp(WTPID,WID_DEL);//xm add 08/12/04
				
				if(AC_WTP[WTPID]->APGroupID != 0){
					ret2 = del_ap_group_member(WTPID,AC_WTP[WTPID]->APGroupID);	
					if(ret2 != 0){
						wid_syslog_debug_debug(WID_DBUS,"ret2 = %d in %s\ n",ret2, __func__);
					}
				}
				ret = WID_DELETE_WTP(WTPID);
			}
		}
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
	
}


DBusMessage * wid_dbus_interface_wtp_add_del_by_mac(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage * reply;
	DBusMessageIter	 iter;
	unsigned char isAdd;
	char* WTPName;
	unsigned int WTPID;
	unsigned char macAddr[MAC_LEN];
	unsigned char *macstr;
	char *WTPModel; 
	int i = 1;
	unsigned int ret = WID_DBUS_SUCCESS;
	int issn = 0;
	DBusError err;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&isAdd,
								DBUS_TYPE_STRING,&WTPName,
								DBUS_TYPE_UINT32,&WTPID,
								DBUS_TYPE_BYTE,&macAddr[0],
							 	DBUS_TYPE_BYTE,&macAddr[1],
							 	DBUS_TYPE_BYTE,&macAddr[2],
							 	DBUS_TYPE_BYTE,&macAddr[3],
							 	DBUS_TYPE_BYTE,&macAddr[4],
							 	DBUS_TYPE_BYTE,&macAddr[5],
								DBUS_TYPE_STRING,&WTPModel,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(WTPID >= WTP_NUM)
		ret = WTP_ID_LARGE_THAN_MAX;
	else{
		if(isAdd){
			if(AC_WTP[WTPID] == NULL){

				/*for(i=1; i<WTP_NUM; i++)
				{
					if((AC_WTP[i] != NULL)&&(AC_WTP[i]->WTPMAC != NULL)&&(memcmp(AC_WTP[i]->WTPMAC, macAddr, sizeof(macAddr)) == 0))
					{
						ret = WTP_MAC_BE_USED;
						break;
					}

				}*/
				if(ret != WTP_MAC_BE_USED){
					macstr = (unsigned char*)WID_MALLOC(7);	
					memset(macstr,0,7);

					macstr[0] = macAddr[0];
					macstr[1] = macAddr[1];
					macstr[2] = macAddr[2];
					macstr[3] = macAddr[3];
					macstr[4] = macAddr[4];
					macstr[5] = macAddr[5];
					
		
					ret = WID_CREATE_NEW_WTP(WTPName,WTPID,macstr,WTPModel,issn);
					WID_FREE(macstr);
					macstr = NULL;
					if (ret == 0){
						AsdWsm_WTPOp(WTPID,WID_ADD);//xm add 08/12/04
					}
				}
			}else{
				ret = WTP_ID_BE_USED;
			}
		}else{
			if(AC_WTP[WTPID] == NULL){
				ret = WTP_ID_NOT_EXIST;
			}else{
				AsdWsm_WTPOp(WTPID,WID_DEL);//xm add 08/12/04
				ret = WID_DELETE_WTP(WTPID);
				
				
			}

		}
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
	
}

#endif

DBusMessage * wid_dbus_interface_wtp_add_del(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
//	printf("wid_dbus_interface_wtp_add_del\n");
	DBusMessage * reply;
	DBusMessageIter	 iter;
	unsigned char isAdd;
	char* WTPName;
	unsigned int WTPID;
	unsigned char* WTPSN;
	char *WTPModel; 
	//int i = 1;
	unsigned int ret = WID_DBUS_SUCCESS;
	unsigned int ret2 = 0;
	int issn = 1;
	int apcodeflag = 0;
	DBusError err;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&isAdd,
								DBUS_TYPE_STRING,&WTPName,
								DBUS_TYPE_UINT32,&WTPID,
								DBUS_TYPE_STRING,&WTPSN,
								DBUS_TYPE_STRING,&WTPModel,
								DBUS_TYPE_UINT32,&apcodeflag,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(WTPID >= WTP_NUM)
		ret = WTP_ID_LARGE_THAN_MAX;
	else{
		if(isAdd){
			if(AC_WTP[WTPID] == NULL){

				/*for(i=1; i<WTP_NUM; i++)
				{
					if((AC_WTP[i] != NULL)&&(memcmp(AC_WTP[i]->WTPSN, WTPSN, strlen(WTPSN)) == 0))
					{
						ret = WTP_SN_BE_USED;
						break;
					}

				}*/
				if(ret != WTP_SN_BE_USED){
					CWThreadMutexLock(&(gWTPs[WTPID].WTPThreadMutex));//fengwenchao add 20121123 for AXSSZFI-1050
					ret = WID_CREATE_NEW_WTP(WTPName,WTPID,WTPSN,WTPModel,issn,apcodeflag," ");
					CWThreadMutexUnlock(&(gWTPs[WTPID].WTPThreadMutex));
					if (ret == 0){
						AsdWsm_WTPOp(WTPID,WID_ADD);//xm add 08/12/04
					}
				}
			}else{
				ret = WTP_ID_BE_USED;
			}
		}
		else{
			if(AC_WTP[WTPID] == NULL){
				ret = WTP_ID_NOT_EXIST;
			}
			
			else{
				if(AC_WTP[WTPID]->isused == 1){
					ret = WTP_ID_BE_USED;
				}
				else{
					AsdWsm_WTPOp(WTPID,WID_DEL);//xm add 08/12/04
				
					if(AC_WTP[WTPID]->APGroupID != 0){
						ret2 = del_ap_group_member(WTPID,AC_WTP[WTPID]->APGroupID);	
						if(ret2 != 0){
							wid_syslog_debug_debug(WID_DBUS,"ret2 = %d in %s\n",ret2, __func__);
						}
					}
					CWThreadMutexLock(&(gWTPs[WTPID].WTPThreadMutex));
					ret = WID_DELETE_WTP(WTPID);
					CWThreadMutexUnlock(&(gWTPs[WTPID].WTPThreadMutex));
				}
			}
		}
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
	
}


DBusMessage * wid_dbus_interface_wtp_add_del_by_mac(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage * reply;
	DBusMessageIter	 iter;
	unsigned char isAdd;
	char* WTPName;
	unsigned int WTPID;
	int bootflag = 0;
	unsigned char macAddr[MAC_LEN];
	unsigned char *macstr;
	char *WTPModel; 
	int i = 1;
	unsigned int ret = WID_DBUS_SUCCESS;
	int issn = 0;
	int apcodeflag = 0;
	int isFirst = 0;
	DBusError err;
	struct wtp_con_info * con_info = NULL;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&isAdd,
								DBUS_TYPE_STRING,&WTPName,
								DBUS_TYPE_UINT32,&WTPID,
								DBUS_TYPE_BYTE,&macAddr[0],
							 	DBUS_TYPE_BYTE,&macAddr[1],
							 	DBUS_TYPE_BYTE,&macAddr[2],
							 	DBUS_TYPE_BYTE,&macAddr[3],
							 	DBUS_TYPE_BYTE,&macAddr[4],
							 	DBUS_TYPE_BYTE,&macAddr[5],
								DBUS_TYPE_STRING,&WTPModel,
								DBUS_TYPE_UINT32,&apcodeflag,
								DBUS_TYPE_UINT32,&bootflag,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	wid_syslog_debug_debug(WID_DEFAULT,"%s,%d,:bootflag:%d,ret=%d.\n",__func__,__LINE__,bootflag,ret);
	if(WTPID >= WTP_NUM)
		ret = WTP_ID_LARGE_THAN_MAX;
	else{
		if(isAdd){
			if(AC_WTP[WTPID] == NULL){

				for(i=1; i<WTP_NUM; i++)
				{
					if((AC_WTP[i] != NULL)&&(AC_WTP[i]->WTPMAC != NULL)\
						&&((AC_WTP[i]->WTPMAC[0]==macAddr[0])&&(AC_WTP[i]->WTPMAC[1]==macAddr[1])&&(AC_WTP[i]->WTPMAC[2]==macAddr[2])&&(AC_WTP[i]->WTPMAC[3]==macAddr[3])&&(AC_WTP[i]->WTPMAC[4]==macAddr[4])&&(AC_WTP[i]->WTPMAC[5]==macAddr[5])))
					{
						wid_syslog_debug_debug(WID_DEFAULT,"%s,%d,:bootflag:%d,ret=%d.\n",__func__,__LINE__,bootflag,ret);
						if(bootflag){
							con_info = WID_MALLOC(sizeof(struct wtp_con_info));
							memset(con_info,0,sizeof(struct wtp_con_info));
							memcpy(con_info->wtpmac,macAddr,MAC_LEN);
							con_info->wtpindex = i;
							con_info->wtpindex2 = WTPID;
							wid_add_wtp(con_info);
							if(first_conflict == 1){
								first_conflict = 0;
								//ret = WTP_MAC_BE_USED;
								isFirst = 1;
								wid_syslog_info("11%s,%d,:bootflag:%d,ret=%d,first_conflict=%d.\n",__func__,__LINE__,bootflag,ret,first_conflict);
							}else{
								wid_syslog_info("22%s,%d,:bootflag:%d,ret=%d,first_conflict=%d.\n",__func__,__LINE__,bootflag,ret,first_conflict);
							}
						}else{
							wid_syslog_debug_debug(WID_DEFAULT,"%s,%d,:bootflag:%d,ret=%d.\n",__func__,__LINE__,bootflag,ret);
							ret = WTP_MAC_BE_USED;
						}
						break;
					}
				
				}
				if(ret != WTP_MAC_BE_USED){
					macstr = (unsigned char*)WID_MALLOC(7);	
					memset(macstr,0,7);

					macstr[0] = macAddr[0];
					macstr[1] = macAddr[1];
					macstr[2] = macAddr[2];
					macstr[3] = macAddr[3];
					macstr[4] = macAddr[4];
					macstr[5] = macAddr[5];
					
					CWThreadMutexLock(&(gWTPs[WTPID].WTPThreadMutex));//fengwenchao add 20121123 for AXSSZFI-1050
					ret = WID_CREATE_NEW_WTP(WTPName,WTPID,macstr,WTPModel,issn,apcodeflag," ");
					CWThreadMutexUnlock(&(gWTPs[WTPID].WTPThreadMutex));
					
					WID_FREE(macstr);
					macstr = NULL;
					if (ret == 0){
						AsdWsm_WTPOp(WTPID,WID_ADD);//xm add 08/12/04
					}
					if((ret == 0)&&(isFirst == 1)){
						ret = WTP_MAC_BE_USED;
					}
				}
			}else{
				ret = WTP_ID_BE_USED;
			}
		}else{
			if(AC_WTP[WTPID] == NULL){
				ret = WTP_ID_NOT_EXIST;
			}else{
				AsdWsm_WTPOp(WTPID,WID_DEL);//xm add 08/12/04
				CWThreadMutexLock(&(gWTPs[WTPID].WTPThreadMutex));
				ret = WID_DELETE_WTP(WTPID);
				CWThreadMutexUnlock(&(gWTPs[WTPID].WTPThreadMutex));
				
				
			}

		}
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	CW_FREE_OBJECT_WID(con_info);
	return reply;
	
}

/* Huangleilei copy from 1.3.18, 20130610 */
DBusMessage * wid_dbus_interface_set_web_report_snr_range(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply = NULL;
	DBusError err;
	DBusMessageIter	iter;
	int max_snr = 0;
	int min_snr = 0;
	int ret = WID_DBUS_SUCCESS;

	dbus_error_init(&err);
	if (!(dbus_message_get_args (msg, &err,
								DBUS_TYPE_INT32,&max_snr,
								DBUS_TYPE_INT32,&min_snr,
								DBUS_TYPE_INVALID))){

		wid_syslog_debug_debug(WID_DEFAULT,"Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			wid_syslog_debug_debug(WID_DEFAULT,"%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if ((AP_SNR_MAX < max_snr) || (AP_SNR_MIN > max_snr))
	{
		ret = VALUE_OUT_OF_RANGE;
	}
	else if ((AP_SNR_MAX < min_snr) || (AP_SNR_MIN > min_snr))
	{
		ret = VALUE_OUT_OF_RANGE;

	}
	else if(min_snr >= max_snr)
	{
		ret = MIN_LARGER_THAN_MAX;	
	}
	else
	{
		gMAX_WEB_REPORT_SNR = max_snr;
		gMIN_WEB_REPORT_SNR = min_snr;
	}

	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	

}


DBusMessage * wid_dbus_interface_show_radio_auto_add_to_ebr_switch(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 
	DBusMessageIter  iter;
	DBusError err;
	dbus_error_init(&err);
		
	int ret = WID_DBUS_SUCCESS;
	unsigned char auto_switch = 0;
	
	auto_switch = g_auto_add_radio_to_ebr;

	reply = dbus_message_new_method_return(msg);
			
	dbus_message_iter_init_append(reply, &iter);
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &auto_switch);
	
	return reply;	

}

DBusMessage * wid_dbus_interface_set_radio_auto_add_to_ebr_switch(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
		
	int ret = WID_DBUS_SUCCESS;
	unsigned char auto_login_switch = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&auto_login_switch,
								DBUS_TYPE_INVALID))){

		wid_syslog_err("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			wid_syslog_err("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	g_auto_add_radio_to_ebr = auto_login_switch;

	wid_syslog_debug_debug(WID_DEFAULT, "set auto add radio to ebr switch %s successfully\n", auto_login_switch ? "enable" : "disable");
	reply = dbus_message_new_method_return(msg);
			
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	
	return reply;	

}


DBusMessage *wid_dbus_interface_wlan_ebr_add_del(DBusConnection *conn, DBusMessage *msg, void *user_data) {
	
	DBusMessage * reply;
	DBusMessageIter	 iter;
	unsigned char isAdd;

	unsigned char WlanID;
	unsigned int bridge_id;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&isAdd,								
								DBUS_TYPE_BYTE,&WlanID,
								DBUS_TYPE_UINT32,&bridge_id,
								DBUS_TYPE_INVALID))){
		wid_syslog_err("%s: Unable to get input args\n", __FUNCTION__);
				
		if (dbus_error_is_set(&err)) {
			wid_syslog_err("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(bridge_id >= EBR_NUM || bridge_id == 0){
		wid_syslog_err("ebr id = %d out of range[1-%d]\n", bridge_id, EBR_NUM-1);
		ret = VALUE_OUT_OF_RANGE;
	} else {
		if(isAdd){
				if(WID_EBR[bridge_id] == NULL){
					ret = WID_EBR_NOT_EXIST;
				}else{
					if (AC_WLAN[WlanID]->ebr_id == bridge_id)
						ret =WID_DBUS_SUCCESS;
					else {
						#if 0
						if (AC_WLAN[WlanID]->ebr_id != 0)
							ret = WLAN_ID_BE_USED;
						else {
							AC_WLAN[WlanID]->ebr_id = bridge_id;
							ret = WID_DBUS_SUCCESS;
						}
						#else
						AC_WLAN[WlanID]->ebr_id = bridge_id;
						ret = WID_DBUS_SUCCESS;
						#endif
					}
				}
			}else{

				ret = WID_DBUS_SUCCESS;
				AC_WLAN[WlanID]->ebr_id = 0;
			}
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
	
}


DBusMessage * wid_dbus_interface_wlan_add_del(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
//	printf("wid_dbus_interface_wlan_add_del\n");
	DBusMessage * reply;
	DBusMessageIter	 iter;
	unsigned char isAdd;
	char* WlanName;
	unsigned char WlanID;
	unsigned char* ESSID;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	unsigned cnFlag = 0;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&isAdd,								
								DBUS_TYPE_BYTE,&WlanID,
								DBUS_TYPE_STRING,&WlanName,
								DBUS_TYPE_STRING,&ESSID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
//	printf("%s,[%s]\n",WlanName,ESSID);
	if(isAdd){
		if(AC_WLAN[WlanID] == NULL){
			ret = WID_CREATE_NEW_WLAN(WlanName,WlanID,ESSID,NULL,cnFlag);
		}else{
			ret = WLAN_ID_BE_USED;
		}
	}else{
		if(AC_WLAN[WlanID] == NULL){
			ret = WLAN_ID_NOT_EXIST;
		}else{
			ret = WID_DELETE_WLAN(WlanID);
		}

	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
	
}


DBusMessage * wid_dbus_interface_wlan_add_del_CN(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage * reply;
	DBusMessageIter	 iter;
	//DBusMessageIter	 iter_array;
	unsigned char isAdd;
	//char name[32];
	//name = (char*)WID_MALLOC(32+1);
	//memset(name,0,32+1);
	unsigned char WlanID;
	char* WlanName;
	unsigned char  ESSID[32];
	memset(ESSID,0,ESSID_DEFAULT_LEN);
	unsigned int ret = WID_DBUS_SUCCESS;
	unsigned int lenth = 32;
	DBusError err;
	//unsigned int i = 0;
	int j =0;
	unsigned cnFlag = 1;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&isAdd,								
								DBUS_TYPE_BYTE,&WlanID,
								DBUS_TYPE_UINT32,&lenth,
								DBUS_TYPE_STRING,&WlanName,
								//DBUS_TYPE_STRING,&essid_str,
								
								DBUS_TYPE_BYTE,&ESSID[0],
								DBUS_TYPE_BYTE,&ESSID[1],
								DBUS_TYPE_BYTE,&ESSID[2],
								DBUS_TYPE_BYTE,&ESSID[3],
								DBUS_TYPE_BYTE,&ESSID[4],
								
								DBUS_TYPE_BYTE,&ESSID[5],
								DBUS_TYPE_BYTE,&ESSID[6],
								DBUS_TYPE_BYTE,&ESSID[7],
								DBUS_TYPE_BYTE,&ESSID[8],
								DBUS_TYPE_BYTE,&ESSID[9],
								
								DBUS_TYPE_BYTE,&ESSID[10],
								DBUS_TYPE_BYTE,&ESSID[11],
								DBUS_TYPE_BYTE,&ESSID[12],
								DBUS_TYPE_BYTE,&ESSID[13],
								DBUS_TYPE_BYTE,&ESSID[14],
								
								DBUS_TYPE_BYTE,&ESSID[15],
								DBUS_TYPE_BYTE,&ESSID[16],
								DBUS_TYPE_BYTE,&ESSID[17],
								DBUS_TYPE_BYTE,&ESSID[18],
								DBUS_TYPE_BYTE,&ESSID[19],
								
								DBUS_TYPE_BYTE,&ESSID[20],
								DBUS_TYPE_BYTE,&ESSID[21],
								DBUS_TYPE_BYTE,&ESSID[22],
								DBUS_TYPE_BYTE,&ESSID[23],
								DBUS_TYPE_BYTE,&ESSID[24],
								
								DBUS_TYPE_BYTE,&ESSID[25],
								DBUS_TYPE_BYTE,&ESSID[26],
								DBUS_TYPE_BYTE,&ESSID[27],
								DBUS_TYPE_BYTE,&ESSID[28],
								DBUS_TYPE_BYTE,&ESSID[29],
								
								DBUS_TYPE_BYTE,&ESSID[30],
								DBUS_TYPE_BYTE,&ESSID[31],

	
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	printf("###wlan##essid###%s,[%s]\n",WlanName,ESSID);
	unsigned char essid_str2[ESSID_DEFAULT_LEN+1];
	//essid_str2 = (char*)WID_MALLOC(ESSID_DEFAULT_LEN+1);
	char *s1=NULL;
	s1 = (char*)WID_MALLOC(1+1);

	memset(essid_str2,0,ESSID_DEFAULT_LEN+1);
	for(j = 0;j < ESSID_DEFAULT_LEN; j++ ){
		//if((j>0)&&(ESSID[j-1] == 0)&&(ESSID[j] == 0)){
		if((j>0)&&(ESSID[j] == 0)){
			break;

		}else{
			memset(s1,0,1+1);
			sprintf(s1,"%x",ESSID[j]);
			printf("s1:%s\n",s1);
			
			strncat((char*)essid_str2,s1,strlen(s1));
			
			//if(j<(ESSID_DEFAULT_LEN-1))
				//strncat(essid_str2," ",1);
			
			//printf("essid_str:%s\n",essid_str2);

		}
	}
	printf("##essid_str:%s\n",essid_str2);
	if(isAdd){
		if(AC_WLAN[WlanID] == NULL){
			ret = WID_CREATE_NEW_WLAN(WlanName,WlanID,ESSID,essid_str2,cnFlag);
		}else{
			ret = WLAN_ID_BE_USED;
		}
	}else{
		if(AC_WLAN[WlanID] == NULL){
			ret = WLAN_ID_NOT_EXIST;
		}else{
			ret = WID_DELETE_WLAN(WlanID);
		}

	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	if(s1 != NULL) 
		WID_FREE(s1);
	return reply;
	
}
DBusMessage * wid_dbus_interface_wlan(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	unsigned char WlanID;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&WlanID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_WLAN[WlanID] == NULL)
		ret = WLAN_ID_NOT_EXIST;
	else if (AC_WLAN[WlanID]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else
	{
	}
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_append_args(reply,
							 DBUS_TYPE_UINT32,&ret,
							 DBUS_TYPE_INVALID);
	return reply;
	
}

DBusMessage * wid_dbus_interface_wtp(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	unsigned int WTPID;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&WTPID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(WTPID >= WTP_NUM)
		ret = WTP_ID_LARGE_THAN_MAX;
	else{
		if(AC_WTP[WTPID] == NULL)
			ret = WTP_ID_NOT_EXIST;
	}
	reply = dbus_message_new_method_return(msg);
	dbus_message_append_args(reply,
							 DBUS_TYPE_UINT32,&ret,
							 DBUS_TYPE_INVALID);
	return reply;
	
}

DBusMessage * wid_dbus_interface_radio(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	unsigned int RadioId;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioId,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(RadioId >= G_RADIO_NUM)
		ret = RADIO_ID_LARGE_THAN_MAX;
	else if(AC_RADIO[RadioId]== NULL)
		ret = RADIO_ID_NOT_EXIST;
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_append_args(reply,
							 DBUS_TYPE_UINT32,&ret,
							 DBUS_TYPE_INVALID);
	return reply;
	
}

//fengwenchao add 20101223
DBusMessage * wid_dbus_interface_show_wlanconf_of_all(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusMessageIter  iter_struct;
	DBusMessageIter  iter_sub_array;
	DBusMessageIter  iter_sub_struct;
	DBusError err;
	dbus_error_init(&err);

	int ret = WID_DBUS_SUCCESS;
	int i = 0;
	int j = 0;
	int wlan_num = 0;
	unsigned char bif_num = 0;
	WID_WLAN **WLAN;
	WLAN = WID_MALLOC(WLAN_NUM*(sizeof(WID_WLAN*)));

	while(i<WLAN_NUM){
		if(AC_WLAN[i] != NULL && (AC_WLAN[i]->want_to_delete != 1))		/* Huangleilei add for ASXXZFI-1622 */
		{
			WLAN[wlan_num] = AC_WLAN[i];
			wlan_num++;
		}
		i++;
	}
	if(wlan_num == 0)
		ret = WLAN_ID_NOT_EXIST;	
	printf("ret = %d \n",ret);

	printf("wlan_num = %d \n",wlan_num);
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);

	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &wlan_num);
		
	dbus_message_iter_open_container (&iter,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING    //wlanid
												DBUS_TYPE_UINT32_AS_STRING  //balance_para
												DBUS_TYPE_UINT32_AS_STRING	//flow_balance_para	
												DBUS_TYPE_BYTE_AS_STRING    //balance switch
												DBUS_TYPE_BYTE_AS_STRING    //balance_method
												DBUS_TYPE_UINT32_AS_STRING  //wlan_max_allowed_sta_num												
												DBUS_TYPE_BYTE_AS_STRING    //Status
												DBUS_TYPE_BYTE_AS_STRING    //SecurityID
												DBUS_TYPE_UINT32_AS_STRING  //SecurityType
												DBUS_TYPE_UINT32_AS_STRING  //EncryptionType
												DBUS_TYPE_BYTE_AS_STRING    //HideESSid
												DBUS_TYPE_BYTE_AS_STRING    //bifnum;
												/*fengwenchao add 20110401*/
												DBUS_TYPE_UINT32_AS_STRING  //tx_pkt MAC
												DBUS_TYPE_UINT64_AS_STRING  //rx_bts MAC
												DBUS_TYPE_UINT64_AS_STRING  //tx_bts MAC
												/*fengwenchao add end*/
												DBUS_TYPE_ARRAY_AS_STRING	
												DBUS_STRUCT_BEGIN_CHAR_AS_STRING
													DBUS_TYPE_STRING_AS_STRING
												DBUS_STRUCT_END_CHAR_AS_STRING		
										DBUS_STRUCT_END_CHAR_AS_STRING,
										&iter_array);

	for(i=0;i<wlan_num;i++)
	{
		struct ifi* ifi = WLAN[i]->Wlan_Ifi;
		while(ifi != NULL){
			bif_num++;
			ifi = ifi->ifi_next;
		}
	
		/*fengwenchao add 20110401 for*/
		unsigned int tx_pkt = 0;
		unsigned long long rx_bts = 0;
		unsigned long long tx_bts = 0;
		WID_CHECK_SAME_ATH_OF_ALL_WTP(WLAN[i]->WlanID,&tx_pkt,&rx_bts,&tx_bts);
		/*fengwenchao add end*/
		
		dbus_message_iter_open_container (&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WLAN[i]->WlanID));

		printf("WLAN[i]->WlanID = %d \n",WLAN[i]->WlanID);
										
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_UINT32,&(WLAN[i]->balance_para));

		printf("WLAN[i]->balance_para = %d \n",WLAN[i]->balance_para);
						
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_UINT32,&(WLAN[i]->flow_balance_para));

		printf("WLAN[i]->flow_balance_para = %d \n",WLAN[i]->flow_balance_para);

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WLAN[i]->balance_switch));

		printf("WLAN[i]->balance_switch = %d \n",WLAN[i]->balance_switch);
					  
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE, &(WLAN[i]->balance_method));

		printf("WLAN[i]->balance_method = %d \n",WLAN[i]->balance_method);

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_UINT32,&(WLAN[i]->wlan_max_allowed_sta_num)); 

		printf("WLAN[i]->wlan_max_allowed_sta_num = %d \n",WLAN[i]->wlan_max_allowed_sta_num);
						
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WLAN[i]->Status));

		printf("WLAN[i]->Status = %d \n",WLAN[i]->Status);
										  					
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WLAN[i]->SecurityID));

		printf("WLAN[i]->SecurityID = %d \n",WLAN[i]->SecurityID);
														  
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_UINT32,&(WLAN[i]->SecurityType));

		printf("WLAN[i]->SecurityType = %d \n",WLAN[i]->SecurityType);
																	
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_UINT32,&(WLAN[i]->EncryptionType));

		printf("WLAN[i]->EncryptionType = %d \n",WLAN[i]->EncryptionType);
						
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WLAN[i]->HideESSid));

		printf("WLAN[i]->HideESSid = %d \n",WLAN[i]->HideESSid);
					
		dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&bif_num);

		printf("bif_num = %d \n",bif_num);
		/*fengwenchao add 20110401*/
		dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_UINT32,&tx_pkt);

		printf("tx_pkt = %d \n",tx_pkt);
		
		dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_UINT64,&rx_bts);

		printf("rx_bts = %llu \n",rx_bts);

		dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_UINT64,&tx_bts);

		printf("tx_bts = %llu\n",tx_bts);
		
		/*fengwenchao add 20110401*/
													
		dbus_message_iter_open_container (&iter_struct,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
										DBUS_STRUCT_END_CHAR_AS_STRING,
										&iter_sub_array);
		ifi = WLAN[i]->Wlan_Ifi;		
		char *name;
		//char *nas_id;
		name = (char*)WID_MALLOC(ETH_IF_NAME_LEN+1);
		//nas_id = (char*)WID_MALLOC(NAS_IDENTIFIER_NAME+1);
		for(j = 0; j < bif_num; j++){			
			memset(name,0,(ETH_IF_NAME_LEN+1));
			memcpy(name,ifi->ifi_name,ETH_IF_NAME_LEN);
			//memset(nas_id,0,NAS_IDENTIFIER_NAME+1);
			/*if(ifi->nas_id_len != 0){				
				memcpy(nas_id,ifi->nas_id,NAS_IDENTIFIER_NAME); 		
			}else
				memcpy(nas_id," ",1); */		
			dbus_message_iter_open_container (&iter_sub_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_sub_struct);
						 				  
			dbus_message_iter_append_basic (&iter_sub_struct,
											 DBUS_TYPE_STRING,
											 &(name));
			printf("name = %s \n",name);
						 
			ifi = ifi->ifi_next;
			dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);				
				 		
		}
		bif_num = 0;
		if(name){
		WID_FREE(name);
		name = NULL;
			}
		dbus_message_iter_close_container(&iter_struct, &iter_sub_array);	
		dbus_message_iter_close_container(&iter_array,&iter_struct);
	}

	if(WLAN){
		WID_FREE(WLAN);
		WLAN = NULL;
		}
	dbus_message_iter_close_container (&iter, &iter_array);
	return reply;
}
//fengwenchao add end 
DBusMessage * wid_dbus_interface_show_wlanconf(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	unsigned char WlanID;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	//char* WlanName;
	//char* ESSID;
	char *wlankey = NULL;
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&WlanID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	ret = WID_CHECK_ID(WID_WLAN_CHECK,(unsigned int)WlanID);
	if(ret != WID_DBUS_SUCCESS){
		reply = dbus_message_new_method_return(msg);
			
		dbus_message_iter_init_append (reply, &iter);
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
		
		return reply;	
	}
	else if(AC_WLAN[WlanID] == NULL){
		ret = WLAN_ID_NOT_EXIST;
		reply = dbus_message_new_method_return(msg);
			
		dbus_message_iter_init_append (reply, &iter);
		
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &ret);
	}
	else if (AC_WLAN[WlanID]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
		reply = dbus_message_new_method_return(msg);
		dbus_message_iter_init_append (reply, &iter);
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &ret);
	}
	else{
		
		DBusMessageIter iter_struct;
		int i=0;
		int j=0;
		unsigned char num = 0;
		WID_WLAN *WLAN = AC_WLAN[WlanID];
		struct ifi* ifi = WLAN->Wlan_Ifi;
		while(ifi != NULL){
			num++;
			ifi = ifi->ifi_next;
		}
		wlankey = (char*)WID_MALLOC(DEFAULT_LEN+1);
		memset(wlankey,0,DEFAULT_LEN+1);
		if(WLAN->WlanKey != NULL){				
			memcpy(wlankey,WLAN->WlanKey,DEFAULT_LEN);		
		}else
			memcpy(wlankey," ",DEFAULT_LEN);		
		reply = dbus_message_new_method_return(msg);
			
		dbus_message_iter_init_append (reply, &iter);
			
		dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &ret);

		dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &(WLAN->balance_para));

		dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &(WLAN->flow_balance_para));

		dbus_message_iter_append_basic (&iter, DBUS_TYPE_BYTE, &(WLAN->balance_switch));

		dbus_message_iter_append_basic (&iter, DBUS_TYPE_BYTE, &(WLAN->balance_method));
		
		dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &(WLAN->wlan_max_allowed_sta_num));  //xm

		
		dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &(WLAN->WlanName));
			
		dbus_message_iter_append_basic (&iter, DBUS_TYPE_BYTE, &(WLAN->WlanID));
			
		dbus_message_iter_open_container (&iter, 
											DBUS_TYPE_ARRAY, 
											DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
											DBUS_STRUCT_END_CHAR_AS_STRING,
										&iter_array);

		for(j=0;j<ESSID_DEFAULT_LEN;j++)
		{
			dbus_message_iter_open_container (&iter_array,
												DBUS_TYPE_STRUCT,
												NULL,
											  &iter_struct);
			dbus_message_iter_append_basic (&iter_struct, DBUS_TYPE_BYTE, &WLAN->ESSID[j]);
			dbus_message_iter_close_container (&iter_array, &iter_struct);
		}
		dbus_message_iter_close_container (&iter, &iter_array);
			
		dbus_message_iter_append_basic (&iter, DBUS_TYPE_BYTE, &(WLAN->Status));
		
		dbus_message_iter_append_basic (&iter, DBUS_TYPE_BYTE, &(WLAN->isolation_policy));
		dbus_message_iter_append_basic (&iter, DBUS_TYPE_BYTE, &(WLAN->multicast_isolation_policy));
		dbus_message_iter_append_basic (&iter, DBUS_TYPE_BYTE, &(WLAN->sameportswitch));
		dbus_message_iter_append_basic (&iter, DBUS_TYPE_BYTE, &(WLAN->bridge_ucast_solicit_stat));
		dbus_message_iter_append_basic (&iter, DBUS_TYPE_BYTE, &(WLAN->bridge_mcast_solicit_stat));
		dbus_message_iter_append_basic (&iter, DBUS_TYPE_BYTE, &(WLAN->SecurityID));
		dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &(WLAN->SecurityType));
		dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &(WLAN->EncryptionType));
		dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &(wlankey));
		dbus_message_iter_append_basic (&iter, DBUS_TYPE_BYTE, &(WLAN->asic_hex));	
		dbus_message_iter_append_basic (&iter, DBUS_TYPE_BYTE, &(WLAN->HideESSid));	
		dbus_message_iter_append_basic (&iter, DBUS_TYPE_BYTE, &(WLAN->SecurityIndex));	
		dbus_message_iter_append_basic (&iter, DBUS_TYPE_BYTE, &(WLAN->wlan_if_policy));	
		dbus_message_iter_append_basic (&iter, DBUS_TYPE_BYTE, &(WLAN->WLAN_TUNNEL_POLICY));	
		dbus_message_iter_append_basic (&iter, DBUS_TYPE_BYTE, &(WLAN->Roaming_Policy));
		dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &(WLAN->wlan_traffic_limit));
		dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT16, &(WLAN->flow_check));
		dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &(WLAN->no_flow_time));
		
		dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &(WLAN->limit_flow));
		dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &(WLAN->wlan_send_traffic_limit));
		
		dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &(WLAN->wlan_station_average_traffic_limit));
		dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &(WLAN->wlan_station_average_send_traffic_limit));

		
		dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &(WLAN->WDSStat));
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(WLAN->wds_mesh));

	    dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(WLAN->eap_mac_switch));
	    dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &(WLAN->eap_mac));

		dbus_message_iter_append_basic (&iter, DBUS_TYPE_BYTE, &num);
 		dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &(WLAN->hotspot_id));
		dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &(WLAN->ebr_id));
		
		dbus_message_iter_open_container (&iter,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_STRING_AS_STRING
												DBUS_TYPE_STRING_AS_STRING
										DBUS_STRUCT_END_CHAR_AS_STRING,
										&iter_array);
		ifi = WLAN->Wlan_Ifi;		
		char *name;
		char *nas_id;
		name = (char*)WID_MALLOC(ETH_IF_NAME_LEN+1);
		nas_id = (char*)WID_MALLOC(NAS_IDENTIFIER_NAME+1);
		for(i = 0; i < num; i++){			
			//DBusMessageIter iter_struct;
			memset(name,0,(ETH_IF_NAME_LEN+1));
			memcpy(name,ifi->ifi_name,ETH_IF_NAME_LEN);
			memset(nas_id,0,NAS_IDENTIFIER_NAME+1);
			if(ifi->nas_id_len != 0){				
				memcpy(nas_id,ifi->nas_id,NAS_IDENTIFIER_NAME); 		
			}else
				memcpy(nas_id," ",1); 		
			dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
		
			dbus_message_iter_append_basic (&iter_struct,
											 DBUS_TYPE_STRING,
											 &(name));
			
			dbus_message_iter_append_basic (&iter_struct,
											 DBUS_TYPE_STRING,
											 &(nas_id));
			ifi = ifi->ifi_next;
			dbus_message_iter_close_container (&iter_array, &iter_struct);
		}
		WID_FREE(name);
		WID_FREE(nas_id);
		WID_FREE(wlankey);
		dbus_message_iter_close_container (&iter, &iter_array);
				
	}
	return reply;	
}

DBusMessage * wid_dbus_interface_show_wlanlist(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	unsigned char num=0;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	int i=0;
	int j =0;
	WID_WLAN *WLAN[WLAN_NUM];
	char *wlan_name = NULL;
	char *essid = NULL;

	while(i<WLAN_NUM){
		if(AC_WLAN[i] != NULL && (AC_WLAN[i]->want_to_delete != 1))		/* Huangleilei add for ASXXZFI-1622 */
		{
			WLAN[num] = AC_WLAN[i];
			num++;
		}
		i++;
	}
	if(num == 0)
		ret = WLAN_ID_NOT_EXIST;
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
		// Total slot count
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &num);
		
	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_ARRAY_AS_STRING
											DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
											DBUS_STRUCT_END_CHAR_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for(i = 0; i < num; i++){			
		DBusMessageIter iter_struct;
		DBusMessageIter  iter_sub_array;
		dbus_message_iter_open_container (&iter_array,
										DBUS_TYPE_STRUCT,
										NULL,
										&iter_struct);
		if(NULL == WLAN[i]->WlanName){
			return NULL;
			printf("happen error\n");
		}
		else{
			wlan_name = (char *)WID_MALLOC(strlen(WLAN[i]->WlanName) + 1);
			memset(wlan_name,0,strlen(WLAN[i]->WlanName) + 1);
			memcpy(wlan_name,WLAN[i]->WlanName,strlen(WLAN[i]->WlanName));
		}
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_STRING,
					  &(wlan_name));
			
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WLAN[i]->WlanID));
			
	dbus_message_iter_open_container (&iter_struct,
							   DBUS_TYPE_ARRAY,
							   DBUS_STRUCT_BEGIN_CHAR_AS_STRING  
								  DBUS_TYPE_BYTE_AS_STRING
							   DBUS_STRUCT_END_CHAR_AS_STRING, 
							   &iter_sub_array);
		if(NULL == WLAN[i]->ESSID){
			return NULL;
			//printf("happen error\n");
		}
		else{
			essid = (char *)WID_MALLOC(ESSID_DEFAULT_LEN + 1);
			memset(essid,0,(ESSID_DEFAULT_LEN + 1));
			//memcpy use error
			//memcpy(essid,WLAN[i]->ESSID,ESSID_DEFAULT_LEN);
			memcpy(essid,WLAN[i]->ESSID,strlen(WLAN[i]->ESSID));
		}
		for(j=0;j<ESSID_DEFAULT_LEN;j++)
		{
			DBusMessageIter iter_sub_struct;				
			dbus_message_iter_open_container (&iter_sub_array,
												DBUS_TYPE_STRUCT,
												NULL,
											  &iter_sub_struct);
			dbus_message_iter_append_basic
						(&iter_sub_struct,
						  DBUS_TYPE_BYTE,
						  &essid[j]);
			dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);
		}
		dbus_message_iter_close_container (&iter_struct, &iter_sub_array);	
			
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WLAN[i]->Status));
		
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WLAN[i]->SecurityID));
		
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WLAN[i]->HideESSid));
		dbus_message_iter_append_basic
			(&iter_struct,
			  DBUS_TYPE_BYTE,
			  &(WLAN[i]->wlan_if_policy));

		dbus_message_iter_append_basic
			(&iter_struct,
			  DBUS_TYPE_UINT32,
			  &(WLAN[i]->WDSStat));

		dbus_message_iter_append_basic
			(&iter_struct,
			  DBUS_TYPE_UINT32,
			  &(WLAN[i]->wds_mesh));
		
		dbus_message_iter_close_container (&iter_array, &iter_struct);
		if(wlan_name != NULL){
			WID_FREE(wlan_name);
			wlan_name = NULL;
		}
		if(essid != NULL){
			WID_FREE(essid);
			essid = NULL;
		}
	}
				
	dbus_message_iter_close_container (&iter, &iter_array);
				
	
	return reply;	
}
//fengwenchao add 20110226
DBusMessage *wid_dbus_interface_show_wtplist_bymodel(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;	
	DBusError err;
	dbus_error_init(&err);

	unsigned int num=0;
	int ret = WID_DBUS_SUCCESS;
	int i=0;
	WID_WTP **WTP;
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	char *no_info = "none";
	while(i<WTP_NUM){
		CWThreadMutexLock(&(gWTPs[i].WTPThreadMutex));//fengwenchao add 20121123 for AXSSZFI-1050
		if(AC_WTP[i] != NULL)
		{			
			WTP[num] = AC_WTP[i];
			num++;
			
		}
		CWThreadMutexUnlock(&(gWTPs[i].WTPThreadMutex));
		i++;
	}	
	if(num == 0)
		ret = WTP_ID_NOT_EXIST;

	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&num);

	dbus_message_iter_open_container (&iter,
								DBUS_TYPE_ARRAY,
								DBUS_STRUCT_BEGIN_CHAR_AS_STRING
										DBUS_TYPE_UINT32_AS_STRING  //wtpid
										DBUS_TYPE_BYTE_AS_STRING    //mac[0]
										DBUS_TYPE_BYTE_AS_STRING	//mac[1]
										DBUS_TYPE_BYTE_AS_STRING    //mac[2]
										DBUS_TYPE_BYTE_AS_STRING    //mac[3]
										DBUS_TYPE_BYTE_AS_STRING    //mac[4]
										DBUS_TYPE_BYTE_AS_STRING    //mac[5]
										DBUS_TYPE_STRING_AS_STRING  //wtpmodel
										DBUS_TYPE_STRING_AS_STRING  //apcode
										DBUS_TYPE_STRING_AS_STRING  //version
										DBUS_TYPE_STRING_AS_STRING  //codever
										DBUS_TYPE_BYTE_AS_STRING  //wtpstat
										DBUS_TYPE_BYTE_AS_STRING  //isused
								DBUS_STRUCT_END_CHAR_AS_STRING,
								&iter_array);

		for(i = 0; i < num; i++){			
		DBusMessageIter iter_struct;
			
		dbus_message_iter_open_container(&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_UINT32,&(WTP[i]->WTPID));

		memset(mac,0,MAC_LEN+1);
		memcpy(mac,WTP[i]->WTPMAC,MAC_LEN);
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[0]));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[1]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[2]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[3]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[4]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[5]));
			
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&(WTP[i]->WTPModel));

		if(WTP[i]->APCode == NULL)
		{
			dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_STRING,&(no_info));
			printf("no_info = %s \n",no_info);
		}
		else
		{
			dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_STRING,&(WTP[i]->APCode));
			
			printf("WTP[i]->APCode = %s \n",WTP[i]->APCode);
		}
		
		if(WTP[i]->ver == NULL)
		{
			dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_STRING,&(no_info));
			
			printf("no_info = %s \n",no_info);
		}
		else
		{
			dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_STRING,&(WTP[i]->ver));
			
			printf("WTP[i]->ver = %s \n",WTP[i]->ver);
		}
		
		if(WTP[i]->codever == NULL)
		{
			dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_STRING,&(no_info));
			
			printf("no_info = %s \n",no_info);
		}
		else
		{
			dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_STRING,&(WTP[i]->codever));
			
			printf("WTP[i]->codever = %s \n",WTP[i]->codever);
		}

		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->WTPStat));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->isused));
		
		dbus_message_iter_close_container (&iter_array, &iter_struct);
	}
				
	dbus_message_iter_close_container (&iter, &iter_array);
				
	WID_FREE(WTP);
	WTP = NULL;
	CW_FREE_OBJECT_WID(mac);
	return reply;	
}
//fengwenchao add end

//fengwenchao add 20110314
DBusMessage * wid_dbus_interface_show_wtplist_byversion(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;	
	DBusError err;
	dbus_error_init(&err);

	unsigned int num=0;
	int ret = WID_DBUS_SUCCESS;
	int i=0;
	WID_WTP **WTP;
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	char *no_info = "none";
	while(i<WTP_NUM){
		CWThreadMutexLock(&(gWTPs[i].WTPThreadMutex));//fengwenchao add 20121123 for AXSSZFI-1050
		if(AC_WTP[i] != NULL)
		{
			WTP[num] = AC_WTP[i];
			num++;
		}
		CWThreadMutexUnlock(&(gWTPs[i].WTPThreadMutex));
		i++;
	}	
	if(num == 0)
		ret = WTP_ID_NOT_EXIST;

	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&num);

	dbus_message_iter_open_container (&iter,
								DBUS_TYPE_ARRAY,
								DBUS_STRUCT_BEGIN_CHAR_AS_STRING
										DBUS_TYPE_UINT32_AS_STRING  //wtpid
										DBUS_TYPE_BYTE_AS_STRING    //mac[0]
										DBUS_TYPE_BYTE_AS_STRING	//mac[1]
										DBUS_TYPE_BYTE_AS_STRING    //mac[2]
										DBUS_TYPE_BYTE_AS_STRING    //mac[3]
										DBUS_TYPE_BYTE_AS_STRING    //mac[4]
										DBUS_TYPE_BYTE_AS_STRING    //mac[5]
										DBUS_TYPE_STRING_AS_STRING  //wtpmodel
										DBUS_TYPE_STRING_AS_STRING  //apcode
										DBUS_TYPE_STRING_AS_STRING  //version
										DBUS_TYPE_STRING_AS_STRING  //codever
										DBUS_TYPE_BYTE_AS_STRING  //wtpstat
										DBUS_TYPE_BYTE_AS_STRING  //isused
								DBUS_STRUCT_END_CHAR_AS_STRING,
								&iter_array);

		for(i = 0; i < num; i++){			
		DBusMessageIter iter_struct;
			
		dbus_message_iter_open_container(&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_UINT32,&(WTP[i]->WTPID));

		memset(mac,0,MAC_LEN+1);
		memcpy(mac,WTP[i]->WTPMAC,MAC_LEN);
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[0]));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[1]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[2]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[3]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[4]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[5]));
			
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&(WTP[i]->WTPModel));

		if(WTP[i]->APCode == NULL)
		{
			dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_STRING,&(no_info));
			printf("no_info = %s \n",no_info);
		}
		else
		{
			dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_STRING,&(WTP[i]->APCode));
			
			printf("WTP[i]->APCode = %s \n",WTP[i]->APCode);
		}
		
		if(WTP[i]->ver == NULL)
		{
			dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_STRING,&(no_info));
			
			printf("no_info = %s \n",no_info);
		}
		else
		{
			dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_STRING,&(WTP[i]->ver));
			
			printf("WTP[i]->ver = %s \n",WTP[i]->ver);
		}
		
		if(WTP[i]->codever == NULL)
		{
			dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_STRING,&(no_info));
			
			printf("no_info = %s \n",no_info);
		}
		else
		{
			dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_STRING,&(WTP[i]->codever));
			
			printf("WTP[i]->codever = %s \n",WTP[i]->codever);
		}

		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->WTPStat));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->isused));
		
		dbus_message_iter_close_container (&iter_array, &iter_struct);
	}
				
	dbus_message_iter_close_container (&iter, &iter_array);
				
	WID_FREE(WTP);
	WTP = NULL;
	CW_FREE_OBJECT_WID(mac);
	return reply;	
}
//fengwenchao add end
DBusMessage * wid_dbus_interface_show_wtplist_new(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	unsigned int num=0;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	int i=0;
	WID_WTP **WTP;
	char *wtp_location = NULL;
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	while(i<WTP_NUM){
		CWThreadMutexLock(&(gWTPs[i].WTPThreadMutex));//fengwenchao add 20121123 for AXSSZFI-1050
		if(AC_WTP[i] != NULL)
		{
			WTP[num] = AC_WTP[i];
			num++;
		}
		CWThreadMutexUnlock(&(gWTPs[i].WTPThreadMutex));
		i++;
	}
	if(num == 0)
		ret = WTP_ID_NOT_EXIST;

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);		
	wtp_location = (char *)WID_MALLOC(strlen("Location not setted")+1);
	memset(wtp_location,0,strlen("Location not setted")+1);
	memcpy(wtp_location,"Location not setted",strlen("Location not setted"));
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&num);
		
	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_STRING_AS_STRING //wtpsn   fengwenchao add 20110530 
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for(i = 0; i < num; i++){			
		DBusMessageIter iter_struct;
			
		dbus_message_iter_open_container(&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_UINT32,&(WTP[i]->WTPID));

		memset(mac,0,MAC_LEN+1);
		memcpy(mac,WTP[i]->WTPMAC,MAC_LEN);
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[0]));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[1]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[2]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[3]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[4]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[5]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&(WTP[i]->WTPIP));
			
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&(WTP[i]->WTPModel));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->WTPStat));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->isused));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&(WTP[i]->WTPNAME));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&(WTP[i]->WTPSN));   //fengwenchao add 20110530
		
		if(WTP[i]->location == NULL)
		{
			dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&wtp_location); 
		}
		else
		{
			dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&(WTP[i]->location));
		}/*zhangcl addef for wtp location*/
		
		dbus_message_iter_close_container (&iter_array, &iter_struct);


	}
				
	dbus_message_iter_close_container (&iter, &iter_array);
				
	WID_FREE(WTP);
	WTP = NULL;
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(wtp_location);
	return reply;	
}
/*xiaodawei transplant from 2.0 for telecom test, 20110301*/
DBusMessage * wid_dbus_interface_show_wtplist_byinterface(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	unsigned int num=0;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	int i=0;
	WID_WTP **WTP;
	char *sn = NULL;
	char *name = NULL;
	char __str[128];			
	char *str = "lo";   //fengwenchao modify 20110525
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);		
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	while(i<WTP_NUM){
		CWThreadMutexLock(&(gWTPs[i].WTPThreadMutex));//fengwenchao add 20121123 for AXSSZFI-1050
		if(AC_WTP[i] != NULL)
		{
			WTP[num] = AC_WTP[i];
			num++;
		}
		CWThreadMutexUnlock(&(gWTPs[i].WTPThreadMutex));
		i++;
	}
	if(num == 0)
		ret = WTP_ID_NOT_EXIST;

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);		
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&num);
		
	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for(i = 0; i < num; i++){			
		DBusMessageIter iter_struct;
			
		dbus_message_iter_open_container(&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_UINT32,&(WTP[i]->WTPID));

		memset(mac,0,MAC_LEN+1);
		memcpy(mac,WTP[i]->WTPMAC,MAC_LEN);
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[0]));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[1]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[2]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[3]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[4]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[5]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&(WTP[i]->WTPIP));

		memset(sn,0,NAS_IDENTIFIER_NAME);
		memcpy(sn,WTP[i]->WTPSN,strlen(WTP[i]->WTPSN));
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&sn);

		name = (char*)WID_MALLOC(ETH_IF_NAME_LEN+1); //20080710
		memset(name,0,(ETH_IF_NAME_LEN+1));
		memcpy(name,WTP[i]->BindingIFName,ETH_IF_NAME_LEN);
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&(name));
		WID_FREE(name);
		name = NULL;
		//memset(str,0,128);
		memset(__str,0,128);
		/*fengwenchao modify begin 20110525*/
		if((gWTPs[WTP[i]->WTPID].interfaceIndex < gMaxInterfacesCount)&&(gWTPs[WTP[i]->WTPID].interfaceIndex >= 0))
		{
			str = sock_ntop_r(((struct sockaddr*)&(gInterfaces[gWTPs[WTP[i]->WTPID].interfaceIndex].addr)), __str);
		}
		else
		{
			wid_syslog_err("gWTPs[%d].interfaceIndex = %d , is not legal \n",WTP[i]->WTPID,gWTPs[WTP[i]->WTPID].interfaceIndex);
		}
		/*fengwenchao modify end*/
		wid_syslog_info("WTP %d on Interface %s (%d)\n",WTP[i]->WTPID, str, gWTPs[WTP[i]->WTPID].interfaceIndex);
		printf("WTP %d on Interface %s (%d)\n",WTP[i]->WTPID, str, gWTPs[WTP[i]->WTPID].interfaceIndex);

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&(str));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&(WTP[i]->WTPModel));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->WTPStat));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->isused));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&(WTP[i]->WTPNAME));

		dbus_message_iter_close_container (&iter_array, &iter_struct);


	}
				
	dbus_message_iter_close_container (&iter, &iter_array);
				
	WID_FREE(WTP);
	WTP = NULL;
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(sn);
	return reply;	
}

/*END*/
DBusMessage * wid_dbus_interface_show_wtplist_update(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	unsigned int num=0;
	unsigned char ret_flag = 0;
	char *wtp_ip = NULL;
	char *wtp_model = NULL;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	int i=0,j=0;
	WID_WTP **WTP;
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	if( WTP == NULL){
		wid_syslog_debug_debug(WID_DBUS,"%s :WID_MALLOC fail.\n",__func__);
		exit(1);
	}
	memset(WTP,0,WTP_NUM*(sizeof(WID_WTP *)));

	for(j=0;j<BATCH_UPGRADE_AP_NUM;j++){
		if(gConfigVersionUpdateInfo[j] != NULL){
			ret_flag = 1;
			break;
		}
	}
	while((ret_flag)&&(i<WTP_NUM)){
		if((AC_WTP[i] != NULL)&&(find_in_wtp_list(i) == CW_TRUE))
		{
			WTP[num] = AC_WTP[i];
			num++;
		}
		i++;
	}
	if(num == 0)
		ret = WTP_ID_NOT_EXIST;
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&num);
		
	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for(i = 0; i < num; i++){			
		DBusMessageIter iter_struct;
			
		dbus_message_iter_open_container(&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_UINT32,&(WTP[i]->WTPID));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->WTPMAC[0]));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->WTPMAC[1]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->WTPMAC[2]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->WTPMAC[3]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->WTPMAC[4]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->WTPMAC[5]));

		
		if(WTP[i]->WTPIP != NULL)
		{
			wtp_ip = (char*)WID_MALLOC(strlen(WTP[i]->WTPIP)+1);
			memset(wtp_ip,0,strlen(WTP[i]->WTPIP)+1);
			memcpy(wtp_ip,WTP[i]->WTPIP,strlen(WTP[i]->WTPIP));		
		}else{
			wtp_ip = (char*)WID_MALLOC(2);
			memset(wtp_ip,0,2);
			memcpy(wtp_ip," ",1);					
		}
		
		if(WTP[i]->WTPModel != NULL)
		{
			wtp_model = (char*)WID_MALLOC(strlen(WTP[i]->WTPModel)+1);
			memset(wtp_model,0,strlen(WTP[i]->WTPModel)+1);
			memcpy(wtp_model,WTP[i]->WTPModel,strlen(WTP[i]->WTPModel));		
		}else{
			wtp_model = (char*)WID_MALLOC(2);
			memset(wtp_model,0,2);
			memcpy(wtp_model," ",1);					
		}
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&(wtp_ip));
			
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&(wtp_model));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->WTPStat));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->updateStat));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_UINT32,&(WTP[i]->manual_update_time));

		dbus_message_iter_close_container (&iter_array, &iter_struct);
		CW_FREE_OBJECT_WID(wtp_ip);
		CW_FREE_OBJECT_WID(wtp_model);

	}
				
	dbus_message_iter_close_container (&iter, &iter_array);
				
	WID_FREE(WTP);
	WTP = NULL;
	return reply;	
}

DBusMessage * wid_dbus_interface_show_wtplist_update_fail(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	unsigned int num=0;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	int i=0;
	WID_WTP **WTP;
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	if( WTP == NULL){
		wid_syslog_debug_debug(WID_DBUS,"%s :malloc fail.\n",__func__);
		return NULL;
	}
	memset(WTP,0,WTP_NUM*(sizeof(WID_WTP *)));

	while(i<WTP_NUM){
		if((AC_WTP[i] != NULL)&&(find_in_uptfail_wtp_list(i) == CW_TRUE))
		{
			WTP[num] = AC_WTP[i];
			num++;
		}
		i++;
	}

	if(num == 0)
		ret = WTP_ID_NOT_EXIST;
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&num);
		
	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for(i = 0; i < num; i++){			
		DBusMessageIter iter_struct;
			
		dbus_message_iter_open_container(&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_UINT32,&(WTP[i]->WTPID));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->WTPMAC[0]));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->WTPMAC[1]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->WTPMAC[2]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->WTPMAC[3]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->WTPMAC[4]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->WTPMAC[5]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&(WTP[i]->WTPIP));
			
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&(WTP[i]->WTPModel));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->WTPStat));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->updatefailstate));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->updatefailcount));

		dbus_message_iter_close_container (&iter_array, &iter_struct);


	}
				
	dbus_message_iter_close_container (&iter, &iter_array);
				
	WID_FREE(WTP);
	WTP = NULL;
	return reply;	
}

/* show hide_quit_wtp_in_showing
** zhangshu append 2010-08-21 */
DBusMessage * wid_dbus_interface_show_wtp_hide_quit(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusMessageIter iter;
	int ret = WID_DBUS_SUCCESS;
	int switch_val = hide_quit_wtp_in_showting;
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append (reply, &iter);
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &ret);
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &switch_val);
	
	return reply;
}

DBusMessage * wid_dbus_interface_show_wtplist(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	unsigned int num=0;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	int i=0;
	WID_WTP **WTP =NULL;
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	while(i<WTP_NUM){
		CWThreadMutexLock(&(gWTPs[i].WTPThreadMutex));//fengwenchao add 20121123 for AXSSZFI-1050	
		if((AC_WTP[i] != NULL)&&(AC_WTP[i]->WTPID<WTP_NUM))
		{
			WTP[num] = AC_WTP[i];
			num++;
		}		
		CWThreadMutexUnlock(&(gWTPs[i].WTPThreadMutex));	
		i++;
	}
	if(num == 0)
		ret = WTP_ID_NOT_EXIST;

	/*store sn&mac of ap*/
	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);		
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
		// Total slot count
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
		
	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for(i = 0; ((i < num)&&(WTP[i] != NULL)); i++){			
		DBusMessageIter iter_struct;
		memset(sn,0,NAS_IDENTIFIER_NAME);
		if(WTP[i]->WTPSN != NULL){
			if(strlen(WTP[i]->WTPSN) > NAS_IDENTIFIER_NAME){
				memcpy(sn,WTP[i]->WTPSN,NAS_IDENTIFIER_NAME);
			}else{
				memcpy(sn,WTP[i]->WTPSN,strlen(WTP[i]->WTPSN));
			}
		}else{
			wid_syslog_err("<error>%s\n",__func__);
		}
			
		dbus_message_iter_open_container (&iter_array,
										DBUS_TYPE_STRUCT,
										NULL,
										&iter_struct);
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_UINT32,
					  &(WTP[i]->WTPID));
		
		dbus_message_iter_append_basic(&iter_struct,
					  DBUS_TYPE_STRING,
					  &sn);
			
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_STRING,
					  &(WTP[i]->WTPNAME));
			
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_STRING,
					  &(WTP[i]->WTPModel));
		
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WTP[i]->RadioCount));
		
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_UINT32,
					  &(WTP[i]->WFR_Index));
		
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WTP[i]->WTPStat));
		
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WTP[i]->CTR_ID));
		
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WTP[i]->DAT_ID));
		
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WTP[i]->isused));

		dbus_message_iter_close_container (&iter_array, &iter_struct);


	}
				
	dbus_message_iter_close_container (&iter, &iter_array);
				
	CW_FREE_OBJECT_WID(WTP);
	CW_FREE_OBJECT_WID(sn);
	return reply;	
}
/*nl add for showing wtp basic information table 1*/
DBusMessage * wid_dbus_interface_show_wtp_basic_information(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply = NULL;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusMessageIter iter_struct;
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int num=0;
	time_t time1;
	time_t *now_time = NULL;
	unsigned int checktimes = 0;
	int i=0;
	unsigned char *mac = NULL;
	char *location =NULL;
	char *no_info = "none";
	
	WID_WTP **WTP = NULL;
	wid_code_infomation *model_info = NULL;

	char *sn = NULL;

	wid_syslog_debug_debug(WID_DBUS,"call %s\n", __FUNCTION__);
	
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	if (!sn) {
		wid_syslog_err("malloc for sn failed\n");
		return NULL;
	}
	char *longitude=NULL;
	char *latitude=NULL;
	char *manufacture_date=NULL;
	
	longitude = WID_MALLOC(LONGITUDE_LATITUDE_MAX_LEN);
	if (!longitude) {
		wid_syslog_err("malloc for longitude failed\n");
		goto free_sn;
	}
	
	latitude = WID_MALLOC(LONGITUDE_LATITUDE_MAX_LEN);
	if (!latitude) {
		wid_syslog_err("malloc for latitude failed\n");
		goto free_longitude;
	}
	
	manufacture_date = WID_MALLOC(MANUFACTURE_DATA_MAX_LEN);
	if (!manufacture_date) {
		wid_syslog_err("malloc for manufacture_date failed\n");
		goto free_latitude;
	}
	
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	if (!WTP) {
		wid_syslog_err("malloc for WTP failed\n");
		goto free_manufacture_date;
	}
	
	memset(WTP,0,WTP_NUM*(sizeof(WID_WTP *)));
	location = (char *)WID_MALLOC(7+1);
	if (!location) {
		wid_syslog_err("malloc for location failed\n");
		goto free_WTP;
	}
	
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	if (!mac) {
		wid_syslog_err("malloc for mac failed\n");
		goto free_location;
	}
	
	num = Wid_Find_Wtp(WTP);
	
	if(num == 0)
		ret = WTP_ID_NOT_EXIST;
	
	model_info = (wid_code_infomation *)WID_MALLOC(sizeof(wid_code_infomation));
	if (!model_info) {
		wid_syslog_err("malloc for model_info failed\n");
		goto free_mac;
	}
	memset(model_info,0,sizeof(wid_code_infomation));
	/*for store HW supplier and SW supplier of AP*/
	char Enterprise_name[] = "/devinfo/enterprise_name";
	char name[DEFAULT_LEN]={0};
	memset(name,0,DEFAULT_LEN);
	
	if(read_ac_info(Enterprise_name,name) == 1){
		memcpy(name,"Autelan",7);
	}

	model_info->sw_supplier = (char *)WID_MALLOC(strlen(name)+1);
	if (!model_info->sw_supplier) {
		wid_syslog_err("malloc for model_info->sw_supplier failed\n");
		goto free_model_info;
	}
	memset(model_info->sw_supplier,0,strlen(name)+1);	
	memcpy(model_info->sw_supplier,name,strlen(name));

	model_info->supplier = (char *)WID_MALLOC(strlen(name)+1);
	if (!model_info->supplier) {
		wid_syslog_err("malloc for model_info->supplier failed\n");
		goto free_sw_supplier;
	}
	memset(model_info->supplier,0,strlen(name)+1);	
	memcpy(model_info->supplier,name,strlen(name));

	//model_info->hw_version = (char *)WID_MALLOC(8);
	
	/*store sn&mac of ap*/
	
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	// Total slot count
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);

	if(num != 0)
	{
    	dbus_message_iter_open_container (&iter,
    									DBUS_TYPE_ARRAY,
    									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING
    											DBUS_TYPE_STRING_AS_STRING
    											DBUS_TYPE_STRING_AS_STRING
    											DBUS_TYPE_STRING_AS_STRING
    											DBUS_TYPE_STRING_AS_STRING
    											DBUS_TYPE_STRING_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING				//ElectrifyRegisterCircle
    											DBUS_TYPE_UINT32_AS_STRING				//checktimes
    											DBUS_TYPE_STRING_AS_STRING
    											DBUS_TYPE_STRING_AS_STRING
    											DBUS_TYPE_STRING_AS_STRING
    											DBUS_TYPE_STRING_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_STRING_AS_STRING
    											DBUS_TYPE_STRING_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_STRING_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											
    									DBUS_STRUCT_END_CHAR_AS_STRING,
    									&iter_array);

    	for(i = 0; i < num; i++){			
			checktimes = 0;
    		memset(sn,0,NAS_IDENTIFIER_NAME);
    		if(strlen(WTP[i]->WTPSN) < NAS_IDENTIFIER_NAME)
    			memcpy(sn,WTP[i]->WTPSN,strlen(WTP[i]->WTPSN));
    		else
    			memcpy(sn,WTP[i]->WTPSN,NAS_IDENTIFIER_NAME-1);

			wid_syslog_debug_debug(WID_DBUS,"1111111111111111111\n");
			
			memset(longitude, '\0', LONGITUDE_LATITUDE_MAX_LEN);
			if(strlen((char *)(WTP[i]->longitude)) < LONGITUDE_LATITUDE_MAX_LEN) {
				if (strlen((char *)(WTP[i]->longitude)) == 0) {
					memcpy(longitude, "unknown", strlen("nknown"));
				} else {
					memcpy(longitude, (char *)WTP[i]->longitude, strlen((char *)WTP[i]->longitude));
				}
			} else {
				memcpy(longitude, (char *)WTP[i]->longitude, LONGITUDE_LATITUDE_MAX_LEN-1);
			}

			memset(latitude, '\0', LONGITUDE_LATITUDE_MAX_LEN);
			if(strlen((char *)(WTP[i]->latitude)) < LONGITUDE_LATITUDE_MAX_LEN) {
				if (strlen((char *)(WTP[i]->latitude)) == 0) {
					memcpy(latitude, "unknown", strlen("nknown"));
				} else {
					memcpy(latitude, (char *)WTP[i]->latitude, strlen((char *)WTP[i]->latitude));
				}
			} else {
				memcpy(latitude, (char *)WTP[i]->latitude, LONGITUDE_LATITUDE_MAX_LEN-1);
			}

			memset(manufacture_date, '\0', MANUFACTURE_DATA_MAX_LEN);
			if(strlen((char *)(WTP[i]->manufacture_date)) < MANUFACTURE_DATA_MAX_LEN) {
				if (strlen((char *)(WTP[i]->manufacture_date)) == 0) {
					memcpy(manufacture_date, "unknown", strlen("nknown"));
				} else {
					memcpy(manufacture_date, (char *)WTP[i]->manufacture_date, strlen((char *)WTP[i]->manufacture_date));
				}
			} else {
				memcpy(manufacture_date, (char *)WTP[i]->manufacture_date, MANUFACTURE_DATA_MAX_LEN-1);
			}

			
			memset(mac,0,MAC_LEN+1);
    		if(WTP[i]->WTPMAC != NULL)
    			memcpy(mac,WTP[i]->WTPMAC,MAC_LEN);
    		
    		if(WTP[i]->add_time == NULL)
    		{
    			time1 = 0;
				if((WTP[i] != NULL)&&(WTP[i]->WTPStat != 5))
				{
					if(now_time == NULL)
					{
						now_time = (time_t*)WID_MALLOC(sizeof(time_t));
						time(now_time);
					}
					else
					{
						time(now_time);
					}
				}
    		}
			else if(0 == *WTP[i]->add_time)
			{
				time1 = *WTP[i]->add_time;
				if(now_time == NULL)
				{
					now_time = (time_t*)WID_MALLOC(sizeof(time_t));
					time(now_time);
				}
				else
					time(now_time);
			}
    		else
    			time1 = *WTP[i]->add_time;
    		//checktimes
    		if((WTP[i]->quit_time)&&(*WTP[i]->quit_time > 0)&&(WTP[i]->add_time)&&(*WTP[i]->add_time > 0))
    		{
    			if(*WTP[i]->add_time> *WTP[i]->quit_time)
    			{
    				if(((*WTP[i]->add_time- *WTP[i]->quit_time)%gCheckRequestTimer) == 0)
    				{
    					checktimes = (*WTP[i]->add_time- *WTP[i]->quit_time)/gCheckRequestTimer - 1;
    				}
					else
					{
						checktimes = (*WTP[i]->add_time- *WTP[i]->quit_time)/gCheckRequestTimer;
					}
    			}
				else
					checktimes = 0;
    		}
			else if((WTP[i]->quit_time)&&(*WTP[i]->quit_time > 0)&&(now_time)&&(*now_time >0))
			{
				if(*now_time > *WTP[i]->quit_time)
				{
					if((*now_time - *WTP[i]->quit_time)%gCheckRequestTimer == 0)
					{
						checktimes = (*now_time - *WTP[i]->quit_time)/gCheckRequestTimer - 1;
					}
					else
					{
						checktimes = (*now_time - *WTP[i]->quit_time)/gCheckRequestTimer;
					}
				}
			}
			else
			{
				checktimes = 0;
			}
    		dbus_message_iter_open_container (&iter_array,
    										DBUS_TYPE_STRUCT,
    										NULL,
    										&iter_struct);
    		dbus_message_iter_append_basic
    					(&iter_struct,
    					  DBUS_TYPE_UINT32,
    					  &(WTP[i]->WTPID));

    		dbus_message_iter_append_basic
    					(&iter_struct,
    					DBUS_TYPE_STRING,&sn);
    			
    		dbus_message_iter_append_basic
    					(&iter_struct,
    					  DBUS_TYPE_STRING,
    					  &(WTP[i]->WTPNAME));
    			
    		dbus_message_iter_append_basic
    					(&iter_struct,
    					  DBUS_TYPE_STRING,
    					  &(WTP[i]->WTPModel));
    		
    		dbus_message_iter_append_basic
    					(&iter_struct,
    					  DBUS_TYPE_STRING,
    					  &(model_info->supplier));
    		
    		dbus_message_iter_append_basic
    					(&iter_struct,
    					  DBUS_TYPE_STRING,
    					  &(model_info->sw_supplier));
    		
    		dbus_message_iter_append_basic
    					(&iter_struct,
    					  DBUS_TYPE_UINT32,
    					  &time1);

    		dbus_message_iter_append_basic
    					(&iter_struct, 
    					  DBUS_TYPE_UINT32, 
    					  &WTP[i]->ElectrifyRegisterCircle);
    		dbus_message_iter_append_basic
    					(&iter_struct,
    					  DBUS_TYPE_UINT32,
    					  &checktimes);

    		if(WTP[i]->location == NULL)
    		{
    			memset(location,0,7+1);
    			memcpy(location,"Not set",7);
    			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_STRING, &(location));
    		}
    		else 
    			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_STRING, &(WTP[i]->location));
    		
    		CWThreadMutexLock(&(gAllThreadMutex));		
    	//	CWConfigVersionInfo *pnode = gConfigVersionInfo;
			CWConfigVersionInfo_new *pnode = gConfigVerInfo;

    		while(pnode != NULL)
    		{
    			if(strcmp(pnode->str_ap_model,WTP[i]->WTPModel) == 0)
    			{
    				break;
    			}
    			pnode = pnode->next;
    		}	
    		CWThreadMutexUnlock(&(gAllThreadMutex));		

    		if(pnode == NULL){
    			wid_syslog_debug_debug(WID_DBUS," 55555555555\n");

    			model_info->sw_name = (char *)WID_MALLOC(8);
    			memset(model_info->sw_name,0,8);		
    			memcpy(model_info->sw_name,"NULL",4);	
    		} else {
    			CWCodeInfo *code_node = pnode->code_info;
				while(code_node != NULL)
				{
					if((WTP[i]->APCode != NULL)&&(code_node->str_ap_version_code != NULL)&&(strcmp(code_node->str_ap_version_code,WTP[i]->APCode) == 0))
					{
						model_info->sw_name = (char *)WID_MALLOC(strlen(code_node->str_ap_version_path)+1);
						memset(model_info->sw_name,0,strlen(code_node->str_ap_version_path)+1);		
						memcpy(model_info->sw_name,code_node->str_ap_version_path,strlen(code_node->str_ap_version_path));			
						break;
					}
					code_node = code_node->next;
				}	
				if(model_info->sw_name == NULL){
					model_info->sw_name = (char *)WID_MALLOC(8);
					memset(model_info->sw_name,0,8);		
					memcpy(model_info->sw_name,"NULL",4);	
				}
    		}
    		

    		if(WTP[i]->sysver == NULL){
    			dbus_message_iter_append_basic (&iter_struct,
    											 DBUS_TYPE_STRING,
    											 &(no_info));
    		}else{
    			dbus_message_iter_append_basic (&iter_struct,
    											 DBUS_TYPE_STRING,
    											 &(WTP[i]->sysver));
    		}
    		
    		if(WTP[i]->ver == NULL){
    			dbus_message_iter_append_basic (&iter_struct,
    											 DBUS_TYPE_STRING,
    											 &(no_info));
    		}else{
    			dbus_message_iter_append_basic (&iter_struct,
    											 DBUS_TYPE_STRING,
    											 &(WTP[i]->ver));
    		}
    				
    		dbus_message_iter_append_basic
    							(&iter_struct,
    							 DBUS_TYPE_STRING,
    							&(model_info->sw_name));
    		
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[0]));
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[1]));
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[2]));
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[3]));
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[4]));
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[5]));

			//wid_syslog_debug_debug(WID_DBUS,"longitude =%s\n", WTP[i]->longitude);
			wid_syslog_debug_debug(WID_DBUS,"longitudesssssssssss =%s\n", longitude);
    		dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_STRING, &longitude);
			
			wid_syslog_debug_debug(WID_DBUS,"latitude =%s\n",  latitude);
			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_STRING, &latitude);

			wid_syslog_debug_debug(WID_DBUS,"power_mode =%d\n", WTP[i]->power_mode);
			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_BYTE, &WTP[i]->power_mode);

			wid_syslog_debug_debug(WID_DBUS,"manufacture_date =%s\n", manufacture_date);
			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_STRING, &manufacture_date);

			wid_syslog_debug_debug(WID_DBUS,"forward_mode =%d\n", WTP[i]->forward_mode);
			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_BYTE, &WTP[i]->forward_mode);
			
			
    		dbus_message_iter_close_container (&iter_array, &iter_struct);
		
    		CW_FREE_OBJECT_WID(model_info->sw_name);
			CW_FREE_OBJECT_WID(now_time);
    		//CW_FREE_OBJECT(model_info->sw_version);
    	}
    				
    	dbus_message_iter_close_container (&iter, &iter_array);
	}

	CW_FREE_OBJECT_WID(model_info->supplier);
free_sw_supplier:
	CW_FREE_OBJECT_WID(model_info->sw_supplier);
free_model_info:
	CW_FREE_OBJECT_WID(model_info);
free_mac:
	CW_FREE_OBJECT_WID(mac);
free_location:
	CW_FREE_OBJECT_WID(location);
free_WTP:
	CW_FREE_OBJECT_WID(WTP);
free_manufacture_date:
	CW_FREE_OBJECT_WID(manufacture_date);
free_latitude:
	CW_FREE_OBJECT_WID(latitude);
free_longitude:
	CW_FREE_OBJECT_WID(longitude);
free_sn:
	CW_FREE_OBJECT_WID(sn);
	return reply;	
}
/*for showing wtp collect information table 3*/
DBusMessage * wid_dbus_interface_show_wtp_collect_information(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusMessageIter iter_struct;
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	
	int ehcotimer = 10;	
	ehcotimer = gEchoRequestTimer;
	unsigned int num = 0;
	int i=0, k=0;
	//int radiocount;
	unsigned long long rx_bts =0;
	unsigned long long tx_bts =0;
	unsigned char *mac = NULL;
	WID_WTP **WTP = NULL;
	
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	memset(WTP,0,WTP_NUM*(sizeof(WID_WTP *)));
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	
	if(hide_quit_wtp_in_showting == 0){
		num = Wid_Find_Wtp(WTP);
	}
	else if (hide_quit_wtp_in_showting == 1){
		num = Wid_Find_Running_Wtp(WTP);
	}
	
	if(num == 0)
		ret = WTP_ID_NOT_EXIST;
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	// Total slot count
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);

    if(num != 0)
    {
    	dbus_message_iter_open_container (&iter,
    									DBUS_TYPE_ARRAY,
    									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING
    											
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING
    											DBUS_TYPE_UINT64_AS_STRING
    											DBUS_TYPE_UINT64_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING		//moment_infor_report_switch
    									DBUS_STRUCT_END_CHAR_AS_STRING,
    									&iter_array);

    	for(i = 0; i < num; i++){	
    		rx_bts =0;
    		tx_bts =0;
    		
    		memset(mac,0,MAC_LEN+1);
    		if(WTP[i]->WTPMAC != NULL)
    			memcpy(mac,WTP[i]->WTPMAC,MAC_LEN);
    		
    		if(WTP[i] != NULL)
    			ehcotimer = WTP[i]->EchoTimer;
    		
    		for(k=0; k<TOTAL_AP_IF_NUM; k++){
    			if((WTP[i]->apstatsinfo[k].radioId < TOTAL_AP_IF_NUM+1)
    				&&(WTP[i]->apstatsinfo[k].type == 1)){
    				
    				tx_bts += WTP[i]->apstatsinfo[k].tx_bytes;
    				rx_bts += WTP[i]->apstatsinfo[k].rx_bytes;
    			}
    		}
    		
    		dbus_message_iter_open_container (&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_UINT32,&(WTP[i]->WTPID));
    		
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[0]));
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[1]));
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[2]));
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[3]));
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[4]));
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[5]));

    		dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_UINT32,&ehcotimer);
    		
    		dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_BYTE, &(WTP[i]->wifi_extension_info.memoryuse));
    		dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT32, &(WTP[i]->wifi_extension_info.rx_drop));
    		dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT32, &(WTP[i]->wifi_extension_info.cpu));

    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_UINT64,&tx_bts);
    		dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64,&rx_bts);	
    		dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_BYTE, &(WTP[i]->moment_infor_report_switch));
    			
    		dbus_message_iter_close_container (&iter_array, &iter_struct);
    	}
    				
    	dbus_message_iter_close_container (&iter, &iter_array);
    }
				
	CW_FREE_OBJECT_WID(WTP);
	CW_FREE_OBJECT_WID(mac);
	
	return reply;	
}
/*table 2*/
DBusMessage * wid_dbus_interface_show_wtp_para_information(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply = NULL;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusMessageIter iter_struct;
	DBusMessageIter	 iter_sub_array;
	DBusMessageIter iter_sub_struct;
	DBusMessageIter  iter_sub_sub_array;
	DBusMessageIter iter_sub_sub_struct;
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int wtp_num = 0;
	time_t add_time;		//xiaodawei add for telecom test, 20110302
	int i=0, j=0, k=0;
	int ii=0,jj=0/*,kk=0*/;
	//char *netid = NULL;
	char *wtp_name = "Not set";
	unsigned char *mac = NULL;
	WID_WTP **WTP = NULL;
	WID_WTP_RADIO	**AC_RADIO_FOR_SEARCH = NULL;
	unsigned char wtp_ipv6_ip_prifix = 128;
	char *wtp_ipv6_ip;
	wtp_ipv6_ip = WID_MALLOC(64);
	memset(wtp_ipv6_ip, '\0', 64);
	strncpy(wtp_ipv6_ip, "::/128", strlen("::/128"));
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	AC_RADIO_FOR_SEARCH = WID_MALLOC(L_RADIO_NUM*(sizeof(WID_WTP_RADIO *)));
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	memset(WTP,0,WTP_NUM*(sizeof(WID_WTP *)));
	
	wtp_num = Wid_Find_Wtp(WTP);
	
	if(wtp_num == 0)
		ret = WTP_ID_NOT_EXIST;

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	// Total slot count
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &wtp_num);

    if(wtp_num != 0)
    {
    	dbus_message_iter_open_container (&iter,
    									DBUS_TYPE_ARRAY,
    									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING		//wtpid

    											DBUS_TYPE_BYTE_AS_STRING		 //mac
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING		//mac

    											DBUS_TYPE_STRING_AS_STRING		//WTPModel
    											DBUS_TYPE_STRING_AS_STRING		//netid
    											DBUS_TYPE_BYTE_AS_STRING		//ipv6 prefix
    											DBUS_TYPE_UINT32_AS_STRING		//mask
    											DBUS_TYPE_UINT32_AS_STRING		//ap_gateway

    											DBUS_TYPE_BYTE_AS_STRING		//opstate
    											DBUS_TYPE_BYTE_AS_STRING		//dos_def_switch
    											DBUS_TYPE_BYTE_AS_STRING		//igmp_snoop_switch
    											DBUS_TYPE_UINT32_AS_STRING			//receiver_signal_level

    											DBUS_TYPE_BYTE_AS_STRING		//isused
    											DBUS_TYPE_BYTE_AS_STRING		//WTPStat
    											DBUS_TYPE_STRING_AS_STRING		//wtpip
    											DBUS_TYPE_STRING_AS_STRING		//wtp ipv6 ip
    											DBUS_TYPE_STRING_AS_STRING		//wtp name
    											DBUS_TYPE_UINT32_AS_STRING		//add_time, xiaodawei add for telecom test, 20110302
    											DBUS_TYPE_UINT32_AS_STRING		//ElectrifyRegisterCircle
    											DBUS_TYPE_UINT32_AS_STRING		//imagedata_time
    											DBUS_TYPE_UINT32_AS_STRING		//config_update_time, xiaodawei add for telecom test end
    									DBUS_STRUCT_END_CHAR_AS_STRING,
    									&iter_array);

    	for(i = 0; i < wtp_num; i++){		
    		memset(mac,0,MAC_LEN+1);
    		if(WTP[i]->WTPMAC != NULL)
    			memcpy(mac,WTP[i]->WTPMAC,MAC_LEN);
			//xiaodawei transplant from 2.0 for telecom test, 20110302
			if(WTP[i]->add_time == NULL)
			{
				add_time = 0;
			}
			else
			{
				add_time = *(WTP[i]->add_time);
			}//xiaodawei add , END
    		dbus_message_iter_open_container (&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_UINT32,&(WTP[i]->WTPID));
    		
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[0]));
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[1]));
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[2]));
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[3]));
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[4]));
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[5]));

    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&(WTP[i]->WTPModel));
    		
    		if(WTP[i]->netid != NULL)
    			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_STRING, &WTP[i]->netid);
    		else
    			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_STRING, &WTP[i]->netid);
			
			dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(wtp_ipv6_ip_prifix));
			
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_UINT32,&WTP[i]->ap_mask_new);
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_UINT32,&WTP[i]->ap_gateway);
    		dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_BYTE, &WTP[i]->WIDS.monitorMode);  //fengwenchao change "gapscanset.opstate" to WTP[i]->WIDS.monitorMode,20111122 for AXSSZFI-525  
    		
    		dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&WTP[i]->mib_info.dos_def_switch); 
    		dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&WTP[i]->mib_info.igmp_snoop_switch); 
    		dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT32, &receiver_signal_level);

    		dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->isused));
    		dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_BYTE,&(WTP[i]->WTPStat));
    		dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_STRING,&WTP[i]->WTPIP);
			
			dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_STRING,&wtp_ipv6_ip);
    		
    		if(WTP[i]->WTPNAME == NULL){
    			dbus_message_iter_append_basic (&iter_struct,
    										DBUS_TYPE_STRING,
    										&wtp_name);
    		}
    		else{
    			dbus_message_iter_append_basic (&iter_struct,
    										DBUS_TYPE_STRING,
    										&WTP[i]->WTPNAME);
			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT32, &add_time);						//xiaodawei add for telecom test , 20110302
    		dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT32, &WTP[i]->ElectrifyRegisterCircle);
    		dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT32, &WTP[i]->imagedata_time);
			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT32, &WTP[i]->config_update_time);	//xiaodawei add for telecom test,END
    		}
    		dbus_message_iter_close_container (&iter_array, &iter_struct);
    	}
    	dbus_message_iter_close_container (&iter, &iter_array);

    /*for sending ssid*/
    	dbus_message_iter_append_basic (&iter,
    										 DBUS_TYPE_UINT32,
    										 &wtp_num);

    	dbus_message_iter_open_container (&iter,
    										DBUS_TYPE_ARRAY,
    										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
    												DBUS_TYPE_BYTE_AS_STRING		//a num_of_radio
    												DBUS_TYPE_UINT32_AS_STRING		//a wtp id
    										DBUS_TYPE_BYTE_AS_STRING		//eth_num
    												DBUS_TYPE_ARRAY_AS_STRING
    												DBUS_STRUCT_BEGIN_CHAR_AS_STRING
    													DBUS_TYPE_BYTE_AS_STRING		//radio bss num
    														DBUS_TYPE_ARRAY_AS_STRING			
    														DBUS_STRUCT_BEGIN_CHAR_AS_STRING
    															DBUS_TYPE_BYTE_AS_STRING		 //mac 1
    															DBUS_TYPE_BYTE_AS_STRING
    															DBUS_TYPE_BYTE_AS_STRING
    															DBUS_TYPE_BYTE_AS_STRING
    															DBUS_TYPE_BYTE_AS_STRING
    															DBUS_TYPE_BYTE_AS_STRING		//mac 6
    														DBUS_STRUCT_END_CHAR_AS_STRING
    												DBUS_STRUCT_END_CHAR_AS_STRING
    										DBUS_STRUCT_END_CHAR_AS_STRING,
    										&iter_array);

    	for(i = 0; i < wtp_num; i++){	
    		WID_BSS *BSS[L_BSS_NUM] = {NULL};
    		unsigned int g_radio_id = 0;
    		unsigned char num_of_radio = 0;
//    		unsigned char ap_eth_num = 0;
    		memset(AC_RADIO_FOR_SEARCH,0,L_RADIO_NUM*(sizeof(WID_WTP_RADIO *)));
    		
    		for(jj = 0;jj<L_RADIO_NUM;jj++){
    			if(WTP[i]->WTP_Radio[jj] != NULL){
    				g_radio_id = WTP[i]->WTP_Radio[jj]->Radio_G_ID;
    				AC_RADIO_FOR_SEARCH[num_of_radio] = AC_RADIO[g_radio_id];
    				num_of_radio ++;
    			}
    		}
    		
    		dbus_message_iter_open_container (&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
    		dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_BYTE,&num_of_radio);
    		
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_UINT32,&(WTP[i]->WTPID));
    		dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_BYTE, &(WTP[i]->apifinfo.eth_num));

    		dbus_message_iter_open_container (&iter_struct,
    											   DBUS_TYPE_ARRAY,
    											  	 	DBUS_STRUCT_BEGIN_CHAR_AS_STRING
    													    DBUS_TYPE_BYTE_AS_STRING		//radio_bss_num
    													    DBUS_TYPE_ARRAY_AS_STRING
    														DBUS_STRUCT_BEGIN_CHAR_AS_STRING
    															DBUS_TYPE_BYTE_AS_STRING
    															DBUS_TYPE_BYTE_AS_STRING
    															DBUS_TYPE_BYTE_AS_STRING
    															DBUS_TYPE_BYTE_AS_STRING
    															DBUS_TYPE_BYTE_AS_STRING
    															DBUS_TYPE_BYTE_AS_STRING
    														DBUS_STRUCT_END_CHAR_AS_STRING
    												DBUS_STRUCT_END_CHAR_AS_STRING,
    											   &iter_sub_array);

    		for (j=0;j<num_of_radio;j++){
    			unsigned char radio_bss_num =0;
    			for(k=0;k<L_BSS_NUM;k++){
    				if((AC_RADIO_FOR_SEARCH[j]->BSS[k] != NULL)&&(AC_RADIO_FOR_SEARCH[j]->BSS[k]->BSSID != NULL)){
    					BSS[radio_bss_num] = AC_RADIO_FOR_SEARCH[j]->BSS[k];
    					radio_bss_num++;
    				}
    			}

    			dbus_message_iter_open_container (&iter_sub_array,DBUS_TYPE_STRUCT,NULL,&iter_sub_struct);

    			dbus_message_iter_append_basic(&iter_sub_struct, DBUS_TYPE_BYTE,&radio_bss_num);

    			dbus_message_iter_open_container (&iter_sub_struct,
    													DBUS_TYPE_ARRAY,
    													DBUS_STRUCT_BEGIN_CHAR_AS_STRING
    														DBUS_TYPE_BYTE_AS_STRING
    														DBUS_TYPE_BYTE_AS_STRING
    														DBUS_TYPE_BYTE_AS_STRING
    														DBUS_TYPE_BYTE_AS_STRING
    														DBUS_TYPE_BYTE_AS_STRING
    														DBUS_TYPE_BYTE_AS_STRING
    													DBUS_STRUCT_END_CHAR_AS_STRING,
    													&iter_sub_sub_array);

    			for(ii=0;ii<radio_bss_num;ii++){
    				dbus_message_iter_open_container (&iter_sub_sub_array,DBUS_TYPE_STRUCT,NULL,&iter_sub_sub_struct);

    				dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_BYTE,&(BSS[ii]->BSSID[0]));
    				dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_BYTE,&(BSS[ii]->BSSID[1]));
    				dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_BYTE,&(BSS[ii]->BSSID[2]));
    				dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_BYTE,&(BSS[ii]->BSSID[3]));
    				dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_BYTE,&(BSS[ii]->BSSID[4]));
    				dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_BYTE,&(BSS[ii]->BSSID[5]));
    				
    				dbus_message_iter_close_container (&iter_sub_sub_array, &iter_sub_sub_struct);
    			}
    			dbus_message_iter_close_container (&iter_sub_struct, &iter_sub_sub_array);
    			dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);
    		}
    		dbus_message_iter_close_container (&iter_struct, &iter_sub_array);
    		dbus_message_iter_close_container (&iter_array, &iter_struct);
    	}
    	dbus_message_iter_close_container (&iter, &iter_array);
    }

	CW_FREE_OBJECT_WID(WTP);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(AC_RADIO_FOR_SEARCH);

	return reply;	
}
/*table 4*/
#if 0
/* book modify, 2011-1-25 */
DBusMessage * wid_dbus_interface_show_wtp_wireless_ifstats_information(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusMessageIter iter_sub_array;
	DBusMessageIter iter_struct;
	DBusMessageIter iter_sub_struct;
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int wtp_num = 0;
	int i=0,j=0,k=0;
	int ii=0/*,jj=0*/;
	unsigned char 	wtp_radiocount = 0;
	unsigned int 	wtp_rx_packets = 0;
	unsigned int	wtp_tx_packets = 0;
	unsigned int	wtp_tx_errors = 0;
	unsigned long long	wtp_rx_bytes = 0;
	unsigned long long 	wtp_tx_bytes = 0;
	unsigned int	wtp_ast_rx_crcerr = 0;
	unsigned int	wtp_ast_rx_badcrypt = 0;
	unsigned int	wtp_ast_rx_badmic = 0;
	unsigned int	wtp_ast_rx_phyerr = 0;
	//unsigned long tx_pkt_mgmt = 0;
	//unsigned long rx_pkt_mgmt = 0;
	//unsigned long tx_pkt_retry = 0;
	//unsigned long tx_total_pkt_retry = 0;

	unsigned int rx_pkt_unicast = 0;
	unsigned int tx_pkt_unicast = 0;
	unsigned int rx_pkt_multicast = 0;
	unsigned int tx_pkt_multicast = 0;
	
	unsigned char wtp_ath_updown_times = 0;
	unsigned char default_char_value = 0;
//	unsigned int default_int_value = 0;
	double defalt_double_value = 0;
	unsigned int  default_wtpid = 0;
	char *default_essid = "none";
	struct Neighbor_AP_ELE *phead = NULL;   //fengwenchao add 20110521
	int neighbor_ap_count = 0;     //fengwenchao add 20110521
	
	WID_WTP **WTP = NULL;
	WID_WTP_RADIO	**AC_RADIO_FOR_SEARCH = NULL;
	unsigned char *mac = NULL;
	
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	AC_RADIO_FOR_SEARCH = WID_MALLOC(L_RADIO_NUM*(sizeof(WID_WTP_RADIO *)));
	memset(WTP,0,WTP_NUM*(sizeof(WID_WTP *)));

	if(hide_quit_wtp_in_showting == 0){
		wtp_num = Wid_Find_Wtp(WTP);
	}
	else if (hide_quit_wtp_in_showting == 1){
		wtp_num = Wid_Find_Running_Wtp(WTP);
	}
	
	if(wtp_num == 0)
		ret = WTP_ID_NOT_EXIST;
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);

	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &wtp_num);

    if(wtp_num != 0)
    {
    	dbus_message_iter_open_container (&iter,
    									DBUS_TYPE_ARRAY,
    									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING

    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING

    											DBUS_TYPE_BYTE_AS_STRING			//wifi_info_switch
    											//qiuchen copy from v1.3
    											/*DBUS_TYPE_BYTE_AS_STRING			//snr_max
    											DBUS_TYPE_BYTE_AS_STRING			//snr_min
    											DBUS_TYPE_BYTE_AS_STRING			//snr_average
    											DBUS_TYPE_DOUBLE_AS_STRING			//snr_math_average
    											DBUS_TYPE_BYTE_AS_STRING	*/		//snr_index

    											DBUS_TYPE_UINT32_AS_STRING			//s1
    											DBUS_TYPE_UINT32_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING
    											
    											DBUS_TYPE_UINT64_AS_STRING			//wtp_rx_bytes
    											DBUS_TYPE_UINT64_AS_STRING			//wtp_tx_bytes
    											DBUS_TYPE_UINT32_AS_STRING
    											
    											DBUS_TYPE_UINT32_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING			//s9
    											
    											/*fengwenchao add 20110521*/
											DBUS_TYPE_UINT32_AS_STRING      // roge_num
											DBUS_TYPE_ARRAY_AS_STRING
		    									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
		    											DBUS_TYPE_UINT32_AS_STRING    //neighbor wtpid

													DBUS_TYPE_ARRAY_AS_STRING
													DBUS_STRUCT_BEGIN_CHAR_AS_STRING
														DBUS_TYPE_BYTE_AS_STRING         //neighbor essid
													DBUS_STRUCT_END_CHAR_AS_STRING
											DBUS_STRUCT_END_CHAR_AS_STRING
											/*fengwenchao add end*/
    											//DBUS_TYPE_BYTE_AS_STRING		//extention information switch
    											DBUS_TYPE_BYTE_AS_STRING		//wtp_radio_num
    												DBUS_TYPE_ARRAY_AS_STRING
    														DBUS_STRUCT_BEGIN_CHAR_AS_STRING
    														
    															DBUS_TYPE_BYTE_AS_STRING
    															DBUS_TYPE_BYTE_AS_STRING

    													DBUS_TYPE_UINT32_AS_STRING		//rx_pkt_unicast
    													DBUS_TYPE_UINT32_AS_STRING		//tx_pkt_unicast
    													DBUS_TYPE_UINT32_AS_STRING		//rx_pkt_multicast
    													DBUS_TYPE_UINT32_AS_STRING		//tx_pkt_multicast

    															DBUS_TYPE_UINT32_AS_STRING		//c1
    															DBUS_TYPE_UINT32_AS_STRING
    															DBUS_TYPE_UINT32_AS_STRING		//sub_tx_errors
    															DBUS_TYPE_UINT32_AS_STRING		//sub_rx_errors
    															DBUS_TYPE_UINT32_AS_STRING		//sub_tx_drops
    															DBUS_TYPE_UINT32_AS_STRING		//sub_rx_drops
    															DBUS_TYPE_UINT64_AS_STRING
    															DBUS_TYPE_UINT64_AS_STRING
    															DBUS_TYPE_UINT32_AS_STRING
    															DBUS_TYPE_UINT32_AS_STRING
    															DBUS_TYPE_UINT32_AS_STRING
    															DBUS_TYPE_UINT32_AS_STRING		//c9
    													DBUS_TYPE_BYTE_AS_STRING		//snr cur	
    													DBUS_TYPE_BYTE_AS_STRING
    													DBUS_TYPE_BYTE_AS_STRING
    													DBUS_TYPE_DOUBLE_AS_STRING		//snr aver
    													/*add for new mgmt infor requrement 20100809 */
    													DBUS_TYPE_UINT32_AS_STRING		//sub_rx_pkt_mgmt
    													DBUS_TYPE_UINT32_AS_STRING		//sub_tx_pkt_mgmt
    													DBUS_TYPE_UINT64_AS_STRING		//sub_rx_mgmt
    													DBUS_TYPE_UINT64_AS_STRING		//sub_tx_mgmt
    													DBUS_TYPE_UINT64_AS_STRING		//sub_total_rx_bytes
    													DBUS_TYPE_UINT64_AS_STRING		//sub_total_tx_bytes
    													DBUS_TYPE_UINT64_AS_STRING		//sub_total_rx_pkt
    													DBUS_TYPE_UINT64_AS_STRING		//sub_total_tx_pkt
													DBUS_TYPE_UINT32_AS_STRING		//tx_pkt_control zhangshu add 2010-10-09
													DBUS_TYPE_UINT32_AS_STRING		//rx_pkt_control
													DBUS_TYPE_UINT32_AS_STRING      //tx_signal_pkts
													DBUS_TYPE_UINT32_AS_STRING      //rx_signal_pkts
    													DBUS_TYPE_UINT32_AS_STRING		//sub_tx_pkt_control zhangshu add
    													DBUS_TYPE_UINT32_AS_STRING		//sub_rx_pkt_control
    													DBUS_TYPE_UINT32_AS_STRING     //rx_data_pkts    fengwenchao add 20110617
    													DBUS_TYPE_UINT32_AS_STRING     //tx_data_pkts    fengwenchao add 20110617
    												DBUS_STRUCT_END_CHAR_AS_STRING
    									DBUS_STRUCT_END_CHAR_AS_STRING,
    									&iter_array);

    	for(i = 0; i < wtp_num; i++){		
    		unsigned char num_of_radio = 0;
    		wtp_rx_packets = 0;
    		wtp_tx_packets = 0;
    		wtp_tx_errors = 0;
    		wtp_rx_bytes = 0;
    		wtp_tx_bytes = 0;
    		wtp_ast_rx_crcerr = 0;
    		wtp_ast_rx_badcrypt = 0;
    		wtp_ast_rx_badmic = 0;
    		wtp_ast_rx_phyerr = 0;
			//tx_pkt_mgmt = 0;
			//rx_pkt_mgmt = 0;
			//tx_pkt_retry = 0;
			//tx_total_pkt_retry = 0;
    		wtp_radiocount = 0;
    		
    		memset(mac,0,MAC_LEN+1);
    		if(WTP[i]->WTPMAC != NULL)
    			memcpy(mac,WTP[i]->WTPMAC,MAC_LEN);
    		memset(AC_RADIO_FOR_SEARCH,0,L_RADIO_NUM*(sizeof(WID_WTP_RADIO *)));
    		num_of_radio = WID_WTP_FIND_RADIO(AC_RADIO_FOR_SEARCH,WTP[i]);

    		for(j=0; j<TOTAL_AP_IF_NUM; j++){
    			if((WTP[i]->apstatsinfo[j].radioId < TOTAL_AP_IF_NUM+1)
    				&&(WTP[i]->apstatsinfo[j].type == 2)){
    				
    				wtp_radiocount++;
				if(wirelessdata_switch)
				{
					wtp_rx_packets += (WTP[i]->apstatsinfo[j].rx_pkt_data > WTP[i]->apstatsinfo[j].rx_pkt_multicast)?
										(WTP[i]->apstatsinfo[j].rx_pkt_data - WTP[i]->apstatsinfo[j].rx_pkt_multicast):
										(WTP[i]->apstatsinfo[j].rx_pkt_multicast - WTP[i]->apstatsinfo[j].rx_pkt_data);
										
					wtp_tx_packets += (WTP[i]->apstatsinfo[j].tx_pkt_data > WTP[i]->apstatsinfo[j].tx_pkt_multicast)?
										(WTP[i]->apstatsinfo[j].tx_pkt_data - WTP[i]->apstatsinfo[j].tx_pkt_multicast):
										(WTP[i]->apstatsinfo[j].tx_pkt_multicast - WTP[i]->apstatsinfo[j].tx_pkt_data);
										
					wtp_rx_bytes += (WTP[i]->apstatsinfo[j].rx_bytes > WTP[i]->apstatsinfo[j].rx_multicast)?
										(WTP[i]->apstatsinfo[j].rx_bytes - WTP[i]->apstatsinfo[j].rx_multicast):
										(WTP[i]->apstatsinfo[j].rx_multicast - WTP[i]->apstatsinfo[j].rx_bytes);
										
					wtp_tx_bytes += (WTP[i]->apstatsinfo[j].tx_bytes > WTP[i]->apstatsinfo[j].tx_multicast)?
										(WTP[i]->apstatsinfo[j].tx_bytes - WTP[i]->apstatsinfo[j].tx_multicast):
										(WTP[i]->apstatsinfo[j].tx_multicast - WTP[i]->apstatsinfo[j].tx_bytes);
				}
				else
				{
					wtp_rx_packets += WTP[i]->apstatsinfo[j].rx_pkt_data;
					wtp_tx_packets += WTP[i]->apstatsinfo[j].tx_pkt_data;
					wtp_rx_bytes += WTP[i]->apstatsinfo[j].rx_bytes;
					wtp_tx_bytes += WTP[i]->apstatsinfo[j].tx_bytes;
				}
    				//wtp_rx_packets += WTP[i]->apstatsinfo[j].rx_pkt_data;//book modify,2011-1-20
    				//wtp_tx_packets += WTP[i]->apstatsinfo[j].tx_pkt_data;//book modify,2011-1-20
    				wtp_tx_errors += WTP[i]->apstatsinfo[j].tx_errors;
    				//wtp_rx_bytes += WTP[i]->apstatsinfo[j].rx_bytes;
    				//wtp_tx_bytes += WTP[i]->apstatsinfo[j].tx_bytes;
    				wtp_ast_rx_crcerr += WTP[i]->apstatsinfo[j].ast_rx_crcerr;
    				wtp_ast_rx_badcrypt += WTP[i]->apstatsinfo[j].ast_rx_badcrypt;
    				wtp_ast_rx_badmic += WTP[i]->apstatsinfo[j].ast_rx_badmic;
    				wtp_ast_rx_phyerr += WTP[i]->apstatsinfo[j].ast_rx_phyerr;

					//tx_pkt_mgmt += WTP[i]->apstatsinfo[j].tx_pkt_mgmt;		//xiaodawei add, 20110421
					//rx_pkt_mgmt += WTP[i]->apstatsinfo[j].rx_pkt_mgmt;
					//tx_pkt_retry += WTP[i]->apstatsinfo[j].tx_pkt_retry;//ap reports total retry pkts, used for data pkts
					//tx_total_pkt_retry += WTP[i]->apstatsinfo[j].tx_pkt_retry*103/100;			//retry pkts * 103%
    			}
    		}
    		
    		dbus_message_iter_open_container (&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
    		
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_UINT32,&(WTP[i]->WTPID));
    			
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[0]));
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[1]));
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[2]));
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[3]));
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[4]));
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[5]));

    		dbus_message_iter_append_basic (&iter_struct,
    											DBUS_TYPE_BYTE,
    											&WTP[i]->wifi_extension_reportswitch); 
			//qiuchen copy from v1.3
			/*
    		if(WTP[i]->wifi_extension_reportswitch == 0){
    			dbus_message_iter_append_basic (&iter_struct,
    											DBUS_TYPE_BYTE,
    											&default_char_value); 

    			dbus_message_iter_append_basic (&iter_struct,
    											DBUS_TYPE_BYTE,
    											&default_char_value); 

    			dbus_message_iter_append_basic (&iter_struct,
    											DBUS_TYPE_BYTE,
    											&default_char_value); 

    			dbus_message_iter_append_basic (&iter_struct,
    											DBUS_TYPE_DOUBLE,
    											&defalt_double_value); 

    			dbus_message_iter_append_basic (&iter_struct,
    											DBUS_TYPE_BYTE,
    											&default_char_value); 
    		}

    		else{
    			dbus_message_iter_append_basic (&iter_struct,
    											DBUS_TYPE_BYTE,
    											&WTP[i]->apcminfo.snr_max_value); 
    			
    			dbus_message_iter_append_basic (&iter_struct,
    											DBUS_TYPE_BYTE,
    											&WTP[i]->apcminfo.snr_min_value); 

    			dbus_message_iter_append_basic (&iter_struct,
    											DBUS_TYPE_BYTE,
    											&WTP[i]->apcminfo.snr_average); 

    			dbus_message_iter_append_basic (&iter_struct,
    											DBUS_TYPE_DOUBLE,
    											&WTP[i]->apcminfo.snr_math_average); 

    			dbus_message_iter_append_basic (&iter_struct,
    											DBUS_TYPE_BYTE,
    											&WTP[i]->wtp_wifi_snr_stats.ifindex); 
    		}
			*/
    		dbus_message_iter_append_basic(&iter_struct,
    									  DBUS_TYPE_UINT32,
    									  &(wtp_rx_packets)); 	
    		dbus_message_iter_append_basic(&iter_struct,
    									  DBUS_TYPE_UINT32,
    									  &(wtp_tx_packets)); 	
    		dbus_message_iter_append_basic(&iter_struct,
    									  DBUS_TYPE_UINT32,
    									  &(wtp_tx_errors));
    						
    		dbus_message_iter_append_basic(&iter_struct,
    									  DBUS_TYPE_UINT64,
    									  &(wtp_tx_bytes));
    		dbus_message_iter_append_basic(&iter_struct,
    									  DBUS_TYPE_UINT64,
    									  &(wtp_rx_bytes));	
    		dbus_message_iter_append_basic(&iter_struct,
    									  DBUS_TYPE_UINT32,
    									  &(wtp_ast_rx_crcerr));	
    		
    		dbus_message_iter_append_basic(&iter_struct,
    									  DBUS_TYPE_UINT32,
    									  &(wtp_ast_rx_badcrypt));
    		dbus_message_iter_append_basic(&iter_struct,
    									  DBUS_TYPE_UINT32,
    									  &(wtp_ast_rx_badmic));	
    		dbus_message_iter_append_basic(&iter_struct,
    									  DBUS_TYPE_UINT32,
    									  &(wtp_ast_rx_phyerr));
		/*fengwenchao add 20110521*/
		int wtpid = WTP[i]->WTPID;
		//printf(" wtpid   =%d   \n",wtpid);
		DBusMessageIter iter_neighbor_array;
		DBusMessageIter iter_neighbor_struct;
		DBusMessageIter iter_sub_neighbor_array;
		DBusMessageIter iter_sub_neighbor_struct;

		if(AC_WTP[wtpid]->NeighborAPInfos == NULL)
		{
			neighbor_ap_count = 0;
		}
		else
		{
			neighbor_ap_count = AC_WTP[wtpid]->NeighborAPInfos->neighborapInfosCount;
			phead = AC_WTP[wtpid]->NeighborAPInfos->neighborapInfos;
		}
		//printf("AC_WTP[wtpid]->NeighborAPInfos->neighborapInfosCount    =%d   \n",AC_WTP[wtpid]->NeighborAPInfos->neighborapInfosCount);

		//neighbor_ap_count = AC_WTP[wtpid]->NeighborAPInfos->neighborapInfosCount;

		dbus_message_iter_append_basic (&iter_struct,
										 DBUS_TYPE_UINT32,
										 &(neighbor_ap_count));	
		//printf("neighbor_ap_count  =  %d \n",neighbor_ap_count);

    		dbus_message_iter_open_container (&iter_struct,
    										DBUS_TYPE_ARRAY,

		    									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
		    											DBUS_TYPE_UINT32_AS_STRING    //neighbor wtpid

													DBUS_TYPE_ARRAY_AS_STRING
													DBUS_STRUCT_BEGIN_CHAR_AS_STRING
														DBUS_TYPE_BYTE_AS_STRING         //neighbor essid
													DBUS_STRUCT_END_CHAR_AS_STRING

    											DBUS_STRUCT_END_CHAR_AS_STRING,
    									&iter_neighbor_array);		

		if(neighbor_ap_count > 0)
		{
			for(j = 0; (j < neighbor_ap_count)&&(phead); j++)
			{	

				dbus_message_iter_open_container (&iter_neighbor_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_neighbor_struct);


				dbus_message_iter_append_basic(&iter_neighbor_struct,DBUS_TYPE_UINT32,&phead->wtpid);
	
				


				dbus_message_iter_open_container (&iter_neighbor_struct,
										   DBUS_TYPE_ARRAY,
										   DBUS_STRUCT_BEGIN_CHAR_AS_STRING  
											  DBUS_TYPE_BYTE_AS_STRING
										   DBUS_STRUCT_END_CHAR_AS_STRING, 
										   &iter_sub_neighbor_array);

				for(k =0;k <ESSID_DEFAULT_LEN+1;k++)
				{
									
					dbus_message_iter_open_container (&iter_sub_neighbor_array,
														DBUS_TYPE_STRUCT,
														NULL,
													  &iter_sub_neighbor_struct);

					dbus_message_iter_append_basic
								(&iter_sub_neighbor_struct,
								  DBUS_TYPE_BYTE,
								  &(phead->ESSID[k]));
					//printf("phead->ESSID  =  %s \n",phead->ESSID);	

					dbus_message_iter_close_container (&iter_sub_neighbor_array, &iter_sub_neighbor_struct);
				}	
				
				dbus_message_iter_close_container (&iter_neighbor_struct, &iter_sub_neighbor_array);
				dbus_message_iter_close_container (&iter_neighbor_array, &iter_neighbor_struct);
				phead = phead->next;
			}			
		}
		else
		{
			dbus_message_iter_open_container (&iter_neighbor_array,
							DBUS_TYPE_STRUCT,
							NULL,
							&iter_neighbor_struct);
			dbus_message_iter_append_basic(&iter_neighbor_struct,DBUS_TYPE_UINT32,&default_wtpid);
			dbus_message_iter_open_container (&iter_neighbor_struct,
											   DBUS_TYPE_ARRAY,
											   DBUS_STRUCT_BEGIN_CHAR_AS_STRING  
												  DBUS_TYPE_BYTE_AS_STRING
											   DBUS_STRUCT_END_CHAR_AS_STRING, 
											   &iter_sub_neighbor_array);

				for(k =0;k <ESSID_DEFAULT_LEN+1;k++)
				{	
					dbus_message_iter_open_container (&iter_sub_neighbor_array,
														DBUS_TYPE_STRUCT,
														NULL,
													  &iter_sub_neighbor_struct);

					dbus_message_iter_append_basic
								(&iter_sub_neighbor_struct,
								  DBUS_TYPE_BYTE,
								  &(default_essid[k]));
					//printf("default_essid  =  %s \n",default_essid);	

					dbus_message_iter_close_container (&iter_sub_neighbor_array, &iter_sub_neighbor_struct);	
				}	
			dbus_message_iter_close_container (&iter_neighbor_struct, &iter_sub_neighbor_array);
			dbus_message_iter_close_container (&iter_neighbor_array, &iter_neighbor_struct);
		}
		dbus_message_iter_close_container (&iter_struct, &iter_neighbor_array);	
		/*fengwenchao add end*/
		
#if 0
    		if(WTP[i]->wifi_extension_reportswitch != 0){
    			dbus_message_iter_append_basic(&iter_struct, 
    											DBUS_TYPE_UINT32, 
    											&(WTP[i]->wifi_extension_info.tx_mgmt));
    			
    			dbus_message_iter_append_basic(&iter_struct, 
    											DBUS_TYPE_UINT32, 
    											&(WTP[i]->wifi_extension_info.rx_mgmt));

    			dbus_message_iter_append_basic(&iter_struct, 
    											DBUS_TYPE_UINT32, 
    											&(WTP[i]->wifi_extension_info.tx_errors));
    			
    			dbus_message_iter_append_basic(&iter_struct, 
    											DBUS_TYPE_UINT32,
    											&(WTP[i]->wifi_extension_info.tx_retry));
    		}
    		else{
    			dbus_message_iter_append_basic(&iter_struct, 
    											DBUS_TYPE_UINT32, 
    											&(default_int_value));
    			
    			dbus_message_iter_append_basic(&iter_struct, 
    											DBUS_TYPE_UINT32, 
    											&(default_int_value));

    			dbus_message_iter_append_basic(&iter_struct, 
    											DBUS_TYPE_UINT32, 
    											&(default_int_value));
    			
    			dbus_message_iter_append_basic(&iter_struct, 
    											DBUS_TYPE_UINT32,
    											&(default_int_value));
    		}
#endif

    		dbus_message_iter_append_basic(&iter_struct, 
    												DBUS_TYPE_BYTE,
    												&(num_of_radio));

    		dbus_message_iter_open_container (&iter_struct,
    											   DBUS_TYPE_ARRAY,
    											  	 	DBUS_STRUCT_BEGIN_CHAR_AS_STRING
    													   
    													    DBUS_TYPE_BYTE_AS_STRING
    														DBUS_TYPE_BYTE_AS_STRING

    														DBUS_TYPE_UINT32_AS_STRING		//rx_pkt_unicast
    														DBUS_TYPE_UINT32_AS_STRING		//tx_pkt_unicast
    														DBUS_TYPE_UINT32_AS_STRING		//rx_pkt_broadcast
    														DBUS_TYPE_UINT32_AS_STRING		//tx_pkt_broadcast

    														DBUS_TYPE_UINT32_AS_STRING		//c1
    														DBUS_TYPE_UINT32_AS_STRING
    														DBUS_TYPE_UINT32_AS_STRING		//sub_tx_errors
    														DBUS_TYPE_UINT32_AS_STRING		//sub_rx_errors
    														DBUS_TYPE_UINT32_AS_STRING		//sub_tx_drop
    														DBUS_TYPE_UINT32_AS_STRING		//sub_rx_drop
    														DBUS_TYPE_UINT64_AS_STRING		//c4
    														DBUS_TYPE_UINT64_AS_STRING		//c5
    														DBUS_TYPE_UINT32_AS_STRING
    														DBUS_TYPE_UINT32_AS_STRING
    														DBUS_TYPE_UINT32_AS_STRING
    														DBUS_TYPE_UINT32_AS_STRING		//c9

    														DBUS_TYPE_BYTE_AS_STRING		//snr cur	
    														DBUS_TYPE_BYTE_AS_STRING
    														DBUS_TYPE_BYTE_AS_STRING
    														DBUS_TYPE_DOUBLE_AS_STRING		//snr aver
    														/*add for new mgmt infor requrement 20100809 */
    														DBUS_TYPE_UINT32_AS_STRING		//sub_rx_pkt_mgmt
    														DBUS_TYPE_UINT32_AS_STRING		//sub_tx_pkt_mgmt
    														DBUS_TYPE_UINT64_AS_STRING		//sub_rx_mgmt
    														DBUS_TYPE_UINT64_AS_STRING		//sub_tx_mgmt
    														DBUS_TYPE_UINT64_AS_STRING		//sub_total_rx_bytes
    														DBUS_TYPE_UINT64_AS_STRING		//sub_total_tx_bytes
    														DBUS_TYPE_UINT64_AS_STRING		//sub_total_rx_pkt
    														DBUS_TYPE_UINT64_AS_STRING		//sub_total_tx_pkt
														DBUS_TYPE_UINT32_AS_STRING		//tx_pkt_ctl  zhangshu add 2010-10-09
														DBUS_TYPE_UINT32_AS_STRING		//rx_pkt_ctl
														DBUS_TYPE_UINT32_AS_STRING      //tx_signal_pkts
    													DBUS_TYPE_UINT32_AS_STRING      //rx_signal_pkts
    														DBUS_TYPE_UINT32_AS_STRING		//sub_tx_pkt_control zhangshu add
    													    DBUS_TYPE_UINT32_AS_STRING		//sub_rx_pkt_control
    													    DBUS_TYPE_UINT32_AS_STRING     //rx_data_pkts    fengwenchao add 20110617
    													    DBUS_TYPE_UINT32_AS_STRING     //tx_data_pkts    fengwenchao add 20110617
    												DBUS_STRUCT_END_CHAR_AS_STRING,
    											   &iter_sub_array);

    		for(k = 0; k < num_of_radio; k++){
    			wtp_ath_updown_times = 0;
    			rx_pkt_unicast = 0;
    			tx_pkt_unicast = 0;
    			rx_pkt_multicast = 0;
    			tx_pkt_multicast = 0;
			unsigned int rx_data_pkts = 0;   //fengwenchao add 20110617
			unsigned int tx_data_pkts = 0;  //fengwenchao add 20110617
    			unsigned int 	sub_rx_packets = 0;
    			unsigned int	sub_tx_packets = 0;
    			unsigned int	sub_tx_errors = 0;
				unsigned long 	sub_rx_errors = 0;
				unsigned long	sub_tx_drops = 0;
				unsigned long	sub_rx_drops = 0;
    			unsigned long long 	sub_rx_bytes = 0;
    			unsigned long long  sub_tx_bytes = 0;
    			unsigned int	sub_ast_rx_crcerr = 0;
    			unsigned int	sub_ast_rx_badcrypt = 0;
    			unsigned int	sub_ast_rx_badmic = 0;
    			unsigned int	sub_ast_rx_phyerr = 0;
    			
    			/*add for new mgmt infor requrement 20100809 */
    			unsigned int sub_rx_pkt_mgmt = 0;  // packets received of management
    			unsigned int sub_tx_pkt_mgmt = 0;	// packets transtmitted of management
    			unsigned long long sub_rx_mgmt = 0;
    			unsigned long long sub_tx_mgmt = 0;
    			unsigned long long sub_total_rx_bytes = 0;
    			unsigned long long sub_total_tx_bytes = 0;
    			unsigned long long sub_total_rx_pkt = 0;
    			unsigned long long sub_total_tx_pkt = 0;
    			unsigned int sub_tx_pkt_control = 0; //zhangshu add 2010-10-11
    			unsigned int sub_rx_pkt_control = 0; //zhangshu add 2010-10-11

                /*book add 2011-5-19*/
    			unsigned int tx_pkt_signal = 0;
    			unsigned int rx_pkt_signal = 0;
    			unsigned int dwlink_retry_pkts = 0; 
    			unsigned int stats_retry_frames = 0;

    			for(ii=0;ii<TOTAL_AP_IF_NUM;ii++){
    				if((WTP[i]->apstatsinfo[ii].type == 0)
    					&&(WTP[i]->apstatsinfo[ii].radioId == AC_RADIO_FOR_SEARCH[k]->Radio_L_ID )){
    					rx_pkt_unicast += WTP[i]->apstatsinfo[ii].rx_pkt_unicast;
    					tx_pkt_unicast += WTP[i]->apstatsinfo[ii].tx_pkt_unicast;
    					rx_pkt_multicast += WTP[i]->apstatsinfo[ii].rx_pkt_multicast;
    					tx_pkt_multicast += WTP[i]->apstatsinfo[ii].tx_pkt_multicast;
					rx_data_pkts +=  WTP[i]->apstatsinfo[ii].rx_pkt_data;  //fengwenchao add 20110617
					tx_data_pkts +=  WTP[i]->apstatsinfo[ii].tx_pkt_data;  //fengwenchao add 20110617
						/*xiaodawei modify, 20110318*/
						if(wirelessdata_switch)
						{
							sub_rx_packets += (WTP[i]->apstatsinfo[ii].rx_pkt_data > WTP[i]->apstatsinfo[ii].rx_pkt_multicast)?
												(WTP[i]->apstatsinfo[ii].rx_pkt_data - WTP[i]->apstatsinfo[ii].rx_pkt_multicast):
												(WTP[i]->apstatsinfo[ii].rx_pkt_multicast - WTP[i]->apstatsinfo[ii].rx_pkt_data);
												
							sub_tx_packets += (WTP[i]->apstatsinfo[ii].tx_pkt_data > WTP[i]->apstatsinfo[ii].tx_pkt_multicast)?
												(WTP[i]->apstatsinfo[ii].tx_pkt_data - WTP[i]->apstatsinfo[ii].tx_pkt_multicast):
												(WTP[i]->apstatsinfo[ii].tx_pkt_multicast - WTP[i]->apstatsinfo[ii].tx_pkt_data);
												
							sub_rx_bytes += (WTP[i]->apstatsinfo[ii].rx_bytes > WTP[i]->apstatsinfo[ii].rx_multicast)?
												(WTP[i]->apstatsinfo[ii].rx_bytes - WTP[i]->apstatsinfo[ii].rx_multicast):
												(WTP[i]->apstatsinfo[ii].rx_multicast - WTP[i]->apstatsinfo[ii].rx_bytes);
												
							sub_tx_bytes += (WTP[i]->apstatsinfo[ii].tx_bytes > WTP[i]->apstatsinfo[ii].tx_multicast)?
												(WTP[i]->apstatsinfo[ii].tx_bytes - WTP[i]->apstatsinfo[ii].tx_multicast):
												(WTP[i]->apstatsinfo[ii].tx_multicast - WTP[i]->apstatsinfo[ii].tx_bytes);
						}
						else
						{
							sub_rx_packets += WTP[i]->apstatsinfo[ii].rx_pkt_data;
							sub_tx_packets += WTP[i]->apstatsinfo[ii].tx_pkt_data;
							sub_rx_bytes += WTP[i]->apstatsinfo[ii].rx_bytes;
							sub_tx_bytes += WTP[i]->apstatsinfo[ii].tx_bytes;
							
						}

					//sub_rx_packets += WTP[i]->apstatsinfo[ii].rx_pkt_data;	//book modify,2011-1-20					//c1
					//sub_tx_packets += WTP[i]->apstatsinfo[ii].tx_pkt_data;  //book modify, 2011-1-20
					sub_tx_errors += WTP[i]->apstatsinfo[ii].tx_errors;
					sub_rx_errors += WTP[i]->apstatsinfo[ii].rx_errors;	//xiaodawei add, 20110406
					sub_tx_drops += WTP[i]->apstatsinfo[ii].tx_drop;	//xiaodawei add, 20110406
					sub_rx_drops += WTP[i]->apstatsinfo[ii].rx_drop;	//xiaodawei add, 20110406
					//sub_rx_bytes += WTP[i]->apstatsinfo[ii].rx_bytes;
					//sub_tx_bytes += WTP[i]->apstatsinfo[ii].tx_bytes;							//c5
					sub_ast_rx_crcerr += WTP[i]->apstatsinfo[ii].ast_rx_crcerr;					//c6
					sub_ast_rx_badcrypt += WTP[i]->apstatsinfo[ii].ast_rx_badcrypt;
					sub_ast_rx_badmic += WTP[i]->apstatsinfo[ii].ast_rx_badmic;
					sub_ast_rx_phyerr += WTP[i]->apstatsinfo[ii].ast_rx_phyerr;					//c9
					/*add for new mgmt infor requrement 20100809 */
					sub_rx_pkt_mgmt += WTP[i]->apstatsinfo[ii].rx_pkt_mgmt;
					sub_tx_pkt_mgmt += WTP[i]->apstatsinfo[ii].tx_pkt_mgmt;
					sub_rx_mgmt += WTP[i]->apstatsinfo[ii].rx_mgmt;
					sub_tx_mgmt += WTP[i]->apstatsinfo[ii].tx_mgmt;
					sub_total_rx_bytes += WTP[i]->apstatsinfo[ii].rx_sum_bytes;//book modify,2011-1-20
					sub_total_tx_bytes += WTP[i]->apstatsinfo[ii].tx_sum_bytes;//
					sub_total_rx_pkt += WTP[i]->apstatsinfo[ii].rx_packets;//
					sub_total_tx_pkt += WTP[i]->apstatsinfo[ii].tx_packets;//book modify,2011-1-20
    					/* zhangshu add for pkt_ctl */
    					sub_tx_pkt_control += WTP[i]->apstatsinfo[ii].tx_pkt_control;
                        sub_rx_pkt_control += WTP[i]->apstatsinfo[ii].rx_pkt_control;

                        /* book add, 2011-5-19 */
                        tx_pkt_signal += WTP[i]->apstatsinfo[ii].tx_pkt_mgmt;		
					    rx_pkt_signal += WTP[i]->apstatsinfo[ii].rx_pkt_mgmt;
                        dwlink_retry_pkts += WTP[i]->apstatsinfo[ii].tx_pkt_retry;//ap reports total retry pkts, used for data pkts
					    stats_retry_frames += WTP[i]->apstatsinfo[ii].tx_pkt_retry*103/100;			//retry pkts * 103%
    				}
    			}

    			wtp_ath_updown_times = WTP[i]->WTP_Radio[k]->upcount + WTP[i]->WTP_Radio[k]->downcount;//book modify, 2011-1-20
    		
    			dbus_message_iter_open_container (&iter_sub_array,
    											   DBUS_TYPE_STRUCT,
    											   NULL,
    											   &iter_sub_struct);

    			dbus_message_iter_append_basic	 (&iter_sub_struct,
    											  DBUS_TYPE_BYTE,
    											  &(AC_RADIO_FOR_SEARCH[k]->Radio_L_ID));
    			
    			dbus_message_iter_append_basic	 (&iter_sub_struct,
    											  DBUS_TYPE_BYTE,
    											  &(wtp_ath_updown_times));
    			
    			dbus_message_iter_append_basic	 (&iter_sub_struct,
    											  DBUS_TYPE_UINT32,
    											  &(rx_pkt_unicast));
    			
    			dbus_message_iter_append_basic	 (&iter_sub_struct,
    											  DBUS_TYPE_UINT32,
    											  &(tx_pkt_unicast));
    			
    			dbus_message_iter_append_basic	 (&iter_sub_struct,
    											  DBUS_TYPE_UINT32,
    											  &(rx_pkt_multicast));
    			
    			dbus_message_iter_append_basic	 (&iter_sub_struct,
    											  DBUS_TYPE_UINT32,
    											  &(tx_pkt_multicast));

    			dbus_message_iter_append_basic	 (&iter_sub_struct,
    											  DBUS_TYPE_UINT32,
    											  &(sub_rx_packets));								//c1
    			dbus_message_iter_append_basic	 (&iter_sub_struct,
    											  DBUS_TYPE_UINT32,
    											  &(sub_tx_packets));
    			dbus_message_iter_append_basic	 (&iter_sub_struct,
    											  DBUS_TYPE_UINT32,
    											  &(sub_tx_errors));								//c3
    			dbus_message_iter_append_basic	 (&iter_sub_struct,
    											  DBUS_TYPE_UINT32,
    											  &(sub_rx_errors));							
    			dbus_message_iter_append_basic	 (&iter_sub_struct,
    											  DBUS_TYPE_UINT32,
    											  &(sub_tx_drops));								
    			dbus_message_iter_append_basic	 (&iter_sub_struct,
    											  DBUS_TYPE_UINT32,
    											  &(sub_rx_drops));								

    			dbus_message_iter_append_basic	 (&iter_sub_struct,
    											  DBUS_TYPE_UINT64,
    											  &(sub_rx_bytes));									//c4
    			dbus_message_iter_append_basic	 (&iter_sub_struct,
    											  DBUS_TYPE_UINT64,
    											  &(sub_tx_bytes));
    			dbus_message_iter_append_basic	 (&iter_sub_struct,
    											  DBUS_TYPE_UINT32,
    											  &(sub_ast_rx_crcerr));							//c6
    			
    			dbus_message_iter_append_basic	 (&iter_sub_struct,
    											  DBUS_TYPE_UINT32,
    											  &(sub_ast_rx_badcrypt));							//c7
    			dbus_message_iter_append_basic	 (&iter_sub_struct,
    											  DBUS_TYPE_UINT32,
    											  &(sub_ast_rx_badmic));
    			dbus_message_iter_append_basic	 (&iter_sub_struct,
    											  DBUS_TYPE_UINT32,
    											  &(sub_ast_rx_phyerr));							//c9
    			//qiuchen copy from v1.3
				#if 0
    			dbus_message_iter_append_basic		(&iter_sub_struct, 
    												DBUS_TYPE_BYTE, 
    												&(WTP[i]->wifi_extension_info.wifi_snr));
    			dbus_message_iter_append_basic		(&iter_sub_struct, 
    												DBUS_TYPE_BYTE, 
    												&(WTP[i]->apcminfo.snr_max_value));
    			dbus_message_iter_append_basic		(&iter_sub_struct, 
    												DBUS_TYPE_BYTE, 
    												&(WTP[i]->apcminfo.snr_min_value));
    			dbus_message_iter_append_basic		(&iter_sub_struct, 
    												DBUS_TYPE_DOUBLE, 
    												&(WTP[i]->apcminfo.snr_math_average));
				#endif
							/*fengwenchao add 20110926*/
			if((WTP[i]->wifi_extension_reportswitch != 0)&&(WTP[i]->wifi_extension_info.wifi_snr_new[k] != 0))
			{
				char wifi_snr_radio = (char)WTP[i]->wifi_extension_info.wifi_snr_new[k] - (char)WTP[i]->wifi_extension_info.wifi_noise_new[k];
				char snr_max_value_radio = (char)WTP[i]->apcminfo.wifi_snr[k].snr_max_value - (char)WTP[i]->wifi_extension_info.wifi_noise_new[k];
				char snr_min_value_radio = (char)WTP[i]->apcminfo.wifi_snr[k].snr_min_value - (char)WTP[i]->wifi_extension_info.wifi_noise_new[k];
				double snr_math_average_radio = WTP[i]->apcminfo.wifi_snr[k].snr_math_average - (double)WTP[i]->wifi_extension_info.wifi_noise_new[k];
				//wid_syslog_debug_debug(WID_DEFAULT,"snr max is %d,snr min is %d.\n",snr_max_value_radio,snr_min_value_radio);

    			dbus_message_iter_append_basic		(&iter_sub_struct, 
    												DBUS_TYPE_BYTE, 
    												&wifi_snr_radio);//qiuchen copy from v1.3

    			dbus_message_iter_append_basic (&iter_sub_struct,
    											DBUS_TYPE_BYTE,
    											&snr_max_value_radio); //qiuchen copy from v1.3
    			
    			dbus_message_iter_append_basic (&iter_sub_struct,
    											DBUS_TYPE_BYTE,
    											&snr_min_value_radio); //qiuchen copy from v1.3

	    			dbus_message_iter_append_basic (&iter_sub_struct,
	    											DBUS_TYPE_DOUBLE,
	    											&snr_math_average_radio); //qiuchen copy from v1.3
			
			}
			else
			{
				dbus_message_iter_append_basic (&iter_sub_struct, 
	    												DBUS_TYPE_BYTE, 
	    												&default_char_value);

	    			dbus_message_iter_append_basic (&iter_sub_struct,
	    											DBUS_TYPE_BYTE,
	    											&default_char_value); 
	    			
	    			dbus_message_iter_append_basic (&iter_sub_struct,
	    											DBUS_TYPE_BYTE,
	    											&default_char_value); 

	    			dbus_message_iter_append_basic (&iter_sub_struct,
	    											DBUS_TYPE_DOUBLE,
	    											&defalt_double_value); 
			}
			/*fengwenchao add end*/
    			/*add for new mgmt infor requrement 20100809 */
    			dbus_message_iter_append_basic	(&iter_sub_struct, 
    											DBUS_TYPE_UINT32, 
    											&(sub_rx_pkt_mgmt));
    			dbus_message_iter_append_basic	(&iter_sub_struct, 
    											DBUS_TYPE_UINT32, 
    											&(sub_tx_pkt_mgmt));
    			dbus_message_iter_append_basic	(&iter_sub_struct, 
    											DBUS_TYPE_UINT64, 
    											&(sub_rx_mgmt));
    			dbus_message_iter_append_basic	(&iter_sub_struct, 
    											DBUS_TYPE_UINT64, 
    											&(sub_tx_mgmt));

    			dbus_message_iter_append_basic	(&iter_sub_struct, 
    											DBUS_TYPE_UINT64, 
    											&(sub_total_rx_bytes));
    			dbus_message_iter_append_basic	(&iter_sub_struct, 
    											DBUS_TYPE_UINT64, 
    											&(sub_total_tx_bytes));
    			dbus_message_iter_append_basic	(&iter_sub_struct, 
    											DBUS_TYPE_UINT64, 
    											&(sub_total_rx_pkt));
    			dbus_message_iter_append_basic	(&iter_sub_struct, 
    											DBUS_TYPE_UINT64, 
    											&(sub_total_tx_pkt));
    			dbus_message_iter_append_basic	(&iter_sub_struct, 
    											DBUS_TYPE_UINT32, 
    											&(sub_tx_pkt_control));
    			dbus_message_iter_append_basic	(&iter_sub_struct, 
    											DBUS_TYPE_UINT32, 
    											&(sub_rx_pkt_control));
    			dbus_message_iter_append_basic  (&iter_sub_struct,
            									  DBUS_TYPE_UINT32,
            									  &(tx_pkt_signal));	
        		dbus_message_iter_append_basic  (&iter_sub_struct,
            									  DBUS_TYPE_UINT32,
            									  &(rx_pkt_signal));
    			dbus_message_iter_append_basic  (&iter_sub_struct, 
    											DBUS_TYPE_UINT32, 
    											&(dwlink_retry_pkts));
    			
    			dbus_message_iter_append_basic  (&iter_sub_struct, 
    											DBUS_TYPE_UINT32,
    											&(stats_retry_frames));
			/*fengwenchao add 20110617*/
    			dbus_message_iter_append_basic  (&iter_sub_struct, 
    											DBUS_TYPE_UINT32,
    											&(rx_data_pkts));

    			dbus_message_iter_append_basic  (&iter_sub_struct, 
    											DBUS_TYPE_UINT32,
    											&(tx_data_pkts));
			/*fengwenchao add 20110617*/

    			dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);
    		}
    		dbus_message_iter_close_container (&iter_struct, &iter_sub_array);			
    		dbus_message_iter_close_container (&iter_array, &iter_struct);
    	}
    				
    	dbus_message_iter_close_container (&iter, &iter_array);
    }
				
	CW_FREE_OBJECT_WID(WTP);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(AC_RADIO_FOR_SEARCH);
	
	return reply;	
}
#endif
/* book modify, 2011-5-19 */
DBusMessage * wid_dbus_interface_show_wtp_wireless_ifstats_information(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusMessageIter iter_sub_array;
	DBusMessageIter iter_struct;
	DBusMessageIter iter_sub_struct;
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	int i=0,j=0,k=0;
	unsigned int wtp_num = 0;
	unsigned char num_of_radio = 0;
	char *default_essid = "none";
	struct Neighbor_AP_ELE *phead = NULL;   //fengwenchao add 20110521
	int neighbor_ap_count = 0;     //fengwenchao add 20110521
	unsigned int  default_wtpid = 0;
	unsigned char wtp_ath_updown_times = 0;
	unsigned char default_char_value = 0;
	//unsigned int default_int_value = 0;
	double defalt_double_value = 0;
	double avr_snr = 0.0;
	WID_WTP **WTP = NULL;	
	unsigned char *mac = NULL;
	
	WTP = (WID_WTP **)WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	if(NULL == WTP)
	{
		wid_syslog_info("%s %d: ERR out of memory\n",__func__,__LINE__);
		return NULL;
	}
	memset(WTP,0,WTP_NUM*(sizeof(WID_WTP *)));

	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	if(NULL == mac)
	{
		wid_syslog_info("%s %d: ERR out of memory\n",__func__,__LINE__);
		WID_FREE(WTP);
		return NULL;
	}
	memset(mac, 0, MAC_LEN+1);	

	if(hide_quit_wtp_in_showting == 0){
		wtp_num = Wid_Find_Wtp(WTP);
	}
	else if (hide_quit_wtp_in_showting == 1){
		wtp_num = Wid_Find_Running_Wtp(WTP);
	}
	
	if(wtp_num == 0)
		ret = WTP_ID_NOT_EXIST;
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret);

	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&wtp_num);

    if(wtp_num != 0)
    {
    	dbus_message_iter_open_container (&iter,
    									DBUS_TYPE_ARRAY,
    									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING

    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING

    											DBUS_TYPE_BYTE_AS_STRING		//wifi_info_switch
												
    											DBUS_TYPE_UINT32_AS_STRING			//s1
    											DBUS_TYPE_UINT32_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING
    											
    											DBUS_TYPE_UINT64_AS_STRING			//wtp_rx_bytes
    											DBUS_TYPE_UINT64_AS_STRING			//wtp_tx_bytes
    											DBUS_TYPE_UINT32_AS_STRING
    											
    											DBUS_TYPE_UINT32_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING			//s9
    											
    											/*fengwenchao add 20110521*/
												DBUS_TYPE_UINT32_AS_STRING      // roge_num
												DBUS_TYPE_ARRAY_AS_STRING
		    										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
		    											DBUS_TYPE_UINT32_AS_STRING    //neighbor wtpid

														DBUS_TYPE_ARRAY_AS_STRING
															DBUS_STRUCT_BEGIN_CHAR_AS_STRING
																DBUS_TYPE_BYTE_AS_STRING         //neighbor essid
															DBUS_STRUCT_END_CHAR_AS_STRING
													DBUS_STRUCT_END_CHAR_AS_STRING
											/*fengwenchao add end*/
    											DBUS_TYPE_BYTE_AS_STRING		//wtp_radio_num
    											DBUS_TYPE_ARRAY_AS_STRING
    												DBUS_STRUCT_BEGIN_CHAR_AS_STRING
    														
														DBUS_TYPE_BYTE_AS_STRING
														DBUS_TYPE_BYTE_AS_STRING

    													DBUS_TYPE_UINT32_AS_STRING		//rx_pkt_unicast
    													DBUS_TYPE_UINT32_AS_STRING		//tx_pkt_unicast
    													DBUS_TYPE_UINT32_AS_STRING		//rx_pkt_multicast
    													DBUS_TYPE_UINT32_AS_STRING		//tx_pkt_multicast

														DBUS_TYPE_UINT32_AS_STRING		//c1
														DBUS_TYPE_UINT32_AS_STRING
														DBUS_TYPE_UINT32_AS_STRING		//sub_tx_errors
														DBUS_TYPE_UINT32_AS_STRING		//sub_rx_errors
														DBUS_TYPE_UINT32_AS_STRING		//sub_tx_drops
														DBUS_TYPE_UINT32_AS_STRING		//sub_rx_drops
														DBUS_TYPE_UINT64_AS_STRING
														DBUS_TYPE_UINT64_AS_STRING
														DBUS_TYPE_UINT32_AS_STRING
														DBUS_TYPE_UINT32_AS_STRING
														DBUS_TYPE_UINT32_AS_STRING
														DBUS_TYPE_UINT32_AS_STRING		//c9
    													DBUS_TYPE_BYTE_AS_STRING		//snr cur	
    													DBUS_TYPE_BYTE_AS_STRING
    													DBUS_TYPE_BYTE_AS_STRING
    													DBUS_TYPE_DOUBLE_AS_STRING		//snr aver
    													/*add for new mgmt infor requrement 20100809 */
    													DBUS_TYPE_UINT32_AS_STRING		//sub_rx_pkt_mgmt
    													DBUS_TYPE_UINT32_AS_STRING		//sub_tx_pkt_mgmt
    													DBUS_TYPE_UINT64_AS_STRING		//sub_rx_mgmt
    													DBUS_TYPE_UINT64_AS_STRING		//sub_tx_mgmt
    													DBUS_TYPE_UINT64_AS_STRING		//sub_total_rx_bytes
    													DBUS_TYPE_UINT64_AS_STRING		//sub_total_tx_bytes
    													DBUS_TYPE_UINT64_AS_STRING		//sub_total_rx_pkt
    													DBUS_TYPE_UINT64_AS_STRING		//sub_total_tx_pkt
    													DBUS_TYPE_UINT32_AS_STRING		//sub_tx_pkt_control zhangshu add
    													DBUS_TYPE_UINT32_AS_STRING		//sub_rx_pkt_control
    													DBUS_TYPE_UINT32_AS_STRING		//tx_signal_pkt
    													DBUS_TYPE_UINT32_AS_STRING		//rx_signal_pkt
    													DBUS_TYPE_UINT32_AS_STRING		//retry 1
    													DBUS_TYPE_UINT32_AS_STRING		//retry 2
    													DBUS_TYPE_UINT32_AS_STRING     //rx_data_pkts    fengwenchao add 20110617
    													DBUS_TYPE_UINT32_AS_STRING     //tx_data_pkts    fengwenchao add 20110617
    												DBUS_STRUCT_END_CHAR_AS_STRING
    									DBUS_STRUCT_END_CHAR_AS_STRING,
    									&iter_array);
		for(i = 0; i < wtp_num; i++)
		{
    		memset(mac, 0, MAC_LEN+1);
    		if(NULL != WTP[i]->WTPMAC)
    		{
    			memcpy(mac, WTP[i]->WTPMAC, MAC_LEN);
			}    		
    		num_of_radio = WTP[i]->RadioCount;
    		
    		dbus_message_iter_open_container (&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
    		
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_UINT32,&(WTP[i]->WTPID));
    			
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[0]));
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[1]));
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[2]));
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[3]));
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[4]));
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[5]));

    		dbus_message_iter_append_basic (&iter_struct,
    										DBUS_TYPE_BYTE,
    										&(WTP[i]->wifi_extension_reportswitch)); 
			
			pthread_mutex_lock(&(WTP[i]->mutex_web_report));
			
    		dbus_message_iter_append_basic(&iter_struct,
    									  DBUS_TYPE_UINT32,
    									  &(WTP[i]->web_manager_stats.wifi_stats.wtp_rx_packets)); 	
    		dbus_message_iter_append_basic(&iter_struct,
    									  DBUS_TYPE_UINT32,
    									  &(WTP[i]->web_manager_stats.wifi_stats.wtp_tx_packets)); 	
    		dbus_message_iter_append_basic(&iter_struct,
    									  DBUS_TYPE_UINT32,
    									  &(WTP[i]->web_manager_stats.wifi_stats.wtp_tx_errors));
    						
    		dbus_message_iter_append_basic(&iter_struct,
    									  DBUS_TYPE_UINT64,
    									  &(WTP[i]->web_manager_stats.wifi_stats.wtp_tx_bytes));
    		dbus_message_iter_append_basic(&iter_struct,
    									  DBUS_TYPE_UINT64,
    									  &(WTP[i]->web_manager_stats.wifi_stats.wtp_rx_bytes));	
    		dbus_message_iter_append_basic(&iter_struct,
    									  DBUS_TYPE_UINT32,
    									  &(WTP[i]->web_manager_stats.wifi_stats.wtp_ast_rx_crcerr));	
    		
    		dbus_message_iter_append_basic(&iter_struct,
    									  DBUS_TYPE_UINT32,
    									  &(WTP[i]->web_manager_stats.wifi_stats.wtp_ast_rx_badcrypt));
    		dbus_message_iter_append_basic(&iter_struct,
    									  DBUS_TYPE_UINT32,
    									  &(WTP[i]->web_manager_stats.wifi_stats.wtp_ast_rx_badmic));	
    		dbus_message_iter_append_basic(&iter_struct,
    									  DBUS_TYPE_UINT32,
    									  &(WTP[i]->web_manager_stats.wifi_stats.wtp_ast_rx_phyerr));
			pthread_mutex_unlock(&(WTP[i]->mutex_web_report));
			/*fengwenchao add 20110521*/
			DBusMessageIter iter_neighbor_array;
			DBusMessageIter iter_neighbor_struct;
			DBusMessageIter iter_sub_neighbor_array;
			DBusMessageIter iter_sub_neighbor_struct;

			if(WTP[i]->NeighborAPInfos == NULL)
			{
				neighbor_ap_count = 0;
			}
			else
			{
				neighbor_ap_count = WTP[i]->NeighborAPInfos->neighborapInfosCount;
				phead = WTP[i]->NeighborAPInfos->neighborapInfos;
			}

			dbus_message_iter_append_basic (&iter_struct,
										 	DBUS_TYPE_UINT32,
										 	&(neighbor_ap_count));	

    			dbus_message_iter_open_container (&iter_struct,
											DBUS_TYPE_ARRAY,

		    									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
		    											DBUS_TYPE_UINT32_AS_STRING    //neighbor wtpid

														DBUS_TYPE_ARRAY_AS_STRING
															DBUS_STRUCT_BEGIN_CHAR_AS_STRING
																DBUS_TYPE_BYTE_AS_STRING         //neighbor essid
														DBUS_STRUCT_END_CHAR_AS_STRING

    											DBUS_STRUCT_END_CHAR_AS_STRING,
    										&iter_neighbor_array);		

			if(neighbor_ap_count > 0)
			{
				for(j = 0; (j < neighbor_ap_count)&&(phead); j++)
				{
					dbus_message_iter_open_container (&iter_neighbor_array,
														DBUS_TYPE_STRUCT,
														NULL,
														&iter_neighbor_struct);

					dbus_message_iter_append_basic(&iter_neighbor_struct,
													DBUS_TYPE_UINT32,
													&phead->wtpid);

					dbus_message_iter_open_container (&iter_neighbor_struct,
											   		DBUS_TYPE_ARRAY,
											   			DBUS_STRUCT_BEGIN_CHAR_AS_STRING  
												  			DBUS_TYPE_BYTE_AS_STRING
											   			DBUS_STRUCT_END_CHAR_AS_STRING, 
											   		&iter_sub_neighbor_array);

					for(k =0;k <ESSID_DEFAULT_LEN+1;k++)
					{
										
						dbus_message_iter_open_container (&iter_sub_neighbor_array,
															DBUS_TYPE_STRUCT,
															NULL,
														  	&iter_sub_neighbor_struct);

						dbus_message_iter_append_basic	(&iter_sub_neighbor_struct,
									  					DBUS_TYPE_BYTE,
									  					&(phead->ESSID[k]));					

						dbus_message_iter_close_container (&iter_sub_neighbor_array, &iter_sub_neighbor_struct);
					}	
					
					dbus_message_iter_close_container (&iter_neighbor_struct, &iter_sub_neighbor_array);
					dbus_message_iter_close_container (&iter_neighbor_array, &iter_neighbor_struct);
					phead = phead->next;
				}			
			}
			else
			{
				dbus_message_iter_open_container (&iter_neighbor_array,
												DBUS_TYPE_STRUCT,
												NULL,
												&iter_neighbor_struct);
				
				dbus_message_iter_append_basic(&iter_neighbor_struct,
												DBUS_TYPE_UINT32,
												&default_wtpid);
				
				dbus_message_iter_open_container (&iter_neighbor_struct,
												DBUS_TYPE_ARRAY,
													DBUS_STRUCT_BEGIN_CHAR_AS_STRING  
													  DBUS_TYPE_BYTE_AS_STRING
												   	DBUS_STRUCT_END_CHAR_AS_STRING, 
												&iter_sub_neighbor_array);

				for(k =0;k <ESSID_DEFAULT_LEN+1;k++)
				{	
					dbus_message_iter_open_container (&iter_sub_neighbor_array,
													DBUS_TYPE_STRUCT,
													NULL,
													&iter_sub_neighbor_struct);

					dbus_message_iter_append_basic	(&iter_sub_neighbor_struct,
								  					DBUS_TYPE_BYTE,
								  					&(default_essid[k]));						

					dbus_message_iter_close_container (&iter_sub_neighbor_array, &iter_sub_neighbor_struct);	
				}	
				dbus_message_iter_close_container (&iter_neighbor_struct, &iter_sub_neighbor_array);
				dbus_message_iter_close_container (&iter_neighbor_array, &iter_neighbor_struct);
			}
			dbus_message_iter_close_container (&iter_struct, &iter_neighbor_array);	
			/*fengwenchao add end*/

    			dbus_message_iter_append_basic(&iter_struct, 
    										DBUS_TYPE_BYTE,
    										&(num_of_radio));

			dbus_message_iter_open_container (&iter_struct,
												DBUS_TYPE_ARRAY,
											  	 	DBUS_STRUCT_BEGIN_CHAR_AS_STRING
													   
													    DBUS_TYPE_BYTE_AS_STRING
														DBUS_TYPE_BYTE_AS_STRING

														DBUS_TYPE_UINT32_AS_STRING		//rx_pkt_unicast
														DBUS_TYPE_UINT32_AS_STRING		//tx_pkt_unicast
														DBUS_TYPE_UINT32_AS_STRING		//rx_pkt_broadcast
														DBUS_TYPE_UINT32_AS_STRING		//tx_pkt_broadcast

														DBUS_TYPE_UINT32_AS_STRING		//c1
														DBUS_TYPE_UINT32_AS_STRING
														DBUS_TYPE_UINT32_AS_STRING		//sub_tx_errors
														DBUS_TYPE_UINT32_AS_STRING		//sub_rx_errors
														DBUS_TYPE_UINT32_AS_STRING		//sub_tx_drop
														DBUS_TYPE_UINT32_AS_STRING		//sub_rx_drop
														DBUS_TYPE_UINT64_AS_STRING		//c4
														DBUS_TYPE_UINT64_AS_STRING		//c5
														DBUS_TYPE_UINT32_AS_STRING
														DBUS_TYPE_UINT32_AS_STRING
														DBUS_TYPE_UINT32_AS_STRING
														DBUS_TYPE_UINT32_AS_STRING		//c9

														DBUS_TYPE_BYTE_AS_STRING		//snr cur	
														DBUS_TYPE_BYTE_AS_STRING
														DBUS_TYPE_BYTE_AS_STRING
														DBUS_TYPE_DOUBLE_AS_STRING		//snr aver
														/*add for new mgmt infor requrement 20100809 */
														DBUS_TYPE_UINT32_AS_STRING		//sub_rx_pkt_mgmt
														DBUS_TYPE_UINT32_AS_STRING		//sub_tx_pkt_mgmt
														DBUS_TYPE_UINT64_AS_STRING		//sub_rx_mgmt
														DBUS_TYPE_UINT64_AS_STRING		//sub_tx_mgmt
														DBUS_TYPE_UINT64_AS_STRING		//sub_total_rx_bytes
														DBUS_TYPE_UINT64_AS_STRING		//sub_total_tx_bytes
														DBUS_TYPE_UINT64_AS_STRING		//sub_total_rx_pkt
														DBUS_TYPE_UINT64_AS_STRING		//sub_total_tx_pkt
														DBUS_TYPE_UINT32_AS_STRING		//sub_tx_pkt_control zhangshu add
													    DBUS_TYPE_UINT32_AS_STRING		//sub_rx_pkt_control
													    DBUS_TYPE_UINT32_AS_STRING		//tx_signal_pkt
													    DBUS_TYPE_UINT32_AS_STRING		//rx_signal_pkt
													    DBUS_TYPE_UINT32_AS_STRING		//retry 1
													    DBUS_TYPE_UINT32_AS_STRING		//retry 2
													    DBUS_TYPE_UINT32_AS_STRING     //rx_data_pkts    fengwenchao add 20110617
													    DBUS_TYPE_UINT32_AS_STRING     //tx_data_pkts    fengwenchao add 20110617
													DBUS_STRUCT_END_CHAR_AS_STRING,
												&iter_sub_array);
			pthread_mutex_lock(&(WTP[i]->mutex_web_report));
	    		for(k = 0; k < num_of_radio; k++)
			{
	    			wtp_ath_updown_times = 0;

	    			wtp_ath_updown_times = WTP[i]->WTP_Radio[k]->upcount + WTP[i]->WTP_Radio[k]->downcount;//book modify, 2011-1-20
	    		
	    			dbus_message_iter_open_container (&iter_sub_array,
	    											   DBUS_TYPE_STRUCT,
	    											   NULL,
	    											   &iter_sub_struct);

	    			dbus_message_iter_append_basic	 (&iter_sub_struct,
	    											  DBUS_TYPE_BYTE,
	    											  &(WTP[i]->WTP_Radio[k]->Radio_L_ID));
	    			
	    			dbus_message_iter_append_basic	 (&iter_sub_struct,
	    											  DBUS_TYPE_BYTE,
	    											  &(wtp_ath_updown_times));
	    			
	    			dbus_message_iter_append_basic	 (&iter_sub_struct,
	    											  DBUS_TYPE_UINT32,
	    											  &(WTP[i]->web_manager_stats.ath_stats[k].rx_pkt_unicast));
	    			
	    			dbus_message_iter_append_basic	 (&iter_sub_struct,
	    											  DBUS_TYPE_UINT32,
	    											  &(WTP[i]->web_manager_stats.ath_stats[k].tx_pkt_unicast));
	    			
	    			dbus_message_iter_append_basic	 (&iter_sub_struct,
	    											  DBUS_TYPE_UINT32,
	    											  &(WTP[i]->web_manager_stats.ath_stats[k].rx_pkt_multicast));
	    			
	    			dbus_message_iter_append_basic	 (&iter_sub_struct,
	    											  DBUS_TYPE_UINT32,
	    											  &(WTP[i]->web_manager_stats.ath_stats[k].tx_pkt_multicast));

	    			dbus_message_iter_append_basic	 (&iter_sub_struct,
	    											  DBUS_TYPE_UINT32,
	    											  &(WTP[i]->web_manager_stats.ath_stats[k].sub_rx_packets));								//c1
	    			dbus_message_iter_append_basic	 (&iter_sub_struct,
	    											  DBUS_TYPE_UINT32,
	    											  &(WTP[i]->web_manager_stats.ath_stats[k].sub_tx_packets));
	    			dbus_message_iter_append_basic	 (&iter_sub_struct,
	    											  DBUS_TYPE_UINT32,
	    											  &(WTP[i]->web_manager_stats.ath_stats[k].sub_tx_errors));								//c3
	    			dbus_message_iter_append_basic	 (&iter_sub_struct,
	    											  DBUS_TYPE_UINT32,
	    											  &(WTP[i]->web_manager_stats.ath_stats[k].sub_rx_errors));							
	    			dbus_message_iter_append_basic	 (&iter_sub_struct,
	    											  DBUS_TYPE_UINT32,
	    											  &(WTP[i]->web_manager_stats.ath_stats[k].sub_tx_drops));								
	    			dbus_message_iter_append_basic	 (&iter_sub_struct,
	    											  DBUS_TYPE_UINT32,
	    											  &(WTP[i]->web_manager_stats.ath_stats[k].sub_rx_drops));								

	    			dbus_message_iter_append_basic	 (&iter_sub_struct,
	    											  DBUS_TYPE_UINT64,
	    											  &(WTP[i]->web_manager_stats.ath_stats[k].sub_rx_bytes));									//c4
	    			dbus_message_iter_append_basic	 (&iter_sub_struct,
	    											  DBUS_TYPE_UINT64,
	    											  &(WTP[i]->web_manager_stats.ath_stats[k].sub_tx_bytes));

	    			dbus_message_iter_append_basic	 (&iter_sub_struct,
	    											  DBUS_TYPE_UINT32,
	    											  &(WTP[i]->web_manager_stats.ath_stats[k].sub_ast_rx_crcerr));							//c6
	    			
	    			dbus_message_iter_append_basic	 (&iter_sub_struct,
	    											  DBUS_TYPE_UINT32,
	    											  &(WTP[i]->web_manager_stats.ath_stats[k].sub_ast_rx_badcrypt));							//c7
	    			dbus_message_iter_append_basic	 (&iter_sub_struct,
	    											  DBUS_TYPE_UINT32,
	    											  &(WTP[i]->web_manager_stats.ath_stats[k].sub_ast_rx_badmic));
	    			dbus_message_iter_append_basic	 (&iter_sub_struct,
	    											  DBUS_TYPE_UINT32,
	    											  &(WTP[i]->web_manager_stats.ath_stats[k].sub_ast_rx_phyerr));							//c9
				/*fengwenchao add 20110926*/
				if((WTP[i]->wifi_extension_reportswitch != 0)&&(WTP[i]->wifi_extension_info.wifi_snr_new[k] != 0))
				{
					char wifi_snr_radio = (char)WTP[i]->wifi_extension_info.wifi_snr_new[k] - (char)WTP[i]->wifi_extension_info.wifi_noise_new[k];
					char snr_max_value_radio = (char)WTP[i]->apcminfo.wifi_snr[k].snr_max_value - (char)WTP[i]->wifi_extension_info.wifi_noise_new[k];
					char snr_min_value_radio = (char)WTP[i]->apcminfo.wifi_snr[k].snr_min_value - (char)WTP[i]->wifi_extension_info.wifi_noise_new[k];
					double snr_math_average_radio = WTP[i]->apcminfo.wifi_snr[k].snr_math_average - (double)WTP[i]->wifi_extension_info.wifi_noise_new[k];
					
					
					check_snr_v2(&wifi_snr_radio,NULL,0);
		    			dbus_message_iter_append_basic (&iter_sub_struct, 
		    											DBUS_TYPE_BYTE, 
		    											&wifi_snr_radio);
					
					check_snr_v2(&snr_max_value_radio,NULL,1);
		    			dbus_message_iter_append_basic (&iter_sub_struct,
		    											DBUS_TYPE_BYTE,
		    											&snr_max_value_radio); 
						
		    			check_snr_v2(&snr_min_value_radio,NULL,2);
		    			dbus_message_iter_append_basic (&iter_sub_struct,
		    											DBUS_TYPE_BYTE,
		    											&snr_min_value_radio); 
					avr_snr = ((double)snr_max_value_radio + (double)snr_min_value_radio)/2.0;
					check_snr_v2(&snr_math_average_radio,&avr_snr,3);
			    		dbus_message_iter_append_basic (&iter_sub_struct,
			    										DBUS_TYPE_DOUBLE,
			    										&snr_math_average_radio); 				
				}
				else
				{
					dbus_message_iter_append_basic (&iter_sub_struct, 
		    										DBUS_TYPE_BYTE, 
		    										&default_char_value);

		    			dbus_message_iter_append_basic (&iter_sub_struct,
		    											DBUS_TYPE_BYTE,
		    											&default_char_value); 
		    			
		    			dbus_message_iter_append_basic (&iter_sub_struct,
		    											DBUS_TYPE_BYTE,
		    											&default_char_value); 

		    			dbus_message_iter_append_basic (&iter_sub_struct,
		    											DBUS_TYPE_DOUBLE,
		    											&defalt_double_value); 
				}
				/*fengwenchao add end*/
	    			/*add for new mgmt infor requrement 20100809 */
	    			dbus_message_iter_append_basic	(&iter_sub_struct, 
	    											DBUS_TYPE_UINT32, 
	    											&(WTP[i]->web_manager_stats.ath_stats[k].sub_rx_pkt_mgmt));
	    			dbus_message_iter_append_basic	(&iter_sub_struct, 
	    											DBUS_TYPE_UINT32, 
	    											&(WTP[i]->web_manager_stats.ath_stats[k].sub_tx_pkt_mgmt));
	    			dbus_message_iter_append_basic	(&iter_sub_struct, 
	    											DBUS_TYPE_UINT64, 
	    											&(WTP[i]->web_manager_stats.ath_stats[k].sub_rx_mgmt));
	    			dbus_message_iter_append_basic	(&iter_sub_struct, 
	    											DBUS_TYPE_UINT64, 
	    											&(WTP[i]->web_manager_stats.ath_stats[k].sub_tx_mgmt));

	    			dbus_message_iter_append_basic	(&iter_sub_struct, 
	    											DBUS_TYPE_UINT64, 
	    											&(WTP[i]->web_manager_stats.ath_stats[k].sub_total_rx_bytes));
	    			dbus_message_iter_append_basic	(&iter_sub_struct, 
	    											DBUS_TYPE_UINT64, 
	    											&(WTP[i]->web_manager_stats.ath_stats[k].sub_total_tx_bytes));
	    			dbus_message_iter_append_basic	(&iter_sub_struct, 
	    											DBUS_TYPE_UINT64, 
	    											&(WTP[i]->web_manager_stats.ath_stats[k].sub_total_rx_pkt));
	    			dbus_message_iter_append_basic	(&iter_sub_struct, 
	    											DBUS_TYPE_UINT64, 
	    											&(WTP[i]->web_manager_stats.ath_stats[k].sub_total_tx_pkt));
	    			dbus_message_iter_append_basic	(&iter_sub_struct, 
	    											DBUS_TYPE_UINT32, 
	    											&(WTP[i]->web_manager_stats.ath_stats[k].sub_tx_pkt_control));
	    			dbus_message_iter_append_basic	(&iter_sub_struct, 
	    											DBUS_TYPE_UINT32, 
	    											&(WTP[i]->web_manager_stats.ath_stats[k].sub_rx_pkt_control));
	    			dbus_message_iter_append_basic  (&iter_sub_struct,
	            									  DBUS_TYPE_UINT32,
	            									  &(WTP[i]->web_manager_stats.ath_stats[k].tx_pkt_signal));	
	        		dbus_message_iter_append_basic  (&iter_sub_struct,
	            									  DBUS_TYPE_UINT32,
	            									  &(WTP[i]->web_manager_stats.ath_stats[k].rx_pkt_signal));
	    			dbus_message_iter_append_basic  (&iter_sub_struct, 
	    											DBUS_TYPE_UINT32, 
	    											&(WTP[i]->web_manager_stats.ath_stats[k].dwlink_retry_pkts));
	    			
	    			dbus_message_iter_append_basic  (&iter_sub_struct, 
	    											DBUS_TYPE_UINT32,
	    											&(WTP[i]->web_manager_stats.ath_stats[k].stats_retry_frames));
				/*fengwenchao add 20110617*/
	    			dbus_message_iter_append_basic  (&iter_sub_struct, 
	    											DBUS_TYPE_UINT32,
	    											&(WTP[i]->web_manager_stats.ath_stats[k].rx_data_pkts));

	    			dbus_message_iter_append_basic  (&iter_sub_struct, 
	    											DBUS_TYPE_UINT32,
	    											&(WTP[i]->web_manager_stats.ath_stats[k].tx_data_pkts));
				/*fengwenchao add 20110617*/    			

    			dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);
    		}
			pthread_mutex_unlock(&(WTP[i]->mutex_web_report));
    		dbus_message_iter_close_container (&iter_struct, &iter_sub_array);			
    		dbus_message_iter_close_container (&iter_array, &iter_struct);
    	}
    				
    	dbus_message_iter_close_container (&iter, &iter_array);
    }
				
	CW_FREE_OBJECT_WID(WTP);
	CW_FREE_OBJECT_WID(mac);
	
	return reply;	
}

//mahz add 2011.1.21
DBusMessage * wid_dbus_interface_show_radio_info_bywtpid_wid(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply; 
	DBusMessageIter  iter;
	DBusMessageIter  iter_array;
	DBusMessageIter iter_struct;
		
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	
	int i=0,/*j=0,*/k=0;			
	unsigned int WTPID = 0;
	
	WID_WTP_RADIO	**AC_RADIO_FOR_SEARCH = NULL;
	AC_RADIO_FOR_SEARCH = WID_MALLOC(L_RADIO_NUM*(sizeof(WID_WTP_RADIO *)));
	
	if (!(dbus_message_get_args ( msg, &err,DBUS_TYPE_UINT32,&WTPID,DBUS_TYPE_INVALID))){
		wid_syslog_debug_debug(WID_DBUS,"Unable to get input args\n");	
				
		if (dbus_error_is_set(&err)) {
			wid_syslog_debug_debug(WID_DBUS,"%s raised: %s",err.name,err.message);	
			dbus_error_free(&err);
		}
		CW_FREE_OBJECT_WID(AC_RADIO_FOR_SEARCH);
		return NULL;
	}
	CWThreadMutexLock(&(gWTPs[WTPID].WTPThreadMutex));//fengwenchao add 20121123 for AXSSZFI-1050
	ret = WID_CHECK_WTP_ID(WTPID);
	CWThreadMutexUnlock(&(gWTPs[WTPID].WTPThreadMutex));
	if(ret != 0)
	{	
		reply = dbus_message_new_method_return(msg);		
		dbus_message_iter_init_append (reply, &iter);
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret); 		
	}else{
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append (reply, &iter);
		
		dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &ret);
	
		unsigned char num_of_radio = 0;
	
		memset(AC_RADIO_FOR_SEARCH,0,L_RADIO_NUM*(sizeof(WID_WTP_RADIO *)));
		num_of_radio = WID_WTP_FIND_RADIO(AC_RADIO_FOR_SEARCH,AC_WTP[WTPID]);				
		//printf("num_of_radio = %d\n",num_of_radio);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(num_of_radio));

		dbus_message_iter_open_container (&iter,
											   DBUS_TYPE_ARRAY,
													DBUS_STRUCT_BEGIN_CHAR_AS_STRING
														DBUS_TYPE_UINT32_AS_STRING		//data
														DBUS_TYPE_UINT32_AS_STRING
														
														DBUS_TYPE_UINT32_AS_STRING		//sub_rx_pkt_mgmt
														DBUS_TYPE_UINT32_AS_STRING		//sub_tx_pkt_mgmt
														
														DBUS_TYPE_UINT32_AS_STRING		//sub_tx_pkt_control 
														DBUS_TYPE_UINT32_AS_STRING		//sub_rx_pkt_control
														DBUS_TYPE_UINT32_AS_STRING		//radio id
												DBUS_STRUCT_END_CHAR_AS_STRING,
											   &iter_array);

		for(k = 0; k < num_of_radio; k++){
			
			unsigned int	sub_rx_pkt_data = 0;
			unsigned int	sub_tx_pkt_data = 0;
							
			unsigned int sub_rx_pkt_mgmt = 0;  // packets received of management
			unsigned int sub_tx_pkt_mgmt = 0;	// packets transtmitted of management

			unsigned int sub_tx_pkt_control = 0; //zhangshu add 2010-10-11
			unsigned int sub_rx_pkt_control = 0; //zhangshu add 2010-10-11

			for(i=0;i<TOTAL_AP_IF_NUM;i++){
				if((AC_WTP[WTPID]->apstatsinfo[i].type == 0)
					&&(AC_WTP[WTPID]->apstatsinfo[i].radioId == AC_RADIO_FOR_SEARCH[k]->Radio_L_ID )){
				
				sub_rx_pkt_data += AC_WTP[WTPID]->apstatsinfo[i].rx_pkt_data;						
				sub_tx_pkt_data += AC_WTP[WTPID]->apstatsinfo[i].tx_pkt_data;
				
				sub_rx_pkt_mgmt += AC_WTP[WTPID]->apstatsinfo[i].rx_pkt_mgmt;
				sub_tx_pkt_mgmt += AC_WTP[WTPID]->apstatsinfo[i].tx_pkt_mgmt;
				
				sub_tx_pkt_control += AC_WTP[WTPID]->apstatsinfo[i].tx_pkt_control;
				sub_rx_pkt_control += AC_WTP[WTPID]->apstatsinfo[i].rx_pkt_control;
				}
			}
			
			dbus_message_iter_open_container (&iter_array, DBUS_TYPE_STRUCT, NULL, &iter_struct);
					
			dbus_message_iter_append_basic	 (&iter_struct, DBUS_TYPE_UINT32, &(sub_rx_pkt_data));								
			dbus_message_iter_append_basic	 (&iter_struct, DBUS_TYPE_UINT32, &(sub_tx_pkt_data));
				
			dbus_message_iter_append_basic	(&iter_struct, 	DBUS_TYPE_UINT32, &(sub_rx_pkt_mgmt));
			dbus_message_iter_append_basic	(&iter_struct,  DBUS_TYPE_UINT32, &(sub_tx_pkt_mgmt));

			dbus_message_iter_append_basic	(&iter_struct,	DBUS_TYPE_UINT32, &(sub_rx_pkt_control));
			dbus_message_iter_append_basic	(&iter_struct, 	DBUS_TYPE_UINT32, &(sub_tx_pkt_control));
			dbus_message_iter_append_basic	 (&iter_struct, DBUS_TYPE_UINT32, &(AC_RADIO_FOR_SEARCH[k]->Radio_G_ID));
/*
			printf("k= %d, radio_id= %d\n",k,AC_RADIO_FOR_SEARCH[k]->Radio_G_ID);
			printf("sub_rx_pkt_data= %d\n",sub_rx_pkt_data);
			printf("sub_rx_pkt_mgmt= %d\n",sub_rx_pkt_mgmt);
			printf("sub_rx_pkt_control= %d\n",sub_rx_pkt_control);
*/			
			dbus_message_iter_close_container (&iter_array, &iter_struct);
		}
	dbus_message_iter_close_container (&iter, &iter_array);
	}
				
	CW_FREE_OBJECT_WID(AC_RADIO_FOR_SEARCH);

	return reply;	
}
DBusMessage * wid_dbus_interface_bss_add_mac_list(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply; 
	DBusMessageIter  iter;
		
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	
	int i=0;			
	unsigned int radioid=0;
	unsigned char wlanid=0;
	unsigned char list_type = 0 ; 
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(WID_MAC_LEN);
	if(NULL == mac)
		return NULL;
	memset(mac,0,WID_MAC_LEN);
	
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_BYTE,&list_type,
								DBUS_TYPE_BYTE,&mac[0],
								DBUS_TYPE_BYTE,&mac[1],
								DBUS_TYPE_BYTE,&mac[2],
								DBUS_TYPE_BYTE,&mac[3],
								DBUS_TYPE_BYTE,&mac[4],
								DBUS_TYPE_BYTE,&mac[5],
								DBUS_TYPE_INVALID))){
		wid_syslog_debug_debug(WID_DBUS,"Unable to get input args\n");	
				
		if (dbus_error_is_set(&err)) {
			wid_syslog_debug_debug(WID_DBUS,"%s raised: %s",err.name,err.message);	
			dbus_error_free(&err);
		}
		WID_FREE(mac);
		mac = NULL;
		return NULL;
	}
	if(AC_WLAN[wlanid] == NULL)
		ret = WLAN_ID_NOT_EXIST;
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else	if(AC_RADIO[radioid] != NULL){
		for(i = 0; i < L_BSS_NUM; i++){
			if((AC_RADIO[radioid] != NULL)&&(AC_RADIO[radioid]->BSS[i] != NULL)&&(AC_BSS[radioid*L_BSS_NUM+i] != NULL)&&(AC_RADIO[radioid]->BSS[i]->WlanID ==	wlanid)){
				if((ret = add_mac_in_maclist(&AC_BSS[radioid*L_BSS_NUM+i] ->acl_conf,mac,list_type)) == -1)
						wid_syslog_debug_debug(WID_DBUS,"wid add sta mac list error!\n ");
				if (ret == 1 )
				   ret	= WID_MAC_ADD_ALREADY;
				else if(AC_BSS[radioid*L_BSS_NUM+i] ->State != 1)
				{
					ret = BSS_NOT_ENABLE;
					
					wid_syslog_debug_debug(WID_DBUS,"bss is not enable!\n ");
				}
				
				if(ret == 1)
					ret = WID_MAC_ADD_ALREADY;
				break;
			}
			ret = BSS_NOT_EXIST;
		}	
	}
	else 
		ret = RADIO_ID_NOT_EXIST;
	reply = dbus_message_new_method_return(msg);		
	dbus_message_iter_init_append (reply, &iter);
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret); 		

	return reply;	
}
//weichao add 
DBusMessage * wid_dbus_interface_bss_del_mac_list(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply; 
	DBusMessageIter  iter;
		
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	
	int i=0;			
	unsigned int radioid=0;
	unsigned char wlanid=0;
	unsigned char list_type = 0 ; 
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(WID_MAC_LEN);
	if(NULL == mac)
		return NULL;
	memset(mac,0,WID_MAC_LEN);
	
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_BYTE,&list_type,
								DBUS_TYPE_BYTE,&mac[0],
								DBUS_TYPE_BYTE,&mac[1],
								DBUS_TYPE_BYTE,&mac[2],
								DBUS_TYPE_BYTE,&mac[3],
								DBUS_TYPE_BYTE,&mac[4],
								DBUS_TYPE_BYTE,&mac[5],
								DBUS_TYPE_INVALID))){
		wid_syslog_debug_debug(WID_DBUS,"Unable to get input args\n");	
				
		if (dbus_error_is_set(&err)) {
			wid_syslog_debug_debug(WID_DBUS,"%s raised: %s",err.name,err.message);	
			dbus_error_free(&err);
		}
		WID_FREE(mac);
		mac = NULL;
		return NULL;
	}
	if(AC_WLAN[wlanid] == NULL)
		ret = WLAN_ID_NOT_EXIST;
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else	if(AC_RADIO[radioid] != NULL){
		for(i = 0; i < L_BSS_NUM; i++){
			if((AC_RADIO[radioid] != NULL)&&(AC_RADIO[radioid]->BSS[i] != NULL)&&(AC_BSS[radioid*L_BSS_NUM+i] != NULL)&&(AC_RADIO[radioid]->BSS[i]->WlanID ==	wlanid)){
				if((ret = del_mac_in_maclist(&AC_BSS[radioid*L_BSS_NUM+i] ->acl_conf,mac,list_type)) == -1)
				{
					wid_syslog_debug_debug(WID_DBUS,"the mac is not in the list!\n ");
					ret = WID_UNKNOWN_ID;
				}
				if(ret != WID_UNKNOWN_ID){//qiuchen add it 
				if(AC_BSS[radioid*L_BSS_NUM+i] ->State != 1)
				{
					ret = BSS_NOT_ENABLE;
					
					wid_syslog_debug_debug(WID_DBUS,"bss is not enable!\n ");
				}
				}
				break;
			}
			ret = BSS_NOT_EXIST;
		}	
	}	
	else 
		ret = RADIO_ID_NOT_EXIST;
	reply = dbus_message_new_method_return(msg);		
	dbus_message_iter_init_append (reply, &iter);
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret); 		

	return reply;	
}
DBusMessage *wid_dbus_interface_bss_use_mac_list(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 	
	DBusMessageIter  iter;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;

	unsigned int radioid=0;
	unsigned char list_type=0;	//0--none,1--black list, 2--white list
	unsigned char wlanid=0;		
	int i = 0;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_BYTE,&list_type,
								DBUS_TYPE_INVALID))){
				
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return NULL;
	}
	wid_syslog_debug_debug(WID_DBUS,"now in func:%s\n",__func__);
	if(AC_WLAN[wlanid] == NULL)
		ret = WLAN_ID_NOT_EXIST;
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else if(AC_RADIO[radioid] != NULL){
		for(i = 0; i < L_BSS_NUM; i++){
			if((AC_RADIO[radioid] != NULL)&&(AC_RADIO[radioid]->BSS[i] != NULL)&&(AC_BSS[radioid*L_BSS_NUM+i] != NULL)&&(AC_RADIO[radioid]->BSS[i]->WlanID ==	wlanid))
			{
			
				wid_syslog_debug_debug(WID_DBUS,"AC_BSS[radioid*L_BSS_NUM+i] ->State  :%d\n",AC_BSS[radioid*L_BSS_NUM+i] ->State );
				 if((ret = change_maclist_security(&AC_BSS[radioid*L_BSS_NUM+i]->acl_conf,list_type))!=0)
						wid_syslog_debug_debug(WID_DBUS,"change mac list failed\n");
				 if(AC_BSS[radioid*L_BSS_NUM+i] ->State != 1)	
				 {	 
					 ret = BSS_NOT_ENABLE;
					 wid_syslog_debug_debug(WID_DBUS,"bss is not enable!\n ");
				 }
				break;
			}
			ret = BSS_NOT_EXIST;
		}	
	}
	else 
		ret = RADIO_ID_NOT_EXIST;

	reply = dbus_message_new_method_return(msg);
			
	dbus_message_iter_init_append (reply, &iter);	

	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 

	return reply;	
}
//mahz add 2011.5.12
DBusMessage * wid_dbus_interface_check_bss_exist(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply; 
	DBusMessageIter  iter;
		
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	
	int i=0,flag=0;			
	unsigned int radioid=0;
	unsigned char wlanid=0;
	
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_INVALID))){
		wid_syslog_debug_debug(WID_DBUS,"Unable to get input args\n");	
				
		if (dbus_error_is_set(&err)) {
			wid_syslog_debug_debug(WID_DBUS,"%s raised: %s",err.name,err.message);	
			dbus_error_free(&err);
		}
		return NULL;
	}

	for(i = 0; i < L_BSS_NUM; i++){
		if((AC_RADIO[radioid] != NULL)&&(AC_RADIO[radioid]->BSS[i] != NULL)&&(AC_BSS[radioid*L_BSS_NUM+i] != NULL)&&(AC_RADIO[radioid]->BSS[i]->WlanID ==	wlanid)){
			flag = 1;
			break;
		}
	}
	if(flag == 0)
		ret = BSS_NOT_EXIST;
	
	reply = dbus_message_new_method_return(msg);		
	dbus_message_iter_init_append (reply, &iter);
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret); 		

	return reply;	
}
DBusMessage *wid_dbus_interface_dbus_show_bss_mac_list(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;
	DBusMessageIter  iter;
	DBusMessageIter	 iter_array;
	DBusError err;

	int ret = WID_DBUS_SUCCESS;
	struct acl_config *conf;
	unsigned int radioid=0;
	unsigned int bssindex=0;
	unsigned char wlanid=0;
	int i=0;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_INVALID))){
	
		wid_syslog_debug_debug(WID_DBUS,"Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			wid_syslog_debug_debug(WID_DBUS,"%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
	
	for(i=radioid*L_BSS_NUM; i<(radioid+1)*L_BSS_NUM; i++){
		if((AC_BSS[i] != NULL)&&(AC_BSS[i]->WlanID == wlanid)){
			if (((AC_WLAN[wlanid] != NULL) && (AC_WLAN[wlanid]->want_to_delete == 1)))		/* Huangleilei add for ASXXZFI-1622, check for AXSSZFI-1701 */
			{
				continue;
			}
			bssindex = i;
			break;
		}
	}
	
	if(radioid >= G_RADIO_NUM){
		ret = RADIO_ID_LARGE_THAN_MAX;
		dbus_message_iter_append_basic (&iter,
											DBUS_TYPE_UINT32,
											&ret); 
	}
	else if(bssindex == 0){
		ret = BSS_NOT_EXIST;
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 
	}
	else {
		dbus_message_iter_append_basic (&iter,
										DBUS_TYPE_UINT32,
										&ret); 
	
		dbus_message_iter_open_container (&iter,
										   DBUS_TYPE_ARRAY,
										   DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_UINT32_AS_STRING
												DBUS_TYPE_UINT32_AS_STRING
												DBUS_TYPE_UINT32_AS_STRING
												DBUS_TYPE_ARRAY_AS_STRING
													DBUS_STRUCT_BEGIN_CHAR_AS_STRING
														DBUS_TYPE_BYTE_AS_STRING
														DBUS_TYPE_BYTE_AS_STRING
														DBUS_TYPE_BYTE_AS_STRING
														DBUS_TYPE_BYTE_AS_STRING
														DBUS_TYPE_BYTE_AS_STRING
														DBUS_TYPE_BYTE_AS_STRING
													DBUS_STRUCT_END_CHAR_AS_STRING
										   DBUS_STRUCT_END_CHAR_AS_STRING,
										   &iter_array);
		{
		DBusMessageIter iter_struct;
		DBusMessageIter iter_sub_array;
		conf = AC_BSS[bssindex]->acl_conf;
		
		dbus_message_iter_open_container (&iter_array,
										   DBUS_TYPE_STRUCT,
										   NULL,
										   &iter_struct);
		
		dbus_message_iter_append_basic (&iter_struct,
										 DBUS_TYPE_UINT32,
										 &conf->macaddr_acl);
		
		dbus_message_iter_append_basic (&iter_struct,
										 DBUS_TYPE_UINT32,
										 &conf->num_deny_mac);
		
		dbus_message_iter_append_basic (&iter_struct,
										 DBUS_TYPE_UINT32,
										 &conf->num_accept_mac);
		
		dbus_message_iter_open_container (&iter_struct,
										   DBUS_TYPE_ARRAY,
										   DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											   DBUS_TYPE_BYTE_AS_STRING
											   DBUS_TYPE_BYTE_AS_STRING
											   DBUS_TYPE_BYTE_AS_STRING
											   DBUS_TYPE_BYTE_AS_STRING
											   DBUS_TYPE_BYTE_AS_STRING
											   DBUS_TYPE_BYTE_AS_STRING
											DBUS_STRUCT_END_CHAR_AS_STRING,
										   &iter_sub_array);
		for(i=0; i<2; i++){
			struct maclist *entry;
			if(i == 0)
				entry = conf->deny_mac;
			else 
				entry = conf->accept_mac;
			
			while (entry) {
				unsigned char  *addr = entry->addr;
				DBusMessageIter iter_sub_struct;
				dbus_message_iter_open_container (&iter_sub_array,
												   DBUS_TYPE_STRUCT,
												   NULL,
												   &iter_sub_struct);
				dbus_message_iter_append_basic
						(&iter_sub_struct,
						  DBUS_TYPE_BYTE,
						  &(addr[0]));
				
				dbus_message_iter_append_basic
						(&iter_sub_struct,
						  DBUS_TYPE_BYTE,
						  &(addr[1]));

				dbus_message_iter_append_basic
						(&iter_sub_struct,
						  DBUS_TYPE_BYTE,
						  &(addr[2]));

				dbus_message_iter_append_basic
						(&iter_sub_struct,
						  DBUS_TYPE_BYTE,
						  &(addr[3]));

				dbus_message_iter_append_basic
						(&iter_sub_struct,
						  DBUS_TYPE_BYTE,
						  &(addr[4]));

				dbus_message_iter_append_basic
						(&iter_sub_struct,
						  DBUS_TYPE_BYTE,
					 	  &(addr[5]));
				
				dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);
				
				entry = entry->next;
			}
		}

		dbus_message_iter_close_container (&iter_struct, &iter_sub_array);			
		dbus_message_iter_close_container (&iter_array, &iter_struct);
		}
		dbus_message_iter_close_container (&iter, &iter_array);
	}
	return reply;

}

//
/*liuzhenhua add 2010-07-30*/
DBusMessage * wid_dbus_show_ssid_config_information_of_all_wlan(DBusConnection *conn, DBusMessage 

*msg, void *user_data){

	
		DBusMessage* reply; 
		DBusMessageIter  iter;
		DBusMessageIter  iter_array;
		DBusMessageIter iter_wlan;
		DBusMessageIter iter_wlan_essid_array;
		DBusMessageIter iter_wlan_essid_struct;
		DBusError err;
		dbus_error_init(&err);
		int ret = WID_DBUS_SUCCESS;
		
		unsigned int wlan_num = 0;
		int i=0;
		int j =0;
		struct wlan *WLAN[WLAN_NUM]={0};
		for(i=0;i<WLAN_NUM;i++){
			if(AC_WLAN[i]!=NULL && (AC_WLAN[i]->want_to_delete != 1)){		/* Huangleilei add for ASXXZFI-1622 */
				WLAN[wlan_num]=AC_WLAN[i];
				wlan_num++;
				}
			}
		if(wlan_num==0)
			ret=WLAN_ID_NOT_EXIST;
		reply=dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply,&iter);

		dbus_message_iter_append_basic(&iter,
										DBUS_TYPE_UINT32,
										&ret);
		dbus_message_iter_append_basic(&iter,
										DBUS_TYPE_UINT32,
										&wlan_num);
		dbus_message_iter_open_container(&iter,
											DBUS_TYPE_ARRAY,
											DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_UINT32_AS_STRING	//wlancurrid; ---------------1
												//DBUS_TYPE_STRING_AS_STRING	//*NewSSIDName
												DBUS_TYPE_ARRAY_AS_STRING
												DBUS_STRUCT_BEGIN_CHAR_AS_STRING
													DBUS_TYPE_BYTE_AS_STRING   //*NewSSIDName
												DBUS_STRUCT_END_CHAR_AS_STRING												
												DBUS_TYPE_UINT32_AS_STRING	//NewSSIDEnabled
												DBUS_TYPE_UINT32_AS_STRING	//NewSSIDHidden;
												DBUS_TYPE_UINT32_AS_STRING	//NewStaIsolate;;-----------5
												DBUS_TYPE_UINT32_AS_STRING	//NewDot11Auth;
												DBUS_TYPE_UINT32_AS_STRING	//Newsecurity;	
												DBUS_TYPE_UINT32_AS_STRING	//NewAuthenMode;
												DBUS_TYPE_UINT32_AS_STRING	//NewSecurityCiphers
												DBUS_TYPE_UINT32_AS_STRING	//NewVlanId;
												DBUS_TYPE_UINT32_AS_STRING	//NewMaxSimultUsers;--------10
												DBUS_TYPE_UINT32_AS_STRING	//NewStaUplinkMaxRate;
												DBUS_TYPE_UINT32_AS_STRING	//NewStaDwlinkMaxRate;
												DBUS_TYPE_UINT32_AS_STRING	//Security_id;
												DBUS_TYPE_UINT32_AS_STRING	//no_flow_time;
												//DBUS_TYPE_UINT32_AS_STRING	//SSIDRowStatus;
											DBUS_STRUCT_END_CHAR_AS_STRING,
										&iter_array);
		long wlan_id;
		unsigned int security_id;
		long ssidenabled;
		long NewSSIDHidden;		//WLAN wlan.HideESSid
		long NewStaIsolate;		/*(bridge isolation), conflict with sameportswitch*/
		long NewDot11Auth;		//802.11 1
		long Newsecurity;		//
		long NewAuthenMode;		//
		long NewSecurityCiphers;	// 2 

		for(i=0;i<wlan_num;i++){
			wlan_id=WLAN[i]->WlanID;
			ssidenabled= (WLAN[i]->Status ==1) ? 0:1;
			NewSSIDHidden=WLAN[i]->HideESSid;
			NewStaIsolate=WLAN[i]->isolation_policy;		/*xiaodawei modify, bridge isolation, 20101221*/
			security_id = WLAN[i]->SecurityID;
			
			switch(WLAN[i]->SecurityType){
				case 0: 	//OPEN:
					NewDot11Auth = 1;
					Newsecurity = 1;
					NewAuthenMode = 1;
					break;
				case 1:		//SHARED:
					NewDot11Auth = 2;
					Newsecurity = 1;
					NewAuthenMode = 1;
					break;
				case 2: 	//IEEE8021X:
					NewDot11Auth = 2;
					Newsecurity = 3;
					NewAuthenMode = 3;
					break;
				case 3:		//WPA_P:
					NewDot11Auth = 1;
					Newsecurity = 2;
					NewAuthenMode = 2;
					break;
				case 4:		//WPA2_P:
					NewDot11Auth = 1;
					Newsecurity = 3;
					NewAuthenMode = 2;
					break;
				case 5:		//WPA_E:
					NewDot11Auth = 1;
					Newsecurity = 2;
					NewAuthenMode = 3;
					break;
				case 6:		//WPA2_E:
					NewDot11Auth = 1;
					Newsecurity = 3;
					NewAuthenMode =3;
					break;
				case 7:		//MD5:
					NewDot11Auth = 1;
					Newsecurity = 4;
					NewAuthenMode = 2;
					break;
				case 8:		//WAPI_PSK:
					NewDot11Auth = 1;
					Newsecurity = 4;
					NewAuthenMode = 2;
					break;
				default:
					NewDot11Auth = 1;
					Newsecurity = 4;
					NewAuthenMode = 4;
					break;
				}
			switch(WLAN[i]->EncryptionType){
				case 0:		//NONE:
					NewSecurityCiphers = 1;;break;
				case 1:		//WEP:
					NewSecurityCiphers = 2;;break;
				case 2:		//AES: 
					NewSecurityCiphers = 4;;break;
				case 3:		//TKIP:
					NewSecurityCiphers = 5;;break;
				case 4:		//SMS4:
					NewSecurityCiphers = 6;;break;
				default:
					NewSecurityCiphers = 0;
					break;
				}


			dbus_message_iter_open_container(&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_wlan);

			dbus_message_iter_append_basic(&iter_wlan,DBUS_TYPE_UINT32,&wlan_id);/*1*/

			//dbus_message_iter_append_basic(&iter_wlan,DBUS_TYPE_STRING,&(WLAN[i]->ESSID));
			dbus_message_iter_open_container (&iter_wlan,
									   DBUS_TYPE_ARRAY,
									   DBUS_STRUCT_BEGIN_CHAR_AS_STRING  
										  DBUS_TYPE_BYTE_AS_STRING
									   DBUS_STRUCT_END_CHAR_AS_STRING, 
									   &iter_wlan_essid_array);
				for(j=0;j<ESSID_DEFAULT_LEN;j++)
				{				
					dbus_message_iter_open_container (&iter_wlan_essid_array,
														DBUS_TYPE_STRUCT,
														NULL,
													  &iter_wlan_essid_struct);
					dbus_message_iter_append_basic
								(&iter_wlan_essid_struct,
								  DBUS_TYPE_BYTE,
								  &WLAN[i]->ESSID[j]);
					dbus_message_iter_close_container (&iter_wlan_essid_array, &iter_wlan_essid_struct);
				}
			dbus_message_iter_close_container (&iter_wlan, &iter_wlan_essid_array);				
			dbus_message_iter_append_basic(&iter_wlan,DBUS_TYPE_UINT32,&ssidenabled);
			dbus_message_iter_append_basic(&iter_wlan,DBUS_TYPE_UINT32,&NewSSIDHidden);
			dbus_message_iter_append_basic(&iter_wlan,DBUS_TYPE_UINT32,&NewStaIsolate);/*5*/
			dbus_message_iter_append_basic(&iter_wlan,DBUS_TYPE_UINT32,&NewDot11Auth);
			dbus_message_iter_append_basic(&iter_wlan,DBUS_TYPE_UINT32,&Newsecurity);
			dbus_message_iter_append_basic(&iter_wlan,DBUS_TYPE_UINT32,&NewAuthenMode);
			dbus_message_iter_append_basic(&iter_wlan,DBUS_TYPE_UINT32,&NewSecurityCiphers);
			dbus_message_iter_append_basic(&iter_wlan,DBUS_TYPE_UINT32,&(WLAN[i]->vlanid));
			dbus_message_iter_append_basic(&iter_wlan,DBUS_TYPE_UINT32,&(WLAN[i]->wlan_max_allowed_sta_num));/*10*/
			dbus_message_iter_append_basic(&iter_wlan,DBUS_TYPE_UINT32,&(WLAN[i]->wlan_traffic_limit));
			dbus_message_iter_append_basic(&iter_wlan,DBUS_TYPE_UINT32,&(WLAN[i]->wlan_send_traffic_limit));
			dbus_message_iter_append_basic(&iter_wlan,DBUS_TYPE_UINT32,&security_id);
			dbus_message_iter_append_basic(&iter_wlan,DBUS_TYPE_UINT32,&(WLAN[i]->no_flow_time));

			dbus_message_iter_close_container(&iter_array,&iter_wlan);

			}
		dbus_message_iter_close_container(&iter,&iter_array);

		return reply;
}

/*liuzhenhua append 2010-05-10*/
/*mib table 24*/
DBusMessage * wid_dbus_interface_show_wtp_wlan_data_pkts_information(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter iter_wtp_array;
	DBusMessageIter iter_wtp;
	DBusMessageIter iter_wlan_array;
	DBusMessageIter	iter_wlan;
	
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int wtp_num=0;
	unsigned int wlan_num=0;
	unsigned int radiocount=0;
	int i=0,j=0,k=0,kk=0;
	int m =0;
	char  wtp_mac[18]={0};	
	char * wtp_mac_p=wtp_mac;
	unsigned int wlanID[WLAN_NUM];
	WID_WTP **WTP = NULL;
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	if( WTP == NULL){
		wid_syslog_debug_debug(WID_DBUS,"%s :malloc fail.\n",__func__);
		return NULL;
	}
	memset(WTP,0,WTP_NUM*(sizeof(WID_WTP *)));
	
	wtp_num = Wid_Find_Wtp(WTP);
	
	if(wtp_num == 0)
		ret =WTP_ID_NOT_EXIST;

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &wtp_num);
	dbus_message_iter_open_container(&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
										DBUS_TYPE_UINT32_AS_STRING //WTPID
										DBUS_TYPE_STRING_AS_STRING //wtp_mat_p
										DBUS_TYPE_UINT32_AS_STRING //wlan_num
										
										DBUS_TYPE_ARRAY_AS_STRING
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING //wlanid
											DBUS_TYPE_UINT64_AS_STRING //tx_bytes
											DBUS_TYPE_UINT64_AS_STRING //rx_bytes
											DBUS_TYPE_UINT64_AS_STRING //tx_sum_bytes
											DBUS_TYPE_UINT64_AS_STRING //rx_sum_bytes
											DBUS_TYPE_UINT32_AS_STRING //tx_pkt_data
											DBUS_TYPE_UINT32_AS_STRING //rx_pkt_data
											DBUS_TYPE_UINT32_AS_STRING //rx_pkts
											DBUS_TYPE_UINT32_AS_STRING //tx_pkts
											DBUS_TYPE_UINT32_AS_STRING //rx_errors
											DBUS_TYPE_UINT32_AS_STRING //tx_errors
											DBUS_TYPE_UINT32_AS_STRING//tx_pkt_retry
											DBUS_TYPE_UINT32_AS_STRING //rx_rate
											DBUS_TYPE_UINT32_AS_STRING //tx_rate
											DBUS_TYPE_UINT32_AS_STRING//tx_broadcast_pkt
											DBUS_TYPE_UINT32_AS_STRING	//tx_drop
											DBUS_TYPE_UINT32_AS_STRING	//rx_drop
										DBUS_STRUCT_END_CHAR_AS_STRING 
										
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_wtp_array);
	struct wlanid * wlanid_node;
	//struct wlanid * wlanid_list=NULL;
	//struct wlanid * wlanid_tail=NULL;
	unsigned int wlan_id;
	unsigned long long tx_bytes;
	unsigned long long rx_bytes;
	unsigned long long tx_sum_bytes;	/*xiaodawei append, 20101116*/
	unsigned long long rx_sum_bytes;
	unsigned int tx_pkt_data;
	unsigned int rx_pkt_data;			/*#######END#######*/
	unsigned int rx_pkts;
	unsigned int tx_pkts;
	unsigned int rx_errors;
	unsigned int tx_errors;
	unsigned int tx_pkt_retry = 0;	//xiaodawei add, 20110425
	unsigned int rx_rate;
	unsigned int tx_rate;
	unsigned int tx_broadcast_pkts;
	unsigned int tx_drop = 0;
	unsigned int rx_drop = 0;
	
	for(i=0;i<wtp_num;i++){
		
		wlan_num=0;
		//wlanid_list=NULL;
		//wlanid_tail=NULL;
		for(j=0;j<WTP[i]->RadioCount;j++){
			wlanid_node=WTP[i]->WTP_Radio[j]->Wlan_Id;
			while(wlanid_node){
				/*
				if(!wlanid_list){
					wlanid_list=wlanid_node;
					wlanid_tail=wlanid_node;
					}
				else{
					wlanid_tail->next=wlanid_node;
					wlanid_tail=wlanid_tail;
					}*/
				if (AC_WLAN[wlanid_node->wlanid] != NULL && AC_WLAN[wlanid_node->wlanid]->want_to_delete != 1)		/* Huangleilei add for ASXXZFI-1622 */
				wlanID[wlan_num] = wlanid_node->wlanid;
				wlan_num++;
				wlanid_node=wlanid_node->next;
				}
			}
		memset(wtp_mac,0,18);
		sprintf(wtp_mac,"%02X:%02X:%02X:%02X:%02X:%02X",
			WTP[i]->WTPMAC[0],WTP[i]->WTPMAC[1],WTP[i]->WTPMAC[2],
			WTP[i]->WTPMAC[3],WTP[i]->WTPMAC[4],WTP[i]->WTPMAC[5]);
		dbus_message_iter_open_container(&iter_wtp_array,DBUS_TYPE_STRUCT,NULL,&iter_wtp);
		dbus_message_iter_append_basic (&iter_wtp,DBUS_TYPE_UINT32,&WTP[i]->WTPID);
		dbus_message_iter_append_basic (&iter_wtp,DBUS_TYPE_STRING,&wtp_mac_p);
		dbus_message_iter_append_basic (&iter_wtp,DBUS_TYPE_UINT32,&wlan_num);
		
		dbus_message_iter_open_container(&iter_wtp,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
										DBUS_TYPE_UINT32_AS_STRING //wlanid
										DBUS_TYPE_UINT64_AS_STRING //tx_bytes
										DBUS_TYPE_UINT64_AS_STRING //rx_bytes
										DBUS_TYPE_UINT64_AS_STRING //tx_sum_bytes
										DBUS_TYPE_UINT64_AS_STRING //rx_sum_bytes
										DBUS_TYPE_UINT32_AS_STRING //tx_pkt_data
										DBUS_TYPE_UINT32_AS_STRING //rx_pkt_data
										DBUS_TYPE_UINT32_AS_STRING //rx_pkts
										DBUS_TYPE_UINT32_AS_STRING //tx_pkts
										DBUS_TYPE_UINT32_AS_STRING //rx_errors
										DBUS_TYPE_UINT32_AS_STRING //tx_errors
										DBUS_TYPE_UINT32_AS_STRING//tx_pkt_retry
										DBUS_TYPE_UINT32_AS_STRING //rx_rate
										DBUS_TYPE_UINT32_AS_STRING //tx_rate
										DBUS_TYPE_UINT32_AS_STRING//tx_broadcast_pkt
										DBUS_TYPE_UINT32_AS_STRING	//tx_drop
										DBUS_TYPE_UINT32_AS_STRING	//rx_drop
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_wlan_array);
		
		for(m=0;m< wlan_num;m++){
			wlan_id=wlanID[m];
			radiocount=0;
			for(k=0; k<TOTAL_AP_IF_NUM; k++){
					if(WTP[i]->apstatsinfo[k].radioId < TOTAL_AP_IF_NUM+1){
						radiocount++;
						if(WTP[i]->apstatsinfo[k].wlanId == wlan_id){
							kk = k;
							break;
						}
					}
				}
			
			if((radiocount >0) && (kk <TOTAL_AP_IF_NUM) &&(WTP[i]->apstatsinfo[kk].type==0)){
				tx_bytes	= WTP[i]->apstatsinfo[kk].tx_bytes;
				rx_bytes	= WTP[i]->apstatsinfo[kk].rx_bytes;
				tx_sum_bytes = WTP[i]->apstatsinfo[kk].tx_sum_bytes;		/*xiaodawei add, 20101116*/
				rx_sum_bytes = WTP[i]->apstatsinfo[kk].rx_sum_bytes;
				tx_pkt_data = WTP[i]->apstatsinfo[kk].tx_pkt_data;
				rx_pkt_data = WTP[i]->apstatsinfo[kk].rx_pkt_data;		/*######END######*/
				rx_pkts		= WTP[i]->apstatsinfo[kk].rx_packets;
				tx_pkts		= WTP[i]->apstatsinfo[kk].tx_packets;
				rx_errors	= WTP[i]->apstatsinfo[kk].rx_errors;
				tx_errors	= WTP[i]->apstatsinfo[kk].tx_errors;
				tx_pkt_retry	= WTP[i]->apstatsinfo[kk].tx_pkt_retry;
				rx_rate		= WTP[i]->apstatsinfo[kk].rx_rate;
				tx_rate		= WTP[i]->apstatsinfo[kk].tx_rate;	
				tx_broadcast_pkts = WTP[i]->apstatsinfo[kk].tx_pkt_broadcast;
				tx_drop     = WTP[i]->apstatsinfo[kk].tx_drop;
				rx_drop     = WTP[i]->apstatsinfo[kk].rx_drop;
				}
			else{
				tx_bytes	= 0;
				rx_bytes	= 0;
				tx_sum_bytes= 0;		/*xiaodawei add, 20101116*/
				rx_sum_bytes= 0;
				tx_pkt_data = 0;
				rx_pkt_data = 0;		/*######END######*/
				rx_pkts		= 0;
				tx_pkts		= 0;
				rx_errors	= 0;
				tx_errors	= 0;
				tx_pkt_retry	= 0;
				rx_rate		= 0;
				tx_rate		= 0;
				tx_broadcast_pkts = 0;
				tx_drop = 0;
				tx_drop = 0;
				}
			dbus_message_iter_open_container(&iter_wlan_array,DBUS_TYPE_STRUCT,NULL,&iter_wlan);
			dbus_message_iter_append_basic (&iter_wlan,DBUS_TYPE_UINT32,&wlan_id);
			dbus_message_iter_append_basic (&iter_wlan,DBUS_TYPE_UINT64,&tx_bytes);
			dbus_message_iter_append_basic (&iter_wlan,DBUS_TYPE_UINT64,&rx_bytes);
			dbus_message_iter_append_basic (&iter_wlan,DBUS_TYPE_UINT64,&tx_sum_bytes);	/*xiaodawei add, 20101116*/
			dbus_message_iter_append_basic (&iter_wlan,DBUS_TYPE_UINT64,&rx_sum_bytes);
			dbus_message_iter_append_basic (&iter_wlan,DBUS_TYPE_UINT32,&tx_pkt_data);
			dbus_message_iter_append_basic (&iter_wlan,DBUS_TYPE_UINT32,&rx_pkt_data);	/*######END######*/
			dbus_message_iter_append_basic (&iter_wlan,DBUS_TYPE_UINT32,&rx_pkts);
			dbus_message_iter_append_basic (&iter_wlan,DBUS_TYPE_UINT32,&tx_pkts);
			dbus_message_iter_append_basic (&iter_wlan,DBUS_TYPE_UINT32,&rx_errors);
			dbus_message_iter_append_basic (&iter_wlan,DBUS_TYPE_UINT32,&tx_errors);
			dbus_message_iter_append_basic (&iter_wlan,DBUS_TYPE_UINT32,&tx_pkt_retry);
			dbus_message_iter_append_basic (&iter_wlan,DBUS_TYPE_UINT32,&rx_rate);
			dbus_message_iter_append_basic (&iter_wlan,DBUS_TYPE_UINT32,&tx_rate);
			dbus_message_iter_append_basic (&iter_wlan,DBUS_TYPE_UINT32,&tx_broadcast_pkts);
			dbus_message_iter_append_basic (&iter_wlan,DBUS_TYPE_UINT32,&tx_drop);
			dbus_message_iter_append_basic (&iter_wlan,DBUS_TYPE_UINT32,&rx_drop);
			
			dbus_message_iter_close_container(&iter_wlan_array,&iter_wlan);
			}
		dbus_message_iter_close_container(&iter_wtp,&iter_wlan_array);
		dbus_message_iter_close_container(&iter_wtp_array,&iter_wtp);
	}
	dbus_message_iter_close_container(&iter,&iter_wtp_array);

	CW_FREE_OBJECT_WID(WTP);
	
	return reply;
}
/*table 5*/
DBusMessage * wid_dbus_interface_show_wtp_device_information(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusMessageIter iter_struct;
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	
	int i=0;
	unsigned int wtp_num = 0;
	/*zhaoruijia,20100831,cpu_typemem_type, flash_type start*/
	char *cpu_type = NULL;
	char *mem_type = NULL;
	char *flash_type = NULL;
	cpu_type =(char*) WID_MALLOC(WTP_TYPE_DEFAULT_LEN+1);
	mem_type =(char*) WID_MALLOC(WTP_TYPE_DEFAULT_LEN+1);
	flash_type = (char*) WID_MALLOC(WTP_TYPE_DEFAULT_LEN+1);
	memset(cpu_type,0,WTP_TYPE_DEFAULT_LEN+1);
	memset(mem_type,0,WTP_TYPE_DEFAULT_LEN+1);
	memset(flash_type,0,WTP_TYPE_DEFAULT_LEN+1);
	/*zhaoruijia,20100831,cpu_typemem_type, flash_type end*/

	/*unsigned int wtp_cpu = 0;	
 	unsigned int wtp_memoryuse = 0;
	wtp_cpu = g_ap_cpu_threshold;
	wtp_memoryuse = g_ap_memuse_threshold;*/
	
	//char *code = NULL;
	unsigned char *mac = NULL;
	WID_WTP **WTP = NULL;
	unsigned char defalt_char = 0;
	unsigned int defalt_int = 0;
	unsigned short defalt_short = 0;
	char *wtp_ipv6_ip = NULL;
	wtp_ipv6_ip = (char *)WID_MALLOC(64);

	memset(wtp_ipv6_ip, '\0', 64);
	strncpy(wtp_ipv6_ip, "::/128:*****", strlen("::/128:*****"));

	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	//code = (char *)WID_MALLOC(sizeof(char)*128);
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	memset(WTP,0,WTP_NUM*(sizeof(WID_WTP *)));

	if(hide_quit_wtp_in_showting == 0){
		wtp_num = Wid_Find_Wtp(WTP);
	}
	else if (hide_quit_wtp_in_showting == 1){
		wtp_num = Wid_Find_Running_Wtp(WTP);
	}
	//wtp_num = Wid_Find_Wtp(WTP);
	
	if(wtp_num == 0)
		ret = WTP_ID_NOT_EXIST;

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	// Total slot count
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &wtp_num);

    if(wtp_num != 0)
    {
    	dbus_message_iter_open_container (&iter,
    									DBUS_TYPE_ARRAY,
    									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING		 //mac
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING

    											DBUS_TYPE_UINT32_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING

    											DBUS_TYPE_STRING_AS_STRING		//WTPModel
    											DBUS_TYPE_STRING_AS_STRING      //cpu_type
    											DBUS_TYPE_STRING_AS_STRING      //mem_type
    											DBUS_TYPE_STRING_AS_STRING      //flash_type

    											DBUS_TYPE_UINT32_AS_STRING		//a1
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_UINT16_AS_STRING
    											
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_UINT16_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING		//a6
    											DBUS_TYPE_BYTE_AS_STRING		//a7

    											DBUS_TYPE_UINT32_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING
    											
    											DBUS_TYPE_STRING_AS_STRING		//ip
    											DBUS_TYPE_STRING_AS_STRING		//IPV6
    											DBUS_TYPE_UINT32_AS_STRING
    									DBUS_STRUCT_END_CHAR_AS_STRING,
    									&iter_array);

    	for(i = 0; i < wtp_num; i++){		
    		memset(mac,0,MAC_LEN+1);
    		if(WTP[i]->WTPMAC != NULL)
    			memcpy(mac,WTP[i]->WTPMAC,MAC_LEN);
    		
    		dbus_message_iter_open_container (&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
    		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_UINT32,&(WTP[i]->WTPID));
    		
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_BYTE,&(mac[0]));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_BYTE,&(mac[1]));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_BYTE,&(mac[2]));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_BYTE,&(mac[3]));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_BYTE,&(mac[4]));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_BYTE,&(mac[5]));

    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_UINT32,
    										&(WTP[i]->wtp_cpu_use_threshold));

    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_UINT32,
    										&(WTP[i]->wtp_mem_use_threshold));
    		
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_STRING,&(WTP[i]->WTPModel));
			/*
    		CWThreadMutexLock(&(gAllThreadMutex));		
    		CWConfigVersionInfo *pnode = gConfigVersionInfo;

    		while(pnode != NULL)
    		{
    			if(strcmp(pnode->str_ap_model,WTP[i]->WTPModel) == 0){
    				break;
    			}
    			pnode = pnode->next;
    		}	
    		CWThreadMutexUnlock(&(gAllThreadMutex));		

    		if(pnode == NULL){
    			wid_syslog_debug_debug(WID_DBUS," 55555555 NULL pnode\n");
    			//cpu_type = 0;
    		}
    		
    		else{
    			memset(code,0,128);
    			if(strlen(pnode->str_ap_code) < 128)
    				memcpy(code,pnode->str_ap_code,strlen(pnode->str_ap_code));
    			else
    				memcpy(code,pnode->str_ap_code,127);
    			
               
    		}*/
    		memcpy(cpu_type,WTP[i]->cpuType,WTP_TYPE_DEFAULT_LEN);
    		memcpy(mem_type,WTP[i]->memType,WTP_TYPE_DEFAULT_LEN);
    		memcpy(flash_type,WTP[i]->flashType,WTP_TYPE_DEFAULT_LEN);

    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_STRING,&(cpu_type));
    		
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_STRING,&(mem_type));
    		
    		dbus_message_iter_append_basic(&iter_struct,
    									    DBUS_TYPE_STRING,&(flash_type));

    		if(1==WTP[i]->wifi_extension_reportswitch ){
    			dbus_message_iter_append_basic(&iter_struct,
    											DBUS_TYPE_UINT32, 
    											&(WTP[i]->wifi_extension_info.cpu));

    			dbus_message_iter_append_basic(&iter_struct, 
    											DBUS_TYPE_BYTE, 
    											&(WTP[i]->wifi_extension_info.ipmode));

    			dbus_message_iter_append_basic(&iter_struct, 
    											DBUS_TYPE_UINT16, 
    											&(WTP[i]->wifi_extension_info.memoryall));

    			dbus_message_iter_append_basic(&iter_struct, 
    											DBUS_TYPE_BYTE, 
    											&(WTP[i]->wifi_extension_info.memoryuse));

    			dbus_message_iter_append_basic(&iter_struct, 
    											DBUS_TYPE_UINT16, 
    											&(WTP[i]->wifi_extension_info.flashall));

    			dbus_message_iter_append_basic(&iter_struct, 
    											DBUS_TYPE_UINT32, 
    											&(WTP[i]->wifi_extension_info.flashempty));
    			
    			dbus_message_iter_append_basic(&iter_struct, 
    											DBUS_TYPE_BYTE, 
    											&(WTP[i]->wifi_extension_info.temperature));

    		}
    		else{
    				dbus_message_iter_append_basic(&iter_struct,
    														DBUS_TYPE_UINT32, &(defalt_int));
    				
    				dbus_message_iter_append_basic(&iter_struct, 
    														DBUS_TYPE_BYTE, &(defalt_char));
    				
    				dbus_message_iter_append_basic(&iter_struct, 
    														DBUS_TYPE_UINT16, &(defalt_short));
    				
    				dbus_message_iter_append_basic(&iter_struct, 
    														DBUS_TYPE_BYTE, &(defalt_char));
    				
    				dbus_message_iter_append_basic(&iter_struct, 
    														DBUS_TYPE_UINT16, &(defalt_short));
    				
    				dbus_message_iter_append_basic(&iter_struct, 
    														DBUS_TYPE_UINT32, &(defalt_int));
    						
    				dbus_message_iter_append_basic(&iter_struct, 
    														DBUS_TYPE_BYTE, &(defalt_char));
    				
    		}
    		dbus_message_iter_append_basic (&iter_struct,
    										DBUS_TYPE_UINT32,&WTP[i]->apcminfo.cpu_average); 
    		
    		dbus_message_iter_append_basic (&iter_struct,
    										DBUS_TYPE_UINT32,&WTP[i]->apcminfo.cpu_peak_value); 

    		dbus_message_iter_append_basic (&iter_struct,
    										DBUS_TYPE_UINT32,&WTP[i]->apcminfo.mem_average); 

    		dbus_message_iter_append_basic (&iter_struct,
    										DBUS_TYPE_UINT32,&WTP[i]->apcminfo.mem_peak_value); 

    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_STRING,&(WTP[i]->WTPIP));


			dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_STRING,&wtp_ipv6_ip);

    		dbus_message_iter_append_basic (&iter_struct,
    										DBUS_TYPE_UINT32,
    										&WTP[i]->wifi_extension_info.cpu_collect_average); 
    		

    		dbus_message_iter_close_container (&iter_array, &iter_struct);
    	}

    	dbus_message_iter_close_container (&iter, &iter_array);
    }
	CW_FREE_OBJECT_WID(WTP);
	CW_FREE_OBJECT_WID(mac);
	//CW_FREE_OBJECT(code);
	CW_FREE_OBJECT_WID(cpu_type);
	CW_FREE_OBJECT_WID(mem_type);
	CW_FREE_OBJECT_WID(flash_type);
	CW_FREE_OBJECT_WID(wtp_ipv6_ip);
	
	return reply;	
}
/*table 6*/
DBusMessage * wid_dbus_interface_show_wtp_datapkts_information(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusMessageIter iter_struct;
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	
	int i=0,j=0;
	unsigned int wtp_num = 0;
	unsigned char *mac = NULL;
	WID_WTP **WTP = NULL;
	
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	memset(WTP,0,WTP_NUM*(sizeof(WID_WTP *)));
	
	wtp_num = Wid_Find_Wtp(WTP);
	
	if(wtp_num == 0)
		ret = WTP_ID_NOT_EXIST;

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	// Total slot count
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &wtp_num);

    if(wtp_num != 0)
    {
    	dbus_message_iter_open_container (&iter,
    									DBUS_TYPE_ARRAY,
    									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING

    											DBUS_TYPE_BYTE_AS_STRING		 //mac
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING

    											DBUS_TYPE_UINT64_AS_STRING  //wireless infor 1
    											DBUS_TYPE_UINT64_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING	//wireless infor 10

    											DBUS_TYPE_UINT64_AS_STRING	//wired infor 1
    											DBUS_TYPE_UINT64_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING

    											DBUS_TYPE_UINT32_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING  // wired infor 7
    											DBUS_TYPE_UINT32_AS_STRING // wired infor 8

    											DBUS_TYPE_UINT64_AS_STRING	//ath infor 1
    											
    											DBUS_TYPE_UINT64_AS_STRING	
    											DBUS_TYPE_UINT64_AS_STRING

    									DBUS_STRUCT_END_CHAR_AS_STRING,
    									&iter_array);

    	for(i = 0; i < wtp_num; i++){			
    		//unsigned char radiocount = 0;
    		unsigned long long  wifi_rx_byte = 0;
    		unsigned long long wifi_tx_byte = 0;
    		unsigned int  wifi_re_pkt = 0;		
    		unsigned int wifi_re_err = 0;	
    		unsigned long long  eth_rx_byte = 0;		
    		unsigned long long  eth_tx_byte = 0;		
    		unsigned int  eth_rx_err = 0;		
    		unsigned int wifi_tx_err = 0;
    		unsigned int wifi_tx_pkt = 0;		
    		unsigned int wifi_re_right = 0;
    		unsigned int wifi_tx_right = 0;
    		unsigned int eth_rx_pkt = 0;
    		unsigned int eth_rx_rightpkt=0;
    		unsigned int eth_tx_pkt = 0;
    		unsigned int eth_tx_err = 0;
    		unsigned int  eth_tx_rightpkt=0;
    		unsigned int wifi_re_rightz = 0;
    		unsigned long long  eth_tx_rightpktz=0;
    		
    		dbus_message_iter_open_container (&iter_array,
    											DBUS_TYPE_STRUCT,
    											NULL,
    											&iter_struct);
    		
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_UINT32,&(WTP[i]->WTPID));
    		
    		memset(mac,0,MAC_LEN+1);
    		if(WTP[i]->WTPMAC != NULL)
    			memcpy(mac,WTP[i]->WTPMAC,MAC_LEN);
    			
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_BYTE,&(mac[0]));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_BYTE,&(mac[1]));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_BYTE,&(mac[2]));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_BYTE,&(mac[3]));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_BYTE,&(mac[4]));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_BYTE,&(mac[5]));

    		for(j=0; j<TOTAL_AP_IF_NUM; j++){
    			if(WTP[i]->apstatsinfo[j].radioId < TOTAL_AP_IF_NUM+1){
        			if(WTP[i]->apstatsinfo[j].type == 2){
        				wifi_rx_byte += WTP[i]->apstatsinfo[j].rx_bytes;
        				wifi_tx_byte += WTP[i]->apstatsinfo[j].tx_bytes;
        				wifi_re_pkt += WTP[i]->apstatsinfo[j].rx_packets+WTP[i]->apstatsinfo[j].rx_errors;	/*xiaodawei modify, 20101118, */
        				wifi_re_err += WTP[i]->apstatsinfo[j].rx_errors;
        				wifi_tx_err += WTP[i]->apstatsinfo[j].tx_errors;
        				wifi_tx_pkt += WTP[i]->apstatsinfo[j].tx_packets+WTP[i]->apstatsinfo[j].tx_errors;
        				wifi_re_right += WTP[i]->apstatsinfo[j].rx_packets;
        				wifi_tx_right += WTP[i]->apstatsinfo[j].tx_packets;									/*END#AP*/
        				wifi_re_rightz += WTP[i]->apstatsinfo[j].tx_bytes;
        			}
        			if(WTP[i]->apstatsinfo[j].type == 1){
        				eth_rx_byte += WTP[i]->apstatsinfo[j].rx_bytes;
        				eth_tx_byte += WTP[i]->apstatsinfo[j].tx_bytes;
        				eth_rx_err += WTP[i]->apstatsinfo[j].rx_errors;
        				eth_rx_pkt += WTP[i]->apstatsinfo[j].rx_packets;
        				eth_rx_rightpkt += WTP[i]->apstatsinfo[j].rx_packets;//book modify, 2011-1-20
        				eth_tx_pkt += WTP[i]->apstatsinfo[j].tx_packets;
        				eth_tx_err += WTP[i]->apstatsinfo[j].tx_errors;
        				eth_tx_rightpkt += WTP[i]->apstatsinfo[j].tx_packets;//book modify, 2011-1-20
        			}
        			if(WTP[i]->apstatsinfo[j].type == 0){
        				eth_tx_rightpktz +=WTP[i]->apstatsinfo[j].rx_bytes;
        			}
        		}
    		}

    		/*wireless information*/
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_UINT64,&(wifi_rx_byte));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_UINT64,&(wifi_tx_byte));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_UINT32,&(wifi_re_pkt));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_UINT32,&(wifi_re_err));
    		
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_UINT32,&(wifi_tx_err));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_UINT32,&(wifi_tx_pkt));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_UINT32,&(wifi_tx_err));
    		
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_UINT32,&(wifi_re_right));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_UINT32,&(wifi_tx_right));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_UINT32,&(wifi_re_rightz));

    		/*wired information*/
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_UINT64,&(eth_rx_byte));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_UINT64,&(eth_tx_byte));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_UINT32,&(eth_rx_err));
    		
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_UINT32,&(eth_rx_pkt));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_UINT32,&(eth_rx_rightpkt));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_UINT32,&(eth_tx_pkt));
    		
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_UINT32,&(eth_tx_err));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_UINT32,&(eth_tx_rightpkt));

    		/*ath information*/
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_UINT64,&(eth_tx_rightpktz));
    		
    		/*wtp information*/
    		dbus_message_iter_append_basic (&iter_struct,
    										 DBUS_TYPE_UINT64,
    										 &(WTP[i]->rx_bytes));
    		dbus_message_iter_append_basic (&iter_struct,
    										 DBUS_TYPE_UINT64,
    										 &(WTP[i]->tx_bytes));
    		
    		dbus_message_iter_close_container (&iter_array, &iter_struct);
    	}
    	dbus_message_iter_close_container (&iter, &iter_array);
    }
	CW_FREE_OBJECT_WID(WTP);
	CW_FREE_OBJECT_WID(mac);

	return reply;	
}
/*table 7*/
DBusMessage * wid_dbus_interface_show_wtp_stats_information(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusMessageIter iter_struct;
	DBusMessageIter iter_sub_array;
	DBusMessageIter iter_sub_struct;
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int wtp_num = 0;
	int i=0,j=0,k=0;
	int ii=0,kk=0;
	unsigned int wtp_bss_num = 0;
 	unsigned char wtpSSIDNum = 0;
	unsigned char *mac = NULL;
	WID_WTP **WTP = NULL;
	WID_WTP_RADIO	**AC_RADIO_FOR_SEARCH = NULL;
	//WID_BSS *BSS[L_BSS_NUM] = {NULL};
	/*for wlan infor*/
	struct wlanid *wlanidlist = NULL;
	unsigned char wlanlist[WLAN_NUM] = {0};//wlanlist has 16 elements,0 means not bind this wlan,1 means bind this wlan
	unsigned char wlanid = 0;
	
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	memset(WTP,0,WTP_NUM*(sizeof(WID_WTP *)));
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	AC_RADIO_FOR_SEARCH = WID_MALLOC(L_RADIO_NUM*(sizeof(WID_WTP_RADIO *)));

	if(hide_quit_wtp_in_showting == 0){
		wtp_num = Wid_Find_Wtp(WTP);
	}
	else if (hide_quit_wtp_in_showting == 1){
		wtp_num = Wid_Find_Running_Wtp(WTP);
	}
	
	//wtp_num = Wid_Find_Wtp(WTP);

	if(wtp_num == 0)
		ret = WTP_ID_NOT_EXIST;

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	// Total slot count
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &wtp_num);

    if(wtp_num != 0)
    {
    	dbus_message_iter_open_container (&iter,
    									DBUS_TYPE_ARRAY,
    									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING

    											DBUS_TYPE_BYTE_AS_STRING		 //mac
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_STRING_AS_STRING		//wtp mode
    	
    											DBUS_TYPE_BYTE_AS_STRING		//wtpSSIDNum
    											DBUS_TYPE_UINT32_AS_STRING		// bss num of a wtp
    											//DBUS_TYPE_BYTE_AS_STRING		//radio_count
    											DBUS_TYPE_BYTE_AS_STRING		//wtp_radio_num
    											/*fengwenchao add 20111125 for GM-3*/
    											DBUS_TYPE_UINT32_AS_STRING    //heart_time_avarge
    											DBUS_TYPE_UINT32_AS_STRING   //heart_lose_pkt
    											DBUS_TYPE_UINT32_AS_STRING   //heart_transfer_pkt
    											/*fengwenchao add end*/
    											DBUS_TYPE_UINT32_AS_STRING			//max allowed sta num
    											DBUS_TYPE_BYTE_AS_STRING			//eth_num
    											/*wlan information*/
    	/*------------------------------wlan id infor start--------------------------------------*/
    											DBUS_TYPE_BYTE_AS_STRING		//bwlan_num
    												DBUS_TYPE_ARRAY_AS_STRING
    													DBUS_STRUCT_BEGIN_CHAR_AS_STRING
    														DBUS_TYPE_BYTE_AS_STRING		//wlanid
    													DBUS_STRUCT_END_CHAR_AS_STRING
    	/*------------------------------wlan id infor end----------------------------------------*/
		    									DBUS_TYPE_UINT32_AS_STRING    //is_refuse_rssi   fengwenchao add 20111122,for chinamobile-177
    											DBUS_STRUCT_END_CHAR_AS_STRING,
    									&iter_array);

    	for(i = 0; i < wtp_num; i++){		
    		unsigned char bwlannum = 0;
    		unsigned char num_of_radio = 0;
		unsigned int is_refuse_lowrssi = 0;  //fengwenchao add 20111122 for chinamobile-177
    		wtp_bss_num = 0;
    		memset(mac,0,MAC_LEN+1);
    		if(WTP[i]->WTPMAC != NULL)
    			memcpy(mac,WTP[i]->WTPMAC,MAC_LEN);
    		
    		memset(wlanlist,0,WLAN_NUM);
    		
    		dbus_message_iter_open_container (&iter_array,
    											DBUS_TYPE_STRUCT,
    											NULL,
    											&iter_struct);
    		
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_UINT32,
    										&(WTP[i]->WTPID));
    		
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_BYTE,&(mac[0]));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_BYTE,&(mac[1]));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_BYTE,&(mac[2]));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_BYTE,&(mac[3]));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_BYTE,&(mac[4]));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_BYTE,&(mac[5]));

    		dbus_message_iter_append_basic(&iter_struct,
    										  DBUS_TYPE_STRING,
    										  &(WTP[i]->WTPModel));

    		CWThreadMutexLock(&(gAllThreadMutex));		
    		CWConfigVersionInfo *pnode = gConfigVersionInfo;

    		while(pnode != NULL)
    		{
    			if(strcmp(pnode->str_ap_model,WTP[i]->WTPModel) == 0)
    			{
    				break;
    			}
    			pnode = pnode->next;
    		}	
    		CWThreadMutexUnlock(&(gAllThreadMutex));		

    		if(pnode == NULL){
    			wid_syslog_debug_debug(WID_DBUS," pnode not exist\n");
    			wtpSSIDNum = 8;
    		}
    		
    		else{
    			wtpSSIDNum = pnode->bss_num;
    		}

    		memset(AC_RADIO_FOR_SEARCH,0,L_RADIO_NUM*(sizeof(WID_WTP_RADIO *)));
    		num_of_radio = WID_WTP_FIND_RADIO(AC_RADIO_FOR_SEARCH,WTP[i]);
    		
    		for(k=0;k<num_of_radio;k++){	
    			//unsigned char radio_bss_num = 0;
    			for(ii=0;ii<L_BSS_NUM;ii++){
    				if(AC_RADIO_FOR_SEARCH[k]->BSS[ii] != NULL)
    				{
    					//BSS[radio_bss_num] = AC_RADIO_FOR_SEARCH[k]->BSS[ii];
    					//radio_bss_num++;
    					wtp_bss_num ++;
    				}
    			}
    		}
    		
    		/*for accouting the wlan which is enabled*/
    		for(j=0; j<(WTP[i]->RadioCount); j++)
    		{
    			if(WTP[i]->WTP_Radio[j] != NULL)
    			{
    				wlanidlist = WTP[i]->WTP_Radio[j]->Wlan_Id;
    				while(wlanidlist != NULL)
    				{
    					wlanid = wlanidlist->wlanid;
    					if(wlanlist[wlanid] == 1)
    					{
    						//printf("wlan %d is already in the list\n",wlanid);
    					}
    					else
    					{
    						//printf("wlan %d is not in the list\n",wlanid);
    						wlanlist[wlanid] = 1;
    						//printf("wlanlist %d %d\n",wlanid,wlanlist[wlanid]);
    					}

    					wlanidlist = wlanidlist->next;
    				}
    			}

    		}
    		
    		for(j=0;j<WLAN_NUM;j++)
    		{
    			if(wlanlist[j] == 1)
    			{
    				bwlannum++;
    			}
    		}
    		
    		dbus_message_iter_append_basic(&iter_struct,
    									  DBUS_TYPE_BYTE,
    									  &(wtpSSIDNum));

    		dbus_message_iter_append_basic(&iter_struct,
    									  DBUS_TYPE_UINT32,
    									  &(wtp_bss_num));

    		dbus_message_iter_append_basic(&iter_struct,
    									  DBUS_TYPE_BYTE,
    									  &(WTP[i]->RadioCount));
		/*fengwenchao add 20111125 for GM-3*/
    		dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT32,&(WTP[i]->heart_time.heart_time_avarge));
		dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT32,&(WTP[i]->heart_time.heart_lose_pkt));	
		dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT32,&(WTP[i]->heart_time.heart_transfer_pkt));	
		/*fengwenchao add end*/
    		dbus_message_iter_append_basic (&iter_struct,
    										 DBUS_TYPE_UINT32,
    										 &(WTP[i]->wtp_allowed_max_sta_num));//max sta allowed num

    		dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_BYTE, &(WTP[i]->apifinfo.eth_num));

    		dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&bwlannum);


    		dbus_message_iter_open_container (&iter_struct,
    										DBUS_TYPE_ARRAY,
    										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
    												DBUS_TYPE_BYTE_AS_STRING
    										DBUS_STRUCT_END_CHAR_AS_STRING,
    										&iter_sub_array);
    		
    		for(kk = 0; kk < WLAN_NUM; kk++)
    		{	
    			if(wlanlist[kk] == 1)
    			{
    				dbus_message_iter_open_container (&iter_sub_array,
    													DBUS_TYPE_STRUCT,
    													NULL,
    													&iter_sub_struct);
    				
    				wlanid = (unsigned char)kk;
    				dbus_message_iter_append_basic (&iter_sub_struct,DBUS_TYPE_BYTE,&wlanid);
				/*fengwenchao add 20111122 for chinamobile-177*/
				int q = 0;	
				for(q=0;q < TOTAL_AP_IF_NUM;q++)
				{
					if((WTP[i])&&(WTP[i]->apstatsinfo[q].wlanId == wlanid))
					{
						is_refuse_lowrssi += WTP[i]->apstatsinfo[q].is_refuse_lowrssi;
					}
				}
				/*fengwenchao add end*/
    				dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);
    			}
    		}
    		dbus_message_iter_close_container (&iter_struct, &iter_sub_array);// next wlan
    		dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_UINT32,&is_refuse_lowrssi); /*fengwenchao add 20111122 for chinamobile-177*/
    		dbus_message_iter_close_container (&iter_array, &iter_struct);	//wtp num
    	}

    	dbus_message_iter_close_container (&iter, &iter_array);			//whole for() function
    }

	CW_FREE_OBJECT_WID(WTP);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(AC_RADIO_FOR_SEARCH);

	return reply;	
}
/*table 8*/
DBusMessage * wid_dbus_interface_show_wlan_stats_information(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusMessageIter iter_struct;
	DBusMessageIter iter_sub_array;
	DBusMessageIter iter_sub_struct;
	DBusMessageIter iter_sub_essid_array;
	DBusMessageIter iter_sub_essid_struct;

	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int wtp_num = 0;
	int i=0,j=0,k=0,l;
	int ii=0,kk=0;
	//unsigned int wtp_bss_num = 0;
 	//unsigned char wtpSSIDNum = 0;
	unsigned char *mac = NULL;
	unsigned char *mac1 = NULL;
	WID_WTP **WTP = NULL;
//	WID_BSS *BSS[L_BSS_NUM] = {NULL};
//	WID_WTP_RADIO	**AC_RADIO_FOR_SEARCH = NULL;

	struct wlanid *wlanidlist = NULL;
	unsigned char wlanlist[WLAN_NUM] = {0};//wlanlist has 16 elements,0 means not bind this wlan,1 means bind this wlan
	unsigned char wlanid = 0;

	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	memset(WTP,0,WTP_NUM*(sizeof(WID_WTP *)));
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	mac1 =(unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	memset(mac1,0,MAC_LEN+1);
	
	wtp_num = Wid_Find_Wtp(WTP);
	
	if(wtp_num == 0)
		ret = WTP_ID_NOT_EXIST;

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	// Total slot count
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &wtp_num);

    if(wtp_num != 0)
    {
    	dbus_message_iter_open_container (&iter,
    									DBUS_TYPE_ARRAY,
    									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
    											DBUS_TYPE_UINT32_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING		 //mac1
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING
    											DBUS_TYPE_BYTE_AS_STRING		//mac 6
    											DBUS_TYPE_BYTE_AS_STRING		//wtp_l2_isolation_switch

     											DBUS_TYPE_BYTE_AS_STRING		//bwlan_num
    												DBUS_TYPE_ARRAY_AS_STRING
    													DBUS_STRUCT_BEGIN_CHAR_AS_STRING
    														DBUS_TYPE_BYTE_AS_STRING		//wlanid
    														DBUS_TYPE_BYTE_AS_STRING		//xiaodawei add L2 isolation, 20110304

													DBUS_TYPE_ARRAY_AS_STRING
    													DBUS_STRUCT_BEGIN_CHAR_AS_STRING
														DBUS_TYPE_BYTE_AS_STRING	//wlan essid
													DBUS_STRUCT_END_CHAR_AS_STRING
													DBUS_TYPE_UINT32_AS_STRING	//balance_para
    															DBUS_TYPE_UINT32_AS_STRING	//flow_balance_para
    															DBUS_TYPE_BYTE_AS_STRING	//balance_switch
    															DBUS_TYPE_BYTE_AS_STRING	//Hide SSID
    															DBUS_TYPE_BYTE_AS_STRING 		//mac1	1
    															DBUS_TYPE_BYTE_AS_STRING
    															DBUS_TYPE_BYTE_AS_STRING
    															DBUS_TYPE_BYTE_AS_STRING
    															DBUS_TYPE_BYTE_AS_STRING
    															DBUS_TYPE_BYTE_AS_STRING		//mac1	6
															/*fengwenchao add 20110401*/
															DBUS_TYPE_UINT32_AS_STRING  //tx_pkt MAC
															DBUS_TYPE_UINT64_AS_STRING  //rx_bts MAC
															DBUS_TYPE_UINT64_AS_STRING  //tx_bts MAC
															/*fengwenchao add end*/    															
    													DBUS_STRUCT_END_CHAR_AS_STRING
    											DBUS_STRUCT_END_CHAR_AS_STRING,
    									&iter_array);
    	

    	for(i = 0; i < wtp_num; i++){		
		/*fengwenchao add 20120217 for AXSSZFI-737*/
		unsigned int tx_pkt = 0;
		unsigned long long rx_bts = 0;
		unsigned long long tx_bts = 0;
		/*fengwenchao add end*/
    		unsigned char wtp_l2_isolation_switch = 0;
    		//unsigned char num_of_radio = 0;
    		//wtp_bss_num = 0;
    		unsigned char bwlannum = 0;
    		
    		memset(wlanlist,0,WLAN_NUM);
    		memset(mac,0,MAC_LEN+1);
    		if(WTP[i]->WTPMAC != NULL)
    			memcpy(mac,WTP[i]->WTPMAC,MAC_LEN);
    			
    		dbus_message_iter_open_container (&iter_array,
    											DBUS_TYPE_STRUCT,
    											NULL,
    											&iter_struct);
    		
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_UINT32,
    										&(WTP[i]->WTPID));
    			
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_BYTE,&(mac[0]));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_BYTE,&(mac[1]));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_BYTE,&(mac[2]));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_BYTE,&(mac[3]));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_BYTE,&(mac[4]));
    		dbus_message_iter_append_basic(&iter_struct,
    										DBUS_TYPE_BYTE,&(mac[5]));

    		for(kk=0;kk<L_BSS_NUM;kk++){
    			if(WTP[i]->mib_info.wlan_l2isolation[kk].l2_isolation_switch ==1)
    				wtp_l2_isolation_switch = 1;
    		}

    		dbus_message_iter_append_basic 
    									(&iter_struct,
    									DBUS_TYPE_BYTE,
    									&wtp_l2_isolation_switch); 
    		
    		//memset(AC_RADIO_FOR_SEARCH,0,L_RADIO_NUM*(sizeof(WID_WTP_RADIO *)));
    		//num_of_radio = WID_WTP_FIND_RADIO(AC_RADIO_FOR_SEARCH,WTP[i]);

    		/*for(k=0;k<num_of_radio;k++){	
    			unsigned char radio_bss_num = 0;
    			for(ii=0;ii<L_BSS_NUM;ii++){
    				if(AC_RADIO_FOR_SEARCH[k]->BSS[ii] != NULL)
    				{
    					BSS[radio_bss_num] = AC_RADIO_FOR_SEARCH[k]->BSS[ii];
    					radio_bss_num++;
    					wtp_bss_num ++;
    				}
    			}
    		}*/
    		
    		for(j=0; j<(WTP[i]->RadioCount); j++)
    		{
    			if(WTP[i]->WTP_Radio[j] != NULL)
    			{
    				wlanidlist = WTP[i]->WTP_Radio[j]->Wlan_Id;
    				while(wlanidlist != NULL && (AC_WLAN[wlanidlist->wlanid] != NULL && AC_WLAN[wlanidlist->wlanid]->want_to_delete != 1))		/* Huangleilei add for ASXXZFI-1622 */
    				{
    					wlanid = wlanidlist->wlanid;
    					if(wlanlist[wlanid] == 1)
    					{
    						//printf("wlan %d is already in the list\n",wlanid);
    					}
    					else
    					{
    						//printf("wlan %d is not in the list\n",wlanid);
    						wlanlist[wlanid] = 1;
    						//printf("wlanlist %d %d\n",wlanid,wlanlist[wlanid]);
    					}
    					wlanidlist = wlanidlist->next;
    				}
    			}
    		}
    		
    		for(j=0;j<WLAN_NUM;j++)
    		{
    			if(wlanlist[j] == 1)
    			{
    				bwlannum++;
    			}
    		}

    		dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&bwlannum);

    		dbus_message_iter_open_container (&iter_struct,
    										DBUS_TYPE_ARRAY,
    										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
    												DBUS_TYPE_BYTE_AS_STRING
    												DBUS_TYPE_BYTE_AS_STRING	//xiaodawei add L2 isolation, 20110304
												DBUS_TYPE_ARRAY_AS_STRING
													DBUS_STRUCT_BEGIN_CHAR_AS_STRING
													DBUS_TYPE_BYTE_AS_STRING	//wlan essid
												DBUS_STRUCT_END_CHAR_AS_STRING

    												DBUS_TYPE_UINT32_AS_STRING	//balance_para
    												DBUS_TYPE_UINT32_AS_STRING	//flow_balance_para
    												DBUS_TYPE_BYTE_AS_STRING	//balance_switch
    												DBUS_TYPE_BYTE_AS_STRING	//Hide SSID
    												
    												DBUS_TYPE_BYTE_AS_STRING 		//mac1	1
    												DBUS_TYPE_BYTE_AS_STRING
    												DBUS_TYPE_BYTE_AS_STRING
    												DBUS_TYPE_BYTE_AS_STRING
    												DBUS_TYPE_BYTE_AS_STRING
    												DBUS_TYPE_BYTE_AS_STRING		//mac1	6
												/*fengwenchao add 20110401*/
												DBUS_TYPE_UINT32_AS_STRING	//tx_pkt MAC
												DBUS_TYPE_UINT64_AS_STRING	//rx_bts MAC
												DBUS_TYPE_UINT64_AS_STRING	//tx_bts MAC
												/*fengwenchao add end*/

    		
    										DBUS_STRUCT_END_CHAR_AS_STRING,
    										&iter_sub_array);
    		
    		for(kk = 0; kk < WLAN_NUM; kk++)
    		{	
    			if(wlanlist[kk] == 1)
    			{
    				wlanid = (unsigned char)kk;
    				WID_WLAN *WLAN = AC_WLAN[kk];
    				//unsigned int radiocount_for_mac = 0;
    				int matched_sign = 0;
					int bssindex = 0;
					unsigned int wirelessifindex = 0;
					char *wlan_essid = NULL;
					wlan_essid = (char *)WID_MALLOC(ESSID_DEFAULT_LEN+1);
					memset(wlan_essid, 0, ESSID_DEFAULT_LEN+1);
					if(WLAN->ESSID!=NULL){
						//memcpy(wlan_essid, WLAN->ESSID, ESSID_DEFAULT_LEN);
						memcpy(wlan_essid, WLAN->ESSID, strlen(WLAN->ESSID));
					}
					else
						memcpy(wlan_essid, " ", 1);
					for(k = 0; k<TOTAL_AP_IF_NUM; k++){
						if(WTP[i]->apstatsinfo[k].radioId < TOTAL_AP_IF_NUM+1 && wlanid == WTP[i]->apstatsinfo[k].wlanId){
							wirelessifindex = WTP[i]->apstatsinfo[k].radioId;
						}
					}
					bssindex = AC_WLAN[kk]->S_WTP_BSS_List[(WTP[i]->WTPID)][wirelessifindex];
    				
     				dbus_message_iter_open_container (&iter_sub_array,
    													DBUS_TYPE_STRUCT,
    													NULL,
    													&iter_sub_struct);
    				
    				dbus_message_iter_append_basic (&iter_sub_struct,
    													DBUS_TYPE_BYTE,
    														&wlanid);
					if(AC_BSS[bssindex] != NULL){
						dbus_message_iter_append_basic (&iter_sub_struct,
															DBUS_TYPE_BYTE,
																&AC_BSS[bssindex]->ath_l2_isolation);	//xiaodawei add L2 isolation, 20110304
					}
					else{
						unsigned char isolation = 0;
						dbus_message_iter_append_basic (&iter_sub_struct,
															DBUS_TYPE_BYTE,
																&isolation);
					}
				dbus_message_iter_open_container (&iter_sub_struct,
						   DBUS_TYPE_ARRAY,
						   DBUS_STRUCT_BEGIN_CHAR_AS_STRING  
							  DBUS_TYPE_BYTE_AS_STRING
						   DBUS_STRUCT_END_CHAR_AS_STRING, 
						   &iter_sub_essid_array);
				for(l=0;l<ESSID_DEFAULT_LEN;l++)
				{
					dbus_message_iter_open_container (&iter_sub_essid_array,
														DBUS_TYPE_STRUCT,
														NULL,
													  &iter_sub_essid_struct);
					
					dbus_message_iter_append_basic(&iter_sub_essid_struct,
								  DBUS_TYPE_BYTE,
								  &wlan_essid[l]);
					dbus_message_iter_close_container (&iter_sub_essid_array ,&iter_sub_essid_struct);
				}
				dbus_message_iter_close_container (&iter_sub_struct, &iter_sub_essid_array);	
    				dbus_message_iter_append_basic(&iter_sub_struct,
    													DBUS_TYPE_UINT32,
    					 							 		&(WLAN->balance_para));

    				dbus_message_iter_append_basic(&iter_sub_struct,
    														DBUS_TYPE_UINT32,
    							  							&(WLAN->flow_balance_para));

    				dbus_message_iter_append_basic(&iter_sub_struct,
    														DBUS_TYPE_BYTE,
    							  							&(WLAN->balance_switch));
    				
    				dbus_message_iter_append_basic(&iter_sub_struct,
    														  DBUS_TYPE_BYTE,
    														  &(WLAN->HideESSid));	

    				/*static mac*/		
    				/*for(ii=0; ii<TOTAL_AP_IF_NUM; ii++){
    					if(WTP[i]->apstatsinfo[ii].radioId < TOTAL_AP_IF_NUM+1)
    						radiocount_for_mac++;
    				}*/

    				for(ii = 0; ii< TOTAL_AP_IF_NUM; ii++){	
    					if((WTP[i]->apstatsinfo[ii].radioId < TOTAL_AP_IF_NUM+1)
    						&&(0 == WTP[i]->apstatsinfo[ii].type)
    						&&(WTP[i]->apstatsinfo[ii].wlanId == kk)){
    						
    						dbus_message_iter_append_basic
    									(&iter_sub_struct,
    									  DBUS_TYPE_BYTE,
    									  &(WTP[i]->apstatsinfo[ii].mac[0]));
    						dbus_message_iter_append_basic
    									(&iter_sub_struct,
    									  DBUS_TYPE_BYTE,
    									  &(WTP[i]->apstatsinfo[ii].mac[1]));
    						dbus_message_iter_append_basic
    									(&iter_sub_struct,
    									  DBUS_TYPE_BYTE,
    									  &(WTP[i]->apstatsinfo[ii].mac[2]));
    						dbus_message_iter_append_basic
    									(&iter_sub_struct,
    									  DBUS_TYPE_BYTE,
    									  &(WTP[i]->apstatsinfo[ii].mac[3]));
    						dbus_message_iter_append_basic
    									(&iter_sub_struct,
    									  DBUS_TYPE_BYTE,
    									  &(WTP[i]->apstatsinfo[ii].mac[4]));
    						dbus_message_iter_append_basic
    									(&iter_sub_struct,
    									  DBUS_TYPE_BYTE,
    									  &(WTP[i]->apstatsinfo[ii].mac[5]));
    						matched_sign = 1;
    						break;
    					}

    				}

    				if (matched_sign != 1){
    					dbus_message_iter_append_basic(&iter_sub_struct,
    												  DBUS_TYPE_BYTE,
    												  &(mac1[0]));
    					dbus_message_iter_append_basic(&iter_sub_struct,
    												  DBUS_TYPE_BYTE,
    												  &(mac1[1]));
    					dbus_message_iter_append_basic(&iter_sub_struct,
    												  DBUS_TYPE_BYTE,
    												  &(mac1[2]));
    					dbus_message_iter_append_basic(&iter_sub_struct,
    												  DBUS_TYPE_BYTE,
    												  &(mac1[3]));
    					dbus_message_iter_append_basic(&iter_sub_struct,
    												  DBUS_TYPE_BYTE,
    												  &(mac1[4]));
    					dbus_message_iter_append_basic(&iter_sub_struct,
    												  DBUS_TYPE_BYTE,
    												  &(mac1[5]));
    				}
				/*fengwenchao add 20110426 for  dot11WlanDataPktsTable*/
				/*unsigned int tx_pkt = 0;
				unsigned long long rx_bts = 0;
				unsigned long long tx_bts = 0;
				WID_CHECK_SAME_ATH_OF_ALL_WTP(wlanid,&tx_pkt,&rx_bts,&tx_bts);*/
				/*fengwenchao add 20120217 for AXSSZFI-737*/
				for(ii = 0; ii< TOTAL_AP_IF_NUM; ii++)
				{	
    					if((WTP[i]->apstatsinfo[ii].radioId < TOTAL_AP_IF_NUM+1)
						&&(0 == WTP[i]->apstatsinfo[ii].type)
    						&&(WTP[i]->apstatsinfo[ii].wlanId == kk))
    					{
						tx_pkt  += WTP[i]->apstatsinfo[ii].tx_packets;;
						rx_bts  += WTP[i]->apstatsinfo[ii].rx_bytes;
						tx_bts  += WTP[i]->apstatsinfo[ii].tx_bytes;						
					}
				}
				/*fengwenchao add end*/				
				dbus_message_iter_append_basic (&iter_sub_struct,DBUS_TYPE_UINT32,&tx_pkt);

				printf("tx_pkt = %d \n",tx_pkt);
				
				dbus_message_iter_append_basic (&iter_sub_struct,DBUS_TYPE_UINT64,&rx_bts);

				printf("rx_bts = %llu \n",rx_bts);

				dbus_message_iter_append_basic (&iter_sub_struct,DBUS_TYPE_UINT64,&tx_bts);

				printf("tx_bts = %llu\n",tx_bts);				
				/*fengwenchao add end*/
    				dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);
				CW_FREE_OBJECT_WID(wlan_essid);
    			}
    		}
    		dbus_message_iter_close_container (&iter_struct, &iter_sub_array);
      		dbus_message_iter_close_container (&iter_array, &iter_struct);	//wtp num
    	}
    	dbus_message_iter_close_container (&iter, &iter_array);			//whole for() function
    }
	CW_FREE_OBJECT_WID(WTP);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(mac1);
	//CW_FREE_OBJECT(AC_RADIO_FOR_SEARCH);

	return reply;	

}
/*table 9*/

#if 0 // for old version
DBusMessage * wid_dbus_interface_show_wlan_ssid_stats_information(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusMessageIter iter_struct;
	DBusMessageIter iter_sub_array;
	DBusMessageIter iter_sub_struct;
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int wtp_num = 0;
	int i=0, j=0, k=0;
	int ii=0,jj=0, kk=0;

	unsigned int wtp_bss_num = 0;
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);

	WID_WTP **WTP;
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	
	wtp_num = Wid_Find_Wtp(WTP);
	
	/*for  accounting bss infor*/
	WID_WTP_RADIO	**AC_RADIO_FOR_SEARCH;
	AC_RADIO_FOR_SEARCH = WID_MALLOC(G_RADIO_NUM*(sizeof(WID_WTP_RADIO *)));
	WID_BSS *BSS[L_BSS_NUM];
	
	/*for wlan infor*/
	struct wlanid *wlanidlist = NULL;
	unsigned char wlanlist[WLAN_NUM];//wlanlist has 16 elements,0 means not bind this wlan,1 means bind this wlan
	unsigned char wlanid;

	if(wtp_num == 0)
		ret = WTP_ID_NOT_EXIST;

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	// Total slot count
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &wtp_num);

	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING		 //mac1
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING		//mac 6
											DBUS_TYPE_UINT32_AS_STRING		//tx_mgmt
											DBUS_TYPE_UINT32_AS_STRING		//rx_mgmt
											DBUS_TYPE_UINT32_AS_STRING	//rx_packets
											DBUS_TYPE_UINT32_AS_STRING	//tx_packets
											DBUS_TYPE_UINT64_AS_STRING	//rx_bytes
											DBUS_TYPE_UINT64_AS_STRING	//tx_bytes
											DBUS_TYPE_UINT32_AS_STRING	//rx_rate
											DBUS_TYPE_UINT32_AS_STRING	//tx_rate
 											DBUS_TYPE_BYTE_AS_STRING		//bwlan_num
 											/*wlan infor*/
												DBUS_TYPE_ARRAY_AS_STRING
													DBUS_STRUCT_BEGIN_CHAR_AS_STRING
														DBUS_TYPE_BYTE_AS_STRING		//wlanid
															DBUS_TYPE_UINT64_AS_STRING	//
															DBUS_TYPE_UINT64_AS_STRING	//
															DBUS_TYPE_UINT64_AS_STRING	//
															DBUS_TYPE_UINT64_AS_STRING	// 
															DBUS_TYPE_UINT64_AS_STRING

															DBUS_TYPE_BYTE_AS_STRING		//bssid0
															DBUS_TYPE_BYTE_AS_STRING
															DBUS_TYPE_BYTE_AS_STRING
															DBUS_TYPE_BYTE_AS_STRING
															DBUS_TYPE_BYTE_AS_STRING
															DBUS_TYPE_BYTE_AS_STRING		//bssid 5
															
															DBUS_TYPE_BYTE_AS_STRING		//state
															DBUS_TYPE_UINT32_AS_STRING		//bss_max_allowed_sta_num
															DBUS_TYPE_BYTE_AS_STRING		//balance_switch
															DBUS_TYPE_BYTE_AS_STRING		//security id
															DBUS_TYPE_STRING_AS_STRING		//essid
															DBUS_TYPE_STRING_AS_STRING		//wlanname
													DBUS_STRUCT_END_CHAR_AS_STRING
											DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for(i = 0; i < wtp_num; i++){	
		unsigned int rx_packets = 0;
		unsigned int tx_packets = 0;
		unsigned long long rx_bytes = 0;
		unsigned long long tx_bytes = 0;
		unsigned int rx_rate = 0;
		unsigned int tx_rate = 0;
		unsigned int wifi_extension_info_tx_mgmt = 0;
		unsigned int wifi_extension_info_rx_mgmt = 0;
		
		unsigned char radiocount =0;
		unsigned char num_of_radio = 0;
		wtp_bss_num = 0;
		unsigned char bwlannum = 0;
		memset(wlanlist,0,WLAN_NUM);
		num_of_radio = WID_WTP_FIND_RADIO(AC_RADIO_FOR_SEARCH,WTP[i]);
		
		memset(mac,0,MAC_LEN+1);
		if(WTP[i]->WTPMAC != NULL)
			memcpy(mac,WTP[i]->WTPMAC,MAC_LEN);
		
		dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
		
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_UINT32,
										&(WTP[i]->WTPID));
			
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[0]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[1]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[2]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[3]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[4]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[5]));
		
		if(WTP[i]->wifi_extension_reportswitch ==1){
			dbus_message_iter_append_basic(&iter_struct, 
											DBUS_TYPE_UINT32, 
											&(WTP[i]->wifi_extension_info.tx_mgmt));
			
			dbus_message_iter_append_basic(&iter_struct, 
											DBUS_TYPE_UINT32, 
											&(WTP[i]->wifi_extension_info.rx_mgmt));
		}
		else{
			dbus_message_iter_append_basic(&iter_struct, 
											DBUS_TYPE_UINT32, 
											&(wifi_extension_info_tx_mgmt));
						
			dbus_message_iter_append_basic(&iter_struct, 
											DBUS_TYPE_UINT32, 
											&(wifi_extension_info_rx_mgmt));
		}
			
		for(j=0; j<TOTAL_AP_IF_NUM; j++){
			if(WTP[i]->apstatsinfo[j].radioId < TOTAL_AP_IF_NUM+1)
				radiocount++;
		}

		for(j=0;j<radiocount;j++){
			if(WTP[i]->apstatsinfo[j].type == 0){
				rx_packets += WTP[i]->apstatsinfo[j].rx_packets;
				tx_packets += WTP[i]->apstatsinfo[j].tx_packets;
				rx_bytes += WTP[i]->apstatsinfo[j].rx_bytes;
				tx_bytes += WTP[i]->apstatsinfo[j].tx_bytes;
				rx_rate += WTP[i]->apstatsinfo[j].rx_rate;
				tx_rate = WTP[i]->rate;
			}
		}
		
		dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_UINT32,
									  &(rx_packets));
		dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_UINT32,
									  &(tx_packets));

		dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_UINT64,
									  &(rx_bytes));
		dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_UINT64,
									  &(tx_bytes));	
		
		dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_UINT32,
									  &(rx_rate));
		dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_UINT32,
									  &(tx_rate));	

		for(k=0;k<num_of_radio;k++){	
			unsigned char radio_bss_num = 0;
			for(ii=0;ii<L_BSS_NUM;ii++){
				if(AC_RADIO_FOR_SEARCH[k]->BSS[ii] != NULL)
				{
					BSS[radio_bss_num] = AC_RADIO_FOR_SEARCH[k]->BSS[ii];
					radio_bss_num++;
					wtp_bss_num ++;
				}
			}
		}
		
		for(j=0; j<(WTP[i]->RadioCount); j++)
		{
			if(WTP[i]->WTP_Radio[j] != NULL)
			{
				wlanidlist = WTP[i]->WTP_Radio[j]->Wlan_Id;
				while(wlanidlist != NULL)
				{
					wlanid = wlanidlist->wlanid;
					if(wlanlist[wlanid] == 1)
					{
						//printf("wlan %d is already in the list\n",wlanid);
					}
					else
					{
						//printf("wlan %d is not in the list\n",wlanid);
						wlanlist[wlanid] = 1;
						//printf("wlanlist %d %d\n",wlanid,wlanlist[wlanid]);
					}

					wlanidlist = wlanidlist->next;
				}
			}
		}
		
		for(j=0;j<WLAN_NUM;j++)
		{
			if(wlanlist[j] == 1)
			{
				bwlannum++;
			}
		}

		dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&bwlannum);

		dbus_message_iter_open_container (&iter_struct,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING	//
												DBUS_TYPE_UINT64_AS_STRING	//
												DBUS_TYPE_UINT64_AS_STRING	//
												DBUS_TYPE_UINT64_AS_STRING	// 
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING		//bssid0
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING		//bssid 5
												DBUS_TYPE_BYTE_AS_STRING		//state
												DBUS_TYPE_UINT32_AS_STRING		//bss_max_allowed_sta_num
												DBUS_TYPE_BYTE_AS_STRING		//balance_switch
												DBUS_TYPE_BYTE_AS_STRING		//security id
												DBUS_TYPE_STRING_AS_STRING		//essid
												DBUS_TYPE_STRING_AS_STRING		//wlanname
										DBUS_STRUCT_END_CHAR_AS_STRING,
										&iter_sub_array);
		
		for(kk = 0; kk < WLAN_NUM; kk++){	
			if(wlanlist[kk] == 1){
				unsigned long long rx_unicast = 0;
				unsigned long long tx_unicast = 0;
				unsigned long long rx_broadcast = 0;
				unsigned long long tx_broadcast = 0;
				unsigned long long retry = 0;

				unsigned char wlan_id = 0;
				unsigned int bss_max_allowed_sta_num = 0;
				unsigned char State = 0;
				unsigned char balance_switch = 0 ;
				unsigned char SecurityID = 0 ;
				char * Essid = NULL;
				unsigned char * WlanName = NULL;
				wlanid = (unsigned char)kk;
				
 				dbus_message_iter_open_container (&iter_sub_array,
													DBUS_TYPE_STRUCT,
													NULL,
													&iter_sub_struct);
				
				dbus_message_iter_append_basic (&iter_sub_struct,DBUS_TYPE_BYTE,&wlanid);

				for(ii=0;ii<L_RADIO_NUM;ii++){
					if(WTP[i]->WTP_Radio[ii] != NULL){
						for(jj=0;jj<L_BSS_NUM;jj++){
							if((WTP[i]->WTP_Radio[ii]->BSS[jj] != NULL)
								&&(WTP[i]->WTP_Radio[ii]->BSS[jj]->WlanID==wlanid)
								&&(WTP[i]->WTP_Radio[ii]->BSS[jj]->BSSID != NULL)){
								rx_unicast = WTP[i]->WTP_Radio[ii]->BSS[jj]->BSS_pkt_info.rx_unicast;
								tx_unicast = WTP[i]->WTP_Radio[ii]->BSS[jj]->BSS_pkt_info.tx_unicast;
								rx_broadcast = WTP[i]->WTP_Radio[ii]->BSS[jj]->BSS_pkt_info.rx_broadcast;
								tx_broadcast = WTP[i]->WTP_Radio[ii]->BSS[jj]->BSS_pkt_info.tx_broadcast;
								retry = WTP[i]->WTP_Radio[ii]->BSS[jj]->BSS_pkt_info.retry;
								BSS[0] = WTP[i]->WTP_Radio[ii]->BSS[jj] ;
								bss_max_allowed_sta_num = WTP[i]->WTP_Radio[ii]->BSS[jj]->bss_max_allowed_sta_num;
								State = WTP[i]->WTP_Radio[ii]->BSS[jj]->State;
								wlan_id = WTP[i]->WTP_Radio[ii]->BSS[jj]->WlanID;

								if((AC_WLAN[wlan_id]!=NULL)&&(AC_WLAN[wlan_id]->ESSID != NULL)){
									balance_switch = AC_WLAN[wlan_id]->balance_switch ;
									SecurityID = AC_WLAN[wlan_id]->SecurityID ; 
									Essid = AC_WLAN[wlan_id]->ESSID ; 
									WlanName = AC_WLAN[wlan_id]->WlanName ;
								}
								break;	
							}
						}
					}
				}
				dbus_message_iter_append_basic(&iter_sub_struct, DBUS_TYPE_UINT64, &rx_unicast);
				dbus_message_iter_append_basic(&iter_sub_struct, DBUS_TYPE_UINT64, &tx_unicast);
				dbus_message_iter_append_basic(&iter_sub_struct, DBUS_TYPE_UINT64, &rx_broadcast);
				dbus_message_iter_append_basic(&iter_sub_struct, DBUS_TYPE_UINT64, &tx_broadcast);
				dbus_message_iter_append_basic(&iter_sub_struct, DBUS_TYPE_UINT64, &retry);

				dbus_message_iter_append_basic(&iter_sub_struct, 
												DBUS_TYPE_BYTE, 
												&BSS[0]->BSSID[0]);
				dbus_message_iter_append_basic(&iter_sub_struct, 
												DBUS_TYPE_BYTE, 
												&BSS[0]->BSSID[1]);		//bssid 1
				dbus_message_iter_append_basic(&iter_sub_struct, 
												DBUS_TYPE_BYTE, 
												&BSS[0]->BSSID[2]);
				dbus_message_iter_append_basic(&iter_sub_struct, 
												DBUS_TYPE_BYTE, 
												&BSS[0]->BSSID[3]);		//bssid 3
				dbus_message_iter_append_basic(&iter_sub_struct, 
												DBUS_TYPE_BYTE, 
												&BSS[0]->BSSID[4]);
				dbus_message_iter_append_basic(&iter_sub_struct, 
												DBUS_TYPE_BYTE, 
												&BSS[0]->BSSID[5]);		//bssid 5

				dbus_message_iter_append_basic(&iter_sub_struct, 
												DBUS_TYPE_BYTE, 
												&State);										//State
				dbus_message_iter_append_basic(&iter_sub_struct, 
												DBUS_TYPE_UINT32, 
												&bss_max_allowed_sta_num);				//bss_max_allowed_sta_num
				dbus_message_iter_append_basic(&iter_sub_struct, 
												DBUS_TYPE_BYTE, 
												&balance_switch);								//balance_switch
												
				dbus_message_iter_append_basic(&iter_sub_struct, 
												DBUS_TYPE_BYTE, 
												&SecurityID);									//SecurityID
				dbus_message_iter_append_basic(&iter_sub_struct, 
												DBUS_TYPE_STRING,
												&Essid);										//Essid

				dbus_message_iter_append_basic(&iter_sub_struct, 
												DBUS_TYPE_STRING,
												&WlanName);										//WlanName

				dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);
			}
		}
		dbus_message_iter_close_container (&iter_struct, &iter_sub_array);
  		dbus_message_iter_close_container (&iter_array, &iter_struct);	//wtp num
	}
	dbus_message_iter_close_container (&iter, &iter_array);			

	CW_FREE_OBJECT_WID(WTP);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(AC_RADIO_FOR_SEARCH);

	return reply;	
}
#endif
/*fengwenchao add 20110617*/
DBusMessage *wid_dbus_interface_show_info_bywtpid(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusMessageIter  iter_struct;
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	int wtpid = 0;
//	int wtp_num = 0;
	int bss_num = 0;
	int radiocount = 0;
	int radioid = 0;
	int i = 0;
	int j =0;
	unsigned int rx_data_pkts = 0;
	unsigned int tx_data_pkts = 0;
	WID_BSS *bss[L_BSS_NUM];
	if (!(dbus_message_get_args ( msg, &err,
									 DBUS_TYPE_UINT32, &wtpid,
									 DBUS_TYPE_INVALID))){

			printf("Unable to get input args\n");
					
			if (dbus_error_is_set(&err)) {
				printf("%s raised: %s",err.name,err.message);
				dbus_error_free(&err);
			}
			return NULL;
		}

	if(wtpid >= WTP_NUM)
	{	
		ret = WTP_ID_LARGE_THAN_MAX;
	}

	CWThreadMutexLock(&(gWTPs[wtpid].WTPThreadMutex));//fengwenchao add 20121123 for AXSSZFI-1050
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	CWThreadMutexUnlock(&(gWTPs[wtpid].WTPThreadMutex));
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);

	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);

	if(ret == WID_DBUS_SUCCESS)
	{
		for(i = 0; i< TOTAL_AP_IF_NUM;i++)
		{
			if(AC_WTP[wtpid]->apstatsinfo[i].type == 0)
			{	
				rx_data_pkts += AC_WTP[wtpid]->apstatsinfo[i].rx_pkt_data;
				tx_data_pkts += AC_WTP[wtpid]->apstatsinfo[i].tx_pkt_data;
			}
		}


		radiocount = AC_WTP[wtpid]->RadioCount;
		for(i = 0; i < radiocount;i++)
		{
			radioid = wtpid*L_RADIO_NUM+i;

			if(AC_WTP[wtpid]->WTP_Radio[i])
			{
				for(j =0 ;j < L_BSS_NUM;j++)
				{
					if(AC_WTP[wtpid]->WTP_Radio[i]->BSS[j] != NULL)
					{
						 bss[bss_num] = AC_WTP[wtpid]->WTP_Radio[i]->BSS[j];
						bss_num++;
					}
				}
				
			}

		}
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &rx_data_pkts);
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &tx_data_pkts);
			
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &bss_num);
			printf("  bss_num  =  %d  \n",bss_num);
			
			
			dbus_message_iter_open_container (&iter,
												DBUS_TYPE_ARRAY,
												DBUS_STRUCT_BEGIN_CHAR_AS_STRING
														DBUS_TYPE_UINT32_AS_STRING	//bssindex
														DBUS_TYPE_UINT32_AS_STRING //rx_data_pkts
														DBUS_TYPE_UINT32_AS_STRING //tx_data_pkts
												DBUS_STRUCT_END_CHAR_AS_STRING,
												&iter_array);	

			for(i = 0; i <bss_num; i++)
			{
				unsigned int bss_rx_pkt_data = 0;
				unsigned int bss_tx_pkt_data = 0;
				dbus_message_iter_open_container (&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_UINT32,&(bss[i]->BSSIndex));
				for(j = 0; j <TOTAL_AP_IF_NUM; j++)
				{
					
					
					if((bss[i] != NULL)&&(AC_WTP[wtpid]->apstatsinfo[j].wlanId == bss[i]->WlanID)&&(bss[i]->Radio_L_ID == AC_WTP[wtpid]->apstatsinfo[j].radioId))
					{
						
						bss_rx_pkt_data = AC_WTP[wtpid]->apstatsinfo[j].rx_pkt_data;
						bss_tx_pkt_data = AC_WTP[wtpid]->apstatsinfo[j].tx_pkt_data;						
						break;
					}
				}
				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_UINT32,&(bss_rx_pkt_data));
				printf("  bss_rx_pkt_data  =  %d  \n",bss_rx_pkt_data);
				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_UINT32,&(bss_tx_pkt_data));
				printf("  bss_tx_pkt_data =  %d  \n",bss_tx_pkt_data);
				dbus_message_iter_close_container (&iter_array, &iter_struct);
			}
			dbus_message_iter_close_container (&iter, &iter_array);
		}
	return reply;	
}

/*fengwenchao add end*/

/*fengwenchao add 20110617*/
DBusMessage *wid_dbus_interface_show_info_allwlan(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 
	DBusMessageIter  iter;
	DBusMessageIter  iter_array;
	DBusMessageIter  iter_struct;
//	DBusMessageIter iter_sub_array;
//	DBusMessageIter iter_sub_struct;	
	DBusError err;	
	dbus_error_init(&err);

	int wlan_num = 0;
//	int bss_num = 0;
	int wtp_num = 0;
	int ret = WID_DBUS_SUCCESS;
	int i=0;
	int j =0;
	int k = 0;
	WID_WTP **WTP=NULL;
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	memset(WTP,0,WTP_NUM*(sizeof(WID_WTP *)));
	wtp_num = Wid_Find_Wtp(WTP);
	

	
	WID_WLAN **WLAN;
	WLAN = WID_MALLOC(WLAN_NUM*(sizeof(WID_WLAN )));
	memset(WLAN,0,WLAN_NUM*(sizeof(WID_WLAN )));

	while(i<WLAN_NUM)
	{
		if(AC_WLAN[i] != NULL && (AC_WLAN[i]->want_to_delete != 1))		/* Huangleilei add for ASXXZFI-1622 */
		{
			WLAN[wlan_num] = AC_WLAN[i];
			wlan_num++;
		}
		i++;
	}

	if(wlan_num == 0)
		ret = WLAN_ID_NOT_EXIST;
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);

	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &wlan_num);
	
	dbus_message_iter_open_container (&iter,
								   DBUS_TYPE_ARRAY,
								   DBUS_STRUCT_BEGIN_CHAR_AS_STRING
										DBUS_TYPE_BYTE_AS_STRING		//wlan id
										DBUS_TYPE_UINT32_AS_STRING		//rx_pkts
										DBUS_TYPE_UINT32_AS_STRING		//tx_pkts
										DBUS_TYPE_UINT64_AS_STRING		//rx_bytes
										DBUS_TYPE_UINT64_AS_STRING		//tx_bytes									
								   DBUS_STRUCT_END_CHAR_AS_STRING,
								   &iter_array);

	for(i = 0; i <wlan_num; i++)
	{
		unsigned int rx_pkts = 0;	
		unsigned int tx_pkts = 0;	
		unsigned long long rx_bytes = 0;
		unsigned long long tx_bytes = 0;

		unsigned char wlanid = 0;
		wlanid = WLAN[i]->WlanID;

		for(j = 0; j < wtp_num; j++)
		{
			if(WTP[j])
			{
				for(k = 0; k < TOTAL_AP_IF_NUM; k++)
				{
					if((WTP[j]->apstatsinfo[k].type == 0)&&(WTP[j]->apstatsinfo[k].wlanId == wlanid))
					{
						rx_pkts += WTP[j]->apstatsinfo[k].rx_pkt_data;	
						tx_pkts += WTP[j]->apstatsinfo[k].tx_pkt_data;	
						rx_bytes +=WTP[j]->apstatsinfo[k].rx_bytes;	
						tx_bytes += WTP[j]->apstatsinfo[k].tx_bytes;	
					}
				}
			}
		}

		dbus_message_iter_open_container (&iter_array,
									DBUS_TYPE_STRUCT,
									NULL,
									&iter_struct);
		
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,
										&wlanid);

		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_UINT32,
										&rx_pkts);
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_UINT32,
										&tx_pkts);
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_UINT64,
										&rx_bytes);
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_UINT64,
										&tx_bytes);
		dbus_message_iter_close_container(&iter_array,&iter_struct);
	}
	dbus_message_iter_close_container(&iter,&iter_array);

	CW_FREE_OBJECT_WID(WTP);
	CW_FREE_OBJECT_WID(WLAN);

	return reply;	
}
/*fengwenchao add end*/

/*fengwenchao add 20110617*/
DBusMessage *wid_dbus_interface_show_info_bywlanid(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
//	DBusMessageIter	 iter_array;
//	DBusMessageIter iter_struct;
//	DBusMessageIter iter_sub_array;
//	DBusMessageIter iter_sub_struct;

	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	unsigned char wlanid = 0;
	int wtp_num = 0;
	int i = 0;
	int j =0;
	unsigned int rx_data_pkts = 0;
	unsigned int tx_data_pkts = 0;
	unsigned long long rx_data_bytes = 0;
	unsigned long long tx_data_bytes = 0;
	if (!(dbus_message_get_args ( msg, &err,
								 DBUS_TYPE_BYTE,  &wlanid,
								 DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}


	WID_WTP **WTP=NULL;
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	if( WTP == NULL){
		wid_syslog_debug_debug(WID_DBUS,"%s :malloc fail.\n",__func__);
		exit(1);
	}
	memset(WTP,0,WTP_NUM*(sizeof(WID_WTP *)));

	wtp_num = Wid_Find_Wtp(WTP);
	for(i = 0; i < wtp_num;i++)
	{
		if(WTP[i])
		{
			for(j = 0; j < TOTAL_AP_IF_NUM; j++)
			{
				if((WTP[i]->apstatsinfo[j].type == 0)&&(WTP[i]->apstatsinfo[j].wlanId == wlanid))
				{
					rx_data_pkts += WTP[i]->apstatsinfo[j].rx_pkt_data;
					tx_data_pkts += WTP[i]->apstatsinfo[j].tx_pkt_data;
					rx_data_bytes += WTP[i]->apstatsinfo[j].rx_bytes;
				 	tx_data_bytes += WTP[i]->apstatsinfo[j].tx_bytes;
				}
			}
		}
	}

	reply = dbus_message_new_method_return(msg);		
	dbus_message_iter_init_append (reply, &iter);
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&rx_data_pkts);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&tx_data_pkts);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT64,&rx_data_bytes);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT64,&tx_data_bytes);	
	if(WTP)
	{
		WID_FREE(WTP);
		WTP = NULL;
	}
	return reply;									 
}

/*fengwenchao add end*/

/*fengwenchao add 20110617*/
DBusMessage * wid_dbus_interface_show_conjunction_info_of_all_wtp(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusMessageIter iter_struct;
	//DBusMessageIter iter_sub_array;
	//DBusMessageIter iter_sub_struct;

	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	unsigned int wtp_num = 0;
	int i = 0;
	int j = 0;

	WID_WTP **WTP=NULL;
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	if( WTP == NULL){
		wid_syslog_debug_debug(WID_DBUS,"%s :malloc fail.\n",__func__);
		exit(1);
	}
	memset(WTP,0,WTP_NUM*(sizeof(WID_WTP *)));

	wtp_num = Wid_Find_Wtp(WTP);

	if(wtp_num == 0)
		ret = WTP_ID_NOT_EXIST;

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);

	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &wtp_num);

	dbus_message_iter_open_container (&iter,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_UINT32_AS_STRING  //wtpid
												DBUS_TYPE_UINT32_AS_STRING  //rx_data_pkts
												DBUS_TYPE_UINT32_AS_STRING  //tx_data_pkts		 
												//DBUS_TYPE_UINT32_AS_STRING
												//DBUS_TYPE_UINT32_AS_STRING
										  DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for(i = 0; i <wtp_num ; i++)
	{
		unsigned int rx_data_pkts = 0;			 
		unsigned int tx_data_pkts = 0;
		unsigned int wtpid = 0;
		wtpid = WTP[i]->WTPID;

		for( j = 0; j <TOTAL_AP_IF_NUM; j++)
		{
			if(WTP[i]->apstatsinfo[j].type == 0)
			{
				rx_data_pkts += WTP[i]->apstatsinfo[j].rx_pkt_data;
				tx_data_pkts += WTP[i]->apstatsinfo[j].tx_pkt_data;
			}
		}

		dbus_message_iter_open_container (&iter_array,DBUS_TYPE_STRUCT, NULL,&iter_struct);

		dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_UINT32,&wtpid);	
											   
		dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_UINT32,&rx_data_pkts);	
		printf("rx_data_pkts   =  %d  ,  wtpid = %d\n",rx_data_pkts,wtpid);										
		dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_UINT32,&tx_data_pkts);												 										 
		printf("tx_data_pkts   =  %d  ,  wtpid = %d\n",tx_data_pkts,wtpid);											   

		dbus_message_iter_close_container (&iter_array, &iter_struct);
	}

	dbus_message_iter_close_container (&iter, &iter_array);

	if(WTP)
	{
		WID_FREE(WTP);
		WTP=NULL;
	}

	return reply;
}

/*fengwenchao add end*/

/* zhangshu copy from 1.2, 2010-09-13 */
/*table 9*/
DBusMessage * wid_dbus_interface_show_wlan_ssid_stats_information(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply = NULL;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusMessageIter iter_struct;
	DBusMessageIter iter_sub_array;
	DBusMessageIter iter_sub_struct;
	/*zhaoruijia,20100804,radiowlan start*/
    DBusMessageIter iter_sub_sub_array;
	DBusMessageIter iter_sub_sub_struct;
	/*zhaoruijia,20100804,radiowlan  ,end*/
	DBusMessageIter iter_sub_essid_array;
	DBusMessageIter iter_sub_essid_struct;
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int wtp_num = 0;
	int i=0, j=0,l/*, k=0*/;
	int ii=0,jj=0, kk=0;
	unsigned char radioBindToWlanNum = 0;//radio wlan
    //unsigned int wtp_bss_num = 0;
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);

	WID_WTP **WTP=NULL;
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	if( WTP == NULL){
		wid_syslog_debug_debug(WID_DBUS,"%s :malloc fail.\n",__func__);
		exit(1);
	}
	memset(WTP,0,WTP_NUM*(sizeof(WID_WTP *)));
	
    unsigned char * bss_id =NULL;
	bss_id = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	wtp_num = Wid_Find_Wtp(WTP);
	
	/*for  accounting bss infor*/
	WID_WTP_RADIO	**AC_RADIO_FOR_SEARCH=NULL;
	AC_RADIO_FOR_SEARCH = WID_MALLOC(G_RADIO_NUM*(sizeof(WID_WTP_RADIO *)));
	if( AC_RADIO_FOR_SEARCH == NULL){
		wid_syslog_debug_debug(WID_DBUS,"%s :malloc fail.\n",__func__);
		exit(1);
	}
	//WID_BSS *BSS[L_BSS_NUM];
	/*zhaoruijia,20100805,for Radio id */
     unsigned  int Radioid =0;
	unsigned int radio_l_id = 0;     //fengwenchao add 20110224
	/*for wlan infor*/
	struct wlanid *wlanidlist = NULL;
	unsigned char wlanlist[WLAN_NUM];//wlanlist has 16 elements,0 means not bind this wlan,1 means bind this wlan
	unsigned char wlanid =0;

	char * Essid = NULL;
	Essid = (char*)WID_MALLOC(ESSID_LENGTH+1);
	if (!Essid) {
		wid_syslog_err("wid_snmp_debug: %s %d\n", __FUNCTION__, __LINE__);
		return reply;
	}
	memset(Essid,0,ESSID_LENGTH+1);
	memcpy(Essid,"illegalEssid",sizeof("illegalEssid"));
	if(wtp_num == 0)
		ret = WTP_ID_NOT_EXIST;

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &wtp_num);

	
	dbus_message_iter_open_container (&iter,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_UINT32_AS_STRING
	                                            DBUS_TYPE_BYTE_AS_STRING		 //mac1
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING		//mac 6
	                                            DBUS_TYPE_UINT32_AS_STRING		//tx_mgmt
												DBUS_TYPE_UINT32_AS_STRING		//rx_mgmt
	                                            DBUS_TYPE_UINT32_AS_STRING	//rx_packets
												DBUS_TYPE_UINT32_AS_STRING	//tx_packets
												DBUS_TYPE_UINT64_AS_STRING	//rx_bytes
												DBUS_TYPE_UINT64_AS_STRING	//tx_bytes
												DBUS_TYPE_UINT32_AS_STRING	//rx_rate
												DBUS_TYPE_UINT32_AS_STRING	//tx_rate
	                                            DBUS_TYPE_BYTE_AS_STRING		//Radio_num
												    DBUS_TYPE_ARRAY_AS_STRING/*Radio infor*/
													DBUS_STRUCT_BEGIN_CHAR_AS_STRING
														DBUS_TYPE_UINT32_AS_STRING//Radioid
												        DBUS_TYPE_BYTE_AS_STRING//radioBindToWlanNum
												        DBUS_TYPE_BYTE_AS_STRING//pureN Mixed  fengwenchao 20110331
												          DBUS_TYPE_ARRAY_AS_STRING /*BSS infor*/
														  DBUS_STRUCT_BEGIN_CHAR_AS_STRING
														      DBUS_TYPE_BYTE_AS_STRING//wlanid
                                                              DBUS_TYPE_UINT64_AS_STRING	//rx_unicast
												              DBUS_TYPE_UINT64_AS_STRING	//tx_unicast
												              DBUS_TYPE_UINT64_AS_STRING	//rx_broadcast
												              DBUS_TYPE_UINT64_AS_STRING	// tx_broadcast
												              DBUS_TYPE_UINT64_AS_STRING   //retrytmp
                                                              DBUS_TYPE_BYTE_AS_STRING 	   //bssid0
												              DBUS_TYPE_BYTE_AS_STRING     //bssid1
															  DBUS_TYPE_BYTE_AS_STRING     //bssid2
															  DBUS_TYPE_BYTE_AS_STRING     //bssid3
															  DBUS_TYPE_BYTE_AS_STRING     //bssid5
															  DBUS_TYPE_BYTE_AS_STRING 	   //bssid 5
															  DBUS_TYPE_BYTE_AS_STRING 	   //state
														      DBUS_TYPE_UINT32_AS_STRING   //bss_max_allowed_sta_num
														      DBUS_TYPE_BYTE_AS_STRING 	   //balance_switch
													          DBUS_TYPE_BYTE_AS_STRING 	   //security id
													DBUS_TYPE_ARRAY_AS_STRING
													DBUS_STRUCT_BEGIN_CHAR_AS_STRING
															  DBUS_TYPE_BYTE_AS_STRING   //essid
														DBUS_STRUCT_END_CHAR_AS_STRING	  
															  DBUS_TYPE_UINT32_AS_STRING   //vlanid
															  /*fengwenchao add 20110617*/
															DBUS_TYPE_UINT32_AS_STRING           //rx_data_pkts
															DBUS_TYPE_UINT32_AS_STRING          //tx_data_pkts
															/*fengwenchao add end*/
															  DBUS_TYPE_UINT32_AS_STRING      //SSID           fengwenchao add 20110127
															  DBUS_TYPE_UINT32_AS_STRING      //SSID
															  DBUS_TYPE_UINT32_AS_STRING      //SSID
															  DBUS_TYPE_UINT32_AS_STRING      // SSID
															  DBUS_TYPE_UINT32_AS_STRING      //SSID
															  DBUS_TYPE_UINT32_AS_STRING      //SSID	
															  DBUS_TYPE_UINT32_AS_STRING      //
															  DBUS_TYPE_UINT32_AS_STRING      //     fengwenchao add end
															  DBUS_TYPE_BYTE_AS_STRING        //traffic_limit_able     fengwenchao add 20110331
															  DBUS_TYPE_UINT32_AS_STRING      //send_traffic_limit    fengwenchao add 20110331
														   DBUS_STRUCT_END_CHAR_AS_STRING
												     DBUS_STRUCT_END_CHAR_AS_STRING
	                                      DBUS_STRUCT_END_CHAR_AS_STRING,
                                    &iter_array);
    //printf("************acd_wtp_num = %d*********\n",wtp_num);

	for(i = 0; i < wtp_num; i++){	
		unsigned int rx_packets = 0;
		unsigned int tx_packets = 0;
		unsigned long long rx_bytes = 0;
		unsigned long long tx_bytes = 0;
		unsigned int rx_rate = 0;
		unsigned int tx_rate = 0;
		unsigned long tx_pkt_mgmt = 0;	//xiaodawei add, 20110421
		unsigned long rx_pkt_mgmt = 0;
		//unsigned int wifi_extension_info_tx_mgmt = 0;
		//unsigned int wifi_extension_info_rx_mgmt = 0;
		
//		unsigned char radiocount =0;
		unsigned char num_of_radio = 0;
		//wtp_bss_num = 0;
//		unsigned char bwlannum = 0;
		memset(wlanlist,0,WLAN_NUM);
		
		memset(AC_RADIO_FOR_SEARCH,0,L_RADIO_NUM*(sizeof(WID_WTP_RADIO *)));
		num_of_radio = WID_WTP_FIND_RADIO(AC_RADIO_FOR_SEARCH,WTP[i]);
		
		memset(mac,0,MAC_LEN+1);
		if(WTP[i]->WTPMAC != NULL)
			memcpy(mac,WTP[i]->WTPMAC,MAC_LEN);
		
		dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
		
		
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_UINT32,
										&(WTP[i]->WTPID));
			
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[0]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[1]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[2]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[3]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[4]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[5]));
#if 0		
		if(WTP[i]->wifi_extension_reportswitch ==1){
			dbus_message_iter_append_basic(&iter_struct, 
											DBUS_TYPE_UINT32, 
											&(WTP[i]->wifi_extension_info.tx_mgmt));
			
			dbus_message_iter_append_basic(&iter_struct, 
											DBUS_TYPE_UINT32, 
											&(WTP[i]->wifi_extension_info.rx_mgmt));
		}
		else{
			dbus_message_iter_append_basic(&iter_struct, 
											DBUS_TYPE_UINT32, 
											&(wifi_extension_info_tx_mgmt));
						
			dbus_message_iter_append_basic(&iter_struct, 
											DBUS_TYPE_UINT32, 
											&(wifi_extension_info_rx_mgmt));
		}
#endif			
		for(j=0; j<TOTAL_AP_IF_NUM; j++){
			if((WTP[i]->apstatsinfo[j].radioId < TOTAL_AP_IF_NUM+1)
			    &&(WTP[i]->apstatsinfo[j].type == 0)){
			  
				rx_packets += WTP[i]->apstatsinfo[j].rx_packets;
				tx_packets += WTP[i]->apstatsinfo[j].tx_packets;
				rx_bytes += WTP[i]->apstatsinfo[j].rx_bytes;
				tx_bytes += WTP[i]->apstatsinfo[j].tx_bytes;
				rx_rate += WTP[i]->apstatsinfo[j].rx_rate;
				/*tx_rate = WTP[i]->rate;*/                      //fengwenchao modify 20110302 before
				tx_rate += WTP[i]->apstatsinfo[j].tx_rate;      //fengwenchao modify 20110302 now
				tx_pkt_mgmt += WTP[i]->apstatsinfo[j].tx_pkt_mgmt;
				rx_pkt_mgmt += WTP[i]->apstatsinfo[j].rx_pkt_mgmt;
			}
		}
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_UINT32,
										&tx_pkt_mgmt);
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_UINT32,
										&rx_pkt_mgmt);
		dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_UINT32,
									  &(rx_packets));
		dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_UINT32,
									  &(tx_packets));

		dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_UINT64,
									  &(rx_bytes));
		dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_UINT64,
									  &(tx_bytes));	
		
		dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_UINT32,
									  &(rx_rate));
		dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_UINT32,
									  &(tx_rate));	

#if 0
		for(k=0;k<num_of_radio;k++){	
			unsigned char radio_bss_num = 0;
			for(ii=0;ii<L_BSS_NUM;ii++){
				if(AC_RADIO_FOR_SEARCH[k]->BSS[ii] != NULL)
				{
					//BSS[radio_bss_num] = AC_RADIO_FOR_SEARCH[k]->BSS[ii];
					radio_bss_num++;
					wtp_bss_num ++;
				}
			}
		}
#endif

		for(j=0; j<(WTP[i]->RadioCount); j++)
		{
			if(WTP[i]->WTP_Radio[j] != NULL)
			{
				wlanidlist = WTP[i]->WTP_Radio[j]->Wlan_Id;
				while(wlanidlist != NULL && (AC_WLAN[wlanidlist->wlanid] != NULL && AC_WLAN[wlanidlist->wlanid]->want_to_delete != 1))		/* Huangleilei add for ASXXZFI-1622 */
				{
					wlanid = wlanidlist->wlanid;
					if(wlanlist[wlanid] == 1)
					{
						//printf("wlan %d is already in the list\n",wlanid);
					}
					else
					{
						//printf("wlan %d is not in the list\n",wlanid);
						wlanlist[wlanid] = 1;
						//printf("wlanlist %d %d\n",wlanid,wlanlist[wlanid]);
					}

					wlanidlist = wlanidlist->next;
				}
			}
		}
	
	    //printf("************acd_num_of_radio = %d*********\n",num_of_radio);
	    dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&num_of_radio);//Radio

	
	    dbus_message_iter_open_container (&iter_struct,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_UINT32_AS_STRING //Radioid
												DBUS_TYPE_BYTE_AS_STRING//radioBindToWlanNum
												DBUS_TYPE_BYTE_AS_STRING//pureN Mixed  fengwenchao 20110331
											       DBUS_TYPE_ARRAY_AS_STRING /*BSS infor*/
												   DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												      DBUS_TYPE_BYTE_AS_STRING      //wlanid
                                                      DBUS_TYPE_UINT64_AS_STRING	//rx_unicast
										              DBUS_TYPE_UINT64_AS_STRING	//tx_unicast
										              DBUS_TYPE_UINT64_AS_STRING	//rx_broadcast
										              DBUS_TYPE_UINT64_AS_STRING	// tx_broadcast
										              DBUS_TYPE_UINT64_AS_STRING    //retrytmp

										              DBUS_TYPE_BYTE_AS_STRING 	     //bssid0
										              DBUS_TYPE_BYTE_AS_STRING
													  DBUS_TYPE_BYTE_AS_STRING
													  DBUS_TYPE_BYTE_AS_STRING
													  DBUS_TYPE_BYTE_AS_STRING
													  DBUS_TYPE_BYTE_AS_STRING 	   //bssid 5
																									   
													  DBUS_TYPE_BYTE_AS_STRING 	   //state
												      DBUS_TYPE_UINT32_AS_STRING   //bss_max_allowed_sta_num
												      DBUS_TYPE_BYTE_AS_STRING 	   //balance_switch
											          DBUS_TYPE_BYTE_AS_STRING 	   //security id
													DBUS_TYPE_ARRAY_AS_STRING
													DBUS_STRUCT_BEGIN_CHAR_AS_STRING
													  DBUS_TYPE_BYTE_AS_STRING   //essid
												DBUS_STRUCT_END_CHAR_AS_STRING
													  DBUS_TYPE_UINT32_AS_STRING   //vlanid
													  /*fengwenchao add 20110617*/
													DBUS_TYPE_UINT32_AS_STRING           //rx_data_pkts
													DBUS_TYPE_UINT32_AS_STRING          //tx_data_pkts
													/*fengwenchao add end*/
													  DBUS_TYPE_UINT32_AS_STRING      //SSID    fengwenchao add 20110127
													  DBUS_TYPE_UINT32_AS_STRING      //SSID
													  DBUS_TYPE_UINT32_AS_STRING      //SSID
													  DBUS_TYPE_UINT32_AS_STRING      // SSID
													  DBUS_TYPE_UINT32_AS_STRING      //SSID
													  DBUS_TYPE_UINT32_AS_STRING      //SSID
													  DBUS_TYPE_UINT32_AS_STRING      //
												   	  DBUS_TYPE_UINT32_AS_STRING      //		 fengwenchao add end	
												   	  DBUS_TYPE_BYTE_AS_STRING        //traffic_limit_able     fengwenchao add 20110331
													  DBUS_TYPE_UINT32_AS_STRING      //send_traffic_limit    fengwenchao add 20110331
												   DBUS_STRUCT_END_CHAR_AS_STRING
										 DBUS_STRUCT_END_CHAR_AS_STRING,
									  &iter_sub_array);
	
   for(kk=0;kk<L_RADIO_NUM;kk++)
   	{
     if(WTP[i]->WTP_Radio[kk] != NULL)
	 {
       
           Radioid = WTP[i]->WTP_Radio[kk]->Radio_G_ID;
		    radio_l_id = WTP[i]->WTP_Radio[kk]->Radio_L_ID;    //fengwenchao add 20110224
		   radioBindToWlanNum = 0;
		   //printf("************acd_Radioid = %d*********\n",Radioid);
	       dbus_message_iter_open_container (&iter_sub_array,
		 									 DBUS_TYPE_STRUCT,
		 									 NULL,
											 &iter_sub_struct);
				
		   dbus_message_iter_append_basic (&iter_sub_struct,DBUS_TYPE_UINT32 ,&Radioid);
		   for(ii=0;ii<WLAN_NUM;ii++)
		   	{
                 
				 if(wlanlist[ii] == 1)
                 	{
                      wlanid = (unsigned char)ii;
					 
					  for(jj=0;jj<L_BSS_NUM;jj++)
		      	       {
				   
                           if((WTP[i]->WTP_Radio[kk]->BSS[jj] != NULL)
								&&(WTP[i]->WTP_Radio[kk]->BSS[jj]->WlanID==wlanid)
								&&(WTP[i]->WTP_Radio[kk]->BSS[jj]->BSSID != NULL)){

								radioBindToWlanNum++;
								break;
								
                             }
		                }
                   
				  }
		    }
        //printf("************acd_radioBindToWlanNum = %d*********\n",radioBindToWlanNum);
		dbus_message_iter_append_basic (&iter_sub_struct,DBUS_TYPE_BYTE,&radioBindToWlanNum);//WTPRadiowlan
		dbus_message_iter_append_basic (&iter_sub_struct,DBUS_TYPE_BYTE,&(WTP[i]->WTP_Radio[kk]->MixedGreenfield.Mixed_Greenfield));   //fengwenchao add 20110331
      
		dbus_message_iter_open_container (&iter_sub_struct,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING//wlanid
											    DBUS_TYPE_UINT64_AS_STRING	//rx_unicast
												DBUS_TYPE_UINT64_AS_STRING	//tx_unicast
												DBUS_TYPE_UINT64_AS_STRING	//rx_broadcast
												DBUS_TYPE_UINT64_AS_STRING	// tx_broadcast
												DBUS_TYPE_UINT64_AS_STRING  //retrytmp

												DBUS_TYPE_BYTE_AS_STRING		//bssid0
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING		//bssid 5
												
												DBUS_TYPE_BYTE_AS_STRING		//state
												DBUS_TYPE_UINT32_AS_STRING		//bss_max_allowed_sta_num
												DBUS_TYPE_BYTE_AS_STRING		//balance_switch
												
												DBUS_TYPE_BYTE_AS_STRING		//security id
												DBUS_TYPE_ARRAY_AS_STRING
												DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING		//essid
												DBUS_STRUCT_END_CHAR_AS_STRING
												DBUS_TYPE_UINT32_AS_STRING		//vlanid
												/*fengwenchao add 20110617*/
												DBUS_TYPE_UINT32_AS_STRING           //rx_data_pkts
												DBUS_TYPE_UINT32_AS_STRING          //tx_data_pkts
												/*fengwenchao add end*/
												DBUS_TYPE_UINT32_AS_STRING      //SSID        fengwenchao add 20110127
												DBUS_TYPE_UINT32_AS_STRING      //SSID
												DBUS_TYPE_UINT32_AS_STRING      //SSID
												DBUS_TYPE_UINT32_AS_STRING      // SSID
												DBUS_TYPE_UINT32_AS_STRING      //SSID
												DBUS_TYPE_UINT32_AS_STRING      //SSID
												DBUS_TYPE_UINT32_AS_STRING      //
												DBUS_TYPE_UINT32_AS_STRING      //     fengwenchao add end
												DBUS_TYPE_BYTE_AS_STRING        //traffic_limit_able     fengwenchao add 20110331
												DBUS_TYPE_UINT32_AS_STRING      //send_traffic_limit    fengwenchao add 20110331
										DBUS_STRUCT_END_CHAR_AS_STRING,
										&iter_sub_sub_array);
		
		for(ii=0;ii<WLAN_NUM;ii++)
           	{
    		   if(wlanlist[ii] == 1)
    		   	{
    		   	    //printf("wlanlist[%d] == 1\n",ii);
    				unsigned long long rx_unicast = 0;
    				unsigned long long tx_unicast = 0;
    				unsigned long long rx_broadcast = 0;
    				unsigned long long tx_broadcast = 0;
    				unsigned long long retry = 0;
				unsigned int rx_data_pkts = 0;  //fengwenchao add 20110617
				unsigned int 	tx_data_pkts = 0;  //fengwenchao add 20110617
//    				unsigned char wlan_id = 0;
    				unsigned int bss_max_allowed_sta_num = 0;
    				unsigned char State = 0;
    				unsigned char balance_switch = 0 ;
    				unsigned char SecurityID = 0 ;
    				//char * Essid = NULL;
					unsigned int vlanid = 0;
    				int isRadioBindToWlan = 0;
                    wlanid = (unsigned char)ii;
                    //printf("wlanid = %d\n",wlanid);
					unsigned int SSIDDwErrPkts = 0;              //fengwenchao add 20101215 begin
					unsigned int SSIDDwDropPkts = 0;
					unsigned int SSIDDwTotErrFrames = 0;
					unsigned int SSIDUpErrPkts = 0;
					unsigned int SSIDUpDropPkts = 0;
					unsigned int SSIDUpTotErrFrames = 0; 
					unsigned int WlanradioRecvSpeed = 0;
					unsigned int WlanradioSendSpeed = 0;   //fengwenchao add 20101215 end
					unsigned char traffic_limit_able;      //fengwenchao add 20110331
					unsigned int  send_traffic_limit;      //fengwenchao add 20110331
					
    			    unsigned int mm = 0;
                    for(mm = 0; mm < TOTAL_AP_IF_NUM; mm++){
                    /* circle ap statistics for type 0 while WlanId = wlanid and RadioId = radioid */
                        if((0 == WTP[i]->apstatsinfo[mm].type) && 
                            (wlanid == WTP[i]->apstatsinfo[mm].wlanId) &&
                            (kk == WTP[i]->apstatsinfo[mm].radioId)){
                            //printf("TOTAL_AP_IF_NUM OK\n");
                            rx_unicast = (unsigned long long)WTP[i]->apstatsinfo[mm].rx_pkt_unicast;
                            tx_unicast = (unsigned long long)WTP[i]->apstatsinfo[mm].tx_pkt_unicast;
                            rx_broadcast = WTP[i]->apstatsinfo[mm].rx_pkt_multicast;    //book modify, 2011-1-20    
                            tx_broadcast = WTP[i]->apstatsinfo[mm].tx_pkt_multicast;    //book modify, 2011-1-20
                            retry = (unsigned long long)WTP[i]->apstatsinfo[mm].tx_pkt_retry;	//xiaodawei modify, 20110425

				rx_data_pkts = WTP[i]->apstatsinfo[mm].rx_pkt_data;   //fengwenchao add 20110617
				tx_data_pkts = WTP[i]->apstatsinfo[mm].tx_pkt_data;   //fengwenchao add 20110617
							SSIDDwErrPkts += WTP[i]->apstatsinfo[mm].rx_errors;        //  fengwenchao  add 201015
							SSIDDwDropPkts += WTP[i]->apstatsinfo[mm].rx_drop;         //  fengwenchao  add 201015
							SSIDDwTotErrFrames += WTP[i]->apstatsinfo[mm].rx_errors;   //  fengwenchao  add 201015
							SSIDUpErrPkts += WTP[i]->apstatsinfo[mm].tx_errors;        //  fengwenchao  add 201015
							SSIDUpDropPkts += WTP[i]->apstatsinfo[mm].tx_drop;         //  fengwenchao  add 201015
							SSIDUpTotErrFrames += WTP[i]->apstatsinfo[mm].tx_errors;   //  fengwenchao  add 201015
							
                            break;
                        }
                    }
					//fengwenchao modify 20110221
					for(mm = 0;mm < TOTAL_AP_IF_NUM; mm++)               
					{
						   if((2 ==WTP[i]->apstatsinfo[mm].type)&& //wifi --2
				            (radio_l_id == WTP[i]->apstatsinfo[mm].wlanId)/*&&*/
                            /*(kk == WTP[i]->apstatsinfo[mm].radioId)*/)
                            {
				 				 WlanradioRecvSpeed += WTP[i]->apstatsinfo[mm].tx_rate;
								 WlanradioSendSpeed += WTP[i]->apstatsinfo[mm].rx_rate;	
							}
                    
					}
					//fengwenchao modify end

                    for(jj=0;jj<L_BSS_NUM;jj++){
                        //printf("jj = %d\n",jj);
                        memset(bss_id,0,MAC_LEN+1);
						if((WTP[i]->WTP_Radio[kk]->BSS[jj] != NULL)
							&&(WTP[i]->WTP_Radio[kk]->BSS[jj]->WlanID == wlanid)
							&&(WTP[i]->WTP_Radio[kk]->BSS[jj]->BSSID != NULL)){
							//printf("WTP[%d]->WTP_Radio[%d]->BSS[%d]->WlanID = %d\n",i,kk,jj,WTP[i]->WTP_Radio[kk]->BSS[jj]->WlanID);
                            //printf("BSS OK\n");
							if(WTP[i]->WTP_Radio[kk]->BSS[jj]->BSSID != NULL)
                                memcpy( bss_id,WTP[i]->WTP_Radio[kk]->BSS[jj]->BSSID,MAC_LEN) ;
                            
							bss_max_allowed_sta_num = WTP[i]->WTP_Radio[kk]->BSS[jj]->bss_max_allowed_sta_num;
							State = WTP[i]->WTP_Radio[kk]->BSS[jj]->State;

							vlanid = WTP[i]->WTP_Radio[kk]->BSS[jj]->vlanid;//xiaodawei add 20101028

							traffic_limit_able = WTP[i]->WTP_Radio[kk]->BSS[jj]->traffic_limit_able;  //fengwenchao add 20110331
							send_traffic_limit = WTP[i]->WTP_Radio[kk]->BSS[jj]->send_traffic_limit;  //fengwenchao add 20110331

							isRadioBindToWlan = 1;

							if((AC_WLAN[wlanid]!=NULL)&&(AC_WLAN[wlanid]->ESSID != NULL)){
								balance_switch = AC_WLAN[wlanid]->balance_switch ;
								SecurityID = AC_WLAN[wlanid]->SecurityID ; 
								//Essid= (char*)malloc(strlen(AC_WLAN[wlanid]->ESSID)+1);
								memset(Essid,0,ESSID_LENGTH+1);
								if(strlen(AC_WLAN[wlanid]->ESSID) <= ESSID_LENGTH)
									memcpy(Essid,AC_WLAN[wlanid]->ESSID,ESSID_LENGTH);
							}
							break;	
						}
				    }
				    //printf("isRadioBindToWlan = %d\n",isRadioBindToWlan);
    			  	
    			  if(isRadioBindToWlan){
    			  	//printf("Transport begin.\n");
    			  	dbus_message_iter_open_container (&iter_sub_sub_array,
    													DBUS_TYPE_STRUCT,
    													NULL,
    													&iter_sub_sub_struct);
    			  	dbus_message_iter_append_basic (&iter_sub_sub_struct,DBUS_TYPE_BYTE,   &wlanid);
    				
                    dbus_message_iter_append_basic(&iter_sub_sub_struct, DBUS_TYPE_UINT64, &rx_unicast);
    				
    				dbus_message_iter_append_basic(&iter_sub_sub_struct, DBUS_TYPE_UINT64, &tx_unicast);
    				
    				dbus_message_iter_append_basic(&iter_sub_sub_struct, DBUS_TYPE_UINT64, &rx_broadcast);
    				
    				dbus_message_iter_append_basic(&iter_sub_sub_struct, DBUS_TYPE_UINT64, &tx_broadcast);
    				
    				dbus_message_iter_append_basic(&iter_sub_sub_struct, DBUS_TYPE_UINT64, &retry);


    				dbus_message_iter_append_basic(&iter_sub_sub_struct, 
    												DBUS_TYPE_BYTE, 
    												&bss_id[0]);
    				dbus_message_iter_append_basic(&iter_sub_sub_struct, 
    												DBUS_TYPE_BYTE, 
    												&bss_id[1]);		//bssid 1
    				dbus_message_iter_append_basic(&iter_sub_sub_struct, 
    												DBUS_TYPE_BYTE, 
    												&bss_id[2]);
    				dbus_message_iter_append_basic(&iter_sub_sub_struct, 
    												DBUS_TYPE_BYTE, 
    												&bss_id[3]);		//bssid 3
    				dbus_message_iter_append_basic(&iter_sub_sub_struct, 
    												DBUS_TYPE_BYTE, 
    												&bss_id[4]);
    				dbus_message_iter_append_basic(&iter_sub_sub_struct, 
    												DBUS_TYPE_BYTE, 
    												&bss_id[5]);		//bssid 5
                    
    				dbus_message_iter_append_basic(&iter_sub_sub_struct, 
    												DBUS_TYPE_BYTE, 
    												&State);										//State
    				dbus_message_iter_append_basic(&iter_sub_sub_struct, 
    												DBUS_TYPE_UINT32, 
    												&bss_max_allowed_sta_num);				//bss_max_allowed_sta_num
                    
    				dbus_message_iter_append_basic(&iter_sub_sub_struct, 
    												DBUS_TYPE_BYTE, 
    												&balance_switch);								//balance_switch
    											
    				dbus_message_iter_append_basic(&iter_sub_sub_struct, 
    												DBUS_TYPE_BYTE, 
    												&SecurityID);		//SecurityID

				dbus_message_iter_open_container (&iter_sub_sub_struct,
										   DBUS_TYPE_ARRAY,
										   DBUS_STRUCT_BEGIN_CHAR_AS_STRING  
											  DBUS_TYPE_BYTE_AS_STRING
										   DBUS_STRUCT_END_CHAR_AS_STRING, 
										   &iter_sub_essid_array);
					for(l=0;l<ESSID_LENGTH;l++)
					{
						dbus_message_iter_open_container (&iter_sub_essid_array,
															DBUS_TYPE_STRUCT,
															NULL,
														  &iter_sub_essid_struct);
						
						dbus_message_iter_append_basic(&iter_sub_essid_struct,
									  DBUS_TYPE_BYTE,
									  &Essid[l]);
						dbus_message_iter_close_container (&iter_sub_essid_array ,&iter_sub_essid_struct);
					}
					dbus_message_iter_close_container (&iter_sub_sub_struct, &iter_sub_essid_array);	

					dbus_message_iter_append_basic(&iter_sub_sub_struct,
													DBUS_TYPE_UINT32,
													&vlanid);							//vlanid, xiaodawei add 20101028
				//CW_FREE_OBJECT(Essid);									
				dbus_message_iter_append_basic(&iter_sub_sub_struct,
												DBUS_TYPE_UINT32,
												&rx_data_pkts);							//rx_data_pkts, fengwenchao add 20110617
				dbus_message_iter_append_basic(&iter_sub_sub_struct,
												DBUS_TYPE_UINT32,
												&tx_data_pkts);							//tx_data_pkts, fengwenchao add 20110617					
					dbus_message_iter_append_basic(&iter_sub_sub_struct,
													DBUS_TYPE_UINT32,
													&SSIDDwErrPkts);					  //fengwenchao add 20101215
					dbus_message_iter_append_basic(&iter_sub_sub_struct,
													DBUS_TYPE_UINT32,
													&SSIDDwDropPkts);					  //fengwenchao add 20101215
					dbus_message_iter_append_basic(&iter_sub_sub_struct,
													DBUS_TYPE_UINT32,
													&SSIDDwTotErrFrames);					  //fengwenchao add 20101215
					dbus_message_iter_append_basic(&iter_sub_sub_struct,
													DBUS_TYPE_UINT32,
													&SSIDUpErrPkts);					  //fengwenchao add 20101215
					dbus_message_iter_append_basic(&iter_sub_sub_struct,
													DBUS_TYPE_UINT32,
													&SSIDUpDropPkts);					  //fengwenchao add 20101215		
					dbus_message_iter_append_basic(&iter_sub_sub_struct,
													DBUS_TYPE_UINT32,
													&SSIDUpTotErrFrames);					  //fengwenchao add 20101215													


					dbus_message_iter_append_basic(&iter_sub_sub_struct,                    //fengwenchao add 20101215	
													DBUS_TYPE_UINT32,
													&WlanradioRecvSpeed);
					dbus_message_iter_append_basic(&iter_sub_sub_struct,                     //fengwenchao add 20101215	
													DBUS_TYPE_UINT32,
													&WlanradioSendSpeed);

					dbus_message_iter_append_basic(&iter_sub_sub_struct,                     //fengwenchao add 20110331
													DBUS_TYPE_BYTE,
													&traffic_limit_able);
					dbus_message_iter_append_basic(&iter_sub_sub_struct,                     //fengwenchao add 20110331	
													DBUS_TYPE_UINT32,
													&send_traffic_limit);					

													
					/*
                                    printf("***acd_wlanid = %d*********\n",wlanid);
                                    printf("***acd_rx_unicast = %llu*********\n",rx_unicast);
                                    printf("***acd_tx_unicast = %llu*********\n",tx_unicast);
                                    printf("***acd_rx_broadcast = %llu*********\n",rx_broadcast);
                                    printf("***acd_tx_broadcast = %llu*********\n",tx_broadcast);
                                    printf("***acd_retry = %llu*********\n",retry);
                                    printf("***acd_BSS[0]->BSSID[0] = %d*********\n",BSS[0]->BSSID[0]);
                                    printf("***acd_BSS[0]->BSSID[0] = %d*********\n",BSS[0]->BSSID[1]);								
                                    printf("***acd_State = %d*********\n",State);	
                                    printf("***acd_bss_max_allowed_sta_num = %d*********\n",bss_max_allowed_sta_num);
                                    printf("***acd_bss_balance_switch = %d*********\n",balance_switch);
                                    printf("***acd_bss_SecurityID = %d*********\n",SecurityID);
                                    printf("***acd_Essid = %s*********\n",Essid);	
    				        */
    				dbus_message_iter_close_container (&iter_sub_sub_array, &iter_sub_sub_struct);
                 }
    		  }
           } 
           dbus_message_iter_close_container (&iter_sub_struct, &iter_sub_sub_array);
    	   dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);
    	 }
       }

		dbus_message_iter_close_container (&iter_struct, &iter_sub_array);
  		dbus_message_iter_close_container (&iter_array, &iter_struct);	//wtp num
    }
	dbus_message_iter_close_container (&iter, &iter_array);			
	CW_FREE_OBJECT_WID(Essid);
	CW_FREE_OBJECT_WID(WTP);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(AC_RADIO_FOR_SEARCH);
	CW_FREE_OBJECT_WID(bss_id);    //fengwenchao add 20101224
	return reply;	
}


/*nl add for showing wtp ifname information table 10*/
DBusMessage * wid_dbus_interface_show_wtp_ifname_information(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusMessageIter iter_struct;
	DBusMessageIter iter_sub_array;
	DBusMessageIter iter_sub_struct;
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int num=0;
	int i=0, j =0;
	int k=0;
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	WID_WTP **WTP;
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	
	num = Wid_Find_Wtp(WTP);
	
	if(num == 0)
		ret = WTP_ID_NOT_EXIST;
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	// Total slot count
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
		
	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING	//wtpid
											DBUS_TYPE_STRING_AS_STRING	//model
											
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING	//eth num

											/*eth infor*/
											DBUS_TYPE_ARRAY_AS_STRING
												DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING	// type
												DBUS_TYPE_BYTE_AS_STRING  //report switch
												DBUS_TYPE_BYTE_AS_STRING	//ifindex
												DBUS_TYPE_BYTE_AS_STRING	//state
												DBUS_TYPE_UINT32_AS_STRING	// state_time
												DBUS_TYPE_UINT32_AS_STRING  // eth_rate
												DBUS_TYPE_UINT32_AS_STRING  //eth_mtu    fengwenchao add 20110127 for XJDEV-32 from 2.0
                                                DBUS_TYPE_UINT32_AS_STRING  //ap uplink rate
												DBUS_TYPE_UINT32_AS_STRING  //ap downlink rate
												
												DBUS_STRUCT_END_CHAR_AS_STRING

									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for(i = 0; i < num; i++){	
		unsigned int UplinkRealtimeRate[AP_ETH_IF_NUM]={0};
		unsigned int DownlinkRealtimeRate[AP_ETH_IF_NUM]={0};
        int ethcount = 0;
		memset(mac,0,MAC_LEN+1);

/*		for(k=0; k<TOTAL_AP_IF_NUM; k++)
		{
			if((WTP[i]->apstatsinfo[k].radioId < TOTAL_AP_IF_NUM+1)&&
				(WTP[i]->apstatsinfo[k].type == 1)){//eth

				 UplinkRealtimeRate[ethcount] = WTP[i]->apstatsinfo[k].tx_rate;//ap uplink rate
				 DownlinkRealtimeRate[ethcount] =  WTP[i]->apstatsinfo[k].rx_rate;//ap downlink rate
                 ethcount++;

			}
          
		}*/
		if(WTP[i]->WTPMAC != NULL)
			memcpy(mac,WTP[i]->WTPMAC,MAC_LEN);
		
		dbus_message_iter_open_container (&iter_array,
										DBUS_TYPE_STRUCT,
										NULL,
										&iter_struct);
		
		dbus_message_iter_append_basic(&iter_struct,
										  DBUS_TYPE_UINT32,
										  &(WTP[i]->WTPID));
				
		dbus_message_iter_append_basic(&iter_struct,
										  DBUS_TYPE_STRING,
										  &(WTP[i]->WTPModel));
				
		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_BYTE,
												&(mac[0]));
		
		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_BYTE,
												&(mac[1]));

		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_BYTE,
												&(mac[2]));

		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_BYTE,
												&(mac[3]));

		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_BYTE,
												&(mac[4]));

		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_BYTE,
												&(mac[5]));
		
		dbus_message_iter_append_basic(&iter_struct,
												DBUS_TYPE_BYTE,
												&(WTP[i]->apifinfo.eth_num));
		
		dbus_message_iter_open_container (&iter_struct,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING	// type
												DBUS_TYPE_BYTE_AS_STRING  //report switch
												DBUS_TYPE_BYTE_AS_STRING	//ifindex
												DBUS_TYPE_BYTE_AS_STRING	//state
												DBUS_TYPE_UINT32_AS_STRING	// state_time
												DBUS_TYPE_UINT32_AS_STRING  // eth_rate
												DBUS_TYPE_UINT32_AS_STRING  //eth_mtu    fengwenchao add 20110127 for XJDEV-32 from 2.0
												DBUS_TYPE_UINT32_AS_STRING  //ap uplink rate
												DBUS_TYPE_UINT32_AS_STRING  ////ap downlink rate
										DBUS_STRUCT_END_CHAR_AS_STRING,
										&iter_sub_array);
		for(j=0;j<WTP[i]->apifinfo.eth_num;j++){
			unsigned char ifindex = (unsigned char)j;
			for(k=0; k<TOTAL_AP_IF_NUM; k++)
			{
				if((WTP[i]->apstatsinfo[k].radioId < TOTAL_AP_IF_NUM+1)&&
					(WTP[i]->apstatsinfo[k].type == 1)&&
					(WTP[i]->apstatsinfo[k].wlanId == ifindex)){//eth

					 UplinkRealtimeRate[ethcount] = WTP[i]->apstatsinfo[k].tx_rate;//ap uplink rate
					 DownlinkRealtimeRate[ethcount] =  WTP[i]->apstatsinfo[k].rx_rate;//ap downlink rate
	                 ethcount++;
				}
	          
			}
			dbus_message_iter_open_container (&iter_sub_array,
														DBUS_TYPE_STRUCT,
														NULL,
														&iter_sub_struct);
	
			dbus_message_iter_append_basic(&iter_sub_struct, 
														DBUS_TYPE_BYTE, 
														&(WTP[i]->apifinfo.eth[j].type));

			dbus_message_iter_append_basic(&iter_sub_struct, 
														DBUS_TYPE_BYTE, 
														&(WTP[i]->apifinfo.report_switch));
			
			dbus_message_iter_append_basic(&iter_sub_struct, 
														DBUS_TYPE_BYTE, 
														&(WTP[i]->apifinfo.eth[j].ifindex));

			dbus_message_iter_append_basic(&iter_sub_struct, 
														DBUS_TYPE_BYTE, 
														&(WTP[i]->apifinfo.eth[j].state));

			dbus_message_iter_append_basic(&iter_sub_struct, 
														DBUS_TYPE_UINT32, 
														&(WTP[i]->apifinfo.eth[j].state_time));

			dbus_message_iter_append_basic(&iter_sub_struct, 
														DBUS_TYPE_UINT32, 
														&(WTP[i]->apifinfo.eth[j].eth_rate));
			//fengwenchao add 20110127 for XJDEV-32 from  2.0
			dbus_message_iter_append_basic(&iter_sub_struct, 
														DBUS_TYPE_UINT32, 
														&(WTP[i]->apifinfo.eth[j].eth_mtu));
			//fengwenchao add end
			dbus_message_iter_append_basic(&iter_sub_struct, 
														DBUS_TYPE_UINT32, 
														&UplinkRealtimeRate[j]);
			dbus_message_iter_append_basic(&iter_sub_struct, 
														DBUS_TYPE_UINT32, 
														&DownlinkRealtimeRate[j]);
			
			dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);
		}
		dbus_message_iter_close_container (&iter_struct, &iter_sub_array);
		dbus_message_iter_close_container (&iter_array, &iter_struct);
	}
	dbus_message_iter_close_container (&iter, &iter_array);
	CW_FREE_OBJECT_WID(WTP);
	CW_FREE_OBJECT_WID(mac);
	
	return reply;	
}
/*nl add for showing all wtp radio para information table 11*/
DBusMessage * wid_dbus_interface_show_wtp_radio_para_information(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusMessageIter iter_sub_array;
	DBusMessageIter iter_struct;
	DBusMessageIter iter_sub_struct;
	DBusError err;
	dbus_error_init(&err);
	
	int i=0, k=0;
	WID_WTP **WTP;
	unsigned char *mac = NULL;
	unsigned int wtp_num = 0;
	unsigned char num_of_radio = 0;
	WID_WTP_RADIO	**AC_RADIO_FOR_SEARCH;
	
	int ret = WID_DBUS_SUCCESS;
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	AC_RADIO_FOR_SEARCH = WID_MALLOC(G_RADIO_NUM*(sizeof(WID_WTP_RADIO *)));
	
	wtp_num = Wid_Find_Wtp(WTP);
	
	if(wtp_num == 0)
		ret = WTP_ID_NOT_EXIST;
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);

	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &wtp_num);

	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING		//WTPID
											DBUS_TYPE_BYTE_AS_STRING		//mac0
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING		//mac 5
											DBUS_TYPE_BYTE_AS_STRING 		//snr
											//DBUS_TYPE_BYTE_AS_STRING   //radio num
											DBUS_TYPE_BYTE_AS_STRING		//wtp_radio_num
												DBUS_TYPE_ARRAY_AS_STRING
														DBUS_STRUCT_BEGIN_CHAR_AS_STRING
															DBUS_TYPE_UINT32_AS_STRING	//global radio id
															DBUS_TYPE_BYTE_AS_STRING 	//local radio id
															DBUS_TYPE_UINT16_AS_STRING	//frag freshhold
															DBUS_TYPE_BYTE_AS_STRING	//IsShortPreamble
															DBUS_TYPE_UINT16_AS_STRING	//rtsthreshold
															DBUS_TYPE_BYTE_AS_STRING	//LongRetry
															DBUS_TYPE_UINT16_AS_STRING	//Radio_TXP
															DBUS_TYPE_UINT16_AS_STRING	//reportinterval
															DBUS_TYPE_UINT16_AS_STRING	//channelchangetime
												DBUS_STRUCT_END_CHAR_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for(i = 0; i < wtp_num; i++){			
		memset(mac,0,MAC_LEN+1);
		if(WTP[i]->WTPMAC != NULL)
			memcpy(mac,WTP[i]->WTPMAC,MAC_LEN);
		
		num_of_radio = WID_WTP_FIND_RADIO(AC_RADIO_FOR_SEARCH,WTP[i]);
		
		dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
		
		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_UINT32,
											&(WTP[i]->WTPID));
			
		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_BYTE,
												&(mac[0]));
		
		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_BYTE,
												&(mac[1]));
		
		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_BYTE,
												&(mac[2]));
		
		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_BYTE,
												&(mac[3]));
		
		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_BYTE,
												&(mac[4]));
		
		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_BYTE,
												&(mac[5]));

		//(AC_WTP[wtpid]->reportswitch == 0)
		dbus_message_iter_append_basic(&iter_struct, 
											DBUS_TYPE_BYTE, 
											&(WTP[i]->wifi_extension_info.wifi_snr));
		
		dbus_message_iter_append_basic(&iter_struct, 
											DBUS_TYPE_BYTE,
												&(num_of_radio));

		dbus_message_iter_open_container (&iter_struct,
											   DBUS_TYPE_ARRAY,
											  	 	DBUS_STRUCT_BEGIN_CHAR_AS_STRING
													   DBUS_TYPE_UINT32_AS_STRING	//global radio id
															DBUS_TYPE_BYTE_AS_STRING 	//local radio id
															DBUS_TYPE_UINT16_AS_STRING	//frag freshhold
															DBUS_TYPE_BYTE_AS_STRING	//IsShortPreamble
															DBUS_TYPE_UINT16_AS_STRING	//rtsthreshold
															DBUS_TYPE_BYTE_AS_STRING	//LongRetry
															DBUS_TYPE_UINT16_AS_STRING	//Radio_TXP
															DBUS_TYPE_UINT16_AS_STRING	//reportinterval
															DBUS_TYPE_UINT16_AS_STRING	//channelchangetime
												DBUS_STRUCT_END_CHAR_AS_STRING,
											   &iter_sub_array);

		for(k = 0; k < num_of_radio; k++){
			unsigned short interval = 0;
			unsigned short count = 0;
			interval = gapscanset.reportinterval;
			count = AC_RADIO_FOR_SEARCH[k]->channelchangetime;
			
			dbus_message_iter_open_container  (&iter_sub_array,
											   DBUS_TYPE_STRUCT,
											   NULL,
											   &iter_sub_struct);

			dbus_message_iter_append_basic	(&iter_sub_struct,
												  DBUS_TYPE_UINT32,
												  &(AC_RADIO_FOR_SEARCH[k]->Radio_G_ID));

			dbus_message_iter_append_basic	(&iter_sub_struct,
												  DBUS_TYPE_BYTE,
												  &(AC_RADIO_FOR_SEARCH[k]->Radio_L_ID));

			dbus_message_iter_append_basic (&iter_sub_struct,
												 DBUS_TYPE_UINT16,
												 &(AC_RADIO_FOR_SEARCH[k]->FragThreshold));

			dbus_message_iter_append_basic (&iter_sub_struct,
												 DBUS_TYPE_BYTE,
												 &(AC_RADIO_FOR_SEARCH[k]->IsShortPreamble));

			dbus_message_iter_append_basic (&iter_sub_struct,
												 DBUS_TYPE_UINT16,
												 &(AC_RADIO_FOR_SEARCH[k]->rtsthreshold));	
			
			dbus_message_iter_append_basic (&iter_sub_struct,
												 DBUS_TYPE_BYTE,
												 &(AC_RADIO_FOR_SEARCH[k]->LongRetry));	
			
			dbus_message_iter_append_basic (&iter_sub_struct,
												 DBUS_TYPE_UINT16,
												 &(AC_RADIO_FOR_SEARCH[k]->Radio_TXP));
			
			dbus_message_iter_append_basic (&iter_sub_struct,
												 DBUS_TYPE_UINT16,
												 &(count));	
		
			dbus_message_iter_append_basic (&iter_sub_struct,
												 DBUS_TYPE_UINT16,
												 &(interval));

			dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);
		}
		dbus_message_iter_close_container (&iter_struct, &iter_sub_array);		
		dbus_message_iter_close_container (&iter_array, &iter_struct);
	}
	dbus_message_iter_close_container (&iter, &iter_array);
				
	CW_FREE_OBJECT_WID(WTP);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(AC_RADIO_FOR_SEARCH);
	
	return reply;	
}

/*nl add for showing wtp eth port information table 12*/
DBusMessage * wid_dbus_interface_show_wtp_eth_port_information(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusMessageIter iter_struct;
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int num=0;
	int i=0, j = 0, k=0;
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	
	WID_WTP **WTP;
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	
	num = Wid_Find_Wtp(WTP);
	
	if(num == 0)
		ret = WTP_ID_NOT_EXIST;
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	// Total slot count
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
		
	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING	//mac1
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING	//mac6
											
											DBUS_TYPE_UINT32_AS_STRING	//tx
											DBUS_TYPE_UINT32_AS_STRING	//rate
											
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING	
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING		//downlink_rate
											DBUS_TYPE_BYTE_AS_STRING		//eth_and_wifi_num
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for(i = 0; i < num; i++){		
		int radiocount = 0;
		unsigned int rx_rate =0;
		unsigned int rate =0;
		unsigned char wifi_extension_info_eth_updown_time = 0;
		unsigned char ath_updown_times = 0;
		unsigned char eth_and_wifi_num = 0;
		memset(mac,0,MAC_LEN+1);
		if(WTP[i]->WTPMAC != NULL)
			memcpy(mac,WTP[i]->WTPMAC,MAC_LEN);
		
		dbus_message_iter_open_container (&iter_array,
										DBUS_TYPE_STRUCT,
										NULL,
										&iter_struct);
		
		dbus_message_iter_append_basic(&iter_struct,
										  DBUS_TYPE_UINT32,
										  &(WTP[i]->WTPID));
			
		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_BYTE,
												&(mac[0]));
		
		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_BYTE,
												&(mac[1]));

		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_BYTE,
												&(mac[2]));

		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_BYTE,
												&(mac[3]));

		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_BYTE,
												&(mac[4]));

		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_BYTE,
												&(mac[5]));
		
		for(j=0; j<TOTAL_AP_IF_NUM; j++){
			if(WTP[i]->apstatsinfo[j].radioId < TOTAL_AP_IF_NUM+1)
				radiocount++;
		}
		for(k=0;k<radiocount;k++){
			if(WTP[i]->apstatsinfo[k].type == 2){
				rx_rate = rx_rate + WTP[i]->apstatsinfo[k].rx_rate;
				/*rate = rate + WTP[i]->rate;*/                    //fengwenchao modify 20110302 before
				rate = rate + WTP[i]->apstatsinfo[k].tx_rate;    //fengwenchao modify 20110302 now
			}
		}
			
		dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_UINT32,
									  &(rx_rate));
		dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_UINT32,
									  &(rate));	

		for(k=0;k<AP_ETH_IF_NUM;k++)
		{
			wifi_extension_info_eth_updown_time += WTP[i]->wifi_extension_info.eth_updown_time[k];
		}

		if(WTP[i]->wifi_extension_info.ath_count > AP_ATH_IF_NUM)
			WTP[i]->wifi_extension_info.ath_count = 1;

		for(k=0;k<WTP[i]->wifi_extension_info.ath_count;k++)
		{
			ath_updown_times += WTP[i]->wifi_extension_info.ath_if_info[k].ath_updown_times;
		}

		dbus_message_iter_append_basic(&iter_struct,
										  DBUS_TYPE_BYTE,
										  &(wifi_extension_info_eth_updown_time)); 
		
		dbus_message_iter_append_basic(&iter_struct,
											  DBUS_TYPE_BYTE,
											  &(ath_updown_times));	

		dbus_message_iter_append_basic(&iter_struct, 
											DBUS_TYPE_UINT32, 
											&(WTP[i]->wid_sample_throughput.uplink_rate));

		dbus_message_iter_append_basic(&iter_struct, 
											DBUS_TYPE_UINT32, 
											&(WTP[i]->wid_sample_throughput.downlink_rate));
		
		eth_and_wifi_num = WTP[i]->apifinfo.eth_num + WTP[i]->apifinfo.wifi_num;

		dbus_message_iter_append_basic(&iter_struct, 
										DBUS_TYPE_BYTE, 
										&(eth_and_wifi_num));

		dbus_message_iter_close_container (&iter_array, &iter_struct);
	}
				
	dbus_message_iter_close_container (&iter, &iter_array);
	CW_FREE_OBJECT_WID(WTP);
	CW_FREE_OBJECT_WID(mac);
	
	return reply;	
}
/*for showting radio stats informaiton 20100520 nl table 13*/
DBusMessage * wid_dbus_interface_show_wtp_radio_stats_information(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusMessageIter iter_sub_array;
	DBusMessageIter iter_struct;
	DBusMessageIter iter_sub_struct;
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int wtp_num = 0;
	int i=0, k=0;
	unsigned int defalt_zero = 0;
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	
	WID_WTP **WTP;
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	WID_WTP_RADIO	**AC_RADIO_FOR_SEARCH;
	AC_RADIO_FOR_SEARCH = WID_MALLOC(G_RADIO_NUM*(sizeof(WID_WTP_RADIO *)));
	
	wtp_num = Wid_Find_Wtp(WTP);
	
	if(wtp_num == 0)
		ret = WTP_ID_NOT_EXIST;
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);

	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &wtp_num);

	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING		//mac0
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING		//mac 5

											DBUS_TYPE_UINT32_AS_STRING		//txpower_state
											DBUS_TYPE_BYTE_AS_STRING		//sample_time
											DBUS_TYPE_BYTE_AS_STRING		//wtp_radio_num
												DBUS_TYPE_ARRAY_AS_STRING
														DBUS_STRUCT_BEGIN_CHAR_AS_STRING
															DBUS_TYPE_UINT32_AS_STRING	//radio global id
															DBUS_TYPE_BYTE_AS_STRING	//Radio_L_ID
															DBUS_TYPE_UINT16_AS_STRING	//Radio_TXP
															DBUS_TYPE_BYTE_AS_STRING	//Radio_Chan
															DBUS_TYPE_UINT32_AS_STRING	//type
															DBUS_TYPE_UINT16_AS_STRING	//BeaconPeriod
															DBUS_TYPE_UINT32_AS_STRING 	//rate
												DBUS_STRUCT_END_CHAR_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for(i = 0; i < wtp_num; i++){	
		int state = txpower_state;
		unsigned char num_of_radio = 0;
		memset(mac,0,MAC_LEN+1);
		if(WTP[i]->WTPMAC != NULL)
			memcpy(mac,WTP[i]->WTPMAC,MAC_LEN);
		
		num_of_radio = WID_WTP_FIND_RADIO(AC_RADIO_FOR_SEARCH,WTP[i]);
		
		dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
		
		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_UINT32,
												&(WTP[i]->WTPID));
		
		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_BYTE,
												&(mac[0]));
		
		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_BYTE,
												&(mac[1]));
		
		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_BYTE,
												&(mac[2]));
		
		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_BYTE,
												&(mac[3]));
		
		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_BYTE,
												&(mac[4]));
		
		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_BYTE,
												&(mac[5]));

		dbus_message_iter_append_basic(&iter_struct, 
											DBUS_TYPE_UINT32, 
													&state);

		dbus_message_iter_append_basic(&iter_struct, 
											DBUS_TYPE_BYTE, 
												&WID_SAMPLE_INFORMATION.sample_time);

		dbus_message_iter_append_basic(&iter_struct, 
												DBUS_TYPE_BYTE,
													&(num_of_radio));

		dbus_message_iter_open_container (&iter_struct,
											   DBUS_TYPE_ARRAY,
											  	 	DBUS_STRUCT_BEGIN_CHAR_AS_STRING
													    DBUS_TYPE_UINT32_AS_STRING	//radio global id
															DBUS_TYPE_BYTE_AS_STRING	//Radio_L_ID
															DBUS_TYPE_UINT16_AS_STRING	//Radio_TXP
															DBUS_TYPE_BYTE_AS_STRING	//Radio_Chan
															DBUS_TYPE_UINT32_AS_STRING	//type
															DBUS_TYPE_UINT16_AS_STRING	//BeaconPeriod
															DBUS_TYPE_UINT32_AS_STRING	//ratdio rate
												DBUS_STRUCT_END_CHAR_AS_STRING,
											   &iter_sub_array);

		for(k = 0; k < num_of_radio; k++){
			dbus_message_iter_open_container (&iter_sub_array,
											   DBUS_TYPE_STRUCT,
											   NULL,
											   &iter_sub_struct);

			dbus_message_iter_append_basic	(&iter_sub_struct,
											  DBUS_TYPE_UINT32,
											  &(AC_RADIO_FOR_SEARCH[k]->Radio_G_ID));

			dbus_message_iter_append_basic	(&iter_sub_struct,
											  DBUS_TYPE_BYTE,
											  &(AC_RADIO_FOR_SEARCH[k]->Radio_L_ID));

			dbus_message_iter_append_basic (&iter_sub_struct,
											  DBUS_TYPE_UINT16,
											  &(AC_RADIO_FOR_SEARCH[k]->Radio_TXP));

			dbus_message_iter_append_basic (&iter_sub_struct,
												 DBUS_TYPE_BYTE,
												 &(AC_RADIO_FOR_SEARCH[k]->Radio_Chan));

			dbus_message_iter_append_basic (&iter_sub_struct,
												 DBUS_TYPE_UINT32,
												 &(AC_RADIO_FOR_SEARCH[k]->Radio_Type));

			dbus_message_iter_append_basic (&iter_sub_struct,
												 DBUS_TYPE_UINT16,
												 &(AC_RADIO_FOR_SEARCH[k]->BeaconPeriod));
			
			if(AC_RADIO_FOR_SEARCH[k]->Support_Rate_Count > 0){
				dbus_message_iter_append_basic (&iter_sub_struct,
												DBUS_TYPE_UINT32,
												&AC_RADIO_FOR_SEARCH[k]->Radio_Rate->Rate);
			}
			else{
				dbus_message_iter_append_basic (&iter_sub_struct,
												DBUS_TYPE_UINT32,
												&defalt_zero);
			}
			
			dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);
		}
		dbus_message_iter_close_container (&iter_struct, &iter_sub_array);			
		dbus_message_iter_close_container (&iter_array, &iter_struct);
	}
	dbus_message_iter_close_container (&iter, &iter_array);
				
	CW_FREE_OBJECT_WID(WTP);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(AC_RADIO_FOR_SEARCH);
	
	return reply;	
}
/*for showting radio config informaiton 20100524 nl table 14*/
DBusMessage * wid_dbus_interface_show_wtp_radio_config_information(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusMessageIter iter_sub_array;
	DBusMessageIter iter_struct;
	DBusMessageIter iter_sub_struct;
	DBusMessageIter iter_sub_sub_struct;
	DBusMessageIter iter_sub_sub_array;
	DBusMessageIter iter_sub_sub_sub_struct;	/* AXSSZFI-1323: 2013-3-15 */
	DBusMessageIter iter_sub_sub_sub_array;	/* AXSSZFI-1323: 2013-3-15 */
	
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int wtp_num = 0;
	int i=0, k=0, ii=0; 
	unsigned char wlan_id =0;
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	
	WID_WTP **WTP;
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	WID_WTP_RADIO	**AC_RADIO_FOR_SEARCH;
	AC_RADIO_FOR_SEARCH = WID_MALLOC(G_RADIO_NUM*(sizeof(WID_WTP_RADIO *)));
	
	wtp_num = Wid_Find_Wtp(WTP);
	
	if(wtp_num == 0)
		ret = WTP_ID_NOT_EXIST;
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);

	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &wtp_num);

	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING		//mac0
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING		//mac 5
											DBUS_TYPE_BYTE_AS_STRING		//wtp_radio_num
												/*radio infor 2*/
												DBUS_TYPE_ARRAY_AS_STRING
													DBUS_STRUCT_BEGIN_CHAR_AS_STRING
													 	 DBUS_TYPE_UINT32_AS_STRING	//radio global id
													 	 DBUS_TYPE_BYTE_AS_STRING	//Radio_L_ID
														 DBUS_TYPE_UINT32_AS_STRING	   //type
														 DBUS_TYPE_UINT16_AS_STRING		//FragThreshold
														 DBUS_TYPE_UINT16_AS_STRING		//BeaconPeriod
														 DBUS_TYPE_BYTE_AS_STRING		//IsShortPreamble
														 DBUS_TYPE_BYTE_AS_STRING		//DTIMPeriod
														 DBUS_TYPE_UINT16_AS_STRING		//rtsthreshold
														 DBUS_TYPE_BYTE_AS_STRING		//ShortRetry
														 DBUS_TYPE_BYTE_AS_STRING		//LongRetry
														 DBUS_TYPE_BYTE_AS_STRING	//Radio_Chan
														 DBUS_TYPE_UINT16_AS_STRING	//Radio_TXP
														 DBUS_TYPE_BYTE_AS_STRING		//AdStat
														 DBUS_TYPE_BYTE_AS_STRING	   //bandwidth
														 DBUS_TYPE_UINT32_AS_STRING	   //qosid
														 DBUS_TYPE_UINT32_AS_STRING		//Radio_Rate
														 DBUS_TYPE_UINT32_AS_STRING	   //bwlannum
															/*wlan infor 3*/
															DBUS_TYPE_ARRAY_AS_STRING
																DBUS_STRUCT_BEGIN_CHAR_AS_STRING
																	DBUS_TYPE_BYTE_AS_STRING		//wlanid
																DBUS_STRUCT_END_CHAR_AS_STRING
														/* AXSSZFI-1323: 2013-3-15 */
														DBUS_TYPE_BYTE_AS_STRING		/* AmpduAble */
														DBUS_TYPE_BYTE_AS_STRING		/* AmsduAble */
														DBUS_TYPE_UINT16_AS_STRING	/* cwmode */
														DBUS_TYPE_UINT16_AS_STRING	/* guardinterval */
														DBUS_TYPE_BYTE_AS_STRING		/* Mixed_Greenfield */
														DBUS_TYPE_UINT32_AS_STRING	/* Radio_type */
														DBUS_TYPE_UINT32_AS_STRING				/* mcs_count */
															DBUS_TYPE_ARRAY_AS_STRING
																DBUS_STRUCT_BEGIN_CHAR_AS_STRING
																	DBUS_TYPE_BYTE_AS_STRING		/* mcs_list */
																DBUS_STRUCT_END_CHAR_AS_STRING
														DBUS_TYPE_BYTE_AS_STRING
														DBUS_TYPE_BYTE_AS_STRING
														DBUS_TYPE_UINT32_AS_STRING
														DBUS_TYPE_UINT32_AS_STRING
														DBUS_TYPE_UINT32_AS_STRING
												DBUS_STRUCT_END_CHAR_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for(i = 0; i < wtp_num; i++){			
		unsigned char num_of_radio = 0;
		memset(mac,0,MAC_LEN+1);
		if(WTP[i]->WTPMAC != NULL)
			memcpy(mac,WTP[i]->WTPMAC,MAC_LEN);
		
		num_of_radio = WID_WTP_FIND_RADIO(AC_RADIO_FOR_SEARCH,WTP[i]);
		
		dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
		
		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_UINT32,
												&(WTP[i]->WTPID));
		
		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_BYTE,
												&(mac[0]));
		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_BYTE,
												&(mac[1]));
		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_BYTE,
												&(mac[2]));
		
		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_BYTE,
												&(mac[3]));
		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_BYTE,
												&(mac[4]));
		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_BYTE,
												&(mac[5]));

		dbus_message_iter_append_basic(&iter_struct, 
												DBUS_TYPE_BYTE,
													&(num_of_radio));
		
		dbus_message_iter_open_container (&iter_struct,
											   DBUS_TYPE_ARRAY,
											  	 	DBUS_STRUCT_BEGIN_CHAR_AS_STRING
													     DBUS_TYPE_UINT32_AS_STRING	//radio global id
														 DBUS_TYPE_BYTE_AS_STRING	//Radio_L_ID
														 DBUS_TYPE_UINT32_AS_STRING		//type
														 DBUS_TYPE_UINT16_AS_STRING		//FragThreshold
														 DBUS_TYPE_UINT16_AS_STRING		//BeaconPeriod
														 DBUS_TYPE_BYTE_AS_STRING		//IsShortPreamble
														 DBUS_TYPE_BYTE_AS_STRING		//DTIMPeriod
														 DBUS_TYPE_UINT16_AS_STRING		//rtsthreshold
														 DBUS_TYPE_BYTE_AS_STRING		//ShortRetry
														 DBUS_TYPE_BYTE_AS_STRING		//LongRetry
														 DBUS_TYPE_BYTE_AS_STRING	//Radio_Chan
														 DBUS_TYPE_UINT16_AS_STRING	//Radio_TXP
														 DBUS_TYPE_BYTE_AS_STRING		//AdStat
														 DBUS_TYPE_BYTE_AS_STRING		//bandwidth
														 DBUS_TYPE_UINT32_AS_STRING		//qosid
														 DBUS_TYPE_UINT32_AS_STRING		//Radio_Rate
														 DBUS_TYPE_UINT32_AS_STRING		//bwlannum
 														 /*wlan infor 3*/
															DBUS_TYPE_ARRAY_AS_STRING
																DBUS_STRUCT_BEGIN_CHAR_AS_STRING
																	DBUS_TYPE_BYTE_AS_STRING		//wlanid
																DBUS_STRUCT_END_CHAR_AS_STRING
														/* AXSSZFI-1323: 2013-3-15 */			
														DBUS_TYPE_BYTE_AS_STRING		/* AmpduAble */
														DBUS_TYPE_BYTE_AS_STRING		/* AmsduAble */
														DBUS_TYPE_UINT16_AS_STRING	/* cwmode */
														DBUS_TYPE_UINT16_AS_STRING	/* guardinterval */
														DBUS_TYPE_BYTE_AS_STRING		/* Mixed_Greenfield */
														DBUS_TYPE_UINT32_AS_STRING	/* Radio_type */
														DBUS_TYPE_UINT32_AS_STRING				/* mcs_count */
															DBUS_TYPE_ARRAY_AS_STRING
																DBUS_STRUCT_BEGIN_CHAR_AS_STRING
																	DBUS_TYPE_BYTE_AS_STRING		/* mcs_list */
																DBUS_STRUCT_END_CHAR_AS_STRING
														DBUS_TYPE_BYTE_AS_STRING
														DBUS_TYPE_BYTE_AS_STRING
														DBUS_TYPE_UINT32_AS_STRING
														DBUS_TYPE_UINT32_AS_STRING
														DBUS_TYPE_UINT32_AS_STRING
												DBUS_STRUCT_END_CHAR_AS_STRING,
											   &iter_sub_array);

		for(k = 0; k < num_of_radio; k++){
 			unsigned char l_radio_id = AC_RADIO_FOR_SEARCH[k]->Radio_L_ID;
 			int default_int_zero = 0; 
			int bwlannum = 0;
			struct wlanid* pwlanid = AC_RADIO_FOR_SEARCH[k]->Wlan_Id;
 			struct wlanid* sendwlanid =NULL;
			
			dbus_message_iter_open_container (&iter_sub_array,
											   DBUS_TYPE_STRUCT,
											   NULL,
											   &iter_sub_struct);

			dbus_message_iter_append_basic	(&iter_sub_struct,
											  DBUS_TYPE_UINT32,
											  &(AC_RADIO_FOR_SEARCH[k]->Radio_G_ID));
			dbus_message_iter_append_basic	(&iter_sub_struct,
											  DBUS_TYPE_BYTE,
											  &(AC_RADIO_FOR_SEARCH[k]->Radio_L_ID));

			dbus_message_iter_append_basic	(&iter_sub_struct,
											  DBUS_TYPE_UINT32,
											  &(AC_RADIO_FOR_SEARCH[k]->Radio_Type));

			dbus_message_iter_append_basic (&iter_sub_struct,
											 DBUS_TYPE_UINT16,
											 &(AC_RADIO_FOR_SEARCH[k]->FragThreshold));
			dbus_message_iter_append_basic (&iter_sub_struct,
											 DBUS_TYPE_UINT16,
											 &(AC_RADIO_FOR_SEARCH[k]->BeaconPeriod));
			dbus_message_iter_append_basic (&iter_sub_struct,
											 DBUS_TYPE_BYTE,
											 &(AC_RADIO_FOR_SEARCH[k]->IsShortPreamble));
			
			dbus_message_iter_append_basic (&iter_sub_struct,
											 DBUS_TYPE_BYTE,
											 &(AC_RADIO_FOR_SEARCH[k]->DTIMPeriod));
			dbus_message_iter_append_basic (&iter_sub_struct,
											 DBUS_TYPE_UINT16,
											 &(AC_RADIO_FOR_SEARCH[k]->rtsthreshold));	
			dbus_message_iter_append_basic (&iter_sub_struct,
											 DBUS_TYPE_BYTE,
											 &(AC_RADIO_FOR_SEARCH[k]->ShortRetry));	
			
			dbus_message_iter_append_basic (&iter_sub_struct,
											 DBUS_TYPE_BYTE,
											 &(AC_RADIO_FOR_SEARCH[k]->LongRetry));	
			dbus_message_iter_append_basic (&iter_sub_struct,
											 DBUS_TYPE_BYTE,
											 &(AC_RADIO_FOR_SEARCH[k]->Radio_Chan));
			dbus_message_iter_append_basic (&iter_sub_struct,
											 DBUS_TYPE_UINT16,
											&(AC_RADIO_FOR_SEARCH[k]->Radio_TXP));
			
			dbus_message_iter_append_basic (&iter_sub_struct,
											 DBUS_TYPE_BYTE,
												&(AC_RADIO_FOR_SEARCH[k]->AdStat));

			dbus_message_iter_append_basic (&iter_sub_struct,
											DBUS_TYPE_BYTE,
											&WTP[i]->WTP_Radio[l_radio_id]->bandwidth);
			dbus_message_iter_append_basic(&iter_sub_struct,
											DBUS_TYPE_UINT32,
											&(AC_RADIO_FOR_SEARCH[k]->QOSID));
			
			if(AC_RADIO_FOR_SEARCH[k]->Radio_Rate !=NULL){
				dbus_message_iter_append_basic (&iter_sub_struct,
												 DBUS_TYPE_UINT32,
												 &AC_RADIO_FOR_SEARCH[k]->Radio_Rate->Rate);
			}
			else{
				dbus_message_iter_append_basic (&iter_sub_struct,
													 DBUS_TYPE_UINT32,
													 &default_int_zero);
			}

 			while(pwlanid != NULL){
				bwlannum++;
				pwlanid = pwlanid->next;
			}
			
			dbus_message_iter_append_basic (&iter_sub_struct,
												 DBUS_TYPE_UINT32,
												 &bwlannum);
			
			dbus_message_iter_open_container (&iter_sub_struct,
									   		DBUS_TYPE_ARRAY,
													DBUS_STRUCT_BEGIN_CHAR_AS_STRING
														DBUS_TYPE_BYTE_AS_STRING		//wlanid
													DBUS_STRUCT_END_CHAR_AS_STRING,
									   &iter_sub_sub_array);

			for(ii = 0; ii < bwlannum; ii++){	
				if(sendwlanid == NULL)
					sendwlanid = AC_RADIO_FOR_SEARCH[k]->Wlan_Id;
				else{
					sendwlanid = sendwlanid ->next;
				}
				wlan_id = sendwlanid->wlanid;
				
				dbus_message_iter_open_container (&iter_sub_sub_array,
											   DBUS_TYPE_STRUCT,
											   NULL,
											   &iter_sub_sub_struct);
				
				dbus_message_iter_append_basic (&iter_sub_sub_struct,
													 DBUS_TYPE_BYTE,
													 &(wlan_id));
				
				dbus_message_iter_close_container (&iter_sub_sub_array, &iter_sub_sub_struct);
			}
			dbus_message_iter_close_container (&iter_sub_struct, &iter_sub_sub_array);	

			dbus_message_iter_append_basic(&iter_sub_struct, DBUS_TYPE_BYTE, &(AC_RADIO_FOR_SEARCH[k]->Ampdu.Able));
			dbus_message_iter_append_basic(&iter_sub_struct, DBUS_TYPE_BYTE, &(AC_RADIO_FOR_SEARCH[k]->Amsdu.Able));
			dbus_message_iter_append_basic(&iter_sub_struct, DBUS_TYPE_UINT16, &(AC_RADIO_FOR_SEARCH[k]->cwmode));
			dbus_message_iter_append_basic(&iter_sub_struct, DBUS_TYPE_UINT16, &(AC_RADIO_FOR_SEARCH[k]->guardinterval));
			dbus_message_iter_append_basic(&iter_sub_struct, DBUS_TYPE_BYTE, &(AC_RADIO_FOR_SEARCH[k]->MixedGreenfield.Mixed_Greenfield));
			dbus_message_iter_append_basic(&iter_sub_struct, DBUS_TYPE_UINT32, &(AC_RADIO_FOR_SEARCH[k]->Radio_Type));
			dbus_message_iter_append_basic(&iter_sub_struct, DBUS_TYPE_UINT32, &(AC_RADIO_FOR_SEARCH[k]->mcs_count));

			dbus_message_iter_open_container (&iter_sub_struct,
									   		DBUS_TYPE_ARRAY,
												DBUS_STRUCT_BEGIN_CHAR_AS_STRING
													DBUS_TYPE_BYTE_AS_STRING		/* mcs_list */
												DBUS_STRUCT_END_CHAR_AS_STRING,
									   		&iter_sub_sub_sub_array);
			for(ii = 0; ii < AC_RADIO_FOR_SEARCH[k]->mcs_count;  ii++){	
				dbus_message_iter_open_container (&iter_sub_sub_sub_array,
											   DBUS_TYPE_STRUCT,
											   NULL,
											   &iter_sub_sub_sub_struct);
				
				dbus_message_iter_append_basic (&iter_sub_sub_sub_struct,
													 DBUS_TYPE_BYTE,
													 &(AC_RADIO_FOR_SEARCH[k]->mcs_list[ii]));

				dbus_message_iter_close_container (&iter_sub_sub_sub_array, &iter_sub_sub_sub_struct);
			}
			dbus_message_iter_close_container (&iter_sub_struct, &iter_sub_sub_sub_array);	

			wid_syslog_debug_debug(WID_DEFAULT,"55555555555555555:%d %d %d\n", (AC_RADIO_FOR_SEARCH[k]->radio_work_role), 
				(AC_RADIO_FOR_SEARCH[k]->radio_channel_use_rate), (AC_RADIO_FOR_SEARCH[k]->radio_channel_change_counter));

			dbus_message_iter_append_basic (&iter_sub_struct, DBUS_TYPE_BYTE, &(AC_RADIO_FOR_SEARCH[k]->radio_work_role));
			dbus_message_iter_append_basic (&iter_sub_struct, DBUS_TYPE_BYTE, &(AC_RADIO_FOR_SEARCH[k]->radio_channel_use_rate));
			dbus_message_iter_append_basic (&iter_sub_struct, DBUS_TYPE_UINT32, &(AC_RADIO_FOR_SEARCH[k]->radio_channel_change_counter));
			AC_RADIO_FOR_SEARCH[k]->radio_channel_width = AC_RADIO_FOR_SEARCH[k]->cwmode;
			dbus_message_iter_append_basic (&iter_sub_struct, DBUS_TYPE_UINT32, &(AC_RADIO_FOR_SEARCH[k]->radio_channel_width));
			AC_RADIO_FOR_SEARCH[k]->radio_noise = RADIO_NOISE_DEFAULT;
			dbus_message_iter_append_basic (&iter_sub_struct, DBUS_TYPE_UINT32, &(AC_RADIO_FOR_SEARCH[k]->radio_noise));
			
			dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);
		}
 		dbus_message_iter_close_container (&iter_struct, &iter_sub_array);			
		dbus_message_iter_close_container (&iter_array, &iter_struct);
 	}
 	dbus_message_iter_close_container (&iter, &iter_array);
				
	CW_FREE_OBJECT_WID(WTP);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(AC_RADIO_FOR_SEARCH);
	
	return reply;	
}
/*table 14 b16*/
DBusMessage * wid_dbus_interface_show_wtp_wired_if_stats_information(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusMessageIter iter_struct;
	DBusMessageIter iter_sub_struct;
	DBusMessageIter iter_sub_array;
	DBusError err;
	
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int wtp_num = 0;
	int i=0,j=0/*,k=0*/;
	unsigned char ethid = 0;
 	unsigned char *mac = NULL;
 	WID_WTP **WTP=NULL;
	
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	if( WTP == NULL){
		wid_syslog_debug_debug(WID_DBUS,"%s :malloc fail.\n",__func__);
		exit(1);
	}
	memset(WTP,0,WTP_NUM*(sizeof(WID_WTP *)));
 	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	
	if(hide_quit_wtp_in_showting == 0){
		wtp_num = Wid_Find_Wtp(WTP);
	}
	else if (hide_quit_wtp_in_showting == 1){
		wtp_num = Wid_Find_Running_Wtp(WTP);
	}
	if(wtp_num == 0)
		ret = WTP_ID_NOT_EXIST;

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	// Total slot count
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &wtp_num);

	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING		//wtpid
 											DBUS_TYPE_BYTE_AS_STRING		 //mac 0
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING		//mac 5
											DBUS_TYPE_BYTE_AS_STRING		//eth_num

												DBUS_TYPE_ARRAY_AS_STRING
														DBUS_STRUCT_BEGIN_CHAR_AS_STRING
															DBUS_TYPE_BYTE_AS_STRING		//ifindex
															DBUS_TYPE_BYTE_AS_STRING		//updown num

															DBUS_TYPE_UINT32_AS_STRING		//wifi_extension_info 1
                											DBUS_TYPE_UINT32_AS_STRING
                											DBUS_TYPE_UINT32_AS_STRING
                											
                											DBUS_TYPE_UINT32_AS_STRING
                											DBUS_TYPE_UINT32_AS_STRING
                											DBUS_TYPE_UINT32_AS_STRING		//wifi_extension_info 6

                											DBUS_TYPE_UINT32_AS_STRING		//apstatsinfo 1
                											DBUS_TYPE_UINT32_AS_STRING
                											DBUS_TYPE_UINT32_AS_STRING
                											DBUS_TYPE_UINT32_AS_STRING
                											
                											DBUS_TYPE_UINT64_AS_STRING
                											DBUS_TYPE_UINT64_AS_STRING
                											DBUS_TYPE_UINT32_AS_STRING		
                											DBUS_TYPE_UINT32_AS_STRING		//apstatsinfo 8

                											DBUS_TYPE_UINT64_AS_STRING		// rx_sum_bytes 20101008  add by zhangshu
                										    DBUS_TYPE_UINT64_AS_STRING		// tx_sum_bytes 20101008
												DBUS_STRUCT_END_CHAR_AS_STRING
  									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for(i = 0; i < wtp_num; i++){	
		//unsigned char radiocount = 0;
		
		memset(mac,0,MAC_LEN+1);
		if(WTP[i]->WTPMAC != NULL)
			memcpy(mac,WTP[i]->WTPMAC,MAC_LEN);
		
		dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
		
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_UINT32,
										&(WTP[i]->WTPID));
		
  		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,
										&(mac[0]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,
										&(mac[1]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,
										&(mac[2]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,
										&(mac[3]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,
										&(mac[4]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,
										&(mac[5]));
		
		dbus_message_iter_append_basic (&iter_struct,
										DBUS_TYPE_BYTE,
										&(WTP[i]->apifinfo.eth_num));

		dbus_message_iter_open_container (&iter_struct,
										DBUS_TYPE_ARRAY,
											DBUS_STRUCT_BEGIN_CHAR_AS_STRING
													DBUS_TYPE_BYTE_AS_STRING
													DBUS_TYPE_BYTE_AS_STRING

													DBUS_TYPE_UINT32_AS_STRING		//apstatsinfo 1
	        										DBUS_TYPE_UINT32_AS_STRING      
	        										DBUS_TYPE_UINT32_AS_STRING
	        										
	        										DBUS_TYPE_UINT32_AS_STRING
	        										DBUS_TYPE_UINT32_AS_STRING
	        										DBUS_TYPE_UINT32_AS_STRING		

	        										DBUS_TYPE_UINT32_AS_STRING		
	        										DBUS_TYPE_UINT32_AS_STRING
	        										DBUS_TYPE_UINT32_AS_STRING
	        										DBUS_TYPE_UINT32_AS_STRING
	        										
	        										DBUS_TYPE_UINT64_AS_STRING
	        										DBUS_TYPE_UINT64_AS_STRING
	        										DBUS_TYPE_UINT32_AS_STRING		
	        										DBUS_TYPE_UINT32_AS_STRING		//apstatsinfo 14
	        										
	        										DBUS_TYPE_UINT64_AS_STRING		// rx_sum_bytes 20100910
	        										DBUS_TYPE_UINT64_AS_STRING		// tx_sum_bytes 20100910
											DBUS_STRUCT_END_CHAR_AS_STRING,
										&iter_sub_array);
		pthread_mutex_lock(&(WTP[i]->mutex_web_report));
		for(j = 0; j < WTP[i]->apifinfo.eth_num; j++)
		{
			ethid= (unsigned char)j;
			dbus_message_iter_open_container (&iter_sub_array,
												DBUS_TYPE_STRUCT,
												NULL,
												&iter_sub_struct);
			
			dbus_message_iter_append_basic (&iter_sub_struct,
											DBUS_TYPE_BYTE,
											&(ethid));
			
			dbus_message_iter_append_basic (&iter_sub_struct,
											DBUS_TYPE_BYTE,
											&(WTP[i]->wifi_extension_info.eth_updown_time[j]));

			dbus_message_iter_append_basic(&iter_sub_struct, 
    										DBUS_TYPE_UINT32, 
    										&(WTP[i]->web_manager_stats.eth_stats[ethid].rx_pkt_broadcast));			
    		
    		dbus_message_iter_append_basic(&iter_sub_struct, 
    										DBUS_TYPE_UINT32, 
    										&(WTP[i]->web_manager_stats.eth_stats[ethid].rx_pkt_unicast));

    		dbus_message_iter_append_basic(&iter_sub_struct, 
    										DBUS_TYPE_UINT32, 
    										&(WTP[i]->web_manager_stats.eth_stats[ethid].tx_pkt_broadcast));
    		
    		dbus_message_iter_append_basic(&iter_sub_struct,
    										DBUS_TYPE_UINT32, 
    										&(WTP[i]->web_manager_stats.eth_stats[ethid].tx_pkt_unicast));

    		dbus_message_iter_append_basic(&iter_sub_struct, 
    										DBUS_TYPE_UINT32, 
    										&(WTP[i]->web_manager_stats.eth_stats[ethid].rx_pkt_multicast));
    		
    		dbus_message_iter_append_basic(&iter_sub_struct, 
    										DBUS_TYPE_UINT32, 
    										&(WTP[i]->web_manager_stats.eth_stats[ethid].tx_pkt_multicast));			

    		dbus_message_iter_append_basic(&iter_sub_struct,
    										DBUS_TYPE_UINT32,
    							 			&(WTP[i]->web_manager_stats.eth_stats[ethid].rx_packets));
    		dbus_message_iter_append_basic(&iter_sub_struct,
    										DBUS_TYPE_UINT32,
    										&(WTP[i]->web_manager_stats.eth_stats[ethid].tx_packets));
    		dbus_message_iter_append_basic(&iter_sub_struct,
    										DBUS_TYPE_UINT32,
    										&(WTP[i]->web_manager_stats.eth_stats[ethid].rx_errors));
    		dbus_message_iter_append_basic(&iter_sub_struct,
    										DBUS_TYPE_UINT32,
    										&(WTP[i]->web_manager_stats.eth_stats[ethid].tx_errors));

    		dbus_message_iter_append_basic(&iter_sub_struct,
    										DBUS_TYPE_UINT64,
    										&(WTP[i]->web_manager_stats.eth_stats[ethid].rx_bytes));
    		dbus_message_iter_append_basic(&iter_sub_struct,
    										DBUS_TYPE_UINT64,
    										&(WTP[i]->web_manager_stats.eth_stats[ethid].tx_bytes));	
    		dbus_message_iter_append_basic(&iter_sub_struct,
    										DBUS_TYPE_UINT32,
    										&(WTP[i]->web_manager_stats.eth_stats[ethid].rx_drop));
    		dbus_message_iter_append_basic(&iter_sub_struct,
											DBUS_TYPE_UINT32,
    										&(WTP[i]->web_manager_stats.eth_stats[ethid].tx_drop));	
    		/******add for total rx ,tx bytes for new require begin 20100910*******/
    		dbus_message_iter_append_basic(&iter_sub_struct,
    										DBUS_TYPE_UINT64,
    										&(WTP[i]->web_manager_stats.eth_stats[ethid].rx_sum_bytes));	
    		
    		dbus_message_iter_append_basic(&iter_sub_struct,
    										DBUS_TYPE_UINT64,
    										&(WTP[i]->web_manager_stats.eth_stats[ethid].tx_sum_bytes));
            /************************** end *****************************/
        
			dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);
		}
		pthread_mutex_unlock(&(WTP[i]->mutex_web_report));
		dbus_message_iter_close_container (&iter_struct, &iter_sub_array);
		dbus_message_iter_close_container (&iter_array, &iter_struct);
	}
	dbus_message_iter_close_container (&iter, &iter_array);

	CW_FREE_OBJECT_WID(WTP);
	CW_FREE_OBJECT_WID(mac);

	return reply;	
}

#if 0
DBusMessage * wid_dbus_interface_show_wtp_wired_if_stats_information(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusMessageIter iter_struct;
	DBusMessageIter iter_sub_struct;
	DBusMessageIter iter_sub_array;
	DBusError err;
	
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int wtp_num = 0;
	int i=0,/*j=0,*//*k=0,*/kk=0;
 	unsigned char *mac = NULL;
 	WID_WTP **WTP;
	
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
 	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	
	if(hide_quit_wtp_in_showting == 0){
		wtp_num = Wid_Find_Wtp(WTP);
	}
	else if (hide_quit_wtp_in_showting == 1){
		wtp_num = Wid_Find_Running_Wtp(WTP);
	}
	if(wtp_num == 0)
		ret = WTP_ID_NOT_EXIST;

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	// Total slot count
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &wtp_num);

	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING		//wtpid
 											DBUS_TYPE_BYTE_AS_STRING		 //mac 0
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING		//mac 5
										DBUS_TYPE_BYTE_AS_STRING		//eth_num
										
											DBUS_TYPE_ARRAY_AS_STRING
												DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												
												DBUS_TYPE_BYTE_AS_STRING		//ifindex
												DBUS_TYPE_BYTE_AS_STRING		//updown num
											DBUS_TYPE_UINT32_AS_STRING		//wifi_extension_info 1
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING		//wifi_extension_info 6

											DBUS_TYPE_UINT32_AS_STRING		//apstatsinfo 1
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											
											DBUS_TYPE_UINT64_AS_STRING
											DBUS_TYPE_UINT64_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING		
											DBUS_TYPE_UINT32_AS_STRING		//apstatsinfo 8

											DBUS_TYPE_UINT64_AS_STRING		// rx_sum_bytes 20101008  add by zhangshu
										    DBUS_TYPE_UINT64_AS_STRING		// tx_sum_bytes 20101008
												DBUS_STRUCT_END_CHAR_AS_STRING
  									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for(i = 0; i < wtp_num; i++){		
		//unsigned char radiocount = 0;
		
		memset(mac,0,MAC_LEN+1);
		if(WTP[i]->WTPMAC != NULL)
			memcpy(mac,WTP[i]->WTPMAC,MAC_LEN);
		
		dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
		
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_UINT32,&(WTP[i]->WTPID));
		
  		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[0]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[1]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[2]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[3]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[4]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[5]));
		
		dbus_message_iter_append_basic (&iter_struct,
										DBUS_TYPE_BYTE,
										&WTP[i]->apifinfo.eth_num);

		dbus_message_iter_open_container (&iter_struct,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING

												DBUS_TYPE_UINT32_AS_STRING		//apstatsinfo 1
        										DBUS_TYPE_UINT32_AS_STRING      
        										DBUS_TYPE_UINT32_AS_STRING
        										
        										DBUS_TYPE_UINT32_AS_STRING
        										DBUS_TYPE_UINT32_AS_STRING
        										DBUS_TYPE_UINT32_AS_STRING		

        										DBUS_TYPE_UINT32_AS_STRING		
        										DBUS_TYPE_UINT32_AS_STRING
        										DBUS_TYPE_UINT32_AS_STRING
        										DBUS_TYPE_UINT32_AS_STRING
        										
        										DBUS_TYPE_UINT64_AS_STRING
        										DBUS_TYPE_UINT64_AS_STRING
        										DBUS_TYPE_UINT32_AS_STRING		
        										DBUS_TYPE_UINT32_AS_STRING		//apstatsinfo 14
        										
        										DBUS_TYPE_UINT64_AS_STRING		// rx_sum_bytes 20100910
        										DBUS_TYPE_UINT64_AS_STRING		// tx_sum_bytes 20100910
										DBUS_STRUCT_END_CHAR_AS_STRING,
										&iter_sub_array);
		
		pthread_mutex_lock(&(WTP[i]->mutex_web_report));
		for(kk = 0; kk < WTP[i]->apifinfo.eth_num; kk++){	
			unsigned char ifindex = (char)kk;

	//		unsigned int rx_packets = 0;
    	//	unsigned int tx_packets = 0;
    	//	unsigned int rx_errors = 0;
    	//	unsigned int tx_errors = 0;
    	//	unsigned long long rx_bytes = 0;
    	//	unsigned long long tx_bytes = 0;
    	//	unsigned int rx_drop = 0;
    	//	unsigned int tx_drop = 0;

    	//	unsigned int rx_pkt_broadcast =0;//zhaoruijia,20100831,,start
    	//	unsigned int rx_pkt_unicast = 0;
    	//	unsigned int tx_pkt_broadcast =0; 
    	//	unsigned int tx_pkt_unicast = 0;
    	//	unsigned int rx_pkt_multicast = 0;
    	//	unsigned int tx_pkt_multicast = 0;//zhaoruijia,20100831,,end

    	//	unsigned long long rx_sum_bytes = 0;  //     
       	//	unsigned long long tx_sum_bytes = 0;  //     
#if 0
       		for(k=0;k<TOTAL_AP_IF_NUM;k++){
    			if((WTP[i]->apstatsinfo[k].radioId < TOTAL_AP_IF_NUM+1)
    				&&(WTP[i]->apstatsinfo[k].type == 1)
    				&&(WTP[i]->apstatsinfo[k].wlanId == ifindex)){
    				
    				rx_packets = WTP[i]->web_manager_stats.eth_stats[ethid].rx_packets;
    				tx_packets = WTP[i]->web_manager_stats.eth_stats[ethid].tx_packets;
    				rx_errors  = WTP[i]->web_manager_stats.eth_stats[ethid]].rx_errors;
    				tx_errors  = WTP[i]->web_manager_stats.eth_stats[ethid].tx_errors;
				if(!wireddata_switch)
				{
					rx_bytes = WTP[i]->apstatsinfo[k].rx_bytes;
					tx_bytes = WTP[i]->apstatsinfo[k].tx_bytes;
				}
    				//rx_bytes   = WTP[i]->apstatsinfo[k].rx_bytes;
    				//tx_bytes   = WTP[i]->apstatsinfo[k].tx_bytes;
    				rx_drop    = WTP[i]->apstatsinfo[k].rx_drop;
    				tx_drop    = WTP[i]->apstatsinfo[k].tx_drop;

    				rx_pkt_broadcast = WTP[i]->apstatsinfo[k].rx_pkt_broadcast;
    				rx_pkt_unicast = WTP[i]->apstatsinfo[k].rx_pkt_unicast;
    				tx_pkt_broadcast = WTP[i]->apstatsinfo[k].tx_pkt_broadcast;
    				tx_pkt_unicast = WTP[i]->apstatsinfo[k].tx_pkt_unicast;
    				rx_pkt_multicast = WTP[i]->apstatsinfo[k].rx_pkt_multicast;
    				tx_pkt_multicast = WTP[i]->apstatsinfo[k].tx_pkt_multicast;
    				
    				rx_sum_bytes = WTP[i]->apstatsinfo[k].rx_sum_bytes;
    				tx_sum_bytes = WTP[i]->apstatsinfo[k].tx_sum_bytes;

    				break;
    			}
			if(wireddata_switch)
			{
				if((WTP[i]->apstatsinfo[k].radioId < TOTAL_AP_IF_NUM+1)&&(WTP[i]->apstatsinfo[k].type == 2))
				{
					if(wirelessdata_switch)
					{
						int randx = RAND(5000,12000);
						rx_bytes += (WTP[i]->apstatsinfo[k].rx_bytes > WTP[i]->apstatsinfo[k].rx_multicast)?
									(WTP[i]->apstatsinfo[k].rx_bytes - WTP[i]->apstatsinfo[k].rx_multicast + randx):
									(WTP[i]->apstatsinfo[k].rx_multicast - WTP[i]->apstatsinfo[k].rx_bytes + randx);
						tx_bytes += (WTP[i]->apstatsinfo[k].tx_bytes > WTP[i]->apstatsinfo[k].tx_multicast)?
									(WTP[i]->apstatsinfo[k].tx_bytes - WTP[i]->apstatsinfo[k].tx_multicast + randx):
									(WTP[i]->apstatsinfo[k].tx_multicast - WTP[i]->apstatsinfo[k].tx_bytes + randx);
					}
					else
					{
						int randx = RAND(5000,12000);
						rx_bytes += WTP[i]->apstatsinfo[k].rx_bytes + randx;
						tx_bytes += WTP[i]->apstatsinfo[k].tx_bytes + randx;
					}
				}
			}
    		}
   		
			dbus_message_iter_open_container (&iter_sub_array,
												DBUS_TYPE_STRUCT,
												NULL,
												&iter_sub_struct);
			
			dbus_message_iter_append_basic (&iter_sub_struct,
												DBUS_TYPE_BYTE,
												&(ifindex));
			
			dbus_message_iter_append_basic (&iter_sub_struct,
												DBUS_TYPE_BYTE,
												&(WTP[i]->wifi_extension_info.eth_updown_time[kk]));

			dbus_message_iter_append_basic(&iter_sub_struct, 
    										DBUS_TYPE_UINT32, 
    										&(rx_pkt_broadcast));			
    		
    		dbus_message_iter_append_basic(&iter_sub_struct, 
    										DBUS_TYPE_UINT32, 
    										&(rx_pkt_unicast));

    		dbus_message_iter_append_basic(&iter_sub_struct, 
    										DBUS_TYPE_UINT32, 
    										&(tx_pkt_broadcast));
    		
    		dbus_message_iter_append_basic(&iter_sub_struct,
    										DBUS_TYPE_UINT32, 
    										&(tx_pkt_unicast));

    		dbus_message_iter_append_basic(&iter_sub_struct, 
    										DBUS_TYPE_UINT32, 
    										&(rx_pkt_multicast));
    		
    		dbus_message_iter_append_basic(&iter_sub_struct, 
    										DBUS_TYPE_UINT32, 
    										&(tx_pkt_multicast));			

    		dbus_message_iter_append_basic(&iter_sub_struct,
    										  DBUS_TYPE_UINT32,
    							 				  &(rx_packets));
    		dbus_message_iter_append_basic(&iter_sub_struct,
    										  DBUS_TYPE_UINT32,
    										 	  &(tx_packets));
    		dbus_message_iter_append_basic(&iter_sub_struct,
    										  DBUS_TYPE_UINT32,
    										 	  &(rx_errors));
    		dbus_message_iter_append_basic(&iter_sub_struct,
    										  DBUS_TYPE_UINT32,
    											  &(tx_errors));

    		dbus_message_iter_append_basic(&iter_sub_struct,
    										  DBUS_TYPE_UINT64,
    											  &(rx_bytes));
    		dbus_message_iter_append_basic(&iter_sub_struct,
    										  DBUS_TYPE_UINT64,
    										  	  &(tx_bytes));	
    		dbus_message_iter_append_basic(&iter_sub_struct,
    										  DBUS_TYPE_UINT32,
    											  &(rx_drop));
    		dbus_message_iter_append_basic(&iter_sub_struct,
    										  DBUS_TYPE_UINT32,
    										  	  &(tx_drop));	
    		/******add for total rx ,tx bytes for new require begin 20100910*******/
    		dbus_message_iter_append_basic(&iter_sub_struct,
    										  DBUS_TYPE_UINT64,
    										  &(rx_sum_bytes));	
    		
    		dbus_message_iter_append_basic(&iter_sub_struct,
    										  DBUS_TYPE_UINT64,
    										   &(tx_sum_bytes));
            /************************** end *****************************/
			#endif
			dbus_message_iter_open_container (&iter_sub_array,
												DBUS_TYPE_STRUCT,
												NULL,
												&iter_sub_struct);
			
			dbus_message_iter_append_basic (&iter_sub_struct,
											DBUS_TYPE_BYTE,
											&(ifindex));
			
			dbus_message_iter_append_basic (&iter_sub_struct,
											DBUS_TYPE_BYTE,
											&(WTP[i]->wifi_extension_info.eth_updown_time[kk]));

			dbus_message_iter_append_basic(&iter_sub_struct, 
    										DBUS_TYPE_UINT32, 
    										&(WTP[i]->web_manager_stats.eth_stats[ifindex].rx_pkt_broadcast));			
    		
    		dbus_message_iter_append_basic(&iter_sub_struct, 
    										DBUS_TYPE_UINT32, 
    										&(WTP[i]->web_manager_stats.eth_stats[ifindex].rx_pkt_unicast));

    		dbus_message_iter_append_basic(&iter_sub_struct, 
    										DBUS_TYPE_UINT32, 
    										&(WTP[i]->web_manager_stats.eth_stats[ifindex].tx_pkt_broadcast));
    		
    		dbus_message_iter_append_basic(&iter_sub_struct,
    										DBUS_TYPE_UINT32, 
    										&(WTP[i]->web_manager_stats.eth_stats[ifindex].tx_pkt_unicast));

    		dbus_message_iter_append_basic(&iter_sub_struct, 
    										DBUS_TYPE_UINT32, 
    										&(WTP[i]->web_manager_stats.eth_stats[ifindex].rx_pkt_multicast));
    		
    		dbus_message_iter_append_basic(&iter_sub_struct, 
    										DBUS_TYPE_UINT32, 
    										&(WTP[i]->web_manager_stats.eth_stats[ifindex].tx_pkt_multicast));			

    		dbus_message_iter_append_basic(&iter_sub_struct,
    										DBUS_TYPE_UINT32,
    							 			&(WTP[i]->web_manager_stats.eth_stats[ifindex].rx_packets));
    		dbus_message_iter_append_basic(&iter_sub_struct,
    										DBUS_TYPE_UINT32,
    										&(WTP[i]->web_manager_stats.eth_stats[ifindex].tx_packets));
    		dbus_message_iter_append_basic(&iter_sub_struct,
    										DBUS_TYPE_UINT32,
    										&(WTP[i]->web_manager_stats.eth_stats[ifindex].rx_errors));
    		dbus_message_iter_append_basic(&iter_sub_struct,
    										DBUS_TYPE_UINT32,
    										&(WTP[i]->web_manager_stats.eth_stats[ifindex].tx_errors));

    		dbus_message_iter_append_basic(&iter_sub_struct,
    										DBUS_TYPE_UINT64,
    										&(WTP[i]->web_manager_stats.eth_stats[ifindex].rx_bytes));
    		dbus_message_iter_append_basic(&iter_sub_struct,
    										DBUS_TYPE_UINT64,
    										&(WTP[i]->web_manager_stats.eth_stats[ifindex].tx_bytes));	
    		dbus_message_iter_append_basic(&iter_sub_struct,
    										DBUS_TYPE_UINT32,
    										&(WTP[i]->web_manager_stats.eth_stats[ifindex].rx_drop));
    		dbus_message_iter_append_basic(&iter_sub_struct,
											DBUS_TYPE_UINT32,
    										&(WTP[i]->web_manager_stats.eth_stats[ifindex].tx_drop));	
    		/******add for total rx ,tx bytes for new require begin 20100910*******/
    		dbus_message_iter_append_basic(&iter_sub_struct,
    										DBUS_TYPE_UINT64,
    										&(WTP[i]->web_manager_stats.eth_stats[ifindex].rx_sum_bytes));	
    		
    		dbus_message_iter_append_basic(&iter_sub_struct,
    										DBUS_TYPE_UINT64,
    										&(WTP[i]->web_manager_stats.eth_stats[ifindex].tx_sum_bytes));
            /************************** end *****************************/
        
			dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);
		}
		dbus_message_iter_close_container (&iter_struct, &iter_sub_array);
		dbus_message_iter_close_container (&iter_array, &iter_struct);
	}
	dbus_message_iter_close_container (&iter, &iter_array);

	CW_FREE_OBJECT_WID(WTP);
	CW_FREE_OBJECT_WID(mac);

	return reply;	
}
#endif
DBusMessage * wid_dbus_show_terminal_info_of_all_wtp(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;	
	DBusMessageIter	iter;
	DBusMessageIter iter_radio_array;
	DBusMessageIter iter_radio;
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int radio_num=0;
	int i=0;
	WID_WTP_RADIO ** G_RADIO = (WID_WTP_RADIO **)WID_MALLOC(WTP_NUM * L_RADIO_NUM * sizeof(WID_WTP_RADIO*));
	if(!G_RADIO)
		return NULL;
	
	for(i=0;i<WTP_NUM*L_RADIO_NUM;i++){
		if(AC_RADIO[i])
				G_RADIO[radio_num++]=AC_RADIO[i];
	}

	if(radio_num == 0)
		ret = RADIO_ID_NOT_EXIST;

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);	
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&radio_num);	
	dbus_message_iter_open_container(&iter,
								DBUS_TYPE_ARRAY,
								DBUS_STRUCT_BEGIN_CHAR_AS_STRING
									DBUS_TYPE_UINT32_AS_STRING	//RADIO_G_ID
									DBUS_TYPE_UINT32_AS_STRING 	//RADI_TYPE
									DBUS_STRUCT_END_CHAR_AS_STRING,
								&iter_radio_array);
	for(i=0;i<radio_num;i++){
		dbus_message_iter_open_container(&iter_radio_array,DBUS_TYPE_STRUCT,NULL,&iter_radio);
		
		dbus_message_iter_append_basic(&iter_radio,DBUS_TYPE_UINT32,&G_RADIO[i]->Radio_G_ID);
		dbus_message_iter_append_basic(&iter_radio,DBUS_TYPE_UINT32,&G_RADIO[i]->Radio_Type);
		
		dbus_message_iter_close_container(&iter_radio_array,&iter_radio);
	}
	dbus_message_iter_close_container(&iter,&iter_radio_array);
	if(G_RADIO){
		WID_FREE(G_RADIO);
		G_RADIO = NULL;
	}
	return reply;
}
/*fengwenchao add 20110329 for dot11WtpStatisticsTable,dot11WtpChannelTable*/
DBusMessage *wid_dbus_show_statistics_information_of_all_wtp_whole(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	iter;
	DBusMessageIter	iter_wtp_array;
	DBusMessageIter iter_wtp;
	DBusError err;
	dbus_error_init(&err);
	//printf("access into wid!!!!!\n");
	int i = 0;
	int j = 0;
	int k = 0;   //fengwenchao add 20110503
	int ret = WID_DBUS_SUCCESS;
	unsigned int wtp_num = 0;
	char wtp_mac[18] = {0};
	char* ptr_wtp_mac = wtp_mac;
	/*unsigned int rx_drop = 0;      //fengwenchao comment 20110423
	unsigned int tx_drop = 0;
	unsigned int rx_pkt = 0;
	unsigned int tx_pkt = 0;
	unsigned int rx_band = 0;
	unsigned int tx_band = 0;
	unsigned int rx_rate = 0;
	unsigned int tx_rate = 0;
	unsigned int ast_rx_phyerr = 0;*/
	//unsigned int wtpRxPacketLossRate = 0;
	//unsigned int wtpTxPacketLossRate = 0;

	WID_WTP **WTP;
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));

	wtp_num = Wid_Find_Wtp(WTP);
	if(wtp_num == 0)
		ret = WTP_ID_NOT_EXIST;

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);	
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&wtp_num);

	dbus_message_iter_open_container(&iter,
								DBUS_TYPE_ARRAY,
								DBUS_STRUCT_BEGIN_CHAR_AS_STRING
								
									DBUS_TYPE_UINT32_AS_STRING  //WTP_ID
									DBUS_TYPE_STRING_AS_STRING	//wtp_mac
									//DBUS_TYPE_UINT32_AS_STRING 	//wtpRxPacketLossRate                 
									//DBUS_TYPE_UINT32_AS_STRING 	//wtpTxPacketLossRate                
									DBUS_TYPE_UINT32_AS_STRING  //wtpTotalRx_Drop
									DBUS_TYPE_UINT32_AS_STRING  //wtpTotalTx_Drop
									DBUS_TYPE_UINT32_AS_STRING  //wtpTotalRx_Pkt
									DBUS_TYPE_UINT32_AS_STRING  //wtpTotalTx_Pkt
									DBUS_TYPE_UINT32_AS_STRING 	//wtpDownBandwidthUtilization      
									DBUS_TYPE_UINT32_AS_STRING 	//wtpUpBandwidthUtilization          
									DBUS_TYPE_UINT32_AS_STRING 	//wtpReceiveRate                        AP	
									DBUS_TYPE_UINT32_AS_STRING 	//wtpSendRate                            AP
									DBUS_TYPE_UINT32_AS_STRING  //ast_rx_phyerr                           
									DBUS_TYPE_UINT32_AS_STRING  //wifi_ex_tx_packets
									DBUS_TYPE_UINT32_AS_STRING  //wifi_ex_tx_errors
									DBUS_TYPE_UINT32_AS_STRING  //wifi_ex_tx_retry
									DBUS_TYPE_BYTE_AS_STRING    //monitor_time                            
									DBUS_TYPE_BYTE_AS_STRING     //AP                        fengwenchao add 20110503 for dot11WtpExtensionTable
									DBUS_TYPE_UINT32_AS_STRING   //               fengwenchao add 20110503 for dot11WtpWidStatisticsTable
									DBUS_TYPE_UINT32_AS_STRING   //Spoof                               fengwenchao add 20110503 for dot11WtpWidStatisticsTable
									DBUS_TYPE_UINT32_AS_STRING   //WeakIV                           fengwenchao add 20110503 for dot11WtpWidStatisticsTable
									DBUS_TYPE_UINT32_AS_STRING   //BSSID                                           fengwenchao add 20110503 for dot11WtpBssIDNumTable

								DBUS_STRUCT_END_CHAR_AS_STRING,
								&iter_wtp_array);

	for(i=0;i<wtp_num;i++)
	{
		unsigned int count = 0; //fengwenchao add 20110503  dot11WtpBssIDNumTable
		/*fengwenchao add 20110423*/
		unsigned int rx_drop = 0;      
		unsigned int tx_drop = 0;
		unsigned int rx_pkt = 0;
		unsigned int tx_pkt = 0;
		unsigned int rx_band = 0;
		unsigned int tx_band = 0;
		unsigned int rx_rate = 0;
		unsigned int tx_rate = 0;
		unsigned int ast_rx_phyerr = 0;
		unsigned int tx_errors = 0;
		unsigned int tx_retry = 0;
		/*fengwenchao add end*/
		for(j=0;j<TOTAL_AP_IF_NUM;j++)
		{
			if(WTP[i]->apstatsinfo[j].type==0)
			{
				rx_drop += WTP[i]->apstatsinfo[j].rx_drop;
				tx_drop += WTP[i]->apstatsinfo[j].tx_drop;
				rx_pkt += WTP[i]->apstatsinfo[j].rx_packets;
				tx_pkt += WTP[i]->apstatsinfo[j].tx_packets;
				rx_rate = WTP[i]->apstatsinfo[j].rx_rate;
				tx_rate = WTP[i]->apstatsinfo[j].tx_rate;
				tx_errors += WTP[i]->apstatsinfo[j].tx_errors;        //fengwenchao add 20110425
				tx_retry += WTP[i]->apstatsinfo[j].tx_pkt_retry;     //fengwenchao add 20110425
			}

			if(WTP[i]->apstatsinfo[j].type==1)
			{
				ast_rx_phyerr += WTP[i]->apstatsinfo[j].ast_rx_phyerr;
			}
		}
		/*fengwenchao add 20110503 dot11WtpBssIDNumTable*/
		for(j = 0; j < WTP[i]->RadioCount; j++)
		{
			for(k = 0; k < L_BSS_NUM ;k++)
			{
				 if(WTP[i]->WTP_Radio[j]->BSS[k] != NULL)
				 {
				 	count++;
				 }
			}
		}
		/*fengwenchao add end*/
		/*if(rx_pkt)
			{wtpRxPacketLossRate = ((unsigned int)((float)rx_drop/(float)rx_pkt))%100;}
		if(tx_pkt)
			{wtpTxPacketLossRate = ((unsigned int)((float)tx_drop/(float)tx_pkt))%100;}	*/	

		tx_band = ((int)((float)tx_rate/15))%100;
		rx_band	= ((int)((float)rx_rate/15))%100;

		sprintf(ptr_wtp_mac,"%02X:%02X:%02X:%02X:%02X:%02X",
		WTP[i]->WTPMAC[0],WTP[i]->WTPMAC[1],WTP[i]->WTPMAC[2],
		WTP[i]->WTPMAC[3],WTP[i]->WTPMAC[4],WTP[i]->WTPMAC[5]);
		//printf("@@@@@@@@@@@@@@@@@@\n");
		dbus_message_iter_open_container(&iter_wtp_array,DBUS_TYPE_STRUCT,NULL,&iter_wtp);
		dbus_message_iter_append_basic(&iter_wtp,DBUS_TYPE_UINT32,&WTP[i]->WTPID);
		dbus_message_iter_append_basic(&iter_wtp,DBUS_TYPE_STRING,&ptr_wtp_mac);
		//dbus_message_iter_append_basic(&iter_wtp,DBUS_TYPE_UINT32,&wtpRxPacketLossRate);
		//dbus_message_iter_append_basic(&iter_wtp,DBUS_TYPE_UINT32,&wtpTxPacketLossRate);
		dbus_message_iter_append_basic(&iter_wtp,DBUS_TYPE_UINT32,&rx_drop);
		dbus_message_iter_append_basic(&iter_wtp,DBUS_TYPE_UINT32,&tx_drop);
		dbus_message_iter_append_basic(&iter_wtp,DBUS_TYPE_UINT32,&rx_pkt);
		dbus_message_iter_append_basic(&iter_wtp,DBUS_TYPE_UINT32,&tx_pkt);
		dbus_message_iter_append_basic(&iter_wtp,DBUS_TYPE_UINT32,&tx_band);
		dbus_message_iter_append_basic(&iter_wtp,DBUS_TYPE_UINT32,&rx_band);
		dbus_message_iter_append_basic(&iter_wtp,DBUS_TYPE_UINT32,&rx_rate);
		dbus_message_iter_append_basic(&iter_wtp,DBUS_TYPE_UINT32,&tx_rate);
		dbus_message_iter_append_basic(&iter_wtp,DBUS_TYPE_UINT32,&ast_rx_phyerr);
		dbus_message_iter_append_basic(&iter_wtp,DBUS_TYPE_UINT32,&tx_pkt);         //fengwenchao modify 20110425
		dbus_message_iter_append_basic(&iter_wtp,DBUS_TYPE_UINT32,&tx_errors);    //fengwenchao modify 20110425
		dbus_message_iter_append_basic(&iter_wtp,DBUS_TYPE_UINT32,&tx_retry);      //fengwenchao modify 20110425
		dbus_message_iter_append_basic(&iter_wtp,DBUS_TYPE_BYTE,&WID_SAMPLE_INFORMATION.monitor_time);
		dbus_message_iter_append_basic(&iter_wtp,DBUS_TYPE_BYTE,&WTP[i]->wifi_extension_reportswitch);            //fengwenchao add 20110503 for dot11WtpExtensionTable
		dbus_message_iter_append_basic(&iter_wtp,DBUS_TYPE_UINT32,&WTP[i]->wids_statist.floodingcount);             //fengwenchao add 20110503 for dot11WtpWidStatisticsTable
		dbus_message_iter_append_basic(&iter_wtp,DBUS_TYPE_UINT32,&WTP[i]->wids_statist.sproofcount);                //fengwenchao add 20110503 for dot11WtpWidStatisticsTable
		dbus_message_iter_append_basic(&iter_wtp,DBUS_TYPE_UINT32,&WTP[i]->wids_statist.weakivcount);               //fengwenchao add 20110503 for dot11WtpWidStatisticsTable
		dbus_message_iter_append_basic(&iter_wtp,DBUS_TYPE_UINT32,&count);                                                             //fengwenchao add 20110503 for dot11WtpBssIDNumTable
		//printf("rx_rate  =  %d\n",rx_rate);
		//printf("tx_rate  =  %d\n",tx_rate);
		//printf("tx_band  =  %d\n",tx_band);
		//printf("rx_band  =  %d\n",rx_band);
		//printf("ast_rx_phyerr  =  %d\n",ast_rx_phyerr);
		//printf("WTP[%d]->wifi_extension_info.tx_packets  =  %d\n",i,WTP[i]->wifi_extension_info.tx_packets);
		//printf("WID_SAMPLE_INFORMATION.monitor_time  =  %d\n",WID_SAMPLE_INFORMATION.monitor_time);
		dbus_message_iter_close_container(&iter_wtp_array,&iter_wtp);
	}
	dbus_message_iter_close_container(&iter,&iter_wtp_array);
	CW_FREE_OBJECT_WID(WTP);
	//printf("over le !!!!!!!\n");
	return reply;
}

/*fengwenchao add end*/
DBusMessage *wid_dbus_interface_show_all_wtp_ath_statistics_information(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;	
	DBusMessageIter	iter;
	DBusMessageIter	iter_wtp_array;
	DBusMessageIter iter_wtp;
	DBusMessageIter iter_ath_array;
	DBusMessageIter iter_ath;

	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	
	//printf("222222222222222222\n");
	unsigned int wtp_num = 0;
	unsigned int ath_num = 0;
	char wtp_mac[18]={0};
	char* ptr_wtp_mac=wtp_mac;
	unsigned int ath_id = 0;
	
	WID_WTP **WTP;
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	
	wtp_num = Wid_Find_Wtp(WTP);
	if(wtp_num == 0)
		ret = WTP_ID_NOT_EXIST;

	//printf(" ath ::: wtp_num = %d\n",wtp_num);
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);	
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&wtp_num);

	dbus_message_iter_open_container(&iter,
								DBUS_TYPE_ARRAY,
								DBUS_STRUCT_BEGIN_CHAR_AS_STRING
									DBUS_TYPE_UINT32_AS_STRING  //WTP_ID
									DBUS_TYPE_STRING_AS_STRING	//wtp_mac
									DBUS_TYPE_UINT32_AS_STRING 	//ath_num
									
									DBUS_TYPE_ARRAY_AS_STRING
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
										DBUS_TYPE_UINT32_AS_STRING  //radio_id
										DBUS_TYPE_UINT32_AS_STRING	//wlan_id
										DBUS_TYPE_UINT32_AS_STRING	//tx_packets 
										DBUS_TYPE_UINT32_AS_STRING	//rx_packets 
										DBUS_TYPE_UINT32_AS_STRING	//tx_pkt_mgmt
										DBUS_TYPE_UINT32_AS_STRING	//rx_pkt_mgmt
										DBUS_TYPE_UINT32_AS_STRING	//rx_pkt_mgmt
										DBUS_TYPE_UINT64_AS_STRING	//tx_bytes 
										DBUS_TYPE_UINT64_AS_STRING	//rx_bytes
										DBUS_TYPE_UINT32_AS_STRING	//tx_pkt_retry 
										DBUS_TYPE_UINT32_AS_STRING	//tx_total_pkt_retry
										DBUS_TYPE_UINT32_AS_STRING	//rx_pkt_unicast 
										DBUS_TYPE_UINT32_AS_STRING	//tx_pkt_unicast 
										DBUS_TYPE_UINT32_AS_STRING	//rx_pkt_multicast 
										DBUS_TYPE_UINT32_AS_STRING	//tx_pkt_multicast 
										DBUS_TYPE_UINT32_AS_STRING	//tx_mgmt 
										DBUS_TYPE_UINT32_AS_STRING	//rx_mgmt 
										DBUS_TYPE_UINT32_AS_STRING // ast_rx_crcerr 
										DBUS_TYPE_UINT32_AS_STRING // ast_rx_badmic
										DBUS_TYPE_UINT32_AS_STRING // ast_rx_badcrypt 
										DBUS_TYPE_UINT32_AS_STRING	//tx_error 
										DBUS_TYPE_UINT32_AS_STRING	//rx_unicast 
										DBUS_TYPE_UINT32_AS_STRING	//tx_unicast 
										DBUS_TYPE_UINT32_AS_STRING	//rx_multicast 
										DBUS_TYPE_UINT32_AS_STRING	//tx_multicast 
										DBUS_TYPE_UINT32_AS_STRING	//tx_mgmt 
										DBUS_TYPE_UINT32_AS_STRING	//rx_mgmt 
										DBUS_TYPE_UINT32_AS_STRING  //ast_rx_phyerr      fengwenchao add
										//fengwenchao add 20101228
										DBUS_TYPE_BYTE_AS_STRING    //snr_max_value  AP     
										DBUS_TYPE_BYTE_AS_STRING    //snr_min_value  AP
										DBUS_TYPE_UINT64_AS_STRING    //snr_average     AP 
										//fengwenchao add end												
									DBUS_STRUCT_END_CHAR_AS_STRING
								DBUS_STRUCT_END_CHAR_AS_STRING,
								&iter_wtp_array);
	
	int i=0;
	for(i=0;i<wtp_num;i++){
		//prepare data for wtp i
		ath_num=0;
		ath_id = 0;
		int j=0;
		for(j=0;j<TOTAL_AP_IF_NUM;j++){
			if(WTP[i]->apstatsinfo[j].type==0)
				ath_num++;
			}
		//printf(" ath ::: ath_num = %d\n",ath_num);
		sprintf(ptr_wtp_mac,"%02X:%02X:%02X:%02X:%02X:%02X",
			WTP[i]->WTPMAC[0],WTP[i]->WTPMAC[1],WTP[i]->WTPMAC[2],
			WTP[i]->WTPMAC[3],WTP[i]->WTPMAC[4],WTP[i]->WTPMAC[5]);
		//sending data for wtp i
		dbus_message_iter_open_container(&iter_wtp_array,DBUS_TYPE_STRUCT,NULL,&iter_wtp);
		dbus_message_iter_append_basic(&iter_wtp,DBUS_TYPE_UINT32,&WTP[i]->WTPID);
		dbus_message_iter_append_basic(&iter_wtp,DBUS_TYPE_STRING,&ptr_wtp_mac);
		dbus_message_iter_append_basic(&iter_wtp,DBUS_TYPE_UINT32,&ath_num);

		dbus_message_iter_open_container(&iter_wtp,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
										DBUS_TYPE_UINT32_AS_STRING	//radio_id
										DBUS_TYPE_UINT32_AS_STRING	//wlan_id
										DBUS_TYPE_UINT32_AS_STRING	//tx_packets 
										DBUS_TYPE_UINT32_AS_STRING	//rx_packets 
										DBUS_TYPE_UINT32_AS_STRING	//tx_pkt_mgmt
										DBUS_TYPE_UINT32_AS_STRING	//rx_pkt_mgmt
										DBUS_TYPE_UINT32_AS_STRING	//rx_pkt_mgmt
										DBUS_TYPE_UINT64_AS_STRING	//tx_bytes 
										DBUS_TYPE_UINT64_AS_STRING	//rx_bytes
										DBUS_TYPE_UINT32_AS_STRING	//tx_pkt_retry 
										DBUS_TYPE_UINT32_AS_STRING	//tx_total_pkt_retry
										DBUS_TYPE_UINT32_AS_STRING	//rx_pkt_unicast 
										DBUS_TYPE_UINT32_AS_STRING	//tx_pkt_unicast 
										DBUS_TYPE_UINT32_AS_STRING	//rx_pkt_multicast 
										DBUS_TYPE_UINT32_AS_STRING	//tx_pkt_multicast 
										DBUS_TYPE_UINT32_AS_STRING	//tx_mgmt 
										DBUS_TYPE_UINT32_AS_STRING	//rx_mgmt 
										DBUS_TYPE_UINT32_AS_STRING // ast_rx_crcerr 
										DBUS_TYPE_UINT32_AS_STRING // ast_rx_badmic
										DBUS_TYPE_UINT32_AS_STRING // ast_rx_badcrypt 
										DBUS_TYPE_UINT32_AS_STRING	//tx_error 
										DBUS_TYPE_UINT32_AS_STRING	//rx_unicast 
										DBUS_TYPE_UINT32_AS_STRING	//tx_unicast 
										DBUS_TYPE_UINT32_AS_STRING	//rx_multicast 
										DBUS_TYPE_UINT32_AS_STRING	//tx_multicast 
										DBUS_TYPE_UINT32_AS_STRING	//tx_mgmt 
										DBUS_TYPE_UINT32_AS_STRING	//rx_mgmt 
										DBUS_TYPE_UINT32_AS_STRING  //ast_rx_phyerr      fengwenchao add
										//fengwenchao add 20101228
										DBUS_TYPE_BYTE_AS_STRING    //snr_max_value  AP     
										DBUS_TYPE_BYTE_AS_STRING    //snr_min_value  AP
										DBUS_TYPE_UINT64_AS_STRING    //snr_average     AP 
										//fengwenchao add end												
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_ath_array);

		
		for(j=0;j<TOTAL_AP_IF_NUM;j++){
			if(WTP[i]->apstatsinfo[j].type==0){
				//prepare data for ath j
				unsigned int wirelessifindex=WTP[i]->apstatsinfo[j].radioId;
				unsigned int wlanid = WTP[i]->apstatsinfo[j].wlanId;
				unsigned int tx_sigpkts=WTP[i]->apstatsinfo[j].tx_pkt_mgmt;
				unsigned int rx_sigpkts=WTP[i]->apstatsinfo[j].rx_pkt_mgmt;
				unsigned int tx_mgmt=WTP[i]->apstatsinfo[j].tx_mgmt;
				unsigned int rx_mgmt=WTP[i]->apstatsinfo[j].rx_mgmt;

				/*xiaodawei modify, 20110318*/
				unsigned int tx_pkt_data = 0;
				unsigned int rx_pkt_data = 0;
				unsigned long long tx_bytes = 0;
				unsigned long long rx_bytes = 0;
				if(wirelessdata_switch)
				{
					tx_pkt_data = (WTP[i]->apstatsinfo[j].tx_pkt_data > WTP[i]->apstatsinfo[j].tx_pkt_multicast)?
									(WTP[i]->apstatsinfo[j].tx_pkt_data - WTP[i]->apstatsinfo[j].tx_pkt_multicast):
									(WTP[i]->apstatsinfo[j].tx_pkt_multicast - WTP[i]->apstatsinfo[j].tx_pkt_data);
									
					rx_pkt_data = (WTP[i]->apstatsinfo[j].rx_pkt_data > WTP[i]->apstatsinfo[j].rx_pkt_multicast)?
									(WTP[i]->apstatsinfo[j].rx_pkt_data - WTP[i]->apstatsinfo[j].rx_pkt_multicast):
									(WTP[i]->apstatsinfo[j].rx_pkt_multicast - WTP[i]->apstatsinfo[j].rx_pkt_data);
									
					tx_bytes = (WTP[i]->apstatsinfo[j].tx_bytes > WTP[i]->apstatsinfo[j].tx_multicast)?
									(WTP[i]->apstatsinfo[j].tx_bytes - WTP[i]->apstatsinfo[j].tx_multicast):
									(WTP[i]->apstatsinfo[j].tx_multicast - WTP[i]->apstatsinfo[j].tx_bytes);
									
					rx_bytes = (WTP[i]->apstatsinfo[j].rx_bytes > WTP[i]->apstatsinfo[j].rx_multicast)?
									(WTP[i]->apstatsinfo[j].rx_bytes - WTP[i]->apstatsinfo[j].rx_multicast):
									(WTP[i]->apstatsinfo[j].rx_multicast - WTP[i]->apstatsinfo[j].rx_bytes);
				}
				else
				{
					tx_pkt_data = WTP[i]->apstatsinfo[j].tx_pkt_data;
					rx_pkt_data = WTP[i]->apstatsinfo[j].rx_pkt_data;
					tx_bytes = WTP[i]->apstatsinfo[j].tx_bytes;
					rx_bytes = WTP[i]->apstatsinfo[j].rx_bytes;
				}

				/* book modify, 2011-1-25 */
                unsigned int wirelessIfUpdownTimes = 0;
                unsigned int bssindex = 0;
                if(AC_WLAN[wlanid] != NULL){
                    bssindex = AC_WLAN[wlanid]->S_WTP_BSS_List[WTP[i]->WTPID][wirelessifindex];
                    if(AC_BSS[bssindex] != NULL){
                        wirelessIfUpdownTimes = AC_BSS[bssindex]->upcount + AC_BSS[bssindex]->downcount;
                    }
                }

				unsigned int tx_total_pkt_retry = WTP[i]->apstatsinfo[j].tx_pkt_retry*103/100;	//xiaodawei add, 20110422
				dbus_message_iter_open_container(&iter_ath_array,DBUS_TYPE_STRUCT,NULL,&iter_ath);
				dbus_message_iter_append_basic(&iter_ath,DBUS_TYPE_UINT32,&wirelessifindex);
				dbus_message_iter_append_basic(&iter_ath,DBUS_TYPE_UINT32,&wlanid);
				dbus_message_iter_append_basic(&iter_ath,DBUS_TYPE_UINT32,&wirelessIfUpdownTimes);
				dbus_message_iter_append_basic(&iter_ath,DBUS_TYPE_UINT32,&tx_sigpkts);
				dbus_message_iter_append_basic(&iter_ath,DBUS_TYPE_UINT32,&rx_sigpkts);
				dbus_message_iter_append_basic(&iter_ath,DBUS_TYPE_UINT32,&tx_pkt_data);//book modify,2011-1-20
				dbus_message_iter_append_basic(&iter_ath,DBUS_TYPE_UINT32,&rx_pkt_data);//book modify,2011-1-20
				dbus_message_iter_append_basic(&iter_ath,DBUS_TYPE_UINT64,&tx_bytes);
				dbus_message_iter_append_basic(&iter_ath,DBUS_TYPE_UINT64,&rx_bytes);
				dbus_message_iter_append_basic(&iter_ath,DBUS_TYPE_UINT32,&WTP[i]->apstatsinfo[j].tx_pkt_retry);
				dbus_message_iter_append_basic(&iter_ath,DBUS_TYPE_UINT32,&tx_total_pkt_retry);
				dbus_message_iter_append_basic(&iter_ath,DBUS_TYPE_UINT32,&WTP[i]->apstatsinfo[j].rx_pkt_unicast);
				dbus_message_iter_append_basic(&iter_ath,DBUS_TYPE_UINT32,&WTP[i]->apstatsinfo[j].tx_pkt_unicast);
				dbus_message_iter_append_basic(&iter_ath,DBUS_TYPE_UINT32,&WTP[i]->apstatsinfo[j].rx_pkt_multicast);
				dbus_message_iter_append_basic(&iter_ath,DBUS_TYPE_UINT32,&WTP[i]->apstatsinfo[j].tx_pkt_multicast);
				dbus_message_iter_append_basic(&iter_ath,DBUS_TYPE_UINT32,&tx_mgmt);
				dbus_message_iter_append_basic(&iter_ath,DBUS_TYPE_UINT32,&rx_mgmt);
				
				dbus_message_iter_append_basic(&iter_ath,DBUS_TYPE_UINT32,&WTP[i]->apstatsinfo[j].ast_rx_crcerr);
				dbus_message_iter_append_basic(&iter_ath,DBUS_TYPE_UINT32,&WTP[i]->apstatsinfo[j].ast_rx_badmic);
				dbus_message_iter_append_basic(&iter_ath,DBUS_TYPE_UINT32,&WTP[i]->apstatsinfo[j].ast_rx_badcrypt);
				dbus_message_iter_append_basic(&iter_ath,DBUS_TYPE_UINT32,&WTP[i]->apstatsinfo[j].tx_errors);
				 
				dbus_message_iter_append_basic(&iter_ath,DBUS_TYPE_UINT32,&rx_pkt_data);
				dbus_message_iter_append_basic(&iter_ath,DBUS_TYPE_UINT32,&tx_pkt_data);
				dbus_message_iter_append_basic(&iter_ath,DBUS_TYPE_UINT32,&WTP[i]->apstatsinfo[j].rx_pkt_mgmt);
				dbus_message_iter_append_basic(&iter_ath,DBUS_TYPE_UINT32,&WTP[i]->apstatsinfo[j].tx_pkt_mgmt);
			    dbus_message_iter_append_basic(&iter_ath,DBUS_TYPE_UINT32,&WTP[i]->apstatsinfo[j].rx_pkt_control);
				dbus_message_iter_append_basic(&iter_ath,DBUS_TYPE_UINT32,&WTP[i]->apstatsinfo[j].tx_pkt_control);

			  	dbus_message_iter_append_basic(&iter_ath,DBUS_TYPE_UINT32,&WTP[i]->apstatsinfo[j].ast_rx_phyerr);  //fengwenchao add  
			  
				//fengwenchao add 20101228
				dbus_message_iter_append_basic (&iter_ath,DBUS_TYPE_BYTE,&WTP[i]->apcminfo.snr_max_value); 																												
				dbus_message_iter_append_basic (&iter_ath,DBUS_TYPE_BYTE,&WTP[i]->apcminfo.snr_min_value); 																							
				dbus_message_iter_append_basic (&iter_ath,DBUS_TYPE_UINT64,&WTP[i]->apcminfo.snr_math_average);																								 					
				//fengwenchao add end							
				dbus_message_iter_close_container(&iter_ath_array,&iter_ath);
				}
			}
		dbus_message_iter_close_container(&iter_wtp,&iter_ath_array);
		dbus_message_iter_close_container(&iter_wtp_array,&iter_wtp);
	}
	dbus_message_iter_close_container(&iter,&iter_wtp_array);
	//printf("eeeeeeeennnnnnddddddd wid \n");
	CW_FREE_OBJECT_WID(WTP);
	return reply;
}

/*b17*/
DBusMessage * wid_dbus_interface_show_wtp_wireless_if_stats_information(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusMessageIter iter_struct;
	DBusMessageIter iter_sub_struct;
	DBusMessageIter iter_sub_array;
	DBusMessageIter iter_sub_sub_struct;
	DBusMessageIter iter_sub_sub_array;
	DBusError err;
	
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int wtp_num = 0;
	char *code;
	code = (char *)WID_MALLOC(sizeof(char)*128);
	int i=0,m=0,j=0;
	int jj=0,kk=0/*,ii=0*/;
	unsigned char default_char_zero = 0;
	//wid_code_infomation *model_info;
	//model_info = (wid_code_infomation *)WID_MALLOC(sizeof(wid_code_infomation));
	
	unsigned int ap_antenna_gain = 0;
	unsigned int txpower ;
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	WID_BSS *BSS[L_BSS_NUM];
	
	WID_WTP **WTP;
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	
	if(hide_quit_wtp_in_showting == 0){
		wtp_num = Wid_Find_Wtp(WTP);
	}
	else if (hide_quit_wtp_in_showting == 1){
		wtp_num = Wid_Find_Running_Wtp(WTP);
	}
	
	if(wtp_num == 0)
		ret = WTP_ID_NOT_EXIST;
		
	if(wtp_num >= WTP_NUM)
		ret = WTP_OVER_MAX_NUM;

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	// Total slot count
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &wtp_num);

	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING		//wtpid
											DBUS_TYPE_BYTE_AS_STRING		 //mac 0
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING		//mac 5

											DBUS_TYPE_STRING_AS_STRING		//model
											DBUS_TYPE_UINT32_AS_STRING		//autena_gain
											DBUS_TYPE_UINT32_AS_STRING		//txpower
											DBUS_TYPE_UINT32_AS_STRING     //wtp_allowed_max_sta_num

												DBUS_TYPE_BYTE_AS_STRING	//wifi num	
												DBUS_TYPE_BYTE_AS_STRING	//radio count xiaodawei add
												DBUS_TYPE_ARRAY_AS_STRING
														DBUS_STRUCT_BEGIN_CHAR_AS_STRING
															DBUS_TYPE_BYTE_AS_STRING		//ifindex
															DBUS_TYPE_UINT32_AS_STRING		//g_radio_id
															
															DBUS_TYPE_BYTE_AS_STRING		//radio chan
															DBUS_TYPE_BYTE_AS_STRING		//auto channel cont
															DBUS_TYPE_UINT16_AS_STRING		//radio TXPOF
															DBUS_TYPE_BYTE_AS_STRING		//txpowerautostate
															DBUS_TYPE_UINT32_AS_STRING		//radio_type

															DBUS_TYPE_BYTE_AS_STRING		//wifi state
															DBUS_TYPE_UINT32_AS_STRING		//time
															DBUS_TYPE_BYTE_AS_STRING		//radio_has_bss//b1
															DBUS_TYPE_BYTE_AS_STRING		//Bssid 0
															DBUS_TYPE_BYTE_AS_STRING
															DBUS_TYPE_BYTE_AS_STRING
															
															DBUS_TYPE_BYTE_AS_STRING
															DBUS_TYPE_BYTE_AS_STRING
															DBUS_TYPE_BYTE_AS_STRING		//Bssid 5
															DBUS_TYPE_BYTE_AS_STRING		//Bss State//b8
                                                            DBUS_TYPE_UINT16_AS_STRING      //txpowerstep
															DBUS_TYPE_UINT32_AS_STRING		//rate num
																DBUS_TYPE_ARRAY_AS_STRING
																	DBUS_STRUCT_BEGIN_CHAR_AS_STRING
																		DBUS_TYPE_UINT32_AS_STRING		
																	DBUS_STRUCT_END_CHAR_AS_STRING
												DBUS_STRUCT_END_CHAR_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for(i = 0; i < wtp_num; i++){	
		memset(mac,0,MAC_LEN+1);
		if(WTP[i]->WTPMAC != NULL)
			memcpy(mac,WTP[i]->WTPMAC,MAC_LEN);
		dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
		
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_UINT32,&(WTP[i]->WTPID));
		
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[0]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[1]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[2]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[3]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[4]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[5]));

		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_STRING,&(WTP[i]->WTPModel));

		CWThreadMutexLock(&(gAllThreadMutex));		
		CWConfigVersionInfo *pnode = gConfigVersionInfo;

		while(pnode != NULL)
		{
			if(strcmp(pnode->str_ap_model,WTP[i]->WTPModel) == 0){
				break;
			}
			pnode = pnode->next;
		}	
		CWThreadMutexUnlock(&(gAllThreadMutex));		

		if(pnode == NULL){
			wid_syslog_debug_debug(WID_DEFAULT," 55555555 NULL pnode\n");
		}
		
		else{
			memset(code,0,128);
			memcpy(code,pnode->str_ap_model,strlen(pnode->str_ap_model));
			
			if((!strncmp(code,"3110-H",6))||(!strncmp(code,"3120-H",6))){	
					ap_antenna_gain = 12;
			}
			else if((!strncmp(code,"1010",4))){
				ap_antenna_gain = 3;
			}
			else{
				ap_antenna_gain = 5;
			}
		}

		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_UINT32,
										&(ap_antenna_gain));

		if ((WTP[i]->WTPModel == NULL)||(WTP[i]->APCode == NULL)){
			txpower = 0;
		}
		else{
			int modellen = strlen(WTP[i]->APCode);

			if(WTP[i]->APCode[modellen-1] == 'H')
			{
				txpower = 27;
			}
			else
			{
				txpower = 20;
			}
		}

		dbus_message_iter_append_basic(&iter_struct,
										 DBUS_TYPE_UINT32,
										 &(txpower));

		dbus_message_iter_append_basic (&iter_struct,
										 DBUS_TYPE_UINT32,
										 &(WTP[i]->wtp_allowed_max_sta_num));
#if 0
		for(ii=0;ii<L_RADIO_NUM;ii++){
			model_info->support_mode[ii] = 3;//b-1/g-2/n-4/a-8//default bg
		}
		
		if((!strncmp(code,"1110-N",6))||(!strncmp(code,"2110-N",6))||(!strncmp(code,"2120-N",6))
			||(!strncmp(code,"3110-N",6))||(!strncmp(code,"3120-N",6)))
		{
			model_info->support_mode[0] = 7;//bgn
		}
		else if((!strncmp(code,"2110",4))||(!strncmp(code,"2110-H",6))||(!strncmp(code,"3110",4))
			||(!strncmp(code,"3110-H",6)))
		{
			model_info->support_mode[0] = 11;//abg
		}

		if((!strncmp(code,"2120-N",6))||(!strncmp(code,"3120-N",6)))
		{	
			model_info->support_mode[1] = 12;//an
		}
		else if((!strncmp(code,"2120-H",6))||(!strncmp(code,"3120-H",6))||(!strncmp(code,"2120",4))||(!strncmp(code,"3120",4)))
		{
			model_info->support_mode[1] = 11;//abg
		}
#endif
		dbus_message_iter_append_basic(&iter_struct, 
										DBUS_TYPE_BYTE, 
										&(WTP[i]->apifinfo.wifi_num));
		dbus_message_iter_append_basic(&iter_struct, 
										DBUS_TYPE_BYTE, 
										&(WTP[i]->RadioCount));		//xiaodawei add radiocount from wtpcompatible.xml, 20110124
		
		dbus_message_iter_open_container (&iter_struct,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING		//ifindex
												DBUS_TYPE_UINT32_AS_STRING		//g_radio_id
												
												DBUS_TYPE_BYTE_AS_STRING		//radio chan
												DBUS_TYPE_BYTE_AS_STRING		//auto channel cont
												DBUS_TYPE_UINT16_AS_STRING		//radio TXPOF
												DBUS_TYPE_BYTE_AS_STRING		//txpowerautostate
												DBUS_TYPE_UINT32_AS_STRING		//radio_type

												DBUS_TYPE_BYTE_AS_STRING		//wifi state
												DBUS_TYPE_UINT32_AS_STRING		//time
												
												DBUS_TYPE_BYTE_AS_STRING		//radio_has_bss//b1
												DBUS_TYPE_BYTE_AS_STRING		//Bssid 0
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING		//Bssid 5
												DBUS_TYPE_BYTE_AS_STRING		//Bss State	//b8
												DBUS_TYPE_UINT16_AS_STRING      //txpowerstep
												DBUS_TYPE_UINT32_AS_STRING		//rate num
														DBUS_TYPE_ARRAY_AS_STRING
															DBUS_STRUCT_BEGIN_CHAR_AS_STRING
																DBUS_TYPE_UINT32_AS_STRING		
															DBUS_STRUCT_END_CHAR_AS_STRING
												
										DBUS_STRUCT_END_CHAR_AS_STRING,
										&iter_sub_array);
		
		for(kk = 0; kk < WTP[i]->apifinfo.wifi_num && kk < WTP[i]->RadioCount; kk++){	
			unsigned int wtp_id = WTP[i]->WTPID;
			unsigned char ifindex = (char)kk ;
			unsigned int g_radio_id = 4*wtp_id +ifindex;
			unsigned char Radio_Chan = 0;
			unsigned char auto_channel_cont = 0;
			unsigned short Radio_TXPOF = 0;
			unsigned char txpowerautostate = 0;
			unsigned int radio_type = 3;	//xiaodawei add, default value is bg
			unsigned char bss_num = 0;
			unsigned int support_rate_num = 0;
			unsigned short Radio_TXP_Step = 1;
			unsigned char AdStat = 0;			//xiaodawei add, 20110106
			
			dbus_message_iter_open_container (&iter_sub_array,
												DBUS_TYPE_STRUCT,
												NULL,
												&iter_sub_struct);
			
			dbus_message_iter_append_basic (&iter_sub_struct,
												DBUS_TYPE_BYTE,
												&(ifindex));

			dbus_message_iter_append_basic (&iter_sub_struct,
												DBUS_TYPE_UINT32,
												&(g_radio_id));

			if(AC_RADIO[g_radio_id]!=NULL){
				Radio_Chan = AC_RADIO[g_radio_id]->Radio_Chan;
				auto_channel_cont = AC_RADIO[g_radio_id]->auto_channel_cont;
				Radio_TXPOF = AC_RADIO[g_radio_id]->Radio_TXPOF;
				txpowerautostate =  AC_RADIO[g_radio_id]->txpowerautostate;
				radio_type = AC_RADIO[g_radio_id]->Radio_Type;
			}
			else{
				wid_syslog_debug_debug(WID_DEFAULT,"AC_RADIO[%d] id empty!!!\n",g_radio_id);
			}
	
			dbus_message_iter_append_basic (&iter_sub_struct,
											 DBUS_TYPE_BYTE,
											 &(Radio_Chan));
					
			dbus_message_iter_append_basic (&iter_sub_struct,
											 DBUS_TYPE_BYTE,
											 &(auto_channel_cont));		
			
			dbus_message_iter_append_basic (&iter_sub_struct,
											 DBUS_TYPE_UINT16,
											 &(Radio_TXPOF));
			
			dbus_message_iter_append_basic (&iter_sub_struct,
											 DBUS_TYPE_BYTE,
											 &(txpowerautostate));
			
			dbus_message_iter_append_basic (&iter_sub_struct,
											 DBUS_TYPE_UINT32,
											 &radio_type); 		//radio_type

			dbus_message_iter_append_basic(&iter_sub_struct, 
											 DBUS_TYPE_BYTE, 
											 &(WTP[i]->apifinfo.wifi[ifindex].state));		

			dbus_message_iter_append_basic(&iter_sub_struct, 
										 	 DBUS_TYPE_UINT32, 
											 &(WTP[i]->apifinfo.wifi[ifindex].state_time));
			
			for(jj=0;jj<L_BSS_NUM;jj++){
				if((AC_RADIO[g_radio_id]!= NULL)&&(AC_RADIO[g_radio_id]->BSS[jj] != NULL)){
					BSS[bss_num] = AC_RADIO[g_radio_id]->BSS[jj];
					bss_num++;
				}
			}
			unsigned char radio_has_bss = 0;
			if(bss_num != 0){
				radio_has_bss = 1;
				dbus_message_iter_append_basic(&iter_sub_struct,
												  DBUS_TYPE_BYTE,
												  &(radio_has_bss));
				
				dbus_message_iter_append_basic(&iter_sub_struct,
												  DBUS_TYPE_BYTE,
												  &(BSS[0]->BSSID[0]));
				dbus_message_iter_append_basic(&iter_sub_struct,
												  DBUS_TYPE_BYTE,
												  &(BSS[0]->BSSID[1]));
				dbus_message_iter_append_basic(&iter_sub_struct,
												  DBUS_TYPE_BYTE,
												  &(BSS[0]->BSSID[2]));
				
				dbus_message_iter_append_basic(&iter_sub_struct,
												  DBUS_TYPE_BYTE,
												  &(BSS[0]->BSSID[3]));
				dbus_message_iter_append_basic(&iter_sub_struct,
												  DBUS_TYPE_BYTE,
												  &(BSS[0]->BSSID[4]));
				dbus_message_iter_append_basic(&iter_sub_struct,
												  DBUS_TYPE_BYTE,
												  &(BSS[0]->BSSID[5]));
				
			}

			else{
				dbus_message_iter_append_basic(&iter_sub_struct,
												  DBUS_TYPE_BYTE,
												  &(radio_has_bss));
				
				dbus_message_iter_append_basic(&iter_sub_struct,
												  DBUS_TYPE_BYTE,
												  &(default_char_zero));
				dbus_message_iter_append_basic(&iter_sub_struct,
												  DBUS_TYPE_BYTE,
												  &(default_char_zero));
				dbus_message_iter_append_basic(&iter_sub_struct,
												  DBUS_TYPE_BYTE,
												  &(default_char_zero));
				
				dbus_message_iter_append_basic(&iter_sub_struct,
												  DBUS_TYPE_BYTE,
												  &(default_char_zero));
				dbus_message_iter_append_basic(&iter_sub_struct,
												  DBUS_TYPE_BYTE,
												  &(default_char_zero));
				dbus_message_iter_append_basic(&iter_sub_struct,
												  DBUS_TYPE_BYTE,
												  &(default_char_zero));

			}
			if(AC_RADIO[g_radio_id] != NULL){			//xiaodawei modify, 20110106
				AdStat = AC_RADIO[g_radio_id]->AdStat;
			}
			else{
				AdStat = 2;
			}
			dbus_message_iter_append_basic(&iter_sub_struct,
											  DBUS_TYPE_BYTE,
											  &AdStat);

			if(AC_RADIO[g_radio_id] != NULL){
				Radio_TXP_Step = AC_RADIO[g_radio_id]->txpowerstep;
			}
			else{
				Radio_TXP_Step = 1;
			}

			dbus_message_iter_append_basic(&iter_sub_struct,
												  DBUS_TYPE_UINT16,
												  &(Radio_TXP_Step));
			

			if(AC_RADIO[g_radio_id] != NULL){
				support_rate_num = AC_RADIO[g_radio_id]->Support_Rate_Count;
			}
			else{
				support_rate_num = 0;
			}
			dbus_message_iter_append_basic(&iter_sub_struct,
												  DBUS_TYPE_UINT32,
												  &(support_rate_num));

			dbus_message_iter_open_container (&iter_sub_struct,
													DBUS_TYPE_ARRAY,
														DBUS_STRUCT_BEGIN_CHAR_AS_STRING
																DBUS_TYPE_UINT32_AS_STRING		//rate num
														DBUS_STRUCT_END_CHAR_AS_STRING,
													&iter_sub_sub_array);

			if(AC_RADIO[g_radio_id] == NULL){
				j = 0;
			}
			else{
				j = length_of_rate_list(AC_RADIO[g_radio_id]->Radio_Rate);
				struct Support_Rate_List *p = NULL;
				p = AC_RADIO[g_radio_id]->Radio_Rate;
					
				for (m=0;m<j;m++){
					dbus_message_iter_open_container (&iter_sub_sub_array,
													DBUS_TYPE_STRUCT,
													NULL,
													&iter_sub_sub_struct);

					dbus_message_iter_append_basic (&iter_sub_sub_struct,
													 DBUS_TYPE_UINT32,
													 &p->Rate);
					
					dbus_message_iter_close_container (&iter_sub_sub_array, &iter_sub_sub_struct);
					p = p->next;
				}	
			}
			dbus_message_iter_close_container (&iter_sub_struct, &iter_sub_sub_array);
			dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);
		}
		dbus_message_iter_close_container (&iter_struct, &iter_sub_array);
		dbus_message_iter_close_container (&iter_array, &iter_struct);
	}
	dbus_message_iter_close_container (&iter, &iter_array);

	CW_FREE_OBJECT_WID(WTP);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(code);
	//CW_FREE_OBJECT(model_info);

	return reply;	
}
/*for table 26 dot11NewWtpWirelessIfConfigTable  ,dot11WtpWiredIfMulticastTable,dot11WtpWirelessIfConfigTable.showting NewWtpWirelessIfInfo 20100603 by nl b18*/
DBusMessage * wid_dbus_interface_show_new_wireless_ifstats_information(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusMessageIter iter_sub_array;
	DBusMessageIter iter_struct;
	DBusMessageIter iter_sub_struct;
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int wtp_num = 0;
	int i=0,k=0;
	unsigned int defalt_zero = 0;
	unsigned char num_of_radio ;
	unsigned char *mac = NULL;
	
	WID_WTP **WTP;
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	WID_WTP_RADIO	**AC_RADIO_FOR_SEARCH;
	AC_RADIO_FOR_SEARCH = WID_MALLOC(G_RADIO_NUM*(sizeof(WID_WTP_RADIO *)));
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);

	wtp_num = Wid_Find_Wtp(WTP);
	
	if(wtp_num == 0)
		ret = WTP_ID_NOT_EXIST;
	if(wtp_num >= WTP_NUM)
		ret = WTP_OVER_MAX_NUM;
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);

	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &wtp_num);

	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING		//wtp_id
											DBUS_TYPE_BYTE_AS_STRING		//wtp_radio_num
											
												DBUS_TYPE_ARRAY_AS_STRING
														DBUS_STRUCT_BEGIN_CHAR_AS_STRING
															DBUS_TYPE_UINT32_AS_STRING	//radio global id
															DBUS_TYPE_BYTE_AS_STRING	//Radio_L_ID
 															DBUS_TYPE_BYTE_AS_STRING		//mac0
															DBUS_TYPE_BYTE_AS_STRING
															DBUS_TYPE_BYTE_AS_STRING
															DBUS_TYPE_BYTE_AS_STRING
															DBUS_TYPE_BYTE_AS_STRING
															DBUS_TYPE_BYTE_AS_STRING		//mac 5
															
															DBUS_TYPE_UINT16_AS_STRING	//FragThreshold
															DBUS_TYPE_UINT16_AS_STRING	//BeaconPeriod
															DBUS_TYPE_BYTE_AS_STRING	//IsShortPreamble
															DBUS_TYPE_BYTE_AS_STRING	//DTIMPeriod
															DBUS_TYPE_UINT16_AS_STRING	//rtsthreshold
															DBUS_TYPE_BYTE_AS_STRING	//ShortRetry
															DBUS_TYPE_BYTE_AS_STRING	//LongRetry
															
															DBUS_TYPE_UINT32_AS_STRING	//dead_time
															DBUS_TYPE_UINT32_AS_STRING	//tx_multicast
															DBUS_TYPE_UINT32_AS_STRING	//rx_multicast
															
												DBUS_STRUCT_END_CHAR_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for(i = 0; i < wtp_num; i++){			
		dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
		
		dbus_message_iter_append_basic(&iter_struct,
											DBUS_TYPE_UINT32,
												&(WTP[i]->WTPID));
		
		num_of_radio = WID_WTP_FIND_RADIO(AC_RADIO_FOR_SEARCH,WTP[i]);
		
		dbus_message_iter_append_basic(&iter_struct, 
												DBUS_TYPE_BYTE,
													&(num_of_radio));
		
		dbus_message_iter_open_container (&iter_struct,
											   DBUS_TYPE_ARRAY,
											  	 	DBUS_STRUCT_BEGIN_CHAR_AS_STRING
													    DBUS_TYPE_UINT32_AS_STRING	//radio global id
															DBUS_TYPE_BYTE_AS_STRING	//Radio_L_ID
															DBUS_TYPE_BYTE_AS_STRING		//mac0
															DBUS_TYPE_BYTE_AS_STRING
															DBUS_TYPE_BYTE_AS_STRING
															DBUS_TYPE_BYTE_AS_STRING
															DBUS_TYPE_BYTE_AS_STRING
															DBUS_TYPE_BYTE_AS_STRING		//mac 5
															
															DBUS_TYPE_UINT16_AS_STRING	//FragThreshold
															DBUS_TYPE_UINT16_AS_STRING	//BeaconPeriod
															DBUS_TYPE_BYTE_AS_STRING	//IsShortPreamble
															DBUS_TYPE_BYTE_AS_STRING	//DTIMPeriod
															DBUS_TYPE_UINT16_AS_STRING	//rtsthreshold
															DBUS_TYPE_BYTE_AS_STRING	//ShortRetry
															DBUS_TYPE_BYTE_AS_STRING	//LongRetry
															
															DBUS_TYPE_UINT32_AS_STRING	//dead_time
															DBUS_TYPE_UINT32_AS_STRING	//tx_multicast
															DBUS_TYPE_UINT32_AS_STRING	//rx_multicast
												DBUS_STRUCT_END_CHAR_AS_STRING,
											   &iter_sub_array);

		for(k = 0; k < num_of_radio; k++){
			memset(mac,0,MAC_LEN+1);
			if(WTP[i]->WTPMAC != NULL)
				memcpy(mac,WTP[i]->WTPMAC,MAC_LEN);
			dbus_message_iter_open_container (&iter_sub_array,
											   DBUS_TYPE_STRUCT,
											   NULL,
											   &iter_sub_struct);

			dbus_message_iter_append_basic	(&iter_sub_struct,
											  DBUS_TYPE_UINT32,
											  &(AC_RADIO_FOR_SEARCH[k]->Radio_G_ID));

			dbus_message_iter_append_basic	(&iter_sub_struct,
											  DBUS_TYPE_BYTE,
											  &(AC_RADIO_FOR_SEARCH[k]->Radio_L_ID));
			
			dbus_message_iter_append_basic(&iter_sub_struct,
												DBUS_TYPE_BYTE,
													&(mac[0]));
			dbus_message_iter_append_basic(&iter_sub_struct,
												DBUS_TYPE_BYTE,
													&(mac[1]));
			dbus_message_iter_append_basic(&iter_sub_struct,
												DBUS_TYPE_BYTE,
													&(mac[2]));
			
			dbus_message_iter_append_basic(&iter_sub_struct,
												DBUS_TYPE_BYTE,
													&(mac[3]));
			dbus_message_iter_append_basic(&iter_sub_struct,
												DBUS_TYPE_BYTE,
													&(mac[4]));
			dbus_message_iter_append_basic(&iter_sub_struct,
												DBUS_TYPE_BYTE,
													&(mac[5]));
			
			dbus_message_iter_append_basic (&iter_sub_struct,
											 DBUS_TYPE_UINT16,
											 &(AC_RADIO_FOR_SEARCH[k]->FragThreshold));
			dbus_message_iter_append_basic (&iter_sub_struct,
											 DBUS_TYPE_UINT16,
											 &(AC_RADIO_FOR_SEARCH[k]->BeaconPeriod));
			dbus_message_iter_append_basic (&iter_sub_struct,
											 DBUS_TYPE_BYTE,
											 &(AC_RADIO_FOR_SEARCH[k]->IsShortPreamble));
			
			dbus_message_iter_append_basic (&iter_sub_struct,
											 DBUS_TYPE_BYTE,
											 &(AC_RADIO_FOR_SEARCH[k]->DTIMPeriod));
			dbus_message_iter_append_basic (&iter_sub_struct,
											 DBUS_TYPE_UINT16,
											 &(AC_RADIO_FOR_SEARCH[k]->rtsthreshold));	
			dbus_message_iter_append_basic (&iter_sub_struct,
											 DBUS_TYPE_BYTE,
											 &(AC_RADIO_FOR_SEARCH[k]->ShortRetry));	
			
			dbus_message_iter_append_basic (&iter_sub_struct,
											 DBUS_TYPE_BYTE,
											 &(AC_RADIO_FOR_SEARCH[k]->LongRetry));	

			dbus_message_iter_append_basic (&iter_sub_struct,
											 DBUS_TYPE_UINT32,
											 &(AC_RADIO_FOR_SEARCH[k]->rx_data_deadtime)); 

			if(WTP[i]->wifi_extension_reportswitch != 0){
				dbus_message_iter_append_basic(&iter_sub_struct, 
												DBUS_TYPE_UINT32, 
												&(WTP[i]->wifi_extension_info.tx_multicast));
				
				dbus_message_iter_append_basic(&iter_sub_struct, 
												DBUS_TYPE_UINT32, 
												&(WTP[i]->wifi_extension_info.rx_multicast));
			}
			else{
				dbus_message_iter_append_basic(&iter_sub_struct, 
												DBUS_TYPE_UINT32, 
												&(defalt_zero));
				
				dbus_message_iter_append_basic(&iter_sub_struct, 
												DBUS_TYPE_UINT32, 
												&(defalt_zero));
			}
			dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);
		}
		dbus_message_iter_close_container (&iter_struct, &iter_sub_array);			
		dbus_message_iter_close_container (&iter_array, &iter_struct);
	}
				
	dbus_message_iter_close_container (&iter, &iter_array);
				
	CW_FREE_OBJECT_WID(WTP);
	CW_FREE_OBJECT_WID(AC_RADIO_FOR_SEARCH);
	CW_FREE_OBJECT_WID(mac);
	
	return reply;	
}
/*table 34 b19*//*useless command, xiaodawei, 20110421*/
DBusMessage * wid_dbus_interface_show_new_wtp_wireless_ifstats_information(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusMessageIter iter_sub_array;
	DBusMessageIter iter_struct;
	DBusMessageIter iter_sub_struct;
	DBusMessageIter iter_sub_sub_struct;
	DBusMessageIter iter_sub_sub_array;
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int wtp_num = 0;
	int i=0,j=0,k=0,ii=0; 
	unsigned char 	wtp_radiocount;
	unsigned int 	wtp_rx_packets;
	unsigned int	wtp_tx_packets;
	unsigned int	wtp_tx_errors;
	unsigned long long 	wtp_rx_bytes;
	unsigned long long	wtp_tx_bytes;
	unsigned int	wtp_ast_rx_crcerr;
	unsigned int	wtp_ast_rx_badcrypt;
	unsigned int	wtp_ast_rx_badmic;
	unsigned int	wtp_ast_rx_phyerr;

	unsigned long long rx_unicast;
	unsigned long long tx_unicast;
	unsigned long long rx_broadcast;
	unsigned long long tx_broadcast;
	
	unsigned char wtp_ath_updown_times;
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	unsigned char default_char_value = 0;
	unsigned int default_int_value = 0;
	
	WID_WTP **WTP;
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	WID_WTP_RADIO	**AC_RADIO_FOR_SEARCH;
	AC_RADIO_FOR_SEARCH = WID_MALLOC(G_RADIO_NUM*(sizeof(WID_WTP_RADIO *)));
	
	wtp_num = Wid_Find_Wtp(WTP);
	
	if(wtp_num == 0)
		ret = WTP_ID_NOT_EXIST;
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);

	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &wtp_num);

	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING			//mac 0
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING			//mac 5

											DBUS_TYPE_BYTE_AS_STRING			//wifi_info_switch
											DBUS_TYPE_BYTE_AS_STRING			//snr_max
											DBUS_TYPE_BYTE_AS_STRING			//snr_min
											DBUS_TYPE_BYTE_AS_STRING			//snr_average
											DBUS_TYPE_BYTE_AS_STRING			//snr_index

											DBUS_TYPE_UINT32_AS_STRING			//s1
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											
											DBUS_TYPE_UINT64_AS_STRING
											DBUS_TYPE_UINT64_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING			//s9

											DBUS_TYPE_UINT32_AS_STRING		//a1
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING		//a4
											
											//DBUS_TYPE_BYTE_AS_STRING		//extention information switch

											DBUS_TYPE_BYTE_AS_STRING		//wtp_radio_num
												DBUS_TYPE_ARRAY_AS_STRING
														DBUS_STRUCT_BEGIN_CHAR_AS_STRING
															DBUS_TYPE_BYTE_AS_STRING
															DBUS_TYPE_BYTE_AS_STRING
															DBUS_TYPE_UINT64_AS_STRING
															DBUS_TYPE_UINT64_AS_STRING
															DBUS_TYPE_UINT64_AS_STRING
															DBUS_TYPE_UINT64_AS_STRING
															DBUS_TYPE_UINT32_AS_STRING      //rx_data_pkts
															DBUS_TYPE_UINT32_AS_STRING      //tx_data_pkts

																DBUS_TYPE_UINT32_AS_STRING	   //bwlannum
																/*wlan infor 3*/
																DBUS_TYPE_ARRAY_AS_STRING
																	DBUS_STRUCT_BEGIN_CHAR_AS_STRING
																		DBUS_TYPE_BYTE_AS_STRING		//wlanid
																	DBUS_STRUCT_END_CHAR_AS_STRING
												DBUS_STRUCT_END_CHAR_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for(i = 0; i < wtp_num; i++){		
		wtp_rx_packets = 0;
		wtp_tx_packets = 0;
		wtp_tx_errors = 0;
		wtp_rx_bytes = 0;
		wtp_tx_bytes = 0;
		wtp_ast_rx_crcerr = 0;
		wtp_ast_rx_badcrypt = 0;
		wtp_ast_rx_badmic = 0;
		wtp_ast_rx_phyerr = 0;
		unsigned char num_of_radio = 0;
		wtp_radiocount = 0;
		
		memset(mac,0,MAC_LEN+1);
		if(WTP[i]->WTPMAC != NULL)
			memcpy(mac,WTP[i]->WTPMAC,MAC_LEN);
		dbus_message_iter_open_container (&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_UINT32,&(WTP[i]->WTPID));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[0]));
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[1]));
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[2]));
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[3]));
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[4]));
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[5]));

		dbus_message_iter_append_basic (&iter_struct,
											DBUS_TYPE_BYTE,
											&WTP[i]->wifi_extension_reportswitch); 

		if(WTP[i]->wifi_extension_reportswitch == 0){
			dbus_message_iter_append_basic (&iter_struct,
											DBUS_TYPE_BYTE,
											&default_char_value); 
			dbus_message_iter_append_basic (&iter_struct,
											DBUS_TYPE_BYTE,
											&default_char_value); 

			dbus_message_iter_append_basic (&iter_struct,
											DBUS_TYPE_BYTE,
											&default_char_value); 
			dbus_message_iter_append_basic (&iter_struct,
											DBUS_TYPE_BYTE,
											&default_char_value); 
		}

		else{
			dbus_message_iter_append_basic (&iter_struct,
											DBUS_TYPE_BYTE,
											&WTP[i]->wtp_wifi_snr_stats.snr_max); 
			dbus_message_iter_append_basic (&iter_struct,
											DBUS_TYPE_BYTE,
											&WTP[i]->wtp_wifi_snr_stats.snr_min); 

			dbus_message_iter_append_basic (&iter_struct,
											DBUS_TYPE_BYTE,
											&WTP[i]->wtp_wifi_snr_stats.snr_average); 
			dbus_message_iter_append_basic (&iter_struct,
											DBUS_TYPE_BYTE,
											&WTP[i]->wtp_wifi_snr_stats.ifindex); 
		}
			
		for(j=0; j<TOTAL_AP_IF_NUM; j++){
			if(WTP[i]->apstatsinfo[j].radioId < TOTAL_AP_IF_NUM+1)
			wtp_radiocount++;
		}
		
		for(j=0;j<wtp_radiocount;j++){
			if(WTP[i]->apstatsinfo[j].type == 2){
				wtp_rx_packets += WTP[i]->apstatsinfo[j].rx_pkt_data;//book modify, 2011-1-20
				wtp_tx_packets += WTP[i]->apstatsinfo[j].tx_pkt_data;//book modify, 2011-1-20
				wtp_tx_errors += WTP[i]->apstatsinfo[j].tx_errors;
				wtp_rx_bytes += WTP[i]->apstatsinfo[j].rx_bytes;
				wtp_tx_bytes += WTP[i]->apstatsinfo[j].tx_bytes;
				wtp_ast_rx_crcerr += WTP[i]->apstatsinfo[j].ast_rx_crcerr;
				wtp_ast_rx_badcrypt += WTP[i]->apstatsinfo[j].ast_rx_badcrypt;
				wtp_ast_rx_badmic += WTP[i]->apstatsinfo[j].ast_rx_badmic;
				wtp_ast_rx_phyerr += WTP[i]->apstatsinfo[j].ast_rx_phyerr;
			}
		}

		dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_UINT32,
									  &(wtp_rx_packets)); 	
		dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_UINT32,
									  &(wtp_tx_packets)); 	
		dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_UINT32,
									  &(wtp_tx_errors));
						
		dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_UINT64,
									  &(wtp_rx_bytes));
		dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_UINT64,
									  &(wtp_tx_bytes));	
		dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_UINT32,
									  &(wtp_ast_rx_crcerr));	
		
		dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_UINT32,
									  &(wtp_ast_rx_badcrypt));
		dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_UINT32,
									  &(wtp_ast_rx_badmic));	
		dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_UINT32,
									  &(wtp_ast_rx_phyerr));	

		if(WTP[i]->wifi_extension_reportswitch != 0){
			dbus_message_iter_append_basic(&iter_struct, 
											DBUS_TYPE_UINT32, 
											&(WTP[i]->wifi_extension_info.tx_mgmt));
			dbus_message_iter_append_basic(&iter_struct, 
											DBUS_TYPE_UINT32, 
											&(WTP[i]->wifi_extension_info.rx_mgmt));

			dbus_message_iter_append_basic(&iter_struct, 
											DBUS_TYPE_UINT32, 
											&(WTP[i]->wifi_extension_info.tx_errors));
			dbus_message_iter_append_basic(&iter_struct, 
											DBUS_TYPE_UINT32,
											&(WTP[i]->wifi_extension_info.tx_retry));
		}
		else{
			dbus_message_iter_append_basic(&iter_struct, 
											DBUS_TYPE_UINT32, 
											&(default_int_value));
			dbus_message_iter_append_basic(&iter_struct, 
											DBUS_TYPE_UINT32, 
											&(default_int_value));

			dbus_message_iter_append_basic(&iter_struct, 
											DBUS_TYPE_UINT32, 
											&(default_int_value));
			dbus_message_iter_append_basic(&iter_struct, 
											DBUS_TYPE_UINT32,
											&(default_int_value));
		}

		num_of_radio = WID_WTP_FIND_RADIO(AC_RADIO_FOR_SEARCH,WTP[i]);

		dbus_message_iter_append_basic(&iter_struct, 
												DBUS_TYPE_BYTE,
												&(num_of_radio));

		dbus_message_iter_open_container (&iter_struct,
											   DBUS_TYPE_ARRAY,
											  	 	DBUS_STRUCT_BEGIN_CHAR_AS_STRING
													   
													    DBUS_TYPE_BYTE_AS_STRING
														DBUS_TYPE_BYTE_AS_STRING

														DBUS_TYPE_UINT64_AS_STRING			//rx_unicast
														DBUS_TYPE_UINT64_AS_STRING			//tx_unicast
														DBUS_TYPE_UINT64_AS_STRING			//rx_broadcast
														DBUS_TYPE_UINT64_AS_STRING			//tx_broadcast
														DBUS_TYPE_UINT32_AS_STRING      //rx_data_pkts
														DBUS_TYPE_UINT32_AS_STRING      //tx_data_pkts

															DBUS_TYPE_UINT32_AS_STRING	   //bwlannum
															/*wlan infor 3*/
															DBUS_TYPE_ARRAY_AS_STRING
																DBUS_STRUCT_BEGIN_CHAR_AS_STRING
																	DBUS_TYPE_BYTE_AS_STRING		//wlanid
																DBUS_STRUCT_END_CHAR_AS_STRING
															
												DBUS_STRUCT_END_CHAR_AS_STRING,
											   &iter_sub_array);

		for(k = 0; k < num_of_radio; k++){
			wtp_ath_updown_times = 0;
			rx_unicast = 0;
			tx_unicast = 0;
			rx_broadcast = 0;
			tx_broadcast = 0;
			int bwlannum = 0;
			unsigned int rx_data_pkts = 0;   //fengwenchao add 20110617
			unsigned int tx_data_pkts = 0;    //fengwenchao add 20110617
			struct wlanid* sendwlanid =NULL;
			struct wlanid* pwlanid = AC_RADIO_FOR_SEARCH[k]->Wlan_Id;
			
			if(1 == WTP[i]->wifi_extension_reportswitch){
				wtp_ath_updown_times = WTP[i]->wifi_extension_info.ath_if_info[k].ath_updown_times;
			}
		
			dbus_message_iter_open_container (&iter_sub_array,
											   DBUS_TYPE_STRUCT,
											   NULL,
											   &iter_sub_struct);

			dbus_message_iter_append_basic	 (&iter_sub_struct,
											  DBUS_TYPE_BYTE,
											  &(AC_RADIO_FOR_SEARCH[k]->Radio_L_ID));
			dbus_message_iter_append_basic	 (&iter_sub_struct,
											  DBUS_TYPE_BYTE,
											  &(wtp_ath_updown_times));
			
			for(ii=0;ii<TOTAL_AP_IF_NUM;ii++){
				if(WTP[i]->apstatsinfo[ii].type == 0){
					rx_unicast += WTP[i]->apstatsinfo[ii].rx_unicast;
					tx_unicast += WTP[i]->apstatsinfo[ii].tx_unicast;
					rx_broadcast += WTP[i]->apstatsinfo[ii].rx_multicast;
					tx_broadcast += WTP[i]->apstatsinfo[ii].tx_multicast;
				}
				if((WTP[i]->apstatsinfo[ii].type == 0)&&(WTP[i]->apstatsinfo[ii].radioId == k))
				{
					rx_data_pkts = WTP[i]->apstatsinfo[ii].rx_pkt_data;
					tx_data_pkts = WTP[i]->apstatsinfo[ii].tx_pkt_data;
				}
			}
			
			dbus_message_iter_append_basic	 (&iter_sub_struct,
											  DBUS_TYPE_UINT64,
											  &(rx_unicast));
			dbus_message_iter_append_basic	 (&iter_sub_struct,
											  DBUS_TYPE_UINT64,
											  &(tx_unicast));
			
			dbus_message_iter_append_basic	 (&iter_sub_struct,
											  DBUS_TYPE_UINT64,
											  &(rx_broadcast));
			dbus_message_iter_append_basic	 (&iter_sub_struct,
											  DBUS_TYPE_UINT64,
											  &(tx_broadcast));

			dbus_message_iter_append_basic	 (&iter_sub_struct,
											  DBUS_TYPE_UINT32,
											  &(rx_data_pkts));

			dbus_message_iter_append_basic	 (&iter_sub_struct,
											  DBUS_TYPE_UINT32,
											  &(tx_data_pkts));
			
			while(pwlanid != NULL){
				bwlannum++;
				pwlanid = pwlanid->next;
			}
			
			dbus_message_iter_append_basic (&iter_sub_struct,
												 DBUS_TYPE_UINT32,
												 &bwlannum);

			dbus_message_iter_open_container (&iter_sub_struct,
										   		DBUS_TYPE_ARRAY,
														DBUS_STRUCT_BEGIN_CHAR_AS_STRING
															DBUS_TYPE_BYTE_AS_STRING		//wlanid
														DBUS_STRUCT_END_CHAR_AS_STRING,
										   &iter_sub_sub_array);

			for(ii = 0; ii < bwlannum; ii++){	
				unsigned char wlan_id;
				dbus_message_iter_open_container (&iter_sub_sub_array,
											   DBUS_TYPE_STRUCT,
											   NULL,
											   &iter_sub_sub_struct);
				if(sendwlanid == NULL)
					sendwlanid = AC_RADIO_FOR_SEARCH[k]->Wlan_Id;
				else{
					sendwlanid = sendwlanid ->next;
				}

				wlan_id = sendwlanid->wlanid;
				dbus_message_iter_append_basic (&iter_sub_sub_struct,
													 DBUS_TYPE_BYTE,
													 &(wlan_id));
				
				dbus_message_iter_close_container (&iter_sub_sub_array, &iter_sub_sub_struct);
			}
			dbus_message_iter_close_container (&iter_sub_struct, &iter_sub_sub_array);			
			dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);
		}
		dbus_message_iter_close_container (&iter_struct, &iter_sub_array);			
		dbus_message_iter_close_container (&iter_array, &iter_struct);
	}
	dbus_message_iter_close_container (&iter, &iter_array);
				
	CW_FREE_OBJECT_WID(WTP);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(AC_RADIO_FOR_SEARCH);
	
	return reply;	
}
/*table 29	dot11RogueAPTable b20*/
DBusMessage * wid_dbus_interface_show_all_rogue_ap_information(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusMessageIter iter_struct;
	DBusMessageIter	 iter_sub_array;
	DBusMessageIter iter_sub_struct;
	DBusMessageIter	 iter_sub_essid_array;
	DBusMessageIter iter_sub_essid_struct;
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	char *essid = NULL;
	int i = 0,j = 0,l;
	unsigned int wtp_num = 0;
	unsigned int rouge_wtp_num = 0;
	unsigned char *mac = NULL;
	WID_WTP **WTP;
	struct Neighbor_AP_ELE *phead = NULL;
	unsigned int  rouge_ap_count = 0;
	
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));

	if(gapscanset.opstate == 0){
		ret = WID_AP_SCANNING_DISABLE;
	}
	rouge_wtp_num = Wid_Find_ROUGE_Wtp(WTP,&wtp_num);
	
	if(wtp_num == 0)
		ret = WTP_ID_NOT_EXIST;
	else if(rouge_wtp_num == 0)
		ret = WTP_NO_NEIGHBORAP;
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &rouge_wtp_num);

	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING		 //mac 0
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING		//mac 5
											DBUS_TYPE_UINT32_AS_STRING		//rouge_ap_count
												DBUS_TYPE_ARRAY_AS_STRING
													DBUS_STRUCT_BEGIN_CHAR_AS_STRING
														DBUS_TYPE_BYTE_AS_STRING //mac	0
														DBUS_TYPE_BYTE_AS_STRING //mac
														DBUS_TYPE_BYTE_AS_STRING //mac
														DBUS_TYPE_BYTE_AS_STRING //mac
														DBUS_TYPE_BYTE_AS_STRING //mac
														DBUS_TYPE_BYTE_AS_STRING //mac	5
														
														DBUS_TYPE_UINT32_AS_STRING				//index
														DBUS_TYPE_UINT16_AS_STRING //rate			//a1
														DBUS_TYPE_BYTE_AS_STRING //channel
														
														DBUS_TYPE_BYTE_AS_STRING //rssi
														DBUS_TYPE_BYTE_AS_STRING //noise
														DBUS_TYPE_BYTE_AS_STRING //beacon interval	//a5
														
														DBUS_TYPE_UINT16_AS_STRING //capability		//a6
																DBUS_TYPE_ARRAY_AS_STRING
																DBUS_STRUCT_BEGIN_CHAR_AS_STRING

																DBUS_TYPE_BYTE_AS_STRING //essid
																DBUS_STRUCT_END_CHAR_AS_STRING
														DBUS_TYPE_STRING_AS_STRING //ie infor		//a8
													DBUS_STRUCT_END_CHAR_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for(i = 0; (i < rouge_wtp_num)&&(WTP[i])&&(WTP[i]->rouge_ap_infos); i++){
		memset(mac,0,MAC_LEN+1);
		if(WTP[i]->WTPMAC != NULL)
			memcpy(mac,WTP[i]->WTPMAC,MAC_LEN);
		dbus_message_iter_open_container (&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
		CWThreadMutexLock(&(gWTPs[i].RRMThreadMutex));

		rouge_ap_count = WTP[i]->rouge_ap_infos->neighborapInfosCount;
		phead = WTP[i]->rouge_ap_infos->neighborapInfos;
		
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_UINT32,
										&(WTP[i]->WTPID));
			
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,
										&(mac[0]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,
										&(mac[1]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,
										&(mac[2]));
		
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,
										&(mac[3]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,
										&(mac[4]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,
										&(mac[5]));

		dbus_message_iter_append_basic (&iter_struct,
										 DBUS_TYPE_UINT32,
										 &rouge_ap_count);

		dbus_message_iter_open_container (&iter_struct,
											   		DBUS_TYPE_ARRAY,
															DBUS_STRUCT_BEGIN_CHAR_AS_STRING
																DBUS_TYPE_BYTE_AS_STRING //mac	0
																DBUS_TYPE_BYTE_AS_STRING //mac
																DBUS_TYPE_BYTE_AS_STRING //mac
																DBUS_TYPE_BYTE_AS_STRING //mac
																DBUS_TYPE_BYTE_AS_STRING //mac
																DBUS_TYPE_BYTE_AS_STRING //mac	5
																
																DBUS_TYPE_UINT16_AS_STRING				//index
																DBUS_TYPE_UINT16_AS_STRING //rate			//a1
																DBUS_TYPE_BYTE_AS_STRING //channel		
																
																DBUS_TYPE_BYTE_AS_STRING //rssi
																DBUS_TYPE_BYTE_AS_STRING //noise
																DBUS_TYPE_BYTE_AS_STRING //beacon interval	//a5
																
																DBUS_TYPE_UINT16_AS_STRING //capability		//a6
																DBUS_TYPE_ARRAY_AS_STRING
																DBUS_STRUCT_BEGIN_CHAR_AS_STRING
																DBUS_TYPE_BYTE_AS_STRING //essid
																DBUS_STRUCT_END_CHAR_AS_STRING		

																DBUS_TYPE_STRING_AS_STRING //ie infor		//a8
															DBUS_STRUCT_END_CHAR_AS_STRING,
											   &iter_sub_array);

		for(j = 0; (j < rouge_ap_count)&&(phead!=NULL); j++){		
			dbus_message_iter_open_container (&iter_sub_array,
										   DBUS_TYPE_STRUCT,
										   NULL,
										   &iter_sub_struct);

			dbus_message_iter_append_basic(&iter_sub_struct,
											  DBUS_TYPE_BYTE,
											  &(phead->BSSID[0]));
			dbus_message_iter_append_basic(&iter_sub_struct,
											  DBUS_TYPE_BYTE,
											  &(phead->BSSID[1]));
			dbus_message_iter_append_basic(&iter_sub_struct,
											  DBUS_TYPE_BYTE,
											  &(phead->BSSID[2]));
			
			dbus_message_iter_append_basic(&iter_sub_struct,
											  DBUS_TYPE_BYTE,
											  &(phead->BSSID[3]));
			dbus_message_iter_append_basic(&iter_sub_struct,
											  DBUS_TYPE_BYTE,
											  &(phead->BSSID[4]));
			dbus_message_iter_append_basic(&iter_sub_struct,
											  DBUS_TYPE_BYTE,
											  &(phead->BSSID[5]));

			dbus_message_iter_append_basic(&iter_sub_struct,
											  DBUS_TYPE_UINT32,
											  &j);										//a0
			dbus_message_iter_append_basic(&iter_sub_struct,
											  DBUS_TYPE_UINT16,
											  &(phead->Rate));							//a1
			dbus_message_iter_append_basic(&iter_sub_struct,
											  DBUS_TYPE_BYTE,
											  &(phead->Channel));
			
			dbus_message_iter_append_basic(&iter_sub_struct,
											  DBUS_TYPE_BYTE,
											  &(phead->RSSI));
			dbus_message_iter_append_basic(&iter_sub_struct,
											  DBUS_TYPE_BYTE,
											  &(phead->NOISE));
			dbus_message_iter_append_basic(&iter_sub_struct,
											  DBUS_TYPE_BYTE,
											  &(phead->BEACON_INT));					//a5
			
			dbus_message_iter_append_basic(&iter_sub_struct,
											  DBUS_TYPE_UINT16,
											  &(phead->capabilityinfo));

			if(phead->ESSID != NULL)
			{
				essid = (char*)WID_MALLOC(ESSID_DEFAULT_LEN+1);
				memset(essid,0,ESSID_DEFAULT_LEN+1);
				memcpy(essid,phead->ESSID,ESSID_DEFAULT_LEN);		
			}else{
				essid = (char*)WID_MALLOC(ESSID_DEFAULT_LEN);
				memset(essid,0,ESSID_DEFAULT_LEN);
				memcpy(essid," ",1);					
			}
			dbus_message_iter_open_container (&iter_sub_struct,
							   DBUS_TYPE_ARRAY,
							   DBUS_STRUCT_BEGIN_CHAR_AS_STRING  
								  DBUS_TYPE_BYTE_AS_STRING
							   DBUS_STRUCT_END_CHAR_AS_STRING, 
					   		&iter_sub_essid_array);
			for(l=0;l<ESSID_DEFAULT_LEN;l++)
			{
				dbus_message_iter_open_container (&iter_sub_essid_array,
													DBUS_TYPE_STRUCT,
													NULL,
												  &iter_sub_essid_struct);
				
				dbus_message_iter_append_basic(&iter_sub_essid_struct,
							  DBUS_TYPE_BYTE,
							  &essid[l]);
				dbus_message_iter_close_container (&iter_sub_essid_array ,&iter_sub_essid_struct);
			}
			dbus_message_iter_close_container (&iter_sub_struct, &iter_sub_essid_array);		
			dbus_message_iter_append_basic(&iter_sub_struct,
											  DBUS_TYPE_STRING,
											  &(phead->IEs_INFO));						//a8

			dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);
			CW_FREE_OBJECT_WID(essid);
			phead = phead->next;
		}
		dbus_message_iter_close_container (&iter_struct, &iter_sub_array);
		CWThreadMutexUnlock(&(gWTPs[i].RRMThreadMutex));
		dbus_message_iter_close_container (&iter_array, &iter_struct);
	}
	dbus_message_iter_close_container (&iter, &iter_array);

	CW_FREE_OBJECT_WID(WTP);
	CW_FREE_OBJECT_WID(mac);
	
	return reply;	
}

DBusMessage * wid_dbus_interface_set_hide_quit_wtp_infor_showwing(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	int hide_switch = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&hide_switch,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}


	if(hide_quit_wtp_in_showting == hide_switch){
		ret = SWITCH_HAS_ALREADY_SETTED;
	}
	else{
		hide_quit_wtp_in_showting = hide_switch;

	}
	reply = dbus_message_new_method_return(msg);
			
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	wid_syslog_debug_debug(WID_DBUS,"set wid  hide_quit_wtp_in_showting  %d\n",hide_switch);
	
	return reply;	

}

/* zhangshu append at 20100824 */
DBusMessage * set_wtp_trap_ignore_percent(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
    DBusMessage* reply; 
    DBusMessageIter  iter;
    DBusError err;
    dbus_error_init(&err);
    int ret = WID_DBUS_SUCCESS;
    unsigned int wtpid = 0;
    unsigned int trap_percent = 0;
    int i = 0;

    if (!(dbus_message_get_args ( msg, &err,
                                DBUS_TYPE_UINT32,&wtpid,
                                DBUS_TYPE_UINT32,&trap_percent,
                                DBUS_TYPE_INVALID))){

        printf("Unable to get input args\n");
                
        if (dbus_error_is_set(&err)) {
            printf("%s raised: %s",err.name,err.message);
            dbus_error_free(&err);
        }
        return NULL;
    }

    if(wtpid == 0){
		for(i = 0; i < WTP_NUM; i++){
			if(AC_WTP[i] != NULL){
				AC_WTP[i]->wid_trap.ignore_percent = trap_percent;	
			}
		}
	}else{
		if(wtpid < WTP_NUM && AC_WTP[wtpid] != NULL){
			AC_WTP[wtpid]->wid_trap.ignore_percent = trap_percent;
		}
	}
	
    reply = dbus_message_new_method_return(msg);
            
    dbus_message_iter_init_append(reply, &iter);
        
    dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
    
    wid_syslog_debug_debug(WID_DBUS,"set wtp trap ignore percent %d\n",trap_percent);
    
    return reply;   

}

DBusMessage * wid_dbus_interface_show_ac_access_wtplist(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	unsigned int num=0;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	int i=0;
	struct wtp_access_info * WTP = NULL;
	CWThreadMutexLock(&ACAccessWTP);
	num = AC_WTP_ACC->num;
	if(num == 0)
		ret = WTP_ID_NOT_EXIST;

	WTP = AC_WTP_ACC->wtp_list;
//	printf("list num %d\n",num);
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
		// Total slot count
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
		
	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for(i = 0; i < num; i++){			
		DBusMessageIter iter_struct;
//		printf("i %d\n",i);	
		//unsigned char *ip = &(WTP->ip);
		/*printf("%02X:%02X:%02X:%02X:%02X:%02X %d.%d.%d.%d %-12s %-10s %-10s %-7s\n",
					WTP->WTPMAC[0],WTP->WTPMAC[1],WTP->WTPMAC[2],WTP->WTPMAC[3],WTP->WTPMAC[4],WTP->WTPMAC[5],
					ip[0],ip[1],ip[2],ip[3],
					WTP->model,
					WTP->apcode,
					WTP->version,
					WTP->codever,
					WTP->ifname);
		printf("SN:%s\n",WTP->sn);
		*/
		dbus_message_iter_open_container (&iter_array,
										DBUS_TYPE_STRUCT,
										NULL,
										&iter_struct);
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_UINT32,
					  &(WTP->ip));
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WTP->WTPMAC[0]));

		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WTP->WTPMAC[1]));
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WTP->WTPMAC[2]));
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WTP->WTPMAC[3]));
		
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WTP->WTPMAC[4]));
		
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WTP->WTPMAC[5]));
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_STRING,
					  &(WTP->model));
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_STRING,
					  &(WTP->apcode));
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_STRING,
					  &(WTP->sn));

		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_STRING,
					  &(WTP->ifname));

		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_STRING,
					  &(WTP->version));
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_STRING,
					  &(WTP->codever));

		dbus_message_iter_close_container (&iter_array, &iter_struct);
		WTP = WTP->next;
	}
	dbus_message_iter_close_container (&iter, &iter_array);
	CWThreadMutexUnlock(&ACAccessWTP);			
	return reply;	
}

DBusMessage * wid_dbus_interface_clean_ac_access_wtplist(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	int ret = 0;
	CWThreadMutexLock(&ACAccessWTP);				
	del_all_ap(AC_WTP_ACC);	
	CWThreadMutexUnlock(&ACAccessWTP);			
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	return reply;
}
DBusMessage * wid_dbus_interface_old_ap_img(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	int stat;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&stat,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	img_now = stat;
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	return reply;

}
DBusMessage * wid_dbus_interface_show_old_ap_img(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
	int stat = img_now;

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &stat);
	return reply;
}

DBusMessage * wid_dbus_interface_show_wtplist_bymac(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	unsigned int num=0;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	int i=0;
	WID_WTP **WTP;
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	while(i<WTP_NUM){
		CWThreadMutexLock(&(gWTPs[i].WTPThreadMutex));//fengwenchao add 20121123 for AXSSZFI-1050	
		if(AC_WTP[i] != NULL)
		{
			WTP[num] = AC_WTP[i];
			num++;
		}
		CWThreadMutexUnlock(&(gWTPs[i].WTPThreadMutex));	
		i++;
	}
	if(num == 0)
		ret = WTP_ID_NOT_EXIST;

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);		

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
		// Total slot count
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
		
	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for(i = 0; i < num; i++){			
		DBusMessageIter iter_struct;
			
		dbus_message_iter_open_container (&iter_array,
										DBUS_TYPE_STRUCT,
										NULL,
										&iter_struct);
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_UINT32,
					  &(WTP[i]->WTPID));
		
		memset(mac,0,MAC_LEN+1);
		memcpy(mac,WTP[i]->WTPMAC,MAC_LEN);	
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[0]));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[1]));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[2]));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[3]));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[4]));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[5]));
		
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_STRING,
					  &(WTP[i]->WTPNAME));

		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_STRING,
					  &(WTP[i]->WTPModel));
		
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WTP[i]->RadioCount));
		
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_UINT32,
					  &(WTP[i]->WFR_Index));
		
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WTP[i]->WTPStat));
		
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WTP[i]->CTR_ID));
		
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WTP[i]->DAT_ID));
		
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WTP[i]->isused));

		dbus_message_iter_close_container (&iter_array, &iter_struct);


	}
				
	dbus_message_iter_close_container (&iter, &iter_array);
				
	WID_FREE(WTP);
	CW_FREE_OBJECT_WID(mac);
	return reply;	
}

/*xdw add for show ap network information of all wtp, 20101215*/
DBusMessage * wid_dbus_interface_show_all_wtp_network_info(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	unsigned int num=0;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	int i=0;
	WID_WTP **WTP;
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	while(i<WTP_NUM){
		CWThreadMutexLock(&(gWTPs[i].WTPThreadMutex));//fengwenchao add 20121123 for AXSSZFI-1050	
		if(AC_WTP[i] != NULL)
		{
			WTP[num] = AC_WTP[i];
			num++;
		}
		CWThreadMutexUnlock(&(gWTPs[i].WTPThreadMutex));
		i++;
	}
	if(num == 0){
		ret = WTP_ID_NOT_EXIST;
	}

	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);		

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);

	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING	//wtp id
											DBUS_TYPE_BYTE_AS_STRING	//mac 
											DBUS_TYPE_BYTE_AS_STRING	//mac 
											DBUS_TYPE_BYTE_AS_STRING	//mac 
											DBUS_TYPE_BYTE_AS_STRING	//mac 
											DBUS_TYPE_BYTE_AS_STRING	//mac 
											DBUS_TYPE_BYTE_AS_STRING	//mac 
											DBUS_TYPE_STRING_AS_STRING	//wtpip
											DBUS_TYPE_UINT32_AS_STRING	//mask
											DBUS_TYPE_UINT32_AS_STRING	//gateway
											DBUS_TYPE_UINT32_AS_STRING	//first dns
											DBUS_TYPE_UINT32_AS_STRING	//second dns
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for(i = 0; i < num; i++){			
		DBusMessageIter iter_struct;
			
		dbus_message_iter_open_container (&iter_array,
										DBUS_TYPE_STRUCT,
										NULL,
										&iter_struct);
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_UINT32,
					  &(WTP[i]->WTPID));
		
		memset(mac,0,MAC_LEN+1);
		memcpy(mac,WTP[i]->WTPMAC,MAC_LEN);	
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[0]));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[1]));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[2]));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[3]));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[4]));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[5]));

		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_STRING,
					  &(WTP[i]->WTPIP));
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_UINT32,
					  &(WTP[i]->ap_mask_new));

		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_UINT32,
					  &(WTP[i]->ap_gateway));

		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_UINT32,
					  &(WTP[i]->ap_dnsfirst));

		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_UINT32,
					  &(WTP[i]->ap_dnssecend));

		dbus_message_iter_close_container (&iter_array, &iter_struct);
	}			
	dbus_message_iter_close_container (&iter, &iter_array);
				
	WID_FREE(WTP);
	CW_FREE_OBJECT_WID(mac);
	return reply;	
}
DBusMessage * wid_dbus_interface_show_acversion(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;
	dbus_error_init(&err);
	
	int ret = WID_DBUS_SUCCESS;
	int num=0;
	int i=0;
	char *str_ap_model = NULL;
	char *str_oem_version = NULL;
	char *str_ap_version_path = NULL;
	CWThreadMutexLock(&(gAllThreadMutex));		
	
	CWConfigVersionInfo *pnode = gConfigVersionInfo;
	while(pnode != NULL)
	{
		//printf("dbus name:<%s> path:<%s> dbus\n",pnode->str_ap_version_name,pnode->str_ap_version_path);
		num++;
		pnode = pnode->next;
	}
	
	pnode = gConfigVersionInfo;
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);

	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
		
	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for(i = 0; i < num; i++){	

	
		DBusMessageIter iter_struct;
			
		dbus_message_iter_open_container (&iter_array,
										DBUS_TYPE_STRUCT,
										NULL,
										&iter_struct);

		if(pnode->str_ap_model != NULL)
		{
			str_ap_model = (char*)WID_MALLOC(strlen(pnode->str_ap_model)+1);
			memset(str_ap_model,0,strlen(pnode->str_ap_model)+1);
			memcpy(str_ap_model,pnode->str_ap_model,strlen(pnode->str_ap_model));		
		}else{
			str_ap_model = (char*)WID_MALLOC(2);
			memset(str_ap_model,0,2);
			memcpy(str_ap_model," ",1);					
		}

		CWConfigVersionInfo_new *pnode_new = gConfigVerInfo;
		while(pnode_new != NULL){
			if((pnode->str_ap_model != NULL)&&(strcmp(pnode->str_ap_model,pnode_new->str_ap_model) == 0)){
				if(pnode_new->code_info != NULL){
					//there is no oem_version info in apimg.xml,so here use str_oem_version to transport str_ap_version_name
					if(pnode_new->code_info->str_ap_version_name != NULL){
						char *vesionname = pnode_new->code_info->str_ap_version_name;
						str_oem_version = (char*)WID_MALLOC(strlen(vesionname)+1);
						memset(str_oem_version,0,strlen(vesionname)+1);
						memcpy(str_oem_version,vesionname,strlen(vesionname));
					}

					if(pnode_new->code_info->str_ap_version_path != NULL){
						char *vesionpath = pnode_new->code_info->str_ap_version_path;
						str_ap_version_path = (char*)WID_MALLOC(strlen(vesionpath)+1);
						memset(str_ap_version_path,0,strlen(vesionpath)+1);
						memcpy(str_ap_version_path,vesionpath,strlen(vesionpath));
					}
				}
				break;
			}
			pnode_new = pnode_new->next;
		}

		if(str_oem_version == NULL)
		{
			str_oem_version = (char*)WID_MALLOC(2);
			memset(str_oem_version,0,2);
			memcpy(str_oem_version," ",1);					
		}

		if(str_ap_version_path == NULL)
		{
			str_ap_version_path = (char*)WID_MALLOC(2);
			memset(str_ap_version_path,0,2);
			memcpy(str_ap_version_path," ",1);					
		}
		dbus_message_iter_append_basic
			(&iter_struct,
			  DBUS_TYPE_STRING,
			  &(str_ap_model));
		
		dbus_message_iter_append_basic
			(&iter_struct,
			  DBUS_TYPE_STRING,
			  &(str_oem_version));

		dbus_message_iter_append_basic
		(&iter_struct,
		  DBUS_TYPE_STRING,
		  &(str_ap_version_path));	
		
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(pnode->radio_num));	

		dbus_message_iter_append_basic
				(&iter_struct,
				  DBUS_TYPE_BYTE,
				  &(pnode->bss_num));	



		dbus_message_iter_close_container (&iter_array, &iter_struct);

		pnode = pnode->next;
		CW_FREE_OBJECT_WID(str_ap_model);
		CW_FREE_OBJECT_WID(str_oem_version);
		CW_FREE_OBJECT_WID(str_ap_version_path);
	}
				
	dbus_message_iter_close_container (&iter, &iter_array);
	CWThreadMutexUnlock(&(gAllThreadMutex));		
				
	
	return reply;	


}

DBusMessage * wid_dbus_interface_show_model_list(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;
	dbus_error_init(&err);
	
	int ret = WID_DBUS_SUCCESS;
	int num=0;
	int i=0;
	char *str_ap_model = NULL;
	char *str_ap_version_name = NULL;
	char *str_ap_version_path = NULL;
	CWThreadMutexLock(&(gAllThreadMutex));		
	
	CWConfigVersionInfo *pnode = gConfigVersionInfo;
	while(pnode != NULL)
	{
		//printf("dbus name:<%s> path:<%s> dbus\n",pnode->str_ap_version_name,pnode->str_ap_version_path);
		num++;
		pnode = pnode->next;
	}
	
		
	pnode = gConfigVersionInfo;
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);

	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
		
	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											//DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											//DBUS_TYPE_UINT32_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for(i = 0; i < num; i++){	

	
		DBusMessageIter iter_struct;
			
		dbus_message_iter_open_container (&iter_array,
										DBUS_TYPE_STRUCT,
										NULL,
										&iter_struct);

		if(pnode->str_ap_model != NULL)
		{
			str_ap_model = (char*)WID_MALLOC(strlen(pnode->str_ap_model)+1);
			memset(str_ap_model,0,strlen(pnode->str_ap_model)+1);
			memcpy(str_ap_model,pnode->str_ap_model,strlen(pnode->str_ap_model));		
		}else{
			str_ap_model = (char*)WID_MALLOC(2);
			memset(str_ap_model,0,2);
			memcpy(str_ap_model," ",1);					
		}

		CWConfigVersionInfo_new *pnode_new = gConfigVerInfo;
		while(pnode_new != NULL){
			if((pnode->str_ap_model != NULL)&&(strcmp(pnode->str_ap_model,pnode_new->str_ap_model) == 0)){
				if(pnode_new->code_info != NULL){
					if(pnode_new->code_info->str_ap_version_name != NULL){
						char *vesionname = pnode_new->code_info->str_ap_version_name;
						str_ap_version_name = (char*)WID_MALLOC(strlen(vesionname)+1);
						memset(str_ap_version_name,0,strlen(vesionname)+1);
						memcpy(str_ap_version_name,vesionname,strlen(vesionname));
					}

					if(pnode_new->code_info->str_ap_version_path != NULL){
						char *vesionpath = pnode_new->code_info->str_ap_version_path;
						str_ap_version_path = (char*)WID_MALLOC(strlen(vesionpath)+1);
						memset(str_ap_version_path,0,strlen(vesionpath)+1);
						memcpy(str_ap_version_path,vesionpath,strlen(vesionpath));
					}
				}
				break;
			}
			pnode_new = pnode_new->next;
		}
		
		if(str_ap_version_name == NULL)
		{
			str_ap_version_name = (char*)WID_MALLOC(2);
			memset(str_ap_version_name,0,2);
			memcpy(str_ap_version_name," ",1);					
		}

		if(str_ap_version_path == NULL)
		{
			str_ap_version_path = (char*)WID_MALLOC(2);
			memset(str_ap_version_path,0,2);
			memcpy(str_ap_version_path," ",1);					
		}	
		
		dbus_message_iter_append_basic
			(&iter_struct,
			  DBUS_TYPE_STRING,
			  &(str_ap_model));
        /*
		dbus_message_iter_append_basic
			(&iter_struct,
			  DBUS_TYPE_STRING,
			  &(str_ap_code));	
                */
		dbus_message_iter_append_basic
			(&iter_struct,
			  DBUS_TYPE_STRING,
			  &(str_ap_version_name));

		dbus_message_iter_append_basic
		(&iter_struct,
		  DBUS_TYPE_STRING,
		  &(str_ap_version_path));	
		
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(pnode->radio_num));	

		dbus_message_iter_append_basic
				(&iter_struct,
				  DBUS_TYPE_BYTE,
				  &(pnode->bss_num));	
/*
		dbus_message_iter_append_basic
				(&iter_struct,
				  DBUS_TYPE_UINT32,
				  &(pnode->apcodeflag));	*/
		dbus_message_iter_close_container (&iter_array, &iter_struct);

		pnode = pnode->next;
		
		CW_FREE_OBJECT_WID(str_ap_model);		
		CW_FREE_OBJECT_WID(str_ap_version_name);		
		CW_FREE_OBJECT_WID(str_ap_version_path);

	}
				
	dbus_message_iter_close_container (&iter, &iter_array);
	CWThreadMutexUnlock(&(gAllThreadMutex));		
				

	return reply;	


}

DBusMessage * wid_dbus_interface_show_model(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply = NULL;	
	DBusMessageIter	 iter;
	DBusMessageIter  iter_array;
	DBusMessageIter  iter_struct;
	DBusError err;
	
	int ret = WID_DBUS_SUCCESS;
	char *model;
	int i;
	char *str_ap_model = NULL;
	char *str_ap_version_name = NULL;
	char *str_ap_version_path = NULL;
	//char *str_ap_code = NULL;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_STRING,&model,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	//printf("model:%s\n",model);
	
	CWThreadMutexLock(&(gAllThreadMutex));		
	CWConfigVersionInfo *pnode = gConfigVersionInfo;
	CWConfigVersionInfo_new *pnode_new = gConfigVerInfo;

	while(pnode != NULL)
	{
		if(strcmp(pnode->str_ap_model,model) == 0)
		{
			break;
		}
		pnode = pnode->next;
	}	
	while(pnode_new != NULL)
	{
		if(strcmp(pnode_new->str_ap_model,model) == 0)
		{
			break;
		}
		pnode_new = pnode_new->next;
	}	

	if(pnode == NULL)
	{
		ret = MODEL_NO_EXIST;
	}
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	if(ret == WID_DBUS_SUCCESS)
	{

		if(pnode->str_ap_model != NULL)
		{
			str_ap_model = (char*)WID_MALLOC(strlen(pnode->str_ap_model)+1);
			memset(str_ap_model,0,strlen(pnode->str_ap_model)+1);
			memcpy(str_ap_model,pnode->str_ap_model,strlen(pnode->str_ap_model));		
		}else{
			str_ap_model = (char*)WID_MALLOC(2);
			memset(str_ap_model,0,2);
			memcpy(str_ap_model," ",1);					
		}		

		if((pnode_new != NULL)&&(pnode_new->code_info != NULL)&&(pnode_new->code_info->str_ap_version_name != NULL))
		{
			str_ap_version_name = (char*)WID_MALLOC(strlen(pnode_new->code_info->str_ap_version_name)+1);
			memset(str_ap_version_name,0,strlen(pnode_new->code_info->str_ap_version_name)+1);
			memcpy(str_ap_version_name,pnode_new->code_info->str_ap_version_name,strlen(pnode_new->code_info->str_ap_version_name));		
		}else{
			str_ap_version_name = (char*)WID_MALLOC(2);
			memset(str_ap_version_name,0,2);
			memcpy(str_ap_version_name," ",1);					
		}	

		if((pnode_new != NULL)&&(pnode_new->code_info != NULL)&&(pnode_new->code_info->str_ap_version_path != NULL))
		{
			str_ap_version_path = (char*)WID_MALLOC(strlen(pnode_new->code_info->str_ap_version_path)+1);
			memset(str_ap_version_path,0,strlen(pnode_new->code_info->str_ap_version_path)+1);
			memcpy(str_ap_version_path,pnode_new->code_info->str_ap_version_path,strlen(pnode_new->code_info->str_ap_version_path));		
		}else{
			str_ap_version_path = (char*)WID_MALLOC(2);
			memset(str_ap_version_path,0,2);
			memcpy(str_ap_version_path," ",1);					
		}	
/*
		if(pnode->str_ap_code != NULL)
		{
			str_ap_code = (char*)malloc(strlen(pnode->str_ap_code)+1);
			memset(str_ap_code,0,strlen(pnode->str_ap_code)+1);
			memcpy(str_ap_code,pnode->str_ap_code,strlen(pnode->str_ap_code));		
		}else{
			str_ap_code = (char*)malloc(2);
			memset(str_ap_code,0,2);
			memcpy(str_ap_code," ",1);				
		}			
		*/
		dbus_message_iter_append_basic
									(&iter,
									  DBUS_TYPE_STRING,
									  &(str_ap_model));			
				  

		dbus_message_iter_append_basic
									(&iter,
									  DBUS_TYPE_STRING,
									  &(str_ap_version_name));	
		
		dbus_message_iter_append_basic
									(&iter,
									  DBUS_TYPE_STRING,
									  &(str_ap_version_path));			
				  
/*
		dbus_message_iter_append_basic
									(&iter,
									  DBUS_TYPE_STRING,
									  &(str_ap_code));	
*/
		
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_BYTE,
											 &pnode->radio_num);	

		/*fengwenchao modify begin 20120502  for autelan-2917*/
		dbus_message_iter_open_container (&iter,
								DBUS_TYPE_ARRAY,
								DBUS_STRUCT_BEGIN_CHAR_AS_STRING
										DBUS_TYPE_BYTE_AS_STRING//radio_type
										DBUS_TYPE_BYTE_AS_STRING//radio_id
										DBUS_TYPE_BYTE_AS_STRING//txpower
										DBUS_TYPE_BYTE_AS_STRING//bss_count
								DBUS_STRUCT_END_CHAR_AS_STRING,
								&iter_array);
		
		for(i=0; i<pnode->radio_num;i++)
		{
			dbus_message_iter_open_container(&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
			
			dbus_message_iter_append_basic (&iter_struct,
								 DBUS_TYPE_BYTE,
								 &pnode->radio_info[i].radio_type);	
			dbus_message_iter_append_basic (&iter_struct,
								 DBUS_TYPE_BYTE,
								 &pnode->radio_info[i].radio_id);	
			
			dbus_message_iter_append_basic (&iter_struct,
								 DBUS_TYPE_BYTE,
								 &pnode->radio_info[i].txpower);				
			
			dbus_message_iter_append_basic (&iter_struct,
								 DBUS_TYPE_BYTE,
								 &pnode->radio_info[i].bss_count);	

			dbus_message_iter_close_container (&iter_array, &iter_struct);
		}
		
		dbus_message_iter_close_container (&iter, &iter_array);
		/*fengwenchao modify end*/
		CW_FREE_OBJECT_WID(str_ap_model);
		CW_FREE_OBJECT_WID(str_ap_version_name);
		CW_FREE_OBJECT_WID(str_ap_version_path);
		//CW_FREE_OBJECT(str_ap_code);
	}
	
	CWThreadMutexUnlock(&(gAllThreadMutex));		
	return reply;	


}
DBusMessage * wid_dbus_interface_set_model(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	
	int ret = WID_DBUS_SUCCESS;
	char *oldmodel;
	char *newmodel;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_STRING,&oldmodel,
								DBUS_TYPE_STRING,&newmodel,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	//printf("oldmodel:%s newmodel:%s\n",oldmodel,newmodel);
	
	CWThreadMutexLock(&(gAllThreadMutex));		
	CWConfigVersionInfo *pnode = gConfigVersionInfo;

	while(pnode != NULL)
	{
		if((strcmp(pnode->str_ap_model,newmodel) == 0))
		{
			if(strcmp(pnode->str_ap_model,oldmodel) == 0)
			{
			}
			else
			{
				ret = MODEL_NO_CONFIG;
				break;
			}

		}
		pnode = pnode->next;
	}

	if(ret != MODEL_NO_CONFIG)
	{
		pnode = gConfigVersionInfo;

		while(pnode != NULL)
		{
			if(strcmp(pnode->str_ap_model,oldmodel) == 0)
			{
				WID_FREE(pnode->str_ap_model);
				pnode->str_ap_model = NULL;

				pnode->str_ap_model= (char*)WID_MALLOC(strlen(newmodel)+1);
				memset(pnode->str_ap_model, 0, strlen(newmodel)+1);
				memcpy(pnode->str_ap_model, newmodel, strlen(newmodel));
				pnode->ismodelchanged = CW_TRUE;
				//printf("newmodel:%s\n",pnode->str_ap_model);
				
				break;
			}
			pnode = pnode->next;
		}	

		if(pnode == NULL)
		{
			ret = MODEL_NO_EXIST;
		}
	}
	
	CWThreadMutexUnlock(&(gAllThreadMutex));		
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	


}

DBusMessage * wid_dbus_interface_show_ap_echotimer(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);

	int ret = WID_DBUS_SUCCESS;
	int ehcotimer = 10;	
 
	ehcotimer = gEchoRequestTimer;
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret);

	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ehcotimer);
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&gCheckRequestTimer);
	return reply;	

}

DBusMessage * wid_dbus_interface_set_ap_cm_threshold(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	
	int ret = WID_DBUS_SUCCESS;
	unsigned int policy = 0;
	unsigned int value = 0;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_UINT32,&value,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	//printf("policy:%d value:%d\n",policy,value);	

	if(policy == 1)
	{
		g_ap_cpu_threshold = value;
	}
	else if(policy == 2)
	{
		g_ap_memuse_threshold = value;
	}
	else if(policy == 3)
	{
		g_ap_temp_threshold = value;
	}
	else
	{
		ret = WID_DBUS_ERROR;
	}
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_interface_set_ap_cm_threshold policy %d value %d",policy,value);
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	


}

DBusMessage * wid_dbus_interface_set_wtp_rogueap_rogue_terminal_cpu_mem_trap_threshold(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	
	int ret = WID_DBUS_SUCCESS;
	unsigned int policy = 0;
	unsigned int value = 0;
	unsigned int wtpid = 0;
	unsigned int i = 0;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_UINT32,&value,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	//printf("policy:%d value:%d\n",policy,value);	
	if(wtpid == 0){
		
		for(i=0;i<WTP_NUM;i++){
			if(AC_WTP[i] != NULL){
				if(policy == 1)
				{
					AC_WTP[i]->wtp_rogue_ap_threshold = value;
				}
				else if(policy == 2)
				{
					AC_WTP[i]->wtp_rogue_terminal_threshold = value;
				}
				else if(policy == 3)
				{
					AC_WTP[i]->wtp_cpu_use_threshold = value;
				}
				else if(policy == 4)
				{
					AC_WTP[i]->wtp_mem_use_threshold = value;
				
				}
			}
		}
	}
	else{

	if(policy == 1)
	{
		AC_WTP[wtpid]->wtp_rogue_ap_threshold = value;
	}
	else if(policy == 2)
	{
		AC_WTP[wtpid]->wtp_rogue_terminal_threshold = value;
	}
	else if(policy == 3)
	{
		AC_WTP[wtpid]->wtp_cpu_use_threshold = value;
	}
	else if(policy == 4)
	{
		AC_WTP[wtpid]->wtp_mem_use_threshold = value;

	}
	else
	{
		ret = WID_DBUS_ERROR;
	}
	}
	wid_syslog_debug_debug(WID_DEFAULT,"wid_dbus_interface_set_wtp_rogueap_rogue_terminal_cpu_mem_trap_threshold policy %d trap_threshold %d",policy,value);
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	


}

DBusMessage * wid_dbus_interface_set_wtp_trap_collect_time(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	unsigned int policy = 0;
	unsigned int value = 0;
	unsigned int wtpid = 0;
	//unsigned int i = 0;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_UINT32,&value,
								DBUS_TYPE_INVALID))){
		printf("Unable to get input args\n");
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(AC_WTP[wtpid] != NULL){
		AC_WTP[wtpid]->trap_collect_time = value;
	}
	wid_syslog_debug_debug(WID_DBUS,"set_wtp_trap_collect_time %d",value);
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append (reply, &iter);
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	
}
//fengwenchao add 20110221
DBusMessage *wid_dbus_interface_set_wid_rogue_danger_unsafe_attack_trap_state(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;

	int set_trap_type = 0;
	int wid_trap_state = 0 ;
	unsigned int wtpid = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&set_trap_type,
								DBUS_TYPE_UINT32,&wid_trap_state,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(set_trap_type == 1)
		{
			if(wid_trap_state)
				{
					AC_WTP[wtpid]->ap_rogue_threshold_flag = 1;
				}
			else
				{
					AC_WTP[wtpid]->ap_rogue_threshold_flag = 0;
				}
			wid_syslog_debug_debug(WID_DEFAULT,"set wid_dbus_trap_ap_rogue_threshold %s",(wid_trap_state==1)?"enable":"disable");
		}
	else if(set_trap_type == 2)
		{
			if(wid_trap_state)
				{
					AC_WTP[wtpid]->ac_discovery_danger_ap_flag = 1;
				}
			else
				{
					AC_WTP[wtpid]->ac_discovery_danger_ap_flag = 0;
				}	
			wid_syslog_debug_debug(WID_DEFAULT,"set wid_dbus_trap_wtp_ac_discovery_danger_ap %s",(wid_trap_state==1)?"enable":"disable");
		}
	else if(set_trap_type == 3)
		{
			if(wid_trap_state)
				{
					AC_WTP[wtpid]->find_wids_attack_flag = 1;
				}
			else
				{
					AC_WTP[wtpid]->find_wids_attack_flag = 0;
				}	
			wid_syslog_debug_debug(WID_DEFAULT,"set wid_dbus_trap_wtp_find_wids_attack %s",(wid_trap_state==1)?"enable":"disable");
		}
	else
		{
			ret = WID_DBUS_ERROR;
		}
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
}
//fengwenchao add end
#if _GROUP_POLICY

DBusMessage * wid_dbus_interface_set_wtp_trap_switch(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	
	int i =0;
	unsigned int ID = 0;
	unsigned int num = 0;
	unsigned int type = 0;
	unsigned int policy = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Wtp_List * wtp_head =NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	//printf("policy:%d value:%d\n",policy,value);	
if(type==0)
{
	if(policy == 1)
	{
		AC_WTP[ID]->wtp_trap_switch = 1;
	}
	else if(policy == 2)
	{
		AC_WTP[ID]->wtp_trap_switch = 0;
	}
	else
	{
		ret = WID_DBUS_ERROR;
	}
	wid_syslog_debug_debug(WID_DEFAULT,"wid_dbus_interface_set_wtp_trap_switch policy %s",(policy==1)?"enable":"disable");
}

else if (type == 1){
	printf("******** type == 1 *****\n");
 
	 if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
		tmp = WTP_GROUP[ID]->WTP_M;
		wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
		
		while(tmp){
			ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
			
			if(ret_check == WID_DBUS_SUCCESS){
 				if(policy ==1)
 					{
 						AC_WTP[tmp->WTPID]->wtp_trap_switch = 1;
						wid_syslog_debug_debug(WID_DEFAULT,"wid_dbus_interface_set_wtp_trap_switch policy %s",(policy==1)?"enable":"disable");
 					}
				else if(policy == 2)
					{
						AC_WTP[tmp->WTPID]->wtp_trap_switch = 0;
						wid_syslog_debug_debug(WID_DEFAULT,"wid_dbus_interface_set_wtp_trap_switch policy %s",(policy==1)?"enable":"disable");
					}
				else
					{
						ret2 = WID_DBUS_ERROR;
						wid_syslog_debug_debug(WID_DEFAULT,"NO, There is a error");
					}
				if(ret2 != WID_DBUS_SUCCESS){
					wtp_head[num].WtpId = tmp->WTPID;
					wtp_head[num].FailReason = ret2;
					num++;
				}
				tmp = tmp->next;
			}
		}
		ret = WID_DBUS_SUCCESS;
	}
	
	else{
		ret = GROUP_ID_NOT_EXIST;
	}
}
	
reply = dbus_message_new_method_return(msg);
					
dbus_message_iter_init_append (reply, &iter);	
dbus_message_iter_append_basic (&iter,
								DBUS_TYPE_UINT32,
								&ret); 

if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);

	for(i = 0; i < num; i++){
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &(wtp_head[i].WtpId ));
		
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_BYTE,
											 &(wtp_head[i].FailReason));
		
	}	

	if(wtp_head!=NULL){
	WID_FREE(wtp_head);
	wtp_head = NULL;	
	}
}



return reply;	
 

}

#else
DBusMessage * wid_dbus_interface_set_wtp_trap_switch(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	
	int ret = WID_DBUS_SUCCESS;
	unsigned int policy = 0;
	unsigned int wtpid = 0;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	//printf("policy:%d value:%d\n",policy,value);	

	if(policy == 1)
	{
		AC_WTP[wtpid]->wtp_trap_switch = 1;
	}
	else if(policy == 2)
	{
		AC_WTP[wtpid]->wtp_trap_switch = 0;
	}
	else
	{
		ret = WID_DBUS_ERROR;
	}
	wid_syslog_debug_debug(WID_DEFAULT,"wid_dbus_interface_set_wtp_trap_switch policy %s",(policy==1)?"enable":"disable");
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	


}
#endif
/*wcl add*/
#if _GROUP_POLICY

DBusMessage * wid_dbus_interface_set_wtp_seqnum_switch(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	
	int i =0;
	unsigned int ID = 0;
	unsigned int num = 0;
	unsigned int type = 0;
	unsigned int policy = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Wtp_List * wtp_head =NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	//printf("policy:%d value:%d\n",policy,value);	
if(type==0)
{
	if(policy == 1)
	{
		AC_WTP[ID]->wtp_seqnum_switch= 1;
	}
	else if(policy == 2)
	{
		AC_WTP[ID]->wtp_seqnum_switch= 0;
	}
	else
	{
		ret = WID_DBUS_ERROR;
	}
	wid_syslog_debug_debug(WID_DEFAULT,"wid_dbus_interface_set_wtp_seqnum_switch policy %s",(policy==1)?"enable":"disable");
}

else if (type == 1){
	printf("******** type == 1 *****\n");
 
	 if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
		tmp = WTP_GROUP[ID]->WTP_M;
		wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
		
		while(tmp){
			ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
			
			if(ret_check == WID_DBUS_SUCCESS){
 				if(policy ==1)
 					{
 						AC_WTP[tmp->WTPID]->wtp_seqnum_switch = 1;
						wid_syslog_debug_debug(WID_DEFAULT,"wid_dbus_interface_set_wtp_seqnum_switch policy %s",(policy==1)?"enable":"disable");
 					}
				else if(policy == 2)
					{
						AC_WTP[tmp->WTPID]->wtp_seqnum_switch = 0;
						wid_syslog_debug_debug(WID_DEFAULT,"wid_dbus_interface_set_wtp_seqnum_switch policy %s",(policy==1)?"enable":"disable");
					}
				else
					{
						ret2 = WID_DBUS_ERROR;
						wid_syslog_debug_debug(WID_DEFAULT,"NO, There is a error");
					}
				if(ret2 != WID_DBUS_SUCCESS){
					wtp_head[num].WtpId = tmp->WTPID;
					wtp_head[num].FailReason = ret2;
					num++;
				}
				tmp = tmp->next;
			}
		}
		ret = WID_DBUS_SUCCESS;
	}
	
	else{
		ret = GROUP_ID_NOT_EXIST;
	}
}
	
reply = dbus_message_new_method_return(msg);
					
dbus_message_iter_init_append (reply, &iter);	
dbus_message_iter_append_basic (&iter,
								DBUS_TYPE_UINT32,
								&ret); 

if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);

	for(i = 0; i < num; i++){
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &(wtp_head[i].WtpId ));
		
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_BYTE,
											 &(wtp_head[i].FailReason));
		
	}	

	if(wtp_head!=NULL){
	WID_FREE(wtp_head);
	wtp_head = NULL;	
	}
}



return reply;	
 

}

#else
DBusMessage * wid_dbus_interface_set_wtp_seqnum_switch(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	
	int ret = WID_DBUS_SUCCESS;
	unsigned int policy = 0;
	unsigned int wtpid = 0;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	//printf("policy:%d value:%d\n",policy,value);	

	if(policy == 1)
	{
		AC_WTP[wtpid]->wtp_seqnum_switch = 1;
	}
	else if(policy == 2)
	{
		AC_WTP[wtpid]->wtp_seqnum_switch = 0;
	}
	else
	{
		ret = WID_DBUS_ERROR;
	}
	wid_syslog_debug_debug(WID_DEFAULT,"wid_dbus_interface_set_wtp_seqnum_switch policy %s",(policy==1)?"enable":"disable");
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	


}
#endif
/*end*/
DBusMessage * wid_dbus_interface_show_wtp_rogueap_terminal_cpu_mem_trap_threshold(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);

	int ret = WID_DBUS_SUCCESS;
	unsigned int i = 0;
	unsigned int flag = 0;
	unsigned int cpu = 0;	
 	unsigned int memoryuse = 0;
	unsigned int rogue_ap_threshold = 0;
	unsigned int rogue_terminal_threshold = 0;
	unsigned int wtpid = 0;
	unsigned int trap_switch = 99;
	unsigned int collecttime = 0;
    int samechannel_ap_rssi_threshold = 0;
	int neighborchannel_ap_rssi_threshold = 0;
	

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	CWThreadMutexLock(&(gWTPs[wtpid].WTPThreadMutex));//fengwenchao add 20121123 for AXSSZFI-1050
	ret = WID_CHECK_ID(WID_WTP_CHECK,wtpid);
	CWThreadMutexUnlock(&(gWTPs[wtpid].WTPThreadMutex));	
	
	if(wtpid == 0){
		
		for(i=0;i<WTP_NUM;i++){
			if(AC_WTP[i] != NULL){
				//printf("111111111111\n");
				trap_switch = AC_WTP[i]->wtp_trap_switch;
				rogue_ap_threshold = AC_WTP[i]->wtp_rogue_ap_threshold;
				rogue_terminal_threshold = AC_WTP[i]->wtp_rogue_terminal_threshold;
				cpu = AC_WTP[i]->wtp_cpu_use_threshold;
				memoryuse = AC_WTP[i]->wtp_mem_use_threshold;
				flag = 1;
				break;		
			}
		}
		if(flag != 1){
			//printf("22222222222222\n");
			trap_switch = 1;
			rogue_ap_threshold = 10;
			rogue_terminal_threshold = 1;
			cpu = 10;
			memoryuse = 30;
		}
	}
	else  if((ret == WID_DBUS_SUCCESS) &&(AC_WTP[wtpid] != NULL)){
		trap_switch = AC_WTP[wtpid]->wtp_trap_switch;
		rogue_ap_threshold = AC_WTP[wtpid]->wtp_rogue_ap_threshold;
		rogue_terminal_threshold = AC_WTP[wtpid]->wtp_rogue_terminal_threshold;
		cpu = AC_WTP[wtpid]->wtp_cpu_use_threshold;
		memoryuse = AC_WTP[wtpid]->wtp_mem_use_threshold;
		collecttime = AC_WTP[wtpid]->trap_collect_time;
		samechannel_ap_rssi_threshold = AC_WTP[wtpid]->samechannelrssithold;
		neighborchannel_ap_rssi_threshold = AC_WTP[wtpid]->neighborchannelrssithold;
	}
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&trap_switch);
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&rogue_ap_threshold);
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&rogue_terminal_threshold);
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&cpu);
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&memoryuse);
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&collecttime);
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&samechannel_ap_rssi_threshold);
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&neighborchannel_ap_rssi_threshold);

	return reply;	

}
DBusMessage * wid_dbus_interface_show_ap_cm_threshold(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);

	int ret = WID_DBUS_SUCCESS;
	unsigned int cpu = 0;	
 	unsigned int memoryuse = 0;
	unsigned int temperatue = 0;
	
	cpu = g_ap_cpu_threshold;
	memoryuse = g_ap_memuse_threshold;
	temperatue = g_ap_temp_threshold;
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);

	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&cpu);

	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&memoryuse);

	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&temperatue);
	return reply;	

}

DBusMessage * wid_dbus_interface_show_wtp_model_code_version(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 
	DBusMessageIter  iter;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	unsigned int wtpid = 0;
	char *no_info = "none";
	
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	CWThreadMutexLock(&(gWTPs[wtpid].WTPThreadMutex));//fengwenchao add 20121123 for AXSSZFI-1050
	ret = WID_CHECK_ID(WID_WTP_CHECK,wtpid);
	CWThreadMutexUnlock(&(gWTPs[wtpid].WTPThreadMutex));	
	
	if(AC_WTP[wtpid] ==  NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if(ret == WID_DBUS_SUCCESS)
	{	
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_STRING,&(AC_WTP[wtpid]->WTPModel));

		if(AC_WTP[wtpid]->APCode == NULL)
		{
			dbus_message_iter_append_basic (&iter,DBUS_TYPE_STRING,&(no_info));
		}
		else
		{
			dbus_message_iter_append_basic (&iter,DBUS_TYPE_STRING,&(AC_WTP[wtpid]->APCode));
		}
		
		if(AC_WTP[wtpid]->ver == NULL)
		{
			dbus_message_iter_append_basic (&iter,DBUS_TYPE_STRING,&(no_info));
		}
		else
		{
			dbus_message_iter_append_basic (&iter,DBUS_TYPE_STRING,&(AC_WTP[wtpid]->ver));
		}
		
		if(AC_WTP[wtpid]->codever == NULL)
		{
			dbus_message_iter_append_basic (&iter,DBUS_TYPE_STRING,&(no_info));
		}
		else
		{
			dbus_message_iter_append_basic (&iter,DBUS_TYPE_STRING,&(AC_WTP[wtpid]->codever));
		}
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&img_now);
		
	}			

	return reply;	
}

#if _GROUP_POLICY

DBusMessage * wid_dbus_interface_update_wtp_img_version(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;	
	int i =0;
	unsigned int ID = 0;
	unsigned int num = 0;
	unsigned int type = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Wtp_List * wtp_head =NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;

	char *vs,*pt;
	unsigned char commandmode;

	dbus_error_init(&err);


	if (!(dbus_message_get_args ( msg, &err,
				DBUS_TYPE_UINT32,&ID,
				DBUS_TYPE_STRING,&vs,
				DBUS_TYPE_STRING,&pt,
				DBUS_TYPE_BYTE,&commandmode,
				DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}

if(type==0)
{
	
	if(AC_WTP[ID]->updateversion != NULL)
	{
		WID_FREE(AC_WTP[ID]->updateversion);
		AC_WTP[ID]->updateversion = NULL;
	}
	
	if(AC_WTP[ID]->updatepath != NULL)
	{
		WID_FREE(AC_WTP[ID]->updatepath);
		AC_WTP[ID]->updatepath = NULL;
	}
	
	AC_WTP[ID]->updateversion = (char*)WID_MALLOC(strlen(vs)+1);
	memset(AC_WTP[ID]->updateversion, 0, strlen(vs)+1);
	memcpy(AC_WTP[ID]->updateversion, vs, strlen(vs));

	AC_WTP[ID]->updatepath = (char*)WID_MALLOC(strlen(pt)+1);
	memset(AC_WTP[ID]->updatepath, 0, strlen(pt)+1);
	memcpy(AC_WTP[ID]->updatepath, pt, strlen(pt));	


	if((AC_WTP[ID]->WTPStat == 5)&&(commandmode == 1))
	{
		wid_set_ap_reboot(ID);
	}
}

else if (type == 1){
	printf("******** type == 1 *****\n");
 
	 if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
		tmp = WTP_GROUP[ID]->WTP_M;
		wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
		
		while(tmp){
			ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
			
			if(ret_check == WID_DBUS_SUCCESS){
					
					if(AC_WTP[tmp->WTPID]->updateversion != NULL)
					{
						WID_FREE(AC_WTP[tmp->WTPID]->updateversion);
						AC_WTP[tmp->WTPID]->updateversion = NULL;
						wid_syslog_debug_debug(WID_DEFAULT,"wtp%d clear updateversion successful",tmp->WTPID);
					}
					
					if(AC_WTP[tmp->WTPID]->updatepath != NULL)
					{
						WID_FREE(AC_WTP[tmp->WTPID]->updatepath);
						AC_WTP[tmp->WTPID]->updatepath = NULL;
						wid_syslog_debug_debug(WID_DEFAULT,"wtp%d clear updatepath successful",tmp->WTPID);
					}
					
					AC_WTP[tmp->WTPID]->updateversion = (char*)WID_MALLOC(strlen(vs)+1);
					memset(AC_WTP[tmp->WTPID]->updateversion, 0, strlen(vs)+1);
					memcpy(AC_WTP[tmp->WTPID]->updateversion, vs, strlen(vs));
					
					AC_WTP[tmp->WTPID]->updatepath = (char*)WID_MALLOC(strlen(pt)+1);
					memset(AC_WTP[tmp->WTPID]->updatepath, 0, strlen(pt)+1);
					memcpy(AC_WTP[tmp->WTPID]->updatepath, pt, strlen(pt)); 
					
					
					if((AC_WTP[tmp->WTPID]->WTPStat == 5)&&(commandmode == 1))
					{
						wid_set_ap_reboot(tmp->WTPID);
					}
					//printf("11111111");
					if(ret2 != WID_DBUS_SUCCESS){
					wtp_head[num].WtpId = tmp->WTPID;
					wtp_head[num].FailReason = ret2;
					num++;
					}
				tmp = tmp->next;
			}
		}
		ret = WID_DBUS_SUCCESS;
	}
	
	else{
		ret = GROUP_ID_NOT_EXIST;
	}
}
	
reply = dbus_message_new_method_return(msg);
					
dbus_message_iter_init_append (reply, &iter);	
dbus_message_iter_append_basic (&iter,
								DBUS_TYPE_UINT32,
								&ret); 

if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);

	for(i = 0; i < num; i++){
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &(wtp_head[i].WtpId ));
		
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_BYTE,
											 &(wtp_head[i].FailReason));
		
	}	
	if(wtp_head!=NULL){
	WID_FREE(wtp_head);
	wtp_head = NULL;	
	}
}



return reply;	
 


}

#else
DBusMessage * wid_dbus_interface_update_wtp_img_version(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;	
	int ret = WID_DBUS_SUCCESS;

	unsigned int wtpid;
	char *vs,*pt;
	unsigned char commandmode;

	dbus_error_init(&err);


	if (!(dbus_message_get_args ( msg, &err,
				DBUS_TYPE_UINT32,&wtpid,
				DBUS_TYPE_STRING,&vs,
				DBUS_TYPE_STRING,&pt,
				DBUS_TYPE_BYTE,&commandmode,
				DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}

	//save parameter
	if(AC_WTP[wtpid]->updateversion != NULL)
	{
		WID_FREE(AC_WTP[wtpid]->updateversion);
		AC_WTP[wtpid]->updateversion = NULL;
	}
	
	if(AC_WTP[wtpid]->updatepath != NULL)
	{
		WID_FREE(AC_WTP[wtpid]->updatepath);
		AC_WTP[wtpid]->updatepath = NULL;
	}
	
	AC_WTP[wtpid]->updateversion = (char*)WID_MALLOC(strlen(vs)+1);
	memset(AC_WTP[wtpid]->updateversion, 0, strlen(vs)+1);
	memcpy(AC_WTP[wtpid]->updateversion, vs, strlen(vs));

	AC_WTP[wtpid]->updatepath = (char*)WID_MALLOC(strlen(pt)+1);
	memset(AC_WTP[wtpid]->updatepath, 0, strlen(pt)+1);
	memcpy(AC_WTP[wtpid]->updatepath, pt, strlen(pt));	


	if((AC_WTP[wtpid]->WTPStat == 5)&&(commandmode == 1))
	{
		wid_set_ap_reboot(wtpid);
	}

	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	return reply;	
}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_clear_update_wtp_img_version(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;	
	int i =0;
	unsigned int ID = 0;
	unsigned int num = 0;
	unsigned int type = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Wtp_List * wtp_head =NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;

	dbus_error_init(&err);


	if (!(dbus_message_get_args ( msg, &err,
				DBUS_TYPE_UINT32,&type,
				DBUS_TYPE_UINT32,&ID,
				DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}

if(type==0)
{
	if(AC_WTP[ID]->updateversion != NULL)
	{
		WID_FREE(AC_WTP[ID]->updateversion);
		AC_WTP[ID]->updateversion = NULL;
	}
	
	if(AC_WTP[ID]->updatepath != NULL)
	{
		WID_FREE(AC_WTP[ID]->updatepath);
		AC_WTP[ID]->updatepath = NULL;
	}
	
}

	else if (type == 1){
		printf("******** type == 1 *****\n");
	 
		 if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
			tmp = WTP_GROUP[ID]->WTP_M;
			wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
			
			while(tmp){
				ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
				
				if(ret_check == WID_DBUS_SUCCESS){
						
						if(AC_WTP[tmp->WTPID]->updateversion != NULL)
						{
							WID_FREE(AC_WTP[tmp->WTPID]->updateversion);
							AC_WTP[tmp->WTPID]->updateversion = NULL;
							wid_syslog_debug_debug(WID_DEFAULT,"wtp%d clear updateversion successful",tmp->WTPID);
						}
	
						if(AC_WTP[tmp->WTPID]->updatepath != NULL)
						{
							WID_FREE(AC_WTP[tmp->WTPID]->updatepath);
							AC_WTP[tmp->WTPID]->updatepath = NULL;
							wid_syslog_debug_debug(WID_DEFAULT,"wtp%d clear updatpath successful",tmp->WTPID);
						}
						if(ret2 != WID_DBUS_SUCCESS){
						wtp_head[num].WtpId = tmp->WTPID;
						wtp_head[num].FailReason = ret2;
						num++;
						}
					tmp = tmp->next;
				}
			}
			ret = WID_DBUS_SUCCESS;
		}
		
		else{
			ret = GROUP_ID_NOT_EXIST;
		}
	}
		
	reply = dbus_message_new_method_return(msg);
						
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 
	
	if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &num);
	
		for(i = 0; i < num; i++){
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_UINT32,
												 &(wtp_head[i].WtpId ));
			
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_BYTE,
												 &(wtp_head[i].FailReason));
			
		}
		if(wtp_head!=NULL){
		WID_FREE(wtp_head);
		wtp_head = NULL;	
		}
	}
	

	
	return reply;	
	 

}

#else
DBusMessage * wid_dbus_interface_clear_update_wtp_img_version(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;	
	int ret = WID_DBUS_SUCCESS;
	unsigned int wtpid;

	dbus_error_init(&err);


	if (!(dbus_message_get_args ( msg, &err,
				DBUS_TYPE_UINT32,&wtpid,
				DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}

	//save parameter
	if(AC_WTP[wtpid]->updateversion != NULL)
	{
		WID_FREE(AC_WTP[wtpid]->updateversion);
		AC_WTP[wtpid]->updateversion = NULL;
	}
	
	if(AC_WTP[wtpid]->updatepath != NULL)
	{
		WID_FREE(AC_WTP[wtpid]->updatepath);
		AC_WTP[wtpid]->updatepath = NULL;
	}
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	return reply;	
}

#endif
DBusMessage * wid_dbus_interface_update_wtp_img_version_list(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusMessageIter  iter1;
	DBusMessageIter  iter_array;
	DBusMessageIter iter_array_fail;	
	DBusError err;	
	int ret = WID_DBUS_SUCCESS;
	unsigned int i;
	unsigned int wtpid;
	char *vs,*pt;
	unsigned char commandmode;
	unsigned int num;
	/*fengwenchao add 20110516*/
	unsigned int success_num = 0;
	int fail_wtp[WTP_MAX_MAX_NUM] = {0};
	unsigned int fail_num = 0;
	/*fengwenchao add end*/
	dbus_error_init(&err);
	
	dbus_message_iter_init(msg,&iter);
	dbus_message_iter_get_basic(&iter,&vs);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&pt);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&commandmode);
	
	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&num);

	
	dbus_message_iter_next(&iter);	
	dbus_message_iter_recurse(&iter, &iter_array);

	for(i = 0; i < num; i++){		/* Huangleilei add it by AXSSZFI-1621: dbus may be not accept more than 255 elements, as string add to it */		
		DBusMessageIter iter_struct;
		dbus_message_iter_recurse(&iter_array, &iter_struct);
		dbus_message_iter_get_basic(&iter_struct, &wtpid);
		dbus_message_iter_next(&iter_array);
		//save parameter
		if((AC_WTP[wtpid] != NULL))
		{
			if(AC_WTP[wtpid]->updateversion != NULL){
				WID_FREE(AC_WTP[wtpid]->updateversion);
				AC_WTP[wtpid]->updateversion = NULL;
			}
			AC_WTP[wtpid]->updateversion = (char*)WID_MALLOC(strlen(vs)+1);
			memset(AC_WTP[wtpid]->updateversion, 0, strlen(vs)+1);
			memcpy(AC_WTP[wtpid]->updateversion, vs, strlen(vs));
			success_num++;    //fengwenchao add 20110516
		}
		/*fengwenchao add 20110516*/
		else
		{
			fail_wtp[fail_num] = wtpid;
			fail_num++;
		}
		/*fengwenchao add end*/
		if((AC_WTP[wtpid] != NULL))
		{
			if(AC_WTP[wtpid]->updatepath != NULL){
				WID_FREE(AC_WTP[wtpid]->updatepath);
				AC_WTP[wtpid]->updatepath = NULL;
			}
			AC_WTP[wtpid]->updatepath = (char*)WID_MALLOC(strlen(pt)+1);
			memset(AC_WTP[wtpid]->updatepath, 0, strlen(pt)+1);
			memcpy(AC_WTP[wtpid]->updatepath, pt, strlen(pt));	
		}

		if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPStat == 5)&&(commandmode == 1))
		{
			wid_set_ap_reboot(wtpid);
		}
	}

	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter1);
	if(success_num == 0)    //fengwenchao add 20110516
	{
		ret = WTP_ID_NOT_EXIST;
	}		
	dbus_message_iter_append_basic(&iter1, DBUS_TYPE_UINT32, &ret);
	dbus_message_iter_append_basic(&iter1, DBUS_TYPE_UINT32, &fail_num);  //fengwenchao add 20110516

	dbus_message_iter_open_container (&iter1,
							DBUS_TYPE_ARRAY,
							DBUS_STRUCT_BEGIN_CHAR_AS_STRING
									DBUS_TYPE_UINT32_AS_STRING
							DBUS_STRUCT_END_CHAR_AS_STRING,
							&iter_array_fail);
	/*fengwenchao add 20110516*/
	if(fail_num != 0)
	{
		for(i = 0; i < fail_num; i++){			
			DBusMessageIter iter_struct;		/* Huangleilei add it by AXSSZFI-1621: dbus may be not accept more than 255 elements, as string add to it */
			dbus_message_iter_open_container(&iter_array_fail, DBUS_TYPE_STRUCT, NULL, &iter_struct);
			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT32, &fail_wtp[i]);
			dbus_message_iter_close_container (&iter_array_fail, &iter_struct);
		}
	}	
	
	dbus_message_iter_close_container (&iter1, &iter_array_fail);
	/*fengwenchao add end*/
	return reply;	
}

DBusMessage * wid_dbus_interface_clear_update_wtp_img_version_list(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusMessageIter  iter1;
	DBusMessageIter iter_array;
	DBusError err;	
	int ret = WID_DBUS_SUCCESS;
	unsigned int i;
	unsigned int wtpid;
	unsigned int num;
	
	dbus_error_init(&err);
	
	dbus_message_iter_init(msg,&iter);
	dbus_message_iter_get_basic(&iter,&num);
	dbus_message_iter_next(&iter);	
	dbus_message_iter_recurse(&iter, &iter_array);
		
	for (i = 0; i < num; i++) 		/* Huangleilei add it by AXSSZFI-1621: dbus may be not accept more than 255 elements, as string add to it */
	{
		DBusMessageIter iter_struct;
		dbus_message_iter_recurse(&iter_array, &iter_struct);
		dbus_message_iter_get_basic(&iter_struct, &wtpid);
		
		//save parameter
		if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->updateversion != NULL))
		{
			WID_FREE(AC_WTP[wtpid]->updateversion);
			AC_WTP[wtpid]->updateversion = NULL;	
		}
		
		if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->updatepath != NULL))
		{
			WID_FREE(AC_WTP[wtpid]->updatepath);
			AC_WTP[wtpid]->updatepath = NULL;
		}
		dbus_message_iter_next(&iter_array);
	}
#if 0
	for(i = 0; i < num; i++){

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&wtpid);
		//save parameter
		if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->updateversion != NULL))
		{
			WID_FREE(AC_WTP[wtpid]->updateversion);
			AC_WTP[wtpid]->updateversion = NULL;	
		}
		
		if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->updatepath != NULL))
		{
			WID_FREE(AC_WTP[wtpid]->updatepath);
			AC_WTP[wtpid]->updatepath = NULL;
		}

	}
	#endif

	if(num == 0){
		for(i = 0; i < WTP_NUM; i++){
			if((AC_WTP[i] != NULL)&&(AC_WTP[i]->updateversion != NULL))
			{
				WID_FREE(AC_WTP[i]->updateversion);
				AC_WTP[i]->updateversion = NULL;	
			}
			
			if((AC_WTP[i] != NULL)&&(AC_WTP[i]->updatepath != NULL))
			{
				WID_FREE(AC_WTP[i]->updatepath);
				AC_WTP[i]->updatepath = NULL;
			}
		}
	}
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter1);
		
	dbus_message_iter_append_basic(&iter1, DBUS_TYPE_UINT32, &ret);

	return reply;	



}

DBusMessage * wid_dbus_interface_clear_update_fail_wtp_list(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusMessageIter  iter1;
	DBusMessageIter  iter_array;
	DBusError err;	
	int ret = WID_DBUS_SUCCESS;
	unsigned int i;
	unsigned int wtpid;
	unsigned int num;
	
	dbus_error_init(&err);
	
	dbus_message_iter_init(msg,&iter);
	dbus_message_iter_get_basic(&iter,&num);
	
	dbus_message_iter_next(&iter);	
	dbus_message_iter_recurse(&iter, &iter_array);
		
	for (i = 0; i < num; i++) 		/* Huangleilei add it for AXSSZFI-1621: dbus may be not accept more than 255 elements, as string add to it */
	{
		DBusMessageIter iter_struct;
		dbus_message_iter_recurse(&iter_array, &iter_struct);
		dbus_message_iter_get_basic(&iter_struct, &wtpid);
		if((AC_WTP[wtpid] != NULL) && (find_in_uptfail_wtp_list(wtpid) == CW_TRUE))
		{
			delete_uptfail_wtp_list(wtpid);
		}
		dbus_message_iter_next(&iter_array);
	}
	if(num == 0){
		destroy_uptfail_wtp_list();
	}
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter1);
		
	dbus_message_iter_append_basic(&iter1, DBUS_TYPE_UINT32, &ret);

	return reply;	



}
//fengwenchao add 20101223
DBusMessage *wid_dbus_interface_show_wtpconf_allwtp(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusMessageIter  iter_struct;
	DBusMessageIter	 iter_sub_array;	
	DBusMessageIter  iter_sub_struct;

//	unsigned int WTPID = 0;
	unsigned int wtp_num = 0;
	unsigned char bwlannum ;

	int ret = WID_DBUS_SUCCESS;
	//int i,j,k = 0;
	int i = 0;
	int j = 0;
//	int k = 0;
	char *name = NULL;
//	char *wlanname = NULL;

	unsigned char *mac = NULL;

	WID_WTP **WTP = NULL;
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP*)));//hjw change sizeof(WTP_WTP) sizeof(WTP_WTP*)
	struct wlanid *wlanidlist = NULL;
	unsigned char wlanlist[WLAN_NUM];//wlanlist has 16 elements,0 means not bind this wlan,1 means bind this wlan
	unsigned char wlanid =0;

	
	while(i<WTP_NUM){
		if(AC_WTP[i] != NULL)
		{
			WTP[wtp_num] = AC_WTP[i];
			wtp_num++;
		}
		i++;
	}
	if(wtp_num == 0)
		ret = WTP_ID_NOT_EXIST;	

	//printf("wtp_num = %d \n",wtp_num);

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);

	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&wtp_num);
		
	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING  //wtpid
											DBUS_TYPE_UINT32_AS_STRING    //wtp_triger_num
											DBUS_TYPE_UINT32_AS_STRING    //wtp_flow_triger
											DBUS_TYPE_UINT32_AS_STRING    //wtp_allowed_max_sta_num
											DBUS_TYPE_STRING_AS_STRING    //ifname
											DBUS_TYPE_BYTE_AS_STRING    //isused
											DBUS_TYPE_BYTE_AS_STRING    //bwlannum
								            DBUS_TYPE_BYTE_AS_STRING		 //mac1
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING		//mac 6			
											DBUS_TYPE_ARRAY_AS_STRING 
											DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											   DBUS_TYPE_BYTE_AS_STRING 	 //wlanid
											   DBUS_TYPE_STRING_AS_STRING	 //wlanname
											   DBUS_TYPE_UINT32_AS_STRING    //indorpPkts
											   DBUS_TYPE_UINT32_AS_STRING    //intotlePkts
											   DBUS_TYPE_UINT32_AS_STRING    //outdorpPkts
											   DBUS_TYPE_UINT32_AS_STRING    //outtotlePkts
											   DBUS_TYPE_UINT32_AS_STRING    //dwbankwith
											   DBUS_TYPE_UINT32_AS_STRING    //upbankwith			   
											DBUS_STRUCT_END_CHAR_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for(i=0;i<wtp_num;i++)
	{
		//WTPID = WTP[i]->WTPID;

		dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);

		dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_UINT32,&(WTP[i]->WTPID));
		
		//printf("WTP[i]->WTPID = %d \n",WTP[i]->WTPID);
		
		dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_UINT32,&(WTP[i]->wtp_triger_num));

		dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_UINT32,&(WTP[i]->wtp_flow_triger));

		dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_UINT32,&(WTP[i]->wtp_allowed_max_sta_num));

		name = (char*)WID_MALLOC(ETH_IF_NAME_LEN+1);
		memset(name,0,(ETH_IF_NAME_LEN+1));
		memcpy(name,WTP[i]->BindingIFName,ETH_IF_NAME_LEN);	

		dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_STRING,&(name));

		WID_FREE(name);
		name = NULL;
		dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->isused));

		memset(wlanlist,0,WLAN_NUM);
		
		for(j=0; j<(WTP[i]->RadioCount); j++)
		{
			if(WTP[i]->WTP_Radio[j] != NULL)
			{
				wlanidlist = WTP[i]->WTP_Radio[j]->Wlan_Id;
				while(wlanidlist != NULL)
				{
					wlanid = wlanidlist->wlanid;
					if(wlanlist[wlanid] == 1)
					{
					}
					else
					{
						wlanlist[wlanid] = 1;
					}
		
					wlanidlist = wlanidlist->next;
				}
			}
		}
		bwlannum= 0;
		for(j=0;j<WLAN_NUM;j++)
		{	//bwlannum = 0;
			if(wlanlist[j] == 1)
				bwlannum++;
		}
		dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&bwlannum);
		//printf("bwlannum = %d \n",bwlannum);

		mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
		memset(mac,0,MAC_LEN+1);
		if(WTP[i]->WTPMAC != NULL)
		memcpy(mac,WTP[i]->WTPMAC,MAC_LEN);

		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[0]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[1]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[2]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[3]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[4]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[5]));
		if(mac)
		{
			WID_FREE(mac);
			mac = NULL;
		}
		dbus_message_iter_open_container (&iter_struct,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING	  //wlanid
											DBUS_TYPE_STRING_AS_STRING	  //wlanname
											DBUS_TYPE_UINT32_AS_STRING    //indorpPkts
											DBUS_TYPE_UINT32_AS_STRING    //intotlePkts
											DBUS_TYPE_UINT32_AS_STRING    //outdorpPkts
											DBUS_TYPE_UINT32_AS_STRING    //outtotlePkts
											DBUS_TYPE_UINT32_AS_STRING    //dwbankwith
											DBUS_TYPE_UINT32_AS_STRING    //upbankwith
										DBUS_STRUCT_END_CHAR_AS_STRING,
										&iter_sub_array);

		for(j = 0; j < WLAN_NUM; j++)
		{	
			if(wlanlist[j] == 1)
			{

				dbus_message_iter_open_container (&iter_sub_array,DBUS_TYPE_STRUCT,NULL,&iter_sub_struct);
				wlanid = (unsigned char)j;
				dbus_message_iter_append_basic (&iter_sub_struct,DBUS_TYPE_BYTE,&wlanid);

				dbus_message_iter_append_basic (&iter_sub_struct,DBUS_TYPE_STRING,&(AC_WLAN[j]->WlanName));

				//printf("wlanid = %d \n",wlanid);
				//printf("wlanname = %s \n",wlanname);

				unsigned int mm = 0;
				unsigned int indorpPkts = 0;
				unsigned int intotlePkts = 0;
				unsigned int outdorpPkts = 0;
				unsigned int outtotlePkts = 0;
				unsigned int dwbankwith = 0;
				unsigned int upbankwith = 0;
				for(mm = 0; mm < TOTAL_AP_IF_NUM; mm++)
				{
				 	if((0 == WTP[i]->apstatsinfo[mm].type)&&(wlanid == WTP[i]->apstatsinfo[mm].wlanId))
				 	{
				 		indorpPkts += WTP[i]->apstatsinfo[mm].rx_drop;
						intotlePkts += WTP[i]->apstatsinfo[mm].rx_packets;
						outdorpPkts += WTP[i]->apstatsinfo[mm].tx_drop;
						outtotlePkts += WTP[i]->apstatsinfo[mm].tx_packets;
				 	}                          
				}
				for(mm = 0; mm < TOTAL_AP_IF_NUM; mm++)
				{
				 	if((0 == WTP[i]->apstatsinfo[mm].type)&&(wlanid == WTP[i]->apstatsinfo[mm].wlanId))
				 	{
				 		
						if(WTP[i]->apstatsinfo[mm].rx_rate > 1)
						{						
							upbankwith = ((int)((float)(WTP[i]->apstatsinfo[mm].rx_rate)/20))%100;
						}
						else
						{
							upbankwith = 0;
						}
						if( WTP[i]->apstatsinfo[mm].tx_rate > 1)
						{						
							dwbankwith = ((int)((float)(WTP[i]->apstatsinfo[mm].tx_rate)/15))%100;		
						}
						else
						{
							dwbankwith = 0;	
						}	

						break;
				 	}                            
				}
				dbus_message_iter_append_basic (&iter_sub_struct,DBUS_TYPE_UINT32,&indorpPkts);
				dbus_message_iter_append_basic (&iter_sub_struct,DBUS_TYPE_UINT32,&intotlePkts);
				dbus_message_iter_append_basic (&iter_sub_struct,DBUS_TYPE_UINT32,&outdorpPkts);
				dbus_message_iter_append_basic (&iter_sub_struct,DBUS_TYPE_UINT32,&outtotlePkts);
				dbus_message_iter_append_basic (&iter_sub_struct,DBUS_TYPE_UINT32,&dwbankwith);
				dbus_message_iter_append_basic (&iter_sub_struct,DBUS_TYPE_UINT32,&upbankwith);

				dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);
			}
		}
		dbus_message_iter_close_container (&iter_struct, &iter_sub_array);

		dbus_message_iter_close_container (&iter_array ,&iter_struct);
	}

	dbus_message_iter_close_container (&iter, &iter_array);
	if(WTP)
	{
		WID_FREE(WTP);
		WTP = NULL;
	}
	return reply;
}

//fengwenchao add end

DBusMessage * wid_dbus_interface_show_wtpconf(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
//	printf("wid_dbus_interface_show_wtpconf\n");
	DBusMessage * reply;
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	unsigned int WTPID, RID;
	unsigned char num;
	unsigned char bwlannum = 0;
	char *no_info = "none";
	int i;
	char *name;
	DBusError err;
	int ret=WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	int j = 0;
	char *wtp_location=NULL;
	unsigned char wlanid = 0;
	unsigned char wlanlist[WLAN_NUM];//wlanlist has 16 elements,0 means not bind this wlan,1 means bind this wlan
	struct wlanid *wlanidlist;
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&WTPID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(WTPID >= WTP_NUM)
		ret = WTP_ID_LARGE_THAN_MAX;
	else{
		if(AC_WTP[WTPID] == NULL)
		{
			ret = WTP_ID_NOT_EXIST;

			reply = dbus_message_new_method_return(msg);
			
			dbus_message_iter_init_append (reply, &iter);
			
			dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);

			return reply;	
		}
		//find radio binding wlan
		memset(wlanlist,0,WLAN_NUM);
		
		for(i=0; i<(AC_WTP[WTPID]->RadioCount); i++)
		{
			if(AC_WTP[WTPID]->WTP_Radio[i] != NULL)
			{
				wlanidlist = AC_WTP[WTPID]->WTP_Radio[i]->Wlan_Id;
				while(wlanidlist != NULL)
				{
					wlanid = wlanidlist->wlanid;
					if(wlanlist[wlanid] == 1)
					{
						//printf("wlan %d is already in the list\n",wlanid);
					}
					else
					{
						//printf("wlan %d is not in the list\n",wlanid);
						wlanlist[wlanid] = 1;
						//printf("wlanlist %d %d\n",wlanid,wlanlist[wlanid]);
					}

					wlanidlist = wlanidlist->next;
			  	}
			}
		}
	}
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	if(ret == 0){
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &(AC_WTP[WTPID]->wtp_triger_num));//xm add 08/12/05

		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &(AC_WTP[WTPID]->wtp_flow_triger));//xm add 08/12/05

		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &(AC_WTP[WTPID]->wtp_allowed_max_sta_num));//xm add 08/12/05
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &(AC_WTP[WTPID]->WTPID));

		dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &(AC_WTP[WTPID]->APGroupID));
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_STRING,
										 &(AC_WTP[WTPID]->WTPSN));
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_STRING,
										 &(AC_WTP[WTPID]->WTPNAME));
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_STRING,
										 &(AC_WTP[WTPID]->WTPModel));
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(AC_WTP[WTPID]->RadioCount));
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(AC_WTP[WTPID]->WTPStat));
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_STRING,
										 &(AC_WTP[WTPID]->WTPIP));
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &(AC_WTP[WTPID]->WFR_Index));
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(AC_WTP[WTPID]->WTPMAC[0]));
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(AC_WTP[WTPID]->WTPMAC[1]));
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(AC_WTP[WTPID]->WTPMAC[2]));
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(AC_WTP[WTPID]->WTPMAC[3]));
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(AC_WTP[WTPID]->WTPMAC[4]));
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(AC_WTP[WTPID]->WTPMAC[5]));
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(AC_WTP[WTPID]->CTR_ID));
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(AC_WTP[WTPID]->DAT_ID));
		if(AC_WTP[WTPID]->sysver == NULL){
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_STRING,
											 &(no_info));
		}else{
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_STRING,
											 &(AC_WTP[WTPID]->sysver));
		}
		
		if(AC_WTP[WTPID]->ver == NULL){
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_STRING,
											 &(no_info));
		}else{
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_STRING,
											 &(AC_WTP[WTPID]->ver));
		}

		if(AC_WTP[WTPID]->updatepath == NULL){
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_STRING,
											 &(no_info));
		}else{
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_STRING,
											 &(AC_WTP[WTPID]->updatepath));
		}
		if(AC_WTP[WTPID]->updateversion == NULL){
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_STRING,
											 &(no_info));
		}else{
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_STRING,
											 &(AC_WTP[WTPID]->updateversion));
		}
		
		name = (char*)WID_MALLOC(ETH_IF_NAME_LEN+1); //20080710
		memset(name,0,(ETH_IF_NAME_LEN+1));
		memcpy(name,AC_WTP[WTPID]->BindingIFName,ETH_IF_NAME_LEN);
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_STRING,
										 &(name));
		WID_FREE(name);
		name=NULL;
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(AC_WTP[WTPID]->isused));
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(AC_WTP[WTPID]->quitreason));
		
		for(j=0;j<WLAN_NUM;j++)
		{
			if(wlanlist[j] == 1)
			{
				bwlannum++;
			}
		}

		dbus_message_iter_append_basic (&iter,DBUS_TYPE_BYTE,&bwlannum);

		dbus_message_iter_open_container (&iter,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
										DBUS_STRUCT_END_CHAR_AS_STRING,
										&iter_array);

		for(i = 0; i < WLAN_NUM; i++)
		{	
			if(wlanlist[i] == 1)
			{
				DBusMessageIter iter_struct;

				dbus_message_iter_open_container (&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
				wlanid = (unsigned char)i;
				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&wlanid);
				//printf("send wlanid %d\n",wlanid);
				dbus_message_iter_close_container (&iter_array, &iter_struct);
			}
		}
		
		dbus_message_iter_close_container (&iter, &iter_array);

		/*
		//added by weiay 20080711
		struct wlanid* pwlanid = AC_WTP[WTPID]->WTP_Radio[0]->Wlan_Id;
		//struct wlanid* pwlanid = NULL;//zhanglei  change
		while(pwlanid != NULL){
			bwlannum++;
			pwlanid = pwlanid->next;
		}

		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_BYTE,
											 &bwlannum);
			
		dbus_message_iter_open_container (&iter,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
										DBUS_STRUCT_END_CHAR_AS_STRING,
										&iter_array);
		
		pwlanid = AC_WTP[WTPID]->WTP_Radio[0]->Wlan_Id;
		//pwlanid = NULL;
		
		for(i = 0; i < bwlannum; i++){			
			DBusMessageIter iter_struct;

			dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
		
			dbus_message_iter_append_basic (&iter_struct,
											 DBUS_TYPE_BYTE,
											 &(pwlanid->wlanid));
			pwlanid = pwlanid->next;
			dbus_message_iter_close_container (&iter_array, &iter_struct);
		}
		
		dbus_message_iter_close_container (&iter, &iter_array);
		//added end
*/
		num = AC_WTP[WTPID]->RadioCount;
		RID = AC_WTP[WTPID]->WFR_Index;
		// Total slot count
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &num);
		
		
		dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING											
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_UINT16_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);
		

		for(i = 0; i < num; i++,RID++){	
		
		
			DBusMessageIter iter_struct;
			
			dbus_message_iter_open_container (&iter_array,
										DBUS_TYPE_STRUCT,
										NULL,
										&iter_struct);
		
		
			dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(AC_RADIO[RID]->Radio_L_ID));
		
			
			dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_UINT32,
					  &(AC_RADIO[RID]->Radio_G_ID));
		
			
			dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_UINT32,
					  &(AC_RADIO[RID]->Radio_Type));
		
			
			dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(AC_RADIO[RID]->Radio_Chan));
		
			dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_UINT16,
					  &(AC_RADIO[RID]->Radio_TXP));
			
			dbus_message_iter_close_container (&iter_array, &iter_struct);

			

		}					
		dbus_message_iter_close_container (&iter, &iter_array);

		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT64,
										 &(AC_WTP[WTPID]->rx_bytes));
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT64,
										 &(AC_WTP[WTPID]->tx_bytes));
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &(AC_WTP[WTPID]->apstatisticsinterval));


		wtp_location = (char *)WID_MALLOC(strlen("Location not setted")+1);
		memset(wtp_location,0,strlen("Location not setted")+1);
		memcpy(wtp_location,"Location not setted",strlen("Location not setted"));
		if(AC_WTP[WTPID]->location == NULL)
		{
			dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_STRING,
										 &wtp_location); 
		}
		else
		{
			dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_STRING,
										 &(AC_WTP[WTPID]->location));
		}/*zhangcl addef for wtp location*/

		CW_FREE_OBJECT_WID(wtp_location);
		
	}	
	return reply;	
}

DBusMessage * wid_dbus_interface_show_wtpconf_bywlanid(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
		
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	unsigned int num=0;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	int i=0,j=0;

	int wlanid = 0;
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wlanid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}	

	ret = WID_CHECK_ID(WID_WLAN_CHECK,(unsigned int)wlanid);
	
	if(ret != WID_DBUS_SUCCESS){
		reply = dbus_message_new_method_return(msg);
					
		dbus_message_iter_init_append (reply, &iter);
				
		dbus_message_iter_append_basic (&iter,
											DBUS_TYPE_UINT32,
											&ret);
		return reply;	
	}
	else{
		WID_WTP **WTP = NULL;
		WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));	
		memset(WTP,0,WTP_NUM*(sizeof(WID_WTP *)));

		while(i<WTP_NUM){
			CWThreadMutexLock(&(gWTPs[i].WTPThreadMutex));//fengwenchao add 20121123 for AXSSZFI-1050	
			if((AC_WTP[i] != NULL)&&(AC_WTP[i]->isused == 1))
			{
				for(j=0; j<AC_WTP[i]->RadioCount; j++)
				{
					if((AC_WLAN[wlanid])&&(AC_WLAN[wlanid]->S_WTP_BSS_List[i][j] != 0))
					{
						WTP[num] = AC_WTP[i];
						num++;
					}

				}

			}
			CWThreadMutexUnlock(&(gWTPs[i].WTPThreadMutex));	
			i++;
		}
		if(num == 0)
			ret = WTP_ID_NOT_EXIST;
		
		reply = dbus_message_new_method_return(msg);
			
		dbus_message_iter_init_append (reply, &iter);
			
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
		
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&num);
			
		dbus_message_iter_open_container (&iter,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_UINT32_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_STRING_AS_STRING
												DBUS_TYPE_STRING_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
										DBUS_STRUCT_END_CHAR_AS_STRING,
										&iter_array);

		for(i = 0; i < num; i++){			
			DBusMessageIter iter_struct;
				
			dbus_message_iter_open_container(&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
			
			dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_UINT32,&(WTP[i]->WTPID));

			dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->WTPMAC[0]));
			
			dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->WTPMAC[1]));

			dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->WTPMAC[2]));

			dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->WTPMAC[3]));

			dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->WTPMAC[4]));

			dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->WTPMAC[5]));

			dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&(WTP[i]->WTPIP));
				
			dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&(WTP[i]->WTPModel));
			
			dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->WTPStat));
			
			dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(WTP[i]->isused));

			dbus_message_iter_close_container (&iter_array, &iter_struct);


		}
					
		dbus_message_iter_close_container (&iter, &iter_array);
					
		WID_FREE(WTP);
		WTP = NULL;
	}

	
	return reply;	
}


DBusMessage * wid_dbus_interface_show_wid_config(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
	int result = 0;
	int ret = WID_DBUS_SUCCESS;
	unsigned int total = WTP_NUM-1;

	if((gACHWVersion_char != NULL)&&(gACSWVersion_char != NULL))
	{
		result = 2;
	}

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter,
									DBUS_TYPE_UINT32,
									&ret);//000 ret
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gACHWVersion);//001 hw version
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gACSWVersion);//002 sw version
	unsigned char protocol = (gNetworkPreferredFamily == CW_IPv4);
	unsigned char security = (gACDescriptorSecurity == CW_X509_CERTIFICATE);
	
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_BYTE,
								  &security);//003 auth security type
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_BYTE,
								  &protocol);//004 lev3 protocol

	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_STRING,
								  &gACName);//005 ac name
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gLimit);//006 max station
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &total);//007 max wtp						
	dbus_message_iter_append_basic(&iter,
								DBUS_TYPE_UINT32,
								&gMaxWTPs
								);
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gStaticWTPs);//007 max wtp	

	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gCWForceMTU);//008 max mtu
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gEnabledLog);//009 log switch	
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gMaxLogFileSize);//010 log size	
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gWIDLOGLEVEL);//011 log level
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gtrapflag);
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_BYTE,
								  &apstatistics);
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_BYTE,
								  &gmacfilterflag);	
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_BYTE,
								  &gessidfilterflag);		
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &g_AC_ALL_EXTENTION_INFORMATION_SWITCH);
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &result);
	if(result == 2)
	{
		
		dbus_message_iter_append_basic(&iter,
									  DBUS_TYPE_STRING,
									  &gACHWVersion_char);
		
		dbus_message_iter_append_basic(&iter,
									  DBUS_TYPE_STRING,
									  &gACSWVersion_char);
		
	}
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &apstatisticsinterval);
	/*xiaodawei add, 20110115*/
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_BYTE,
								  &gapscanset.opstate);	//radio resource management
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &txpower_state);	//transmit power control
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_BYTE,
								  &control_scope);	//transmit power control scope
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_BYTE,
								  &(g_auto_ap_login.auto_ap_switch));	//set auto_ap_login switch
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_BYTE,
								  &(g_auto_ap_login.save_switch));	//set auto_ap_login save_config_switch
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_BYTE,
								  &(WID_SAMPLE_INFORMATION.monitor_switch));	//set wireless-control monitor
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_BYTE,
								  &(WID_SAMPLE_INFORMATION.sample_switch));		//set wireless-control sample
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_BYTE,
								  &WID_WATCH_DOG_OPEN);	//set wid watch dog
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_BYTE,
								  &(ac_flow_num_balance_flag.state));	//set ac balance method
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_BYTE,
								  &aphotreboot);	//set ap hotreboot
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &ApAccessNat);	//set ap access through nat
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_BYTE,
								  &gwidspolicy);	//set wtp wids policy
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_BYTE,
								  &(gapscanset.countermeasures_switch));	//set radio resource management countermeasures
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_BYTE,
								  &(gapscanset.countermeasures_mode));	//set radio resource management countermeasures mode
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &set_vmac_state);	//set wireless interface vmac
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_BYTE,
								  &wtp_link_detect);	//set wtp link detect
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &wsmswitch);	//set wsm switch
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &g_ap_auto_update_service_tftp);	//service tftp
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &g_service_ftp_state);	//service ftp
	/*xiaodawei add for trap switch, 20110115*/
		dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gtrap_ap_run_quit_trap_switch);
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gtrap_ap_cpu_trap_switch);
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gtrap_ap_mem_trap_switch);
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gtrap_flash_write_fail_trap_switch);				  
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gtrap_rrm_change_trap_switch);
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gtrap_rogue_ap_threshold_switch);
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gtrap_channel_terminal_interference_switch);
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gtrap_channel_device_interference_switch);
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gtrap_wireless_interface_down_switch);
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gtrap_channel_count_minor_switch);
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gtrap_channel_change_switch);
    dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gtrap_channel_device_ap_switch);
	/*wcl add*/
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gCOUNTRYCODE);
	/*end*/

	/*end of trap switch*/
	return reply;	

}

DBusMessage * wid_dbus_interface_set_wid_name(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
		
	int ret = WID_DBUS_SUCCESS;
	char *acname = NULL;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_STRING,&acname,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	//save parameter
	WID_FREE(gACName);
	gACName = NULL;
	
	CW_CREATE_STRING_ERR_WID(gACName,strlen(acname),return NULL;);
	strcpy(gACName,acname);
	wid_syslog_debug_debug(WID_DBUS,"set ac name is:%s\n",gACName);
	
	return reply;	

}
DBusMessage * wid_dbus_interface_set_wid_sw_version(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
		
	int ret = WID_DBUS_SUCCESS;
	char *swversion = NULL;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_STRING,&swversion,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	//save parameter
	WID_FREE(gACSWVersion_char);
	gACSWVersion_char = NULL;
	
	CW_CREATE_STRING_ERR_WID(gACSWVersion_char,strlen(swversion),return NULL;);
	strcpy(gACSWVersion_char,swversion);

	wid_syslog_debug_debug(WID_DBUS,"set ac sw version is:%s\n",gACSWVersion_char);
	
	return reply;	

}
DBusMessage * wid_dbus_interface_set_wid_hw_version(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
		
	int ret = WID_DBUS_SUCCESS;
	char *hwversion = NULL;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_STRING,&hwversion,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	//save parameter
	WID_FREE(gACHWVersion_char);
	gACHWVersion_char = NULL;
	
	CW_CREATE_STRING_ERR_WID(gACHWVersion_char,strlen(hwversion),return NULL;);
	strcpy(gACHWVersion_char,hwversion);

	wid_syslog_debug_debug(WID_DBUS,"set ac hw version is:%s\n",gACHWVersion_char);
	
	return reply;	

}
DBusMessage * wid_dbus_interface_set_wid_security_type(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
		
	int ret = WID_DBUS_SUCCESS;
	unsigned char securitytype = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&securitytype,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	//save parameter
	if(securitytype == CW_X509_CERTIFICATE)
	{
		gACDescriptorSecurity = CW_X509_CERTIFICATE;
	}
	else
	{
		gACDescriptorSecurity = CW_PRESHARED;
	}


	wid_syslog_debug_debug(WID_DBUS,"set ac security is:%d\n",gACDescriptorSecurity);
	
	return reply;	

}
DBusMessage * wid_dbus_interface_set_wid_lev3_protocol(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
		
	int ret = WID_DBUS_SUCCESS;
	unsigned char lev3protocol = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&lev3protocol,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	//save parameter
	if(lev3protocol == CW_IPv4)
	{
		gNetworkPreferredFamily = CW_IPv4;
	}
	else
	{
		gNetworkPreferredFamily = CW_IPv6;
	}


	wid_syslog_debug_debug(WID_DBUS,"set ac lev3 protocol is:%d\n",gNetworkPreferredFamily);
	
	return reply;	

}

DBusMessage * wid_dbus_interface_set_wid_max_wtp(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
		
	int ret = WID_DBUS_SUCCESS;
	int maxwtp = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&maxwtp,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	//save parameter
	if((maxwtp > gStaticWTPs)&&(maxwtp < WTP_NUM))
	{
		gMaxWTPs = maxwtp;
		wid_syslog_debug_debug(WID_DBUS,"set wireless-control max wtp is:%d\n",gMaxWTPs);
	}
	else
	{
		ret = WTP_LESS_THAN_STATIC_WTP;
	}
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	
	return reply;	

}
DBusMessage * wid_dbus_interface_set_wid_max_mtu(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
		
	int ret = WID_DBUS_SUCCESS;
	int maxmtu = 0;
	int i;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&maxmtu,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	//save parameter

	gCWForceMTU = maxmtu;

	for(i=0;i<WTP_NUM;i++)
	{
		if(gWTPs[i].isNotFree == CW_TRUE)
		{
			gWTPs[i].pathMTU = gCWForceMTU;
		}
	}

	wid_syslog_debug_debug(WID_DBUS,"set wireless-control mtu is:%d\n",gCWForceMTU);
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	
	return reply;	

}
DBusMessage * wid_dbus_interface_set_wid_log_switch(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
		
	int ret = WID_DBUS_SUCCESS;
	unsigned char logswitch = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&logswitch,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	//save parameter
	if(logswitch == 1)
	{
		gEnabledLog = 1;
	}
	else
	{
		gEnabledLog = 0;
	}


	wid_syslog_debug_debug(WID_DBUS,"set ac log switch is:%d\n",gEnabledLog);
	
	return reply;	


}
DBusMessage * wid_dbus_interface_set_wid_log_size(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
		
	int ret = WID_DBUS_SUCCESS;
	int logsize = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&logsize,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	//save parameter

	gMaxLogFileSize = logsize;

	wid_syslog_debug_debug(WID_DBUS,"set wid log size is:%d\n",gMaxLogFileSize);
	
	return reply;	

}
//sz20080917
DBusMessage * wid_dbus_interface_set_wid_syslog_debug_level(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
	char loglevel[ACDBUS_LOG_LEVEL_LEN];	
	int ret = WID_DBUS_SUCCESS;
	unsigned char widloglevel = 1;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&widloglevel,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	//save parameter
	if(widloglevel == WID_SYSLOG_DEBUG_NONE)
	{
		gWIDLogdebugLevel = WID_SYSLOG_DEBUG_NONE;
		strcpy(loglevel, "None");
	}
	else if(widloglevel == WID_SYSLOG_DEBUG_INFO)
	{
		gWIDLogdebugLevel = WID_SYSLOG_DEBUG_INFO;
		strcpy(loglevel, "Info");
	}
	else if(widloglevel == WID_SYSLOG_DEBUG_DEBUG)
	{
		gWIDLogdebugLevel = WID_SYSLOG_DEBUG_DEBUG;
		strcpy(loglevel, "Debug");
	}
	else if(widloglevel == WID_SYSLOG_DEBUG_ALL)
	{
		gWIDLogdebugLevel = WID_SYSLOG_DEBUG_ALL;
		strcpy(loglevel, "All");
	}

	
	wid_syslog_debug_debug(WID_DBUS,"set wid debug log level is:%d\n",gWIDLogdebugLevel);
	//wid_syslog_notice("wid log debug level is:%s\n",loglevel);
	return reply;	

}

DBusMessage * wid_dbus_interface_set_wid_daemonlog_level(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
	char loglevel[ACDBUS_LOG_LEVEL_LEN];	
	int ret = WID_DBUS_SUCCESS;
	unsigned int daemonlogtype = 0;
	unsigned int daemonloglevel = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&daemonlogtype,
								DBUS_TYPE_UINT32,&daemonloglevel,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	//save parameter

	
	if(daemonloglevel == WID_SYSLOG_DEBUG)
	{
		gWIDLOGLEVEL |= daemonlogtype;
		strcpy(loglevel, "open");
	}
	else if(daemonloglevel == WID_SYSLOG_DEFAULT)
	{
		gWIDLOGLEVEL &= ~daemonlogtype;
		strcpy(loglevel, "close");
	}

	
	wid_syslog_debug_debug(WID_DBUS,"set wid daemonlog debug %s\n",loglevel);
	//wid_syslog_notice("wid log debug level is:%s\n",loglevel);
	return reply;	

}
/* qiuchen add it for china mobile log system */
DBusMessage *wid_dbus_interface_set_log_statistics_interval(DBusConnection *conn, DBusMessage *msg, void *user_data)
	{
			DBusMessage* reply; 
			DBusMessageIter  iter;
			DBusError err;
			dbus_error_init(&err);
			int ret = WID_DBUS_SUCCESS;
			unsigned char type = 0;
			unsigned int interval = 0;
		
			if (!(dbus_message_get_args ( msg, &err,
										DBUS_TYPE_BYTE,&type,
										DBUS_TYPE_UINT32,&interval,
										DBUS_TYPE_INVALID))){
		
				wid_syslog_debug_debug(WID_DBUS,"Unable to get input args\n");
						
				if (dbus_error_is_set(&err)) {
					wid_syslog_debug_debug(WID_DBUS,"%s raised: %s",err.name,err.message);
					dbus_error_free(&err);
				}
				return NULL;
			}
			if(type == TUNNEL_STATISTICS)
				TUNNEL_STATISTICS_LOG_INTERVAL = interval;
			else if(type == RADIO_STATISTICS)
				RADIO_STATISTICS_LOG_INTERVAL = interval;
			else if(type == ALL_STATISTICS){
				TUNNEL_STATISTICS_LOG_INTERVAL = interval;
				RADIO_STATISTICS_LOG_INTERVAL = interval;
			}
			reply = dbus_message_new_method_return(msg);
				
			dbus_message_iter_init_append(reply, &iter);
				
			dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
		
			wid_syslog_debug_debug(WID_DBUS,"set log statistics interval type = %d interval = %d\n",TUNNEL_STATISTICS_LOG_INTERVAL);
			wid_syslog_debug_debug(WID_DBUS,"set log statistics interval type = %d interval = %d\n",RADIO_STATISTICS_LOG_INTERVAL);
			return reply;	
		
	}

//qiuchen add it for Henan Mobile 2013.02.21
DBusMessage *wid_dbus_interface_set_wid_log_hn_enable(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
		DBusMessage* reply; 
		DBusMessageIter  iter;
		DBusError err;
		dbus_error_init(&err);
		int ret = WID_DBUS_SUCCESS;
		unsigned char group = 0;
		unsigned char switchi = 0;
	
		if (!(dbus_message_get_args ( msg, &err,
									DBUS_TYPE_BYTE,&group,
									DBUS_TYPE_BYTE,&switchi,
									DBUS_TYPE_INVALID))){
	
			wid_syslog_debug_debug(WID_DBUS,"Unable to get input args\n");
					
			if (dbus_error_is_set(&err)) {
				wid_syslog_debug_debug(WID_DBUS,"%s raised: %s",err.name,err.message);
				dbus_error_free(&err);
			}
			return NULL;
		}
		if(switchi == 1)
			gWIDLOGHN |= group;
		else if(switchi == 0)
			gWIDLOGHN &= (~group);
		reply = dbus_message_new_method_return(msg);
			
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
		wid_syslog_debug_debug(WID_DBUS,"set wid log group %x\n",gWIDLOGHN);
		return reply;	
	
}
DBusMessage *wid_dbus_interface_set_ac_management_ip(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 
	DBusMessageIter  iter;
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	unsigned long man_ip = 0;	
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&man_ip,
								DBUS_TYPE_INVALID))){

		wid_syslog_debug_debug(WID_DBUS,"Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			wid_syslog_debug_debug(WID_DBUS,"%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	gWID_AC_MANAGEMENT_IP = man_ip;
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	wid_syslog_debug_debug(WID_DBUS,"set ac management ip addr %lu.%lu.%lu.%lu\n",((gWID_AC_MANAGEMENT_IP & 0xff000000) >> 24),((gWID_AC_MANAGEMENT_IP & 0xff0000) >> 16),	\
					((gWID_AC_MANAGEMENT_IP & 0xff00) >> 8),(gWID_AC_MANAGEMENT_IP & 0xff));
	return reply;	
	
}

DBusMessage * wid_dbus_interface_set_wid_trap_debug(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
//	char loglevel[ACDBUS_LOG_LEVEL_LEN];	
	int ret = WID_DBUS_SUCCESS;
	unsigned char trapflag = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&trapflag,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	//save parameter

	/*
	if(trapflag == 1)
	{
		gtrapflag = 1;
		strcpy(loglevel, "open");
	}
	else if(trapflag == 0)
	{
		gtrapflag = 0;
		strcpy(loglevel, "close");
	}
	*/

	gtrapflag=trapflag;
	wid_syslog_debug_debug(WID_DBUS,"set wid trap level %d\n",gtrapflag);

	return reply;	

}
DBusMessage * wid_dbus_interface_set_wid_trap_switch_able(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
	char loglevel[ACDBUS_LOG_LEVEL_LEN+ACDBUS_LOG_LEVEL_LEN+10];
	char logpolicy[ACDBUS_LOG_LEVEL_LEN];
	int ret = WID_DBUS_SUCCESS;
	int i = 0;
	unsigned int trap_switch = 0;
	unsigned int trap_policy = 0;
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&trap_switch,
								DBUS_TYPE_UINT32,&trap_policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if(trap_policy == 1){
		if(trap_switch == 1)
		{
			gtrap_ap_run_quit_trap_switch = 1;
			strcpy(loglevel, "gtrap_ap_run_quit_trap_switch");
		}
		else if(trap_switch == 2)
		{
			gtrap_ap_cpu_trap_switch = 1;
			for(i=0;i<WTP_NUM;i++){
				if(AC_WTP[i] != NULL){
					AC_WTP[i]->wtp_trap_switch = 1;
				}
			}
			strcpy(loglevel, "gtrap_ap_cpu_trap_switch");
		}
		else if(trap_switch == 3)
		{
			gtrap_ap_mem_trap_switch = 1;
			for(i=0;i<WTP_NUM;i++){
				if(AC_WTP[i] != NULL){
					AC_WTP[i]->wtp_trap_switch = 1;
				}
			}
			strcpy(loglevel, "gtrap_ap_mem_trap_switch");
		}
		else if(trap_switch == 4)
		{
			gtrap_flash_write_fail_trap_switch = 1;
			strcpy(loglevel, "gtrap_flash_write_fail_trap_switch");
		}
		else if(trap_switch == 5)
		{
			gtrap_rrm_change_trap_switch = 1;
			strcpy(loglevel, "gtrap_rrm_change_trap_switch");
		}
		else if(trap_switch == 6)
		{
			gtrap_rogue_ap_threshold_switch = 1;
			for(i=0;i<WTP_NUM;i++){
				if(AC_WTP[i] != NULL){
					AC_WTP[i]->wtp_trap_switch = 1;
				}
			}
			strcpy(loglevel, "gtrap_rogue_ap_threshold_switch");
		}
		else if(trap_switch == 7)
		{
			gtrap_channel_terminal_interference_switch = 1;
			for(i=0;i<WTP_NUM;i++){
				if(AC_WTP[i] != NULL){
					AC_WTP[i]->wtp_trap_switch = 1;
				}
			}
			strcpy(loglevel, "gtrap_channel_terminal_interference_switch");
		}
		else if(trap_switch == 8)
		{
			gtrap_channel_device_interference_switch = 1;
			strcpy(loglevel, "gtrap_channel_device_interference_switch");
		}
		else if(trap_switch == 9)
		{
			gtrap_wireless_interface_down_switch = 1;
			strcpy(loglevel, "gtrap_wireless_interface_down_switch");
		}
		else if(trap_switch == 10)
		{
			gtrap_channel_count_minor_switch = 1;
			strcpy(loglevel, "gtrap_channel_count_minor_switch");
		}
		else if(trap_switch == 11)
		{
			gtrap_channel_change_switch = 1;
			strcpy(loglevel, "gtrap_channel_change_switch");
		}
    /*zhaoruijia,translate  neighbor_channel_interference to 1.3,start*/
		else if(trap_switch == 12){
			gtrap_channel_device_ap_switch = 1;
			strcpy(loglevel, "gtrap_channel_device_ap_switch");
		}
    /*zhaoruijia,translate  neighbor_channel_interference to 1.3,end*/
		strcpy(logpolicy, "enable");
	}else if(trap_policy == 0){
		if(trap_switch == 1)
		{
			gtrap_ap_run_quit_trap_switch = 0;
			strcpy(loglevel, "gtrap_ap_run_quit_trap_switch");
		}
		else if(trap_switch == 2)
		{
			gtrap_ap_cpu_trap_switch = 0;
			for(i=0;i<WTP_NUM;i++){
				if(AC_WTP[i] != NULL){
					AC_WTP[i]->wtp_trap_switch = 1;
				}
			}
			strcpy(loglevel, "gtrap_ap_cpu_trap_switch");
		}
		else if(trap_switch == 3)
		{
			gtrap_ap_mem_trap_switch = 0;
			
			for(i=0;i<WTP_NUM;i++){
				if(AC_WTP[i] != NULL){
					AC_WTP[i]->wtp_trap_switch = 1;
				}
			}
			strcpy(loglevel, "gtrap_ap_mem_trap_switch");
		}
		else if(trap_switch == 4)
		{
			gtrap_flash_write_fail_trap_switch = 0;
			strcpy(loglevel, "gtrap_flash_write_fail_trap_switch");
		}
		else if(trap_switch == 5)
		{
			gtrap_rrm_change_trap_switch  = 0;
			strcpy(loglevel, "gtrap_rrm_change_trap_switch");
		}
		else if(trap_switch == 6)
		{
			gtrap_rogue_ap_threshold_switch = 0;
			
			for(i=0;i<WTP_NUM;i++){
				if(AC_WTP[i] != NULL){
					AC_WTP[i]->wtp_trap_switch = 1;
				}
			}
			strcpy(loglevel, "gtrap_rogue_ap_threshold_switch");
		}
		else if(trap_switch == 7)
		{
			gtrap_channel_terminal_interference_switch = 0;
			
			for(i=0;i<WTP_NUM;i++){
				if(AC_WTP[i] != NULL){
					AC_WTP[i]->wtp_trap_switch = 1;
				}
			}
			strcpy(loglevel, "gtrap_channel_terminal_interference_switch");
		}
		else if(trap_switch == 8)
		{
			gtrap_channel_device_interference_switch = 0;
			strcpy(loglevel, "gtrap_channel_device_interference_switch");
		}
		else if(trap_switch == 9)
		{
			gtrap_wireless_interface_down_switch = 0;
			strcpy(loglevel, "gtrap_wireless_interface_down_switch");
		}
		else if(trap_switch == 10)
		{
			gtrap_channel_count_minor_switch = 0;
			strcpy(loglevel, "gtrap_channel_count_minor_switch");
		}
		else if(trap_switch == 11)
		{
			gtrap_channel_change_switch = 0;
			strcpy(loglevel, "gtrap_channel_change_switch");
		}
		/*zhaoruijia,tranlate  neighbor_channel_interference to 1.3,start*/
		else if(trap_switch == 12){
			gtrap_channel_device_ap_switch = 0;
			strcpy(loglevel, "gtrap_channel_device_ap_switch");
		}
		/*zhaoruijia,tranlate  neighbor_channel_interference to 1.3,end*/
		strcpy(logpolicy, "disable");
	}


	wid_syslog_debug_debug(WID_DEFAULT,"set wid trap switch %s %s\n",loglevel,logpolicy);

	return reply;	

}
DBusMessage * wid_dbus_interface_show_wid_trap_switch_state(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;
	dbus_error_init(&err);
//	int result = 0;
	int ret = WID_DBUS_SUCCESS;

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter,
									DBUS_TYPE_UINT32,
									&ret);//000 ret
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gtrap_ap_run_quit_trap_switch);
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gtrap_ap_cpu_trap_switch);
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gtrap_ap_mem_trap_switch);
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gtrap_flash_write_fail_trap_switch);				  
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gtrap_rrm_change_trap_switch);

	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gtrap_rogue_ap_threshold_switch);
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gtrap_channel_terminal_interference_switch);
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gtrap_channel_device_interference_switch);
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gtrap_wireless_interface_down_switch);
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gtrap_channel_count_minor_switch);
	dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gtrap_channel_change_switch);
	/*zhaoruijia,tranlate  neighbor_channel_interference to 1.3,start*/
    dbus_message_iter_append_basic(&iter,
								  DBUS_TYPE_UINT32,
								  &gtrap_channel_device_ap_switch);
	
	return reply;	

}
DBusMessage * wid_dbus_interface_set_ap_scanning(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int policy = 0;
	int i = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}


	//printf("received policy:%d\n",policy);
	
	if(policy != gapscanset.opstate)
	{
		//printf("##001##\n");
		gapscanset.opstate = policy;
		gapscanset.flag = 1;

		if(gapscanset.reportinterval == 0)
		{
			gapscanset.reportinterval = ROGUE_AP_REPORT_INT;
		}


		ret = wid_set_ap_scanning(gapscanset);

		if(policy == 0)
		{		
			for(i=0; i<WTP_NUM; i++)
			{
				if((AC_WTP[i] != NULL)&&(AC_WTP[i]->WTPStat == 5))
				{
					CWThreadMutexLock(&(gWTPs[i].RRMThreadMutex));

					if((AC_WTP[i]->NeighborAPInfos) != NULL)
					{
						destroy_ap_info_list(&(AC_WTP[i]->NeighborAPInfos));
					}
					if((AC_WTP[i]->rouge_ap_infos) != NULL)
					{
						destroy_ap_info_list(&(AC_WTP[i]->rouge_ap_infos));
					}
					
					CWThreadMutexUnlock(&(gWTPs[i].RRMThreadMutex)); 

				}
			}
		}
	}


	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	
	
	wid_syslog_debug_debug(WID_DBUS,"set ap scanning %d successfully\n",policy);
	
	return reply;	

}

DBusMessage * wid_dbus_interface_set_wid_mac_whitelist_switch(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
		
	int ret = WID_DBUS_SUCCESS;
	unsigned char macfilterflag = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&macfilterflag,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	//save parameter
	gmacfilterflag = macfilterflag;



	wid_syslog_debug_debug(WID_DEFAULT,"set mac whitelist flag is:%d\n",gmacfilterflag);
	
	return reply;	

}

DBusMessage * wid_dbus_interface_set_wid_essid_whitelist_switch(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
		
	int ret = WID_DBUS_SUCCESS;
	unsigned char essidfilterflag = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&essidfilterflag,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	//save parameter
	gessidfilterflag = essidfilterflag;



	wid_syslog_debug_debug(WID_DEFAULT,"set wid essid whitelist flag is:%d\n",gessidfilterflag);
	
	return reply;	

}

DBusMessage * wid_dbus_interface_set_ap_scanning_report_interval(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int time = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&time,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}


	//printf("received time:%d",time);
	
	if(time != gapscanset.reportinterval)
	{

		gapscanset.reportinterval = (unsigned short)time;

		if(gapscanset.opstate == 1)
		{
			ret = wid_set_ap_scanning(gapscanset);
		}
	}	
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	
	
	wid_syslog_debug_debug(WID_DBUS,"set ap scanning report interval %d successfully\n",time);
	
	return reply;	

}
DBusMessage * wid_dbus_interface_set_ap_countermeasures(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int policy = 0;
	int i = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}


	//printf("received policy:%d\n",policy);
	
	gapscanset.countermeasures_switch = policy;
	countermeasurecount = 0;
	//fengwenchao add 20110325, AP
	int num = 0;
	if(policy == 0)
	{
		WID_WTP_RADIO **RADIO;	
		RADIO = WID_MALLOC(G_RADIO_NUM*(sizeof(WID_WTP_RADIO *)));
		while(i<WTP_NUM)
			{		
				if(AC_WTP[i] != NULL)
				{	
					int n=0;
					int m=0;
					int j=0;
					n = AC_WTP[i]->RadioCount;
					m = AC_WTP[i]->WFR_Index;
					for(j=0;j<n;j++)
					{
						RADIO[num] = AC_RADIO[m];
						m++;
						num++;
					}
				}
				i++;
			}
		if(num != 0)
		{
			for(i = 0;i<num;i++)
			{
				RADIO[i]->radio_countermeasures_flag = 0;
			}
		}
		CW_FREE_OBJECT_WID(RADIO);
	}
	//fengwenchao add end

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	
	
	wid_syslog_debug_debug(WID_DEFAULT,"set ap scanning %d successfully\n",policy);
	
	return reply;	

}

DBusMessage * wid_dbus_interface_set_ap_countermeasures_mode(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int policy = 0;
//	int i = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}


	//printf("received policy:%d\n",policy);
	gapscanset.countermeasures_mode = policy;

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	
	
	wid_syslog_debug_debug(WID_DEFAULT,"set ap scanning %d successfully\n",policy);
	
	return reply;	

}

DBusMessage * wid_dbus_interface_update_ap_scanning_info(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int state = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&state,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}


	//printf("received state:%d",state);
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	
	
	wid_syslog_debug_debug(WID_DBUS,"update ap scanning info successfully\n");
	
	return reply;	

}

DBusMessage * wid_dbus_interface_set_wireless_control_whitelist(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;

	WIDMACADDR macaddr;
	

	if (!(dbus_message_get_args ( msg, &err,
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[0],
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[1],
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[2],
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[3],
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[4],
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[5],
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	wid_add_mac_whitelist(macaddr.macaddr);

	//printf("mac :: %02X:%02X:%02X:%02X:%02X:%02X\n",macaddr.macaddr[0],macaddr.macaddr[1],macaddr.macaddr[2],macaddr.macaddr[3],macaddr.macaddr[4],macaddr.macaddr[5]);
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	
	
	wid_syslog_debug_debug(WID_DBUS,"set mac whitelist successfully\n");
	
	return reply;	

}


DBusMessage * wid_dbus_interface_change_wireless_control_whitelist(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;

	WIDMACADDR macaddr;
	WIDMACADDR macaddrdest;
	

	if (!(dbus_message_get_args ( msg, &err,
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[0],
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[1],
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[2],
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[3],
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[4],
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[5],
								 
								 DBUS_TYPE_BYTE,  &macaddrdest.macaddr[0],
								 DBUS_TYPE_BYTE,  &macaddrdest.macaddr[1],
								 DBUS_TYPE_BYTE,  &macaddrdest.macaddr[2],
								 DBUS_TYPE_BYTE,  &macaddrdest.macaddr[3],
								 DBUS_TYPE_BYTE,  &macaddrdest.macaddr[4],
								 DBUS_TYPE_BYTE,  &macaddrdest.macaddr[5],								 
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	ret = wid_change_mac_whitelist(macaddr.macaddr,macaddrdest.macaddr);

	//printf("mac :: %02X:%02X:%02X:%02X:%02X:%02X\n",macaddr.macaddr[0],macaddr.macaddr[1],macaddr.macaddr[2],macaddr.macaddr[3],macaddr.macaddr[4],macaddr.macaddr[5]);
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	
	
	wid_syslog_debug_debug(WID_DEFAULT,"change mac whitelist successfully\n");
	
	return reply;	

}

DBusMessage * wid_dbus_interface_change_wireless_control_blacklist(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;

	WIDMACADDR macaddr;
	WIDMACADDR macaddrdest;
	

	if (!(dbus_message_get_args ( msg, &err,
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[0],
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[1],
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[2],
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[3],
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[4],
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[5],
								 DBUS_TYPE_BYTE,  &macaddrdest.macaddr[0],
								 DBUS_TYPE_BYTE,  &macaddrdest.macaddr[1],
								 DBUS_TYPE_BYTE,  &macaddrdest.macaddr[2],
								 DBUS_TYPE_BYTE,  &macaddrdest.macaddr[3],
								 DBUS_TYPE_BYTE,  &macaddrdest.macaddr[4],
								 DBUS_TYPE_BYTE,  &macaddrdest.macaddr[5],								 
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	ret = wid_change_mac_blacklist(macaddr.macaddr,macaddrdest.macaddr);

	//printf("mac :: %02X:%02X:%02X:%02X:%02X:%02X\n",macaddr.macaddr[0],macaddr.macaddr[1],macaddr.macaddr[2],macaddr.macaddr[3],macaddr.macaddr[4],macaddr.macaddr[5]);
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	
	
	wid_syslog_debug_debug(WID_DEFAULT,"change mac whitelist successfully\n");
	
	return reply;	

}


DBusMessage * wid_dbus_interface_set_wireless_control_blacklist(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	WIDMACADDR macaddr;

	if (!(dbus_message_get_args ( msg, &err,
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[0],
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[1],
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[2],
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[3],
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[4],
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[5],
								 DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	wid_add_mac_blacklist(macaddr.macaddr);


	//printf("mac :: %02X:%02X:%02X:%02X:%02X:%02X\n",macaddr.macaddr[0],macaddr.macaddr[1],macaddr.macaddr[2],macaddr.macaddr[3],macaddr.macaddr[4],macaddr.macaddr[5]);
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	
	
	wid_syslog_debug_debug(WID_DBUS,"set mac blacklist successfully\n");
	
	return reply;	

}

DBusMessage * wid_dbus_interface_delete_wireless_control_whitelist(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;

	WIDMACADDR macaddr;
	

	if (!(dbus_message_get_args ( msg, &err,
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[0],
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[1],
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[2],
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[3],
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[4],
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[5],
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	wid_delete_mac_whitelist(macaddr.macaddr);

	//printf("mac :: %02X:%02X:%02X:%02X:%02X:%02X\n",macaddr.macaddr[0],macaddr.macaddr[1],macaddr.macaddr[2],macaddr.macaddr[3],macaddr.macaddr[4],macaddr.macaddr[5]);
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	
	
	wid_syslog_debug_debug(WID_DBUS,"set mac whitelist successfully\n");
	
	return reply;	

}

DBusMessage * wid_dbus_interface_delete_wireless_control_blacklist(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	WIDMACADDR macaddr;

	if (!(dbus_message_get_args ( msg, &err,
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[0],
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[1],
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[2],
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[3],
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[4],
								 DBUS_TYPE_BYTE,  &macaddr.macaddr[5],
								 DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	wid_delete_mac_blacklist(macaddr.macaddr);


	//printf("mac :: %02X:%02X:%02X:%02X:%02X:%02X\n",macaddr.macaddr[0],macaddr.macaddr[1],macaddr.macaddr[2],macaddr.macaddr[3],macaddr.macaddr[4],macaddr.macaddr[5]);
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	
	
	wid_syslog_debug_debug(WID_DBUS,"set mac blacklist successfully\n");
	
	return reply;	

}

DBusMessage * wid_dbus_interface_show_wireless_control_blacklist(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter  iter_array;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int state = 0;
	int i = 0;

	int maclistcount = 0;
	struct white_mac *pmac = NULL;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&state,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(pblack_mac_list ==  NULL)
	{
		ret = WID_NO_BLACKLIST;
	}

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if(ret == WID_DBUS_SUCCESS)
	{	
		
		maclistcount = pblack_mac_list->imaccount;
		pmac = pblack_mac_list->list_mac;
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &maclistcount);
		
		
		dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);		

		for(i = 0; i < maclistcount; i++)
		{	
			
			
			DBusMessageIter iter_struct;
				
			dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(pmac->elem_mac[0]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(pmac->elem_mac[1]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(pmac->elem_mac[2]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(pmac->elem_mac[3]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(pmac->elem_mac[4]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(pmac->elem_mac[5]));

			dbus_message_iter_close_container(&iter_array, &iter_struct);

			pmac = pmac->next;

		}
				
		dbus_message_iter_close_container (&iter, &iter_array);
	}			

	return reply;	


}


DBusMessage * wid_dbus_interface_set_wids_judge_policy(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 
	DBusMessageIter  iter;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int mode = 0;
	int policy = 0;
	if (!(dbus_message_get_args ( msg, &err,
								 DBUS_TYPE_UINT32,&mode,	
								 DBUS_TYPE_UINT32,&policy,	
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	//save parameter
	printf("set wids judge mode = %d policy = %d \n",mode,policy);
	//if(policy == 1)
	{
		wids_judge_policy = mode;
	}
	/*
	else
	{
		if(wids_judge_policy&mode == 1)
		{
			wids_judge_policy -= 1;
		}
		else if(wids_judge_policy&mode == 2)
		{
			wids_judge_policy -= 2;
		}
		else if(wids_judge_policy&mode == 4)
		{
			wids_judge_policy -= 4;
		}
		
	}
	*/

	printf("set wids judge policy = %d \n",wids_judge_policy);

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	wid_syslog_debug_debug(WID_DEFAULT,"set wids judge policy successfully\n");
	
	return reply;	

}
DBusMessage * wid_dbus_interface_show_wids_judge_policy(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 
	DBusMessageIter  iter;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int mode = 0;
	//int policy = 0;
	if (!(dbus_message_get_args ( msg, &err,
								 DBUS_TYPE_UINT32,&mode,	
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}


	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &wids_judge_policy);

	printf("show wids judge policy = %d \n",wids_judge_policy);
	
	wid_syslog_debug_debug(WID_DEFAULT,"show wids judge policy successfully\n");
	return reply;	

}

DBusMessage * wid_dbus_interface_set_wids_monitor_mode(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int mode = 0;
	unsigned int wtpid = 0;
	unsigned char premode = 0;
	int i = 0;
	if (!(dbus_message_get_args ( msg, &err,
								 DBUS_TYPE_UINT32,&mode,	
								 DBUS_TYPE_UINT32,&wtpid,    
								 DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	//printf("monitor mode is %d\n",mode);
	if(wtpid == 0){
		if(mode == 2){//monitor
			if(1 != gapscanset.opstate)
			{
				gapscanset.opstate = 1;//enable
				gapscanset.flag = 1;
			
				if(gapscanset.reportinterval == 0)
				{
					gapscanset.reportinterval = ROGUE_AP_REPORT_INT;
				}
				
				for(i=0; i<WTP_NUM&&AC_WTP[i]; i++)
				{
					premode = AC_WTP[i]->WIDS.monitorMode; 
					AC_WTP[i]->WIDS.monitorMode = mode;//when scanning mode is all ,channel mode only be all
					wid_set_ap_scanning_wtp(wtpid,gapscanset,premode);
				}
			}
			//send max sta num to zero
			i = 0;
			//msgq msg;
			for(i=0; i<WTP_NUM; i++)
			{
				if((AC_WTP[i] != NULL)&&(AC_WTP[i]->WTPStat == 5))
				{
					if(AC_WTP[i]!=NULL){
							AC_WTP[i]->wtp_allowed_max_sta_num = 0;
							AsdWsm_WTPOp(i,WID_MODIFY);
					}
				}
			}

		}else if(mode == 1){
		
			if(1 != gapscanset.opstate)
			{
				gapscanset.opstate = 1;
				gapscanset.flag = 1;
			
				if(gapscanset.reportinterval == 0)
				{
					gapscanset.reportinterval = ROGUE_AP_REPORT_INT;
				}
				for(i=0; i<WTP_NUM; i++)
				{
					if(AC_WTP[i] != NULL){
						premode = AC_WTP[i]->WIDS.monitorMode;
						AC_WTP[i]->WIDS.monitorMode = mode;
						wid_set_ap_scanning_wtp(wtpid,gapscanset,premode);
						if((AC_WTP[i]->WIDS.scanningMode == 1)||(AC_WTP[i]->WIDS.scanningMode == 2)){//current scanning channel auto or all
						
						}else{
							AC_WTP[i]->WIDS.scanningMode = 2;//default is all
						}
					}
				}
			}

			i = 0;
			for(i=0; i<WTP_NUM; i++)
			{
				//set wtp max sta num to default num 64
				if(AC_WTP[i]!=NULL){
						AC_WTP[i]->wtp_allowed_max_sta_num = 64;
						AsdWsm_WTPOp(i,WID_MODIFY);
				}
			}
			
		}
		else if(mode == 0){//disable

			if(0 != gapscanset.opstate)
			{
				gapscanset.opstate = 0;
				gapscanset.flag = 1;
			
				if(gapscanset.reportinterval == 0)
				{
					gapscanset.reportinterval = ROGUE_AP_REPORT_INT;
				}
				for(i=0; i<WTP_NUM; i++)
				{
					if(AC_WTP[i] != NULL){
						premode = AC_WTP[i]->WIDS.monitorMode;						
						AC_WTP[i]->WIDS.monitorMode = mode;//none
						wid_set_ap_scanning_wtp(wtpid,gapscanset,premode);
					}
				}
			
				if(mode == 0)
				{	
					i = 0;
					for(i=0; i<WTP_NUM; i++)
					{
						//set wtp max sta num to default num 64
						if(AC_WTP[i] != NULL){
							AC_WTP[i]->wtp_allowed_max_sta_num = 64;
							AsdWsm_WTPOp(i,WID_MODIFY);
						}
						//destroy neighborapinfo
						if((AC_WTP[i] != NULL)&&(AC_WTP[i]->WTPStat == 5))
						{
							CWThreadMutexLock(&(gWTPs[i].RRMThreadMutex));
			
							if((AC_WTP[i]->NeighborAPInfos) != NULL)
							{
								destroy_ap_info_list(&(AC_WTP[i]->NeighborAPInfos));
							}
							if((AC_WTP[i]->rouge_ap_infos) != NULL)
							{
								destroy_ap_info_list(&(AC_WTP[i]->rouge_ap_infos));
							}
							
							CWThreadMutexUnlock(&(gWTPs[i].RRMThreadMutex)); 
			
						}
					}
				}
			}
		}
		ret = WID_DBUS_SUCCESS;
	}else if(AC_WTP[wtpid] != NULL){

		if(AC_WTP[wtpid]->WIDS.monitorMode != mode){
			premode = AC_WTP[wtpid]->WIDS.monitorMode;
			AC_WTP[wtpid]->WIDS.monitorMode = mode;
			if(mode == 2){//monitor
				AC_WTP[wtpid]->WIDS.scanningMode = 2;//when scanning mode is all ,channel mode only be all

				if(1 != gapscanset.opstate)
				{
					gapscanset.opstate = 1;//enable
					gapscanset.flag = 1;
				
					if(gapscanset.reportinterval == 0)
					{
						gapscanset.reportinterval = ROGUE_AP_REPORT_INT;
					}
					ret = wid_set_ap_scanning_wtp(wtpid,gapscanset,premode);
				}
				
				//send max sta num to zero
			
				if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPStat == 5))
				{
					if(AC_WTP[wtpid]!=NULL){
							AC_WTP[wtpid]->wtp_allowed_max_sta_num = 0;
							AsdWsm_WTPOp(wtpid,WID_MODIFY);
					}
				}

			}else if(mode == 1){
			
				if(1 != gapscanset.opstate)
				{
					gapscanset.opstate = 1;
					gapscanset.flag = 1;
				
					if(gapscanset.reportinterval == 0)
					{
						gapscanset.reportinterval = ROGUE_AP_REPORT_INT;
					}
					ret = wid_set_ap_scanning_wtp(wtpid,gapscanset,premode);
				}

				if((AC_WTP[wtpid]->WIDS.scanningMode == 1)||(AC_WTP[wtpid]->WIDS.scanningMode == 2)){//current scanning channel auto or all

				}else{
					AC_WTP[wtpid]->WIDS.scanningMode = 2;//default is all
				}
				
				//set wtp max sta num to default num 64
				if(AC_WTP[wtpid]!=NULL){
					AC_WTP[wtpid]->wtp_allowed_max_sta_num = 64;
					AsdWsm_WTPOp(wtpid,WID_MODIFY);
				}
				
			}
			else if(mode == 0){//disable
				AC_WTP[wtpid]->WIDS.scanningMode = 0;//none

				if(0 != gapscanset.opstate)
				{
					gapscanset.opstate = 0;
					gapscanset.flag = 1;
				
					if(gapscanset.reportinterval == 0)
					{
						gapscanset.reportinterval = ROGUE_AP_REPORT_INT;
					}
					ret = wid_set_ap_scanning_wtp(wtpid,gapscanset,premode);
				
					if(mode == 0)
					{	
							//set wtp max sta num to default num 64
							if(AC_WTP[wtpid] != NULL){
								AC_WTP[wtpid]->wtp_allowed_max_sta_num = 64;
								AsdWsm_WTPOp(wtpid,WID_MODIFY);
							}
							//destroy neighborapinfo
							if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPStat == 5))
							{
								CWThreadMutexLock(&(gWTPs[wtpid].RRMThreadMutex));
				
								if((AC_WTP[wtpid]->NeighborAPInfos) != NULL)
								{
									destroy_ap_info_list(&(AC_WTP[wtpid]->NeighborAPInfos));
								}
								if((AC_WTP[wtpid]->rouge_ap_infos) != NULL)
								{
									destroy_ap_info_list(&(AC_WTP[wtpid]->rouge_ap_infos));
								}
								
								CWThreadMutexUnlock(&(gWTPs[wtpid].RRMThreadMutex)); 
				
							}
					}
				}
			}
			ret = WID_DBUS_SUCCESS;
		}else{
			ret = WID_DBUS_SUCCESS;
		}
	}
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	wid_syslog_debug_debug(WID_DEFAULT,"set wids monitor mode successfully\n");
	
	return reply;	

}

DBusMessage * wid_dbus_interface_set_wids_mode(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int i = 0;
	int mode = 0;
	unsigned int wtpid = 0;
	if (!(dbus_message_get_args ( msg, &err,
								 DBUS_TYPE_UINT32,&mode,
							   	DBUS_TYPE_UINT32,&wtpid,
							 	DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid == 0)
	{
		for(i = 0; i< WTP_NUM; i++)
		{
			if(AC_WTP[i]&&AC_WTP[i]->WIDS.monitorMode != 1){//only when scanning mode be monitor,can set channel mode
				ret = WID_AP_SCANNING_DISABLE;
				continue;
			}
			else if(AC_WTP[i]&&AC_WTP[i]->WIDS.scanningMode != mode){
				AC_WTP[i]->WIDS.scanningMode = mode;
				ret = WID_DBUS_SUCCESS;
			}else{
				ret = WID_DBUS_SUCCESS;
			}
		}
	}
	else
	{
		if(AC_WTP[wtpid]&&AC_WTP[wtpid]->WIDS.monitorMode != 1){//only when scanning mode be monitor,can set channel mode
			ret = WID_AP_SCANNING_DISABLE;
		}
		else if(AC_WTP[wtpid]&&AC_WTP[wtpid]->WIDS.scanningMode != mode){
			AC_WTP[wtpid]->WIDS.scanningMode = mode;
			ret = WID_DBUS_SUCCESS;
		}else{
			ret = WID_DBUS_SUCCESS;
		}
	}
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	wid_syslog_debug_debug(WID_DEFAULT,"set wids scanning mode successfully\n");
	
	return reply;	

}

DBusMessage * wid_dbus_interface_set_wids_channel(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	unsigned int num = 0;
	int i = 0;
	int j = 0;
	int k = 0;
	int m = 1;
	unsigned int wtpid = 0;
	int channel[SCANNING_CHANNEL_NUM];
	dbus_error_init(&err);
	//dbus_message_iter_next(&iter);
	dbus_message_iter_init(msg,&iter);
	dbus_message_iter_get_basic(&iter,&wtpid);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&num);
	memset(channel,0,SCANNING_CHANNEL_NUM);
	if(num > 0 )
	{		
		dbus_message_iter_next(&iter);	
		for (i = 0; i < num; i++) 
		{
			dbus_message_iter_get_basic(&iter,&channel[i]);
			dbus_message_iter_next(&iter);	
		}
		
	}
	while(j<num){
		
		ret = check_channel(channel[j]);
		if(ret != COUNTRY_CODE_SUCCESS)
		{
			reply = dbus_message_new_method_return(msg);
			dbus_message_iter_init_append (reply, &iter);
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &ret);
			return reply;
		}
		j++;
	}
	if ((ret == COUNTRY_CODE_SUCCESS))
	{
		if(wtpid == 0){
			for(m=1;m<(WTP_NUM-1);m++){
				if(AC_WTP[m] != NULL){
					AC_WTP[m]->WIDS.num = num;
					for(k = 0; k < num; k++)
					{
						AC_WTP[m]->WIDS.channel[k] = channel[k];
					}
				}
			}
		}else if(AC_WTP[wtpid] != NULL){
			AC_WTP[wtpid]->WIDS.num = num;
			for(k = 0; k < num; k++)
			{
				AC_WTP[wtpid]->WIDS.channel[k] = channel[k];
			}
		}
	}	
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append (reply, &iter);
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	wid_syslog_debug_debug(WID_DEFAULT,"set wids scanning channel successfully\n");
	
	return reply;	

}


DBusMessage * wid_dbus_interface_show_wids_mode_channel(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	//int mode = 0;
	int state = 0;
	int i = 0;
	unsigned int wtpid = 0;
	SCNANNING_MODE INFO;
	INFO.num= 0;
	INFO.monitorMode = 0;
	INFO.scanningMode = 0;
	if (!(dbus_message_get_args ( msg, &err,
								 DBUS_TYPE_UINT32,&state,	
								 DBUS_TYPE_UINT32,&wtpid,   
								 DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	printf("dbus:wtpid: %d\n",wtpid);
	if(state == 0){
		ret = WID_DBUS_SUCCESS;
	}
	reply = dbus_message_new_method_return(msg);
	printf("dbus:111111\n");
	dbus_message_iter_init_append(reply, &iter);
	printf("dbus:2222wtpid: %d\n",wtpid);
	if(wtpid == 0){
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &INFO.num);
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &INFO.monitorMode);
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &INFO.scanningMode);
		printf("dbus:333333333wtpid: %d\n",wtpid);
		
		if(INFO.scanningMode == 3){
			printf("dbus:44444wtpid: %d\n",wtpid);
			for(i =0;(i<INFO.num)&&(i<SCANNING_CHANNEL_NUM);i++){
				printf("dbus:555555wtpid: %d\n",wtpid);
				dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &INFO.channel[i]);
			}
		}
	}else if(AC_WTP[wtpid] != NULL){
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &AC_WTP[wtpid]->WIDS.num);
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &AC_WTP[wtpid]->WIDS.monitorMode);
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &AC_WTP[wtpid]->WIDS.scanningMode);
		printf("dbus:333333333wtpid: %d\n",wtpid);
		
		if(AC_WTP[wtpid]->WIDS.scanningMode == 3){
			printf("dbus:44444wtpid: %d\n",wtpid);
			for(i =0;(i<AC_WTP[wtpid]->WIDS.num)&&(i<SCANNING_CHANNEL_NUM);i++){
				printf("dbus:555555wtpid: %d\n",wtpid);
				dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &AC_WTP[wtpid]->WIDS.channel[i]);
			}
		}
	}
	printf("dbus:66666666wtpid: %d\n",wtpid);
	wid_syslog_debug_debug(WID_DEFAULT,"show wids scanning mode channel\n");
	
	return reply;	

}


DBusMessage * wid_dbus_interface_show_access_wtpvendor_count(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 
	DBusMessageIter  iter;
	DBusMessageIter  iter_array;
	DBusError err;
	int i = 0;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int state = 0;
	int bind_lic_count = 0;
	int cur_count = 0;
	int max_count = 0;
	int bind_flag = 0;
	if (!(dbus_message_get_args ( msg, &err,
								 DBUS_TYPE_UINT32,&state,								 
								DBUS_TYPE_INVALID))){
		printf("Unable to get input args\n");
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(state == 0){
		ret = WID_DBUS_SUCCESS;
	}
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&glicensecount);
	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
									DBUS_TYPE_UINT32_AS_STRING 
									DBUS_TYPE_UINT32_AS_STRING
									DBUS_TYPE_UINT32_AS_STRING
									DBUS_TYPE_UINT32_AS_STRING
									DBUS_TYPE_UINT32_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);		
		for(i = 0; i < glicensecount; i++)
		{	
			DBusMessageIter iter_struct;
			dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(g_wtp_count[i]->gcurrent_wtp_count));/*xiaodawei modify, 20101029*/
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(g_wtp_count[i]->gmax_wtp_count));/*xiaodawei modify, 20101029*/
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(g_wtp_count[i]->flag));			/*xiaodawei add for bindingflag, 20101109*/			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(g_wtp_count[i]->isShm));					
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(g_wtp_count[i]->gmax_wtp_count_assign));					
			dbus_message_iter_close_container(&iter_array, &iter_struct);
		}

		for(i=1;i<glicensecount;i++){
			if(g_wtp_binding_count[i] != NULL){
				bind_lic_count ++;
			}
		}
		wid_syslog_info("%s,%d,g_wtp_binding_count is %d.\n",__func__,__LINE__,bind_lic_count);
		dbus_message_iter_close_container (&iter, &iter_array);
		
		dbus_message_iter_append_basic (&iter,
										DBUS_TYPE_UINT32,
										&bind_lic_count);
		dbus_message_iter_open_container (&iter,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
										DBUS_TYPE_UINT32_AS_STRING 
										DBUS_TYPE_UINT32_AS_STRING
										DBUS_TYPE_UINT32_AS_STRING
										DBUS_STRUCT_END_CHAR_AS_STRING,
										&iter_array);		
		for(i = 1; i <= bind_lic_count; i++)
		{	
			if(g_wtp_binding_count[i] != NULL){
				cur_count = g_wtp_binding_count[i]->gcurrent_wtp_count;
				max_count = g_wtp_binding_count[i]->gmax_wtp_count;
				bind_flag = g_wtp_binding_count[i]->flag;
			}else{
				cur_count = max_count = bind_flag = 0;
				wid_syslog_warning("%s,%d,g_wtp_binding_count[%d] is NULL.\n",__func__,__LINE__,i);
			}
			DBusMessageIter iter_struct;
			dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(cur_count));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(max_count));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(bind_flag)); 			
			dbus_message_iter_close_container(&iter_array, &iter_struct);
		}
		dbus_message_iter_close_container (&iter, &iter_array);
	wid_syslog_debug_debug(WID_DEFAULT,"show access wtp vendor count\n");
	return reply;	
}
/*xiaodawei add for set license binding|nobinding , 20101029*/
DBusMessage * wid_dbus_interface_set_license_bind(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 
	DBusMessageIter  iter;
	DBusError err;
	unsigned char type;
	int i = 0;
	int j = 0;
	int k = 0;
	unsigned int flag = 0;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	char *string = NULL;
	int strlength = 0;
	int *licenselist = NULL;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&type,
								DBUS_TYPE_STRING,&string,								 
								DBUS_TYPE_INVALID))){
		printf("Unable to get input args\n");
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	strlength = strlen(string);
	/*process license type list*/
	if((*string<'0'||*string>'9')||(string[strlength-1]==',')){
		ret=WRONG_LICENSE_LIST;//wrong license type list!
		reply = dbus_message_new_method_return(msg);
		dbus_message_iter_init_append (reply, &iter);
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
		return reply;
	}
	for(i=1;string[i];i++){
		if((string[i]<'0'||string[i]>'9')&&string[i]!=','){
			ret=WRONG_LICENSE_LIST;//wrong license type list!
			reply = dbus_message_new_method_return(msg);
			dbus_message_iter_init_append (reply, &iter);
			dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
			return reply;
		}
		if(string[i]==','&&string[i+1]==','){
			ret=WRONG_LICENSE_LIST;//wrong license type list!
			reply = dbus_message_new_method_return(msg);
			dbus_message_iter_init_append (reply, &iter);
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &ret);
			return reply;
		}
	}
	licenselist = (int *)WID_MALLOC((glicensecount+1)*sizeof(int));
	for(i=0,j=0; i<strlength;i++){
		if(string[i]!=','){
			licenselist[j] = string[i]-'0';
			for(; string[i+1]!=','&&string[i+1]!='\0'; i++){
				licenselist[j] = licenselist[j]*10+string[i+1]-'0';
			}
			j++;
		}
		//license type max num is glicensecount
		if(j>glicensecount){
			ret=LICENSE_NUM_LARGER_THAN_MAX;//exceed the max number of license type!
			reply = dbus_message_new_method_return(msg);
			dbus_message_iter_init_append (reply, &iter);
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &ret);
			if(licenselist!=NULL){
				WID_FREE(licenselist);
				licenselist = NULL;
			}
			return reply;
		}
	}
	//license type num should >1
	if(j==1&&type==1){
		ret=LICENSE_NUM_LESS_THAN_TWO;
		reply = dbus_message_new_method_return(msg);
		dbus_message_iter_init_append (reply, &iter);
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
		if(licenselist!=NULL){
			WID_FREE(licenselist);
			licenselist = NULL;
		}
		return reply;
	}
	//license type <= glicensecount
	for(i=0; i<j; i++){
		if(licenselist[i]==0||licenselist[i]>glicensecount){
			ret=LICENSE_NOT_EXIST;//license type %d doesn't exist!
			reply = dbus_message_new_method_return(msg);
			dbus_message_iter_init_append (reply, &iter);
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &ret);
			dbus_message_iter_append_basic (&iter,
											DBUS_TYPE_UINT32,
											&licenselist[i]);
			if(licenselist!=NULL){
				WID_FREE(licenselist);
				licenselist = NULL;
			}
			return reply;
		}
	}
	//duplicated license type
	for(i=1; i<j; i++){
		for(k=0; k<i; k++){
			if(licenselist[k]==licenselist[i]){
				ret=LICENSE_TYPE_DUPLICATED;//duplicated license type!
				reply = dbus_message_new_method_return(msg);
				dbus_message_iter_init_append (reply, &iter);
				dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_UINT32,
												 &ret);
				if(licenselist!=NULL){
					WID_FREE(licenselist);
					licenselist = NULL;
				}
				return reply;
			}
		}
	}
	//binded lincense type
	for(i=0; i<j; i++){
		if(g_wtp_count[licenselist[i]-1]->flag!=0&&type==1){
			ret = LICENSE_TYPE_BINDED;//license was binded!
			reply = dbus_message_new_method_return(msg);
			dbus_message_iter_init_append (reply, &iter);
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &ret);
			dbus_message_iter_append_basic (&iter,
											DBUS_TYPE_UINT32,
											&licenselist[i]);
			if(licenselist!=NULL){
				WID_FREE(licenselist);
				licenselist = NULL;
			}
			return reply;
		}
	}
	/*set license LICENSELIST binding*/
	if(type==1){
		//binding license type
		for(flag=1; flag<glicensecount+1; flag++){
			if(g_wtp_binding_count[flag]==NULL){
				g_wtp_binding_count[flag] = WID_MALLOC(sizeof(LICENSE_TYPE));
				break;
			}
		}
		for(i=0;i<j;i++){
		g_wtp_count[licenselist[i]-1]->flag = flag;
		//printf("license %d\n",licenselist[i]);
		//printf("flag is %d\n",g_wtp_count[licenselist[i]-1]->flag);
		}
		g_wtp_binding_count[flag]->flag = flag;
		g_wtp_binding_count[flag]->gcurrent_wtp_count = 0;
		g_wtp_binding_count[flag]->gmax_wtp_count = 0;
		CWThreadMutexLock(&ACLicense);
		for(i=0;i<j;i++){
			g_wtp_binding_count[flag]->gcurrent_wtp_count+=g_wtp_count[licenselist[i]-1]->gcurrent_wtp_count;
			g_wtp_binding_count[flag]->gmax_wtp_count+=g_wtp_count[licenselist[i]-1]->gmax_wtp_count;
		}
		CWThreadMutexUnlock(&ACLicense);
		reply = dbus_message_new_method_return(msg);
		dbus_message_iter_init_append(reply, &iter);
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	}
	/*set license LICENSELIST nobinding*/
	else{
		//license type hasn't been binded
		for(i=0; i<j; i++){
			if(g_wtp_count[licenselist[i]-1]->flag == 0){
				ret = LICENSE_NOT_BINDED;
				reply = dbus_message_new_method_return(msg);
				dbus_message_iter_init_append (reply, &iter);
				dbus_message_iter_append_basic (&iter,
											 	DBUS_TYPE_UINT32,
											 	&ret);
				dbus_message_iter_append_basic (&iter,
												DBUS_TYPE_UINT32,
												&licenselist[i]);
				if(licenselist!=NULL){
					WID_FREE(licenselist);
					licenselist = NULL;
				}
				return reply;
			}
		}
		flag = g_wtp_count[licenselist[0]-1]->flag;
		for(i=0; i<j; i++){
			if(g_wtp_count[licenselist[i]-1]->flag!=flag){
				ret = LICENSE_BINDED_ANOTHER;
				reply = dbus_message_new_method_return(msg);
				dbus_message_iter_init_append (reply, &iter);
				dbus_message_iter_append_basic (&iter,
											 	DBUS_TYPE_UINT32,
											 	&ret);
				dbus_message_iter_append_basic (&iter,
												DBUS_TYPE_UINT32,
												&licenselist[i]);
				if(licenselist!=NULL){
					WID_FREE(licenselist);
					licenselist = NULL;
				}
				return reply;
			}
		}
		/*after unbinding, the current num MUST be less than the max num*/
		CWThreadMutexLock(&ACLicense);
		for(i=0; i<j && g_wtp_binding_count[flag]!=NULL; i++){
			if(g_wtp_count[licenselist[i]-1]->gcurrent_wtp_count<=g_wtp_count[licenselist[i]-1]->gmax_wtp_count){
				g_wtp_binding_count[flag]->gcurrent_wtp_count-=g_wtp_count[licenselist[i]-1]->gcurrent_wtp_count;
				g_wtp_binding_count[flag]->gmax_wtp_count-=g_wtp_count[licenselist[i]-1]->gmax_wtp_count;
				if(g_wtp_binding_count[flag]->gcurrent_wtp_count<=g_wtp_binding_count[flag]->gmax_wtp_count){
					g_wtp_count[licenselist[i]-1]->flag = 0;
				}
				else{
					g_wtp_binding_count[flag]->gcurrent_wtp_count+=g_wtp_count[licenselist[i]-1]->gcurrent_wtp_count;
					g_wtp_binding_count[flag]->gmax_wtp_count+=g_wtp_count[licenselist[i]-1]->gmax_wtp_count;
					ret = CURRENT_NUM_MORE_THAN_MAX;
					reply = dbus_message_new_method_return(msg);
					dbus_message_iter_init_append (reply, &iter);
					dbus_message_iter_append_basic (&iter,
												 	DBUS_TYPE_UINT32,
												 	&ret);
					dbus_message_iter_append_basic (&iter,
													DBUS_TYPE_UINT32,
													&licenselist[i]);
					CWThreadMutexUnlock(&ACLicense);
					if(licenselist!=NULL){
						WID_FREE(licenselist);
						licenselist = NULL;
					}
					return reply;
				}
			}
			else{
				ret = CURRENT_NUM_MORE_THAN_MAX;
				reply = dbus_message_new_method_return(msg);
				dbus_message_iter_init_append (reply, &iter);
				dbus_message_iter_append_basic (&iter,
											 	DBUS_TYPE_UINT32,
											 	&ret);
				dbus_message_iter_append_basic (&iter,
												DBUS_TYPE_UINT32,
												&licenselist[i]);
				CWThreadMutexUnlock(&ACLicense);
				if(licenselist!=NULL){
					WID_FREE(licenselist);
					licenselist = NULL;
				}
				return reply;
			}
		}
		CWThreadMutexUnlock(&ACLicense);
		/*after unbinding if only one was still binded, unbind it!!*/
		CWThreadMutexLock(&ACLicense);
		for(i=0,j=0; i<glicensecount; i++){
			if(g_wtp_count[i]->flag == flag){
				j++;
			}
		}
		if(j==1){
			for(i=0; i<glicensecount; i++){
				if(g_wtp_count[i]->flag == flag){
					g_wtp_count[i]->flag = 0;
					WID_FREE(g_wtp_binding_count[flag]);
					g_wtp_binding_count[flag]=NULL;
					break;
				}
			}	
		}
		if(g_wtp_binding_count[flag]!=NULL&&g_wtp_binding_count[flag]->gmax_wtp_count==0){
			WID_FREE(g_wtp_binding_count[flag]);
			g_wtp_binding_count[flag]=NULL;
		}
		CWThreadMutexUnlock(&ACLicense);
		ret = LICENSE_NO_BINDING_SUCCESS;
		reply = dbus_message_new_method_return(msg);
		dbus_message_iter_init_append(reply, &iter);
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	}
	if(licenselist!=NULL){
		WID_FREE(licenselist);
		licenselist = NULL;
	}
	
	wid_syslog_debug_debug(WID_DEFAULT,"set license binding\n");
	return reply;	
}

/*############END#################*/
/*xiaodawei add for iperf*/
DBusMessage * wid_dbus_interface_iperf_wtpip(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 
	DBusMessageIter  iter;
	//DBusMessageIter  iter_array;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	char *wtp_ip = NULL;
	char *ip = NULL;
	struct NetworkQuality network_quality = {0};

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_STRING,&wtp_ip,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	ip = (char*)WID_MALLOC(strlen(wtp_ip)+1);
	memset(ip, 0 ,strlen(wtp_ip)+1);
	memcpy(ip, wtp_ip, strlen(wtp_ip));
	
	ret = measure_quality_of_network_link(ip,&network_quality);
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if(ret == WID_DBUS_SUCCESS)
	{	
		
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_DOUBLE,&network_quality.jitter);
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_DOUBLE,&network_quality.datagramloss);

	}
	
	FREE(ip);	
	return reply;	

}

DBusMessage * wid_dbus_interface_show_essid_list(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter  iter_array;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int state = 0;
	int i = 0;

	int maclistcount = 0;
	struct essid_node *essid = NULL;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&state,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(g_essid_list.list_len==0)
	{
		ret = WID_NO_WHITELIST;
	}

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if(ret == WID_DBUS_SUCCESS)
	{	
		
		maclistcount = g_essid_list.list_len;
		essid = g_essid_list.essid_list;
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &maclistcount);
		
		
		dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_STRING_AS_STRING //mac
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);		

		for(i = 0; i < maclistcount; i++)
		{	
			
			
			DBusMessageIter iter_struct;
				
			dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_STRING,
						  &(essid->essid));
		//printf("\t%d :essid %s\n",i+1,essid->essid);
			dbus_message_iter_close_container(&iter_array, &iter_struct);

			essid = essid->next;

		}
				
		dbus_message_iter_close_container (&iter, &iter_array);
	}			

	return reply;	

}


DBusMessage * wid_dbus_interface_show_oui_list(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter  iter_array;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int state = 0;
	int i = 0;

	int maclistcount = 0;
	struct oui_node *pmac = NULL;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&state,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(g_oui_list.list_len==0)
	{
		ret = WID_NO_WHITELIST;
	}

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if(ret == WID_DBUS_SUCCESS)
	{	
		
		maclistcount = g_oui_list.list_len;
		pmac = g_oui_list.oui_list;
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &maclistcount);
		
		
		dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);		

		for(i = 0; i < maclistcount; i++)
		{	
			
			
			DBusMessageIter iter_struct;
				
			dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(pmac->oui[0]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(pmac->oui[1]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(pmac->oui[2]));

			dbus_message_iter_close_container(&iter_array, &iter_struct);

			pmac = pmac->next;

		}
				
		dbus_message_iter_close_container (&iter, &iter_array);
	}			

	return reply;	

}


DBusMessage * wid_dbus_interface_show_attack_mac_list(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter  iter_array;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int state = 0;
	int i = 0;

	int maclistcount = 0;
	struct attack_mac_node *pmac = NULL;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&state,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(g_attack_mac_list.list_len == 0)
	{
		ret = WID_NO_WHITELIST;
	}

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if(ret == WID_DBUS_SUCCESS)
	{	
		
		maclistcount = g_attack_mac_list.list_len;
		pmac = g_attack_mac_list.attack_mac_list;
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &maclistcount);
		
		
		dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);		

		for(i = 0; i < maclistcount; i++)
		{	
			
			
			DBusMessageIter iter_struct;
				
			dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(pmac->mac[0]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(pmac->mac[1]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(pmac->mac[2]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(pmac->mac[3]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(pmac->mac[4]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(pmac->mac[5]));

			dbus_message_iter_close_container(&iter_array, &iter_struct);

			pmac = pmac->next;

		}
				
		dbus_message_iter_close_container (&iter, &iter_array);
	}			

	return reply;	

}

DBusMessage * wid_dbus_interface_show_wids_mac_list(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 
	DBusMessageIter  iter;
	DBusMessageIter  iter_array;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int state = 0;
	int i = 0;

	int maclistcount = 0;
	struct tag_wids_device_ele *wids_device_ele = NULL;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&state,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if((wids_ignore_list == NULL)||(wids_ignore_list->count == 0))
	{
		ret = WID_NO_WHITELIST;
	}

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if(ret == WID_DBUS_SUCCESS)
	{	
		
		maclistcount = wids_ignore_list->count;
		wids_device_ele = wids_ignore_list->wids_device_info;
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &maclistcount);
		
		
		dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);		

		for(i = 0; i < maclistcount; i++)
		{	
			
			
			DBusMessageIter iter_struct;
				
			dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(wids_device_ele->bssid[0]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(wids_device_ele->bssid[1]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(wids_device_ele->bssid[2]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(wids_device_ele->bssid[3]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(wids_device_ele->bssid[4]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(wids_device_ele->bssid[5]));

			dbus_message_iter_close_container(&iter_array, &iter_struct);

			wids_device_ele = wids_device_ele->next;

		}
				
		dbus_message_iter_close_container (&iter, &iter_array);
	}			

	return reply;	

}

DBusMessage * wid_dbus_interface_show_wireless_control_whitelist(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter  iter_array;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int state = 0;
	int i = 0;

	int maclistcount = 0;
	struct white_mac *pmac = NULL;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&state,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(pwhite_mac_list ==  NULL)
	{
		ret = WID_NO_WHITELIST;
	}

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if(ret == WID_DBUS_SUCCESS)
	{	
		
		maclistcount = pwhite_mac_list->imaccount;
		pmac = pwhite_mac_list->list_mac;
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &maclistcount);
		
		
		dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);		

		for(i = 0; i < maclistcount; i++)
		{	
			
			
			DBusMessageIter iter_struct;
				
			dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(pmac->elem_mac[0]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(pmac->elem_mac[1]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(pmac->elem_mac[2]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(pmac->elem_mac[3]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(pmac->elem_mac[4]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(pmac->elem_mac[5]));

			dbus_message_iter_close_container(&iter_array, &iter_struct);

			pmac = pmac->next;

		}
				
		dbus_message_iter_close_container (&iter, &iter_array);
	}			

	return reply;	

}

DBusMessage * wid_dbus_interface_show_rogue_ap_list(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter  iter_array;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	Neighbor_AP_INFOS *progueaplist = NULL;
	int state = 0;
	int i = 0;
	int j = 0;
	struct Neighbor_AP_ELE *phead;
	int rouge_ap_count = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&state,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}


	//printf("received state:%d\n",state);

	//CWThreadMutexLock(&(gACChannelMutex));
	if(gapscanset.opstate == 0)
	{
		ret = WID_AP_SCANNING_DISABLE;
	}
	else
	{
		progueaplist = wid_check_rogue_ap_all();
		if(gmacfilterflag == 1)
		{
			delete_rouge_ap_list_by_whitelist(&(progueaplist));
		}
		delete_rouge_ap_list_by_ouilist(&(progueaplist));
		if(gessidfilterflag == 1)
		{
			delete_rouge_ap_list_by_essidlist(&(progueaplist));
		}
		if(progueaplist == NULL)
		{
			ret = WTP_NO_NEIGHBORAP;
		}
	}
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if(ret == WID_DBUS_SUCCESS)
	{	
		if(progueaplist != NULL)
		{
			rouge_ap_count = progueaplist->neighborapInfosCount;
			phead = progueaplist->neighborapInfos;
		}else{
			wid_syslog_debug_debug(WID_DEFAULT,"progueaplist  =  NULL\n");		
		}
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &rouge_ap_count);
		
		dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_UINT16_AS_STRING //rate
											
											DBUS_TYPE_BYTE_AS_STRING //channel
											DBUS_TYPE_BYTE_AS_STRING //rssi
											DBUS_TYPE_BYTE_AS_STRING //noise
											DBUS_TYPE_BYTE_AS_STRING //beacon interval
											
											DBUS_TYPE_BYTE_AS_STRING //status
											DBUS_TYPE_BYTE_AS_STRING //oprate status
											DBUS_TYPE_UINT16_AS_STRING //capability
											
											DBUS_TYPE_ARRAY_AS_STRING
											DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
											DBUS_STRUCT_END_CHAR_AS_STRING
											DBUS_TYPE_STRING_AS_STRING //ie infor

									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);		

		for(i = 0; (i < rouge_ap_count)&&(phead); i++)
		{	
		
			DBusMessageIter iter_struct;
			DBusMessageIter  iter_sub_array;
			dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BSSID[0]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BSSID[1]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BSSID[2]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BSSID[3]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BSSID[4]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BSSID[5]));

			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT16,
						  &(phead->Rate));
			
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->Channel));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->RSSI));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->NOISE));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BEACON_INT));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->status));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->opstatus));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT16,
						  &(phead->capabilityinfo));
			
		dbus_message_iter_open_container (&iter_struct,
								   DBUS_TYPE_ARRAY,
								   DBUS_STRUCT_BEGIN_CHAR_AS_STRING  
									  DBUS_TYPE_BYTE_AS_STRING
								   DBUS_STRUCT_END_CHAR_AS_STRING, 
								   &iter_sub_array);
			for(j=0;j<ESSID_DEFAULT_LEN+1;j++)
			{
				DBusMessageIter iter_sub_struct;				
				dbus_message_iter_open_container (&iter_sub_array,
													DBUS_TYPE_STRUCT,
													NULL,
												  &iter_sub_struct);
				dbus_message_iter_append_basic
							(&iter_sub_struct,
							  DBUS_TYPE_BYTE,
							  &(phead->ESSID[j]));
				dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);
			}
			dbus_message_iter_close_container (&iter_struct, &iter_sub_array);	
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_STRING,
						  &(phead->IEs_INFO));

			dbus_message_iter_close_container (&iter_array, &iter_struct);

			phead = phead->next;

		}
				
		dbus_message_iter_close_container (&iter, &iter_array);
	}			

	if(progueaplist != NULL)
	{
		destroy_ap_info_list(&progueaplist);
	}
	
	//CWThreadMutexUnlock(&gACChannelMutex);	
	return reply;	

}

DBusMessage * wid_dbus_interface_show_rogue_ap_threshold(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
//	DBusMessageIter  iter_array;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
//	Neighbor_AP_INFOS *progueaplist = NULL;
	int state = 0;
//	int i = 0;
//	struct Neighbor_AP_ELE *phead;
	int rouge_ap_count = 0;
	printf("11111 here is in show_rogue_ap_threshold.\n");
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&state,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	printf("22222 here is in show_rogue_ap_threshold.\n");
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if(ret == WID_DBUS_SUCCESS)
	{	
		
		rouge_ap_count = neighborrogueapcount;
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &rouge_ap_count);	
				
	}			
	return reply;	

}

DBusMessage * wid_dbus_interface_show_rogue_ap_list_v1(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter  iter_array;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	Neighbor_AP_INFOS *progueaplist = NULL;
	int state = 0;
	int i = 0;
	int j = 0;
	struct Neighbor_AP_ELE *phead;
	int rouge_ap_count = 0;
	
	/*fengwenchao add 201104101*/
	unsigned int wtp_num = 0;
	unsigned int wtp_online_num = 0;
	WID_WTP **WTP;	
	struct white_mac *Wmacnode = NULL;
	struct white_mac *Bmacnode = NULL;

	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));

	wtp_num = Wid_Find_Wtp(WTP);
	
	for(i = 0; i < wtp_num; i++)
	{
		if(WTP[i]->WTPStat == 5)
			wtp_online_num++;
	}
	
	if(pwhite_mac_list != NULL)
	{
		Wmacnode = pwhite_mac_list->list_mac;
	}
	if(pblack_mac_list != NULL)
	{
		Bmacnode = pblack_mac_list->list_mac;
	}

	/*fengwenchao add end*/
	
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&state,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		if(WTP)
		{
			WID_FREE(WTP);
			WTP = NULL;
		}
		return NULL;
	}


	//printf("received state:%d\n",state);

	//CWThreadMutexLock(&(gACChannelMutex));
	if(gapscanset.opstate == 0)
	{
		ret = WID_AP_SCANNING_DISABLE;
	}
	else
	{
		progueaplist = wid_check_rogue_ap_all();
		if(gmacfilterflag == 1)
		{
			delete_rouge_ap_list_by_whitelist(&(progueaplist));
		}
		delete_rouge_ap_list_by_ouilist(&(progueaplist));
		if(gessidfilterflag == 1)
		{
			delete_rouge_ap_list_by_essidlist(&(progueaplist));
		}

		if(progueaplist == NULL)
		{
			ret = WTP_NO_NEIGHBORAP;
		}
	}
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if(ret == WID_DBUS_SUCCESS)
	{	
		if(progueaplist != NULL)
		{
			rouge_ap_count = progueaplist->neighborapInfosCount;
			phead = progueaplist->neighborapInfos;
		}else{
			wid_syslog_debug_debug(WID_DEFAULT,"progueaplist  =  NULL\n");				
		}
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &rouge_ap_count);
		/*fengwenchao add 20110401*/
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &wtp_online_num);
		/*fengwenchao add end*/
		
		dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_UINT16_AS_STRING //rate
											
											DBUS_TYPE_BYTE_AS_STRING //channel
											DBUS_TYPE_BYTE_AS_STRING //rssi
											DBUS_TYPE_BYTE_AS_STRING //noise
											DBUS_TYPE_BYTE_AS_STRING //beacon interval
											
											DBUS_TYPE_BYTE_AS_STRING //status
											DBUS_TYPE_BYTE_AS_STRING //oprate status
											DBUS_TYPE_UINT16_AS_STRING //capability
											
											/*fengwenchao add 20110401*/
											DBUS_TYPE_UINT32_AS_STRING   //RogueAPToIgnore
											DBUS_TYPE_UINT32_AS_STRING   //RogueAPAttackedStatus
											/*fengwenchao add end*/
		
											DBUS_TYPE_ARRAY_AS_STRING
											DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
											DBUS_STRUCT_END_CHAR_AS_STRING
											DBUS_TYPE_STRING_AS_STRING //ie infor
											DBUS_TYPE_UINT32_AS_STRING //first detect time
											DBUS_TYPE_UINT32_AS_STRING // 
											DBUS_TYPE_BYTE_AS_STRING //encry type
											DBUS_TYPE_BYTE_AS_STRING // policy

									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);		

		for(i = 0; (i < rouge_ap_count)&&(phead); i++)
		{	
			/*fengwenchao add 20110401*/

			phead->RogueAPToIgnore = 0;
			phead->RogueAPAttackedStatus = 0;

			while(Wmacnode)
			{
				if((Wmacnode->elem_mac!=NULL)&&(memcmp((phead->BSSID),Wmacnode->elem_mac,6) == 0))
				{
					phead->RogueAPToIgnore = 1;
					break;
				}
				Wmacnode = Wmacnode->next;
			}
			while(Bmacnode)
			{			
				if((Bmacnode->elem_mac!=NULL)&&(memcmp((phead->BSSID),Bmacnode->elem_mac,6) == 0))
				{
					phead->RogueAPAttackedStatus = 1;
					break;
				}
				Bmacnode = Bmacnode->next;
			}

			/*fengwenchao add end*/
			DBusMessageIter iter_struct;
			DBusMessageIter  iter_sub_array;
			dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BSSID[0]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BSSID[1]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BSSID[2]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BSSID[3]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BSSID[4]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BSSID[5]));

			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT16,
						  &(phead->Rate));
			
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->Channel));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->RSSI));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->NOISE));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BEACON_INT));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->status));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->opstatus));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT16,
						  &(phead->capabilityinfo));

			/*fengwenchao add 20110401*/
			dbus_message_iter_append_basic
						(&iter_struct,
					  	 DBUS_TYPE_UINT32,
					    &(phead->RogueAPToIgnore));

			dbus_message_iter_append_basic
						(&iter_struct,
					  	 DBUS_TYPE_UINT32,
					    &(phead->RogueAPAttackedStatus));
			/*fengwenchao add end*/
						
			dbus_message_iter_open_container (&iter_struct,
								   DBUS_TYPE_ARRAY,
								   DBUS_STRUCT_BEGIN_CHAR_AS_STRING  
									  DBUS_TYPE_BYTE_AS_STRING
								   DBUS_STRUCT_END_CHAR_AS_STRING, 
								   &iter_sub_array);
			for(j=0;j<ESSID_DEFAULT_LEN+1;j++)
			{
				DBusMessageIter iter_sub_struct;				
				dbus_message_iter_open_container (&iter_sub_array,
													DBUS_TYPE_STRUCT,
													NULL,
												  &iter_sub_struct);
				dbus_message_iter_append_basic
							(&iter_sub_struct,
							  DBUS_TYPE_BYTE,
							  &(phead->ESSID[j]));
				dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);
			}
			dbus_message_iter_close_container (&iter_struct, &iter_sub_array);	
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_STRING,
						  &(phead->IEs_INFO));
			
			dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_UINT32,
					  &(phead->fst_dtc_tm));
			
			dbus_message_iter_append_basic
				(&iter_struct,
				  DBUS_TYPE_UINT32,
				  &(phead->lst_dtc_tm));
			dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(phead->encrp_type));
			dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(phead->polcy));

			dbus_message_iter_close_container (&iter_array, &iter_struct);

			phead = phead->next;

		}
				
		dbus_message_iter_close_container (&iter, &iter_array);
	}			

	if(progueaplist != NULL)
	{
		destroy_ap_info_list(&progueaplist);
	}
	/*fengwenchao add 20110401*/
	if(WTP)
	{
		WID_FREE(WTP);
		WTP = NULL;
	}
	/*fengwenchao add end*/
	//CWThreadMutexUnlock(&gACChannelMutex);	
	return reply;	

}

DBusMessage * wid_dbus_interface_show_rogue_ap_list_bywtpid(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	//printf("#### 0000 #######################\n");
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter  iter_array;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int wtpid = 0;
	int state = 0;
	int i = 0;
	int j = 0;
	//char length = 0;
	//Neighbor_AP_INFOS *rogueaplist = NULL;
	struct Neighbor_AP_ELE *phead;
	int rouge_ap_count = 0;
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&state,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid >= WTP_NUM)
		ret = WTP_ID_LARGE_THAN_MAX;
	else{
		//printf("received wtpid:%d state:%d\n",wtpid,state);
		CWThreadMutexLock(&(gWTPs[wtpid].RRMThreadMutex));
		if(gapscanset.opstate == 0)
		{
			ret = WID_AP_SCANNING_DISABLE;
		}
		else
		{

			if(AC_WTP[wtpid] == NULL)
			{
				ret = WTP_ID_NOT_EXIST;
			}

			else if((AC_WTP[wtpid]->NeighborAPInfos == NULL)||(AC_WTP[wtpid]->NeighborAPInfos->neighborapInfosCount == 0))
			{
				ret = WTP_NO_NEIGHBORAP;
			}
		 	else 
			{
				if(AC_WTP[wtpid]->rouge_ap_infos == NULL)
				{
					AC_WTP[wtpid]->rouge_ap_infos = wid_check_rogue_ap_mac(wtpid);
					delete_rouge_ap_list_by_whitelist(&(AC_WTP[wtpid]->rouge_ap_infos));

				}
				else
				{
					if((AC_WTP[wtpid]->rouge_ap_infos) != NULL)
					{
						destroy_ap_info_list(&(AC_WTP[wtpid]->rouge_ap_infos));
					}
					AC_WTP[wtpid]->rouge_ap_infos = wid_check_rogue_ap_mac(wtpid);
					delete_rouge_ap_list_by_whitelist(&(AC_WTP[wtpid]->rouge_ap_infos));
				}

				if((AC_WTP[wtpid]->rouge_ap_infos == NULL)||(AC_WTP[wtpid]->rouge_ap_infos->neighborapInfosCount == 0))
				{
					ret = WTP_NO_NEIGHBORAP;
				}

			}
		}
		//printf("##wid_dbus_interface_show_rogue_ap_list_bywtpid ret = %d##\n",ret);
	}
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);

	if(ret == WID_DBUS_SUCCESS)
	{	
		// Total slot count
		//printf("##wid_dbus_interface_show_rogue_ap_list_bywtpid rouge_ap_count = %d##\n",AC_WTP[wtpid]->rouge_ap_infos->neighborapInfosCount);
		if( AC_WTP[wtpid]->rouge_ap_infos != NULL)
		{
			rouge_ap_count = AC_WTP[wtpid]->rouge_ap_infos->neighborapInfosCount;
			phead = AC_WTP[wtpid]->rouge_ap_infos->neighborapInfos;
		}else{
			wid_syslog_debug_debug(WID_DEFAULT," AC_WTP[%d]->rouge_ap_infos  =  NULL\n",wtpid);				
		}
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &rouge_ap_count);
		
		
		dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_UINT16_AS_STRING //rate
											
											DBUS_TYPE_BYTE_AS_STRING //channel
											DBUS_TYPE_BYTE_AS_STRING //rssi
											DBUS_TYPE_BYTE_AS_STRING //noise
											DBUS_TYPE_BYTE_AS_STRING //beacon interval
											
											DBUS_TYPE_BYTE_AS_STRING //status
											DBUS_TYPE_BYTE_AS_STRING //oprate status
											DBUS_TYPE_UINT16_AS_STRING //capability
											
											DBUS_TYPE_ARRAY_AS_STRING
											DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
											DBUS_STRUCT_END_CHAR_AS_STRING
											DBUS_TYPE_STRING_AS_STRING //ie infor

									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);		

		for(i = 0; (i < rouge_ap_count)&&(phead); i++)
		{	
			
			
			DBusMessageIter iter_struct;
			DBusMessageIter  iter_sub_array;
			dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);

			//printf("assemble data num = %d, mac = %s\n",i,phead->BSSID);
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BSSID[0]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BSSID[1]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BSSID[2]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BSSID[3]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BSSID[4]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BSSID[5]));

			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT16,
						  &(phead->Rate));
			
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->Channel));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->RSSI));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->NOISE));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BEACON_INT));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->status));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->opstatus));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT16,
						  &(phead->capabilityinfo));
			
			dbus_message_iter_open_container (&iter_struct,
								   DBUS_TYPE_ARRAY,
								   DBUS_STRUCT_BEGIN_CHAR_AS_STRING  
									  DBUS_TYPE_BYTE_AS_STRING
								   DBUS_STRUCT_END_CHAR_AS_STRING, 
								   &iter_sub_array);
			for(j=0;j<ESSID_DEFAULT_LEN+1;j++)
			{
				DBusMessageIter iter_sub_struct;				
				dbus_message_iter_open_container (&iter_sub_array,
													DBUS_TYPE_STRUCT,
													NULL,
												  &iter_sub_struct);
				dbus_message_iter_append_basic
							(&iter_sub_struct,
							  DBUS_TYPE_BYTE,
							  &(phead->ESSID[j]));
				dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);
			}
			dbus_message_iter_close_container (&iter_struct, &iter_sub_array);	
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_STRING,
						  &(phead->IEs_INFO));

			dbus_message_iter_close_container (&iter_array, &iter_struct);

			phead = phead->next;

		}
				
		dbus_message_iter_close_container (&iter, &iter_array);
	}			
	
	//printf("##wid_dbus_interface_show_rogue_ap_list_bywtpid end ###########\n");	
	//CWThreadMutexUnlock(&gACChannelMutex);	
	CWThreadMutexUnlock(&(gWTPs[wtpid].RRMThreadMutex));
	return reply;		

}

DBusMessage * wid_dbus_interface_show_neighbor_ap_list(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter  iter_array;
	DBusMessageIter  iter_struct;
	DBusMessageIter	 iter_sub_array;
	DBusMessageIter  iter_sub_struct;
	DBusMessageIter  iter_sub_sub_array;
	DBusMessageIter	 iter_sub_sub_struct;
	DBusMessageIter  iter_sub_sub_sub_array;
	DBusMessageIter  iter_sub_sub_sub_struct;
	DBusError err;
	dbus_error_init(&err);	

	//printf("accessinto wid\n");
	
	int ret = WID_DBUS_SUCCESS;
	int ret1 = WID_DBUS_SUCCESS;
//	int wtpid = 0;
	int state = 0;
	int i = 0;
	int j = 0;
	int k = 0;
	int q = 0;
	int wtp_num = 0;

	unsigned char nullessid = 0 ;
	unsigned char nullbssid[MAC_LEN] = {0};
	unsigned char nullchar = 0;
	unsigned int nullint = 0;
	unsigned short nullshort = 0;
	
	char* nullinfo = " 0 ";	
	//char* nullessid ;	
	struct Neighbor_AP_ELE *phead;

	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	if(NULL == mac){
		return NULL;
	}

	WID_WTP **WTP;
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	if(NULL == WTP){
		CW_FREE_OBJECT_WID(mac);
		return NULL;
	}
	wtp_num = Wid_Find_Wtp(WTP);

	
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&state,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		CW_FREE_OBJECT_WID(WTP);
		CW_FREE_OBJECT_WID(mac);
		return NULL;
	}

	if(wtp_num == 0)
		ret = WTP_ID_NOT_EXIST;

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	//printf("ret = %d \n",ret);
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &wtp_num);

	//printf("wtp_num = %d \n",wtp_num);
	dbus_message_iter_open_container (&iter,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_UINT32_AS_STRING       //wtpid
	                                            DBUS_TYPE_BYTE_AS_STRING		 //mac1
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING		//mac 6
												DBUS_TYPE_BYTE_AS_STRING 	  //radio_num
												   DBUS_TYPE_ARRAY_AS_STRING
												   DBUS_STRUCT_BEGIN_CHAR_AS_STRING
	                                            		DBUS_TYPE_UINT32_AS_STRING	   //wtpWirelessIfIndex
	                                            		DBUS_TYPE_UINT32_AS_STRING      //ret1
	                                            		DBUS_TYPE_UINT32_AS_STRING      //rouge_ap_count 
														    DBUS_TYPE_ARRAY_AS_STRING
															DBUS_STRUCT_BEGIN_CHAR_AS_STRING
																	DBUS_TYPE_BYTE_AS_STRING //mac
																	DBUS_TYPE_BYTE_AS_STRING //mac
																	DBUS_TYPE_BYTE_AS_STRING //mac
																	DBUS_TYPE_BYTE_AS_STRING //mac
																	DBUS_TYPE_BYTE_AS_STRING //mac
																	DBUS_TYPE_BYTE_AS_STRING //mac
																	DBUS_TYPE_UINT32_AS_STRING //wtpid
																	DBUS_TYPE_UINT16_AS_STRING //rate
																	
																	DBUS_TYPE_BYTE_AS_STRING //channel
																	DBUS_TYPE_BYTE_AS_STRING //rssi
																	DBUS_TYPE_BYTE_AS_STRING //noise
																	DBUS_TYPE_BYTE_AS_STRING //beacon interval
																	
																	DBUS_TYPE_BYTE_AS_STRING //status
																	DBUS_TYPE_BYTE_AS_STRING //oprate status
																	DBUS_TYPE_UINT16_AS_STRING //capability
																	
																	DBUS_TYPE_ARRAY_AS_STRING
																	DBUS_STRUCT_BEGIN_CHAR_AS_STRING
																		DBUS_TYPE_BYTE_AS_STRING
																	DBUS_STRUCT_END_CHAR_AS_STRING
																	DBUS_TYPE_STRING_AS_STRING //ie infor													
														  DBUS_STRUCT_END_CHAR_AS_STRING
												  DBUS_STRUCT_END_CHAR_AS_STRING

	                                      DBUS_STRUCT_END_CHAR_AS_STRING,
                                    &iter_array);
	
	for(i=0;i<wtp_num;i++)
	{
		unsigned char radio_num = 0;
		unsigned int  wtpid = 0;
		int wtpWirelessIfIndex = 0;
		int rouge_ap_count = 0;
		
		radio_num = WTP[i]->RadioCount;
		wtpid = WTP[i]->WTPID;

		memset(mac,0,MAC_LEN+1);
		if(WTP[i]->WTPMAC != NULL)
			memcpy(mac,WTP[i]->WTPMAC,MAC_LEN);	

		dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
	
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_UINT32,
										&(WTP[i]->WTPID));
		
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[0]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[1]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[2]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[3]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[4]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&(mac[5]));
		dbus_message_iter_append_basic(&iter_struct,
										DBUS_TYPE_BYTE,&radio_num);

		//printf("WTP[i]->WTPID  =  %d\n",WTP[i]->WTPID);
		//printf("mac =  %s \n",mac);
		//printf("radio_num = %d \n",radio_num);


		 dbus_message_iter_open_container (&iter_struct,					 	
									  DBUS_TYPE_ARRAY,
									  DBUS_STRUCT_BEGIN_CHAR_AS_STRING
										   DBUS_TYPE_UINT32_AS_STRING	  //wtpWirelessIfIndex															   
										   DBUS_TYPE_UINT32_AS_STRING	   //ret1
										   DBUS_TYPE_UINT32_AS_STRING      //rouge_ap_count
											   DBUS_TYPE_ARRAY_AS_STRING
											   DBUS_STRUCT_BEGIN_CHAR_AS_STRING
													   DBUS_TYPE_BYTE_AS_STRING //mac
													   DBUS_TYPE_BYTE_AS_STRING //mac
													   DBUS_TYPE_BYTE_AS_STRING //mac
													   DBUS_TYPE_BYTE_AS_STRING //mac
													   DBUS_TYPE_BYTE_AS_STRING //mac
													   DBUS_TYPE_BYTE_AS_STRING //mac
													   DBUS_TYPE_UINT32_AS_STRING //wtpid
													   DBUS_TYPE_UINT16_AS_STRING //rate
													   
													   DBUS_TYPE_BYTE_AS_STRING //channel
													   DBUS_TYPE_BYTE_AS_STRING //rssi
													   DBUS_TYPE_BYTE_AS_STRING //noise
													   DBUS_TYPE_BYTE_AS_STRING //beacon interval
													   
													   DBUS_TYPE_BYTE_AS_STRING //status
													   DBUS_TYPE_BYTE_AS_STRING //oprate status
													   DBUS_TYPE_UINT16_AS_STRING //capability
													   
													   DBUS_TYPE_ARRAY_AS_STRING
													   DBUS_STRUCT_BEGIN_CHAR_AS_STRING
														   DBUS_TYPE_BYTE_AS_STRING
													   DBUS_STRUCT_END_CHAR_AS_STRING
													   DBUS_TYPE_STRING_AS_STRING //ie infor												   
											   DBUS_STRUCT_END_CHAR_AS_STRING
									 DBUS_STRUCT_END_CHAR_AS_STRING,
								&iter_sub_array);
		
		for(j=0;j<WTP[i]->RadioCount;j++)
		{
			if(j==0)
				{
					//printf("accessinto single radio\n");
					
					wtpWirelessIfIndex = 1;

					if(gapscanset.opstate == 0)
					{
						ret1 = WID_AP_SCANNING_DISABLE;
						
					}
					else if((WTP[i]->NeighborAPInfos == NULL)||(WTP[i]->NeighborAPInfos->neighborapInfosCount == 0))
					{
						ret1 = WTP_NO_NEIGHBORAP;
					}
					else	
					{
						rouge_ap_count = WTP[i]->NeighborAPInfos->neighborapInfosCount;
						phead = WTP[i]->NeighborAPInfos->neighborapInfos;
						ret1 = WID_DBUS_SUCCESS;

					}	
				}
			else 
				{				
					if(j == 1){
					wtpWirelessIfIndex = 2;}
					if(j == 2){
					wtpWirelessIfIndex = 3;}
					if(j == 3){
					wtpWirelessIfIndex = 4;}

					if(gapscanset.opstate == 0)
					{
						ret1 = WID_AP_SCANNING_DISABLE;
					}
					else if((WTP[i]->NeighborAPInfos2 == NULL)||(WTP[i]->NeighborAPInfos2->neighborapInfosCount == 0))
					{
						ret1 = WTP_NO_NEIGHBORAP;
					}
					else	
					{
						rouge_ap_count = WTP[i]->NeighborAPInfos2->neighborapInfosCount;
						phead = WTP[i]->NeighborAPInfos2->neighborapInfos;
						ret1 = WID_DBUS_SUCCESS;

					}	
				}
			
					//printf("ret1 =   %d\n",ret1);


					 dbus_message_iter_open_container (&iter_sub_array,
		 									 			DBUS_TYPE_STRUCT,
		 									 			NULL,
											 			&iter_sub_struct);
					 dbus_message_iter_append_basic(&iter_sub_struct,
													DBUS_TYPE_UINT32,&wtpWirelessIfIndex);
					 //printf("wtpWirelessIfIndex = %d  \n",wtpWirelessIfIndex);

					 dbus_message_iter_append_basic(&iter_sub_struct,
													DBUS_TYPE_UINT32,&ret1);
					// printf("ret1 = %d \n",ret1);
					 dbus_message_iter_append_basic(&iter_sub_struct,
													DBUS_TYPE_UINT32,&rouge_ap_count);
					// printf("rouge_ap_count =  %d \n",rouge_ap_count);
					 

					
											
					dbus_message_iter_open_container (&iter_sub_struct,
													   DBUS_TYPE_ARRAY,
													   DBUS_STRUCT_BEGIN_CHAR_AS_STRING
															   DBUS_TYPE_BYTE_AS_STRING //mac
															   DBUS_TYPE_BYTE_AS_STRING //mac
															   DBUS_TYPE_BYTE_AS_STRING //mac
															   DBUS_TYPE_BYTE_AS_STRING //mac
															   DBUS_TYPE_BYTE_AS_STRING //mac
															   DBUS_TYPE_BYTE_AS_STRING //mac
															   DBUS_TYPE_UINT32_AS_STRING //wtpid
															   DBUS_TYPE_UINT16_AS_STRING //rate
															   
															   DBUS_TYPE_BYTE_AS_STRING //channel
															   DBUS_TYPE_BYTE_AS_STRING //rssi
															   DBUS_TYPE_BYTE_AS_STRING //noise
															   DBUS_TYPE_BYTE_AS_STRING //beacon interval
															   
															   DBUS_TYPE_BYTE_AS_STRING //status
															   DBUS_TYPE_BYTE_AS_STRING //oprate status
															   DBUS_TYPE_UINT16_AS_STRING //capability
															   
															   DBUS_TYPE_ARRAY_AS_STRING
															   DBUS_STRUCT_BEGIN_CHAR_AS_STRING
																   DBUS_TYPE_BYTE_AS_STRING
															   DBUS_STRUCT_END_CHAR_AS_STRING
															   DBUS_TYPE_STRING_AS_STRING //ie infor												   
													   DBUS_STRUCT_END_CHAR_AS_STRING,
													 &iter_sub_sub_array);
						if(ret1 == WID_DBUS_SUCCESS)
		 					{	
								for(k = 0; (k < rouge_ap_count)&&(phead); k++)
								{							
									dbus_message_iter_open_container (&iter_sub_sub_array,
																		DBUS_TYPE_STRUCT,
																		NULL,
																		&iter_sub_sub_struct);
								
									dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_BYTE,&(phead->BSSID[0]));
									
									dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_BYTE,&(phead->BSSID[1]));
													
									dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_BYTE,&(phead->BSSID[2]));
																																		  								
									dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_BYTE,&(phead->BSSID[3]));
																							 											 
									dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_BYTE,&(phead->BSSID[4]));
																							  											  								
									dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_BYTE,&(phead->BSSID[5]));
																							  											  
									dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_UINT32,&(phead->wtpid));
																							  											 							
									dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_UINT16,&(phead->Rate));																						  
												  																
									dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_BYTE,&(phead->Channel));											
												 											
									dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_BYTE, &(phead->RSSI));																						  
												 
									dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_BYTE,&(phead->NOISE));
																							  											  
									dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_BYTE,&(phead->BEACON_INT));
																							 											  								
									dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_BYTE,&(phead->status));
																							  											  								
									dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_BYTE,&(phead->opstatus));
																							  											  								
									dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_UINT16,&(phead->capabilityinfo));
																							  											  								
									dbus_message_iter_open_container (&iter_sub_sub_struct,
														   				DBUS_TYPE_ARRAY,
														   				DBUS_STRUCT_BEGIN_CHAR_AS_STRING  
																		  DBUS_TYPE_BYTE_AS_STRING
														   				DBUS_STRUCT_END_CHAR_AS_STRING, 
														   			  &iter_sub_sub_sub_array);
									for(q = 0;q<ESSID_DEFAULT_LEN+1;q++)
									{				
										dbus_message_iter_open_container (&iter_sub_sub_sub_array,
																			DBUS_TYPE_STRUCT,
																			NULL,
																		  &iter_sub_sub_sub_struct);
										dbus_message_iter_append_basic
													(&iter_sub_sub_sub_struct,
													  DBUS_TYPE_BYTE,
													  &(phead->ESSID[q]));
										dbus_message_iter_close_container (&iter_sub_sub_sub_array, &iter_sub_sub_sub_struct);
									}
									dbus_message_iter_close_container (&iter_sub_sub_struct, &iter_sub_sub_sub_array);	
								
									dbus_message_iter_append_basic
												(&iter_sub_sub_struct,
												  DBUS_TYPE_STRING,
												  &(phead->IEs_INFO));
								
									dbus_message_iter_close_container (&iter_sub_sub_array, &iter_sub_sub_struct);							
									phead = phead->next;							
								}
							dbus_message_iter_close_container (&iter_sub_struct, &iter_sub_sub_array);	
						}
					else
						{	
								//for(k = 0; k < rouge_ap_count; k++)
								
								//{			

									//nullessid = (char*)malloc(ESSID_DEFAULT_LEN);
									//memset(nullessid,0,ESSID_DEFAULT_LEN);
									dbus_message_iter_open_container (&iter_sub_sub_array,
																		DBUS_TYPE_STRUCT,
																		NULL,
																		&iter_sub_sub_struct);
									
									dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_BYTE,&nullbssid[0]);
									
									dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_BYTE,&nullbssid[1]);
													
									dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_BYTE,&nullbssid[2]);
																																		  								
									dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_BYTE,&nullbssid[3]);
																							 											 
									dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_BYTE,&nullbssid[4]);
																							  											  								
									dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_BYTE,&nullbssid[5]);
																							  											  
									dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_UINT32,&nullint);

									//printf("nullint =  %d  \n",nullint);
																							  											 							
									dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_UINT16,&nullshort);

									//printf("nullshort =  %d \n",nullshort);
												  																
									dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_BYTE,&nullchar);											
												 											
									dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_BYTE, &nullchar);																						  
												 
									dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_BYTE,&nullchar);
																							  											  
									dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_BYTE,&nullchar);
																							 											  								
									dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_BYTE,&nullchar);
																							  											  								
									dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_BYTE,&nullchar);
																							  											  								
									dbus_message_iter_append_basic(&iter_sub_sub_struct,DBUS_TYPE_UINT16,&nullshort);
																							  											  								
									dbus_message_iter_open_container (&iter_sub_sub_struct,
														   				DBUS_TYPE_ARRAY,
														   				DBUS_STRUCT_BEGIN_CHAR_AS_STRING  
																		  DBUS_TYPE_BYTE_AS_STRING
														   				DBUS_STRUCT_END_CHAR_AS_STRING, 
														   			  &iter_sub_sub_sub_array);
									//for(q = 0;q<ESSID_DEFAULT_LEN;q++)
									//{				
										dbus_message_iter_open_container (&iter_sub_sub_sub_array,
																			DBUS_TYPE_STRUCT,
																			NULL,
																		  &iter_sub_sub_sub_struct);
										dbus_message_iter_append_basic
													(&iter_sub_sub_sub_struct,
													  DBUS_TYPE_BYTE,
													  &nullessid);
										dbus_message_iter_close_container (&iter_sub_sub_sub_array, &iter_sub_sub_sub_struct);
								//	}
									dbus_message_iter_close_container (&iter_sub_sub_struct, &iter_sub_sub_sub_array);	
								
									dbus_message_iter_append_basic
												(&iter_sub_sub_struct,
												  DBUS_TYPE_STRING,
												  &nullinfo);
									//printf("nullessid = %d\n",nullessid);
									//printf("nullinfo = %s \n",nullinfo);
									dbus_message_iter_close_container (&iter_sub_sub_array, &iter_sub_sub_struct);							
								//	phead = phead->next;							
								//}
								//free(nullessid);
							//	nullessid = NULL;
							dbus_message_iter_close_container (&iter_sub_struct, &iter_sub_sub_array);	
					}	
					dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);
					dbus_message_iter_close_container (&iter_struct, &iter_sub_array);				
				}
				dbus_message_iter_close_container (&iter_array, &iter_struct);		
			}	
	dbus_message_iter_close_container (&iter,&iter_array);
	CW_FREE_OBJECT_WID(WTP);
	CW_FREE_OBJECT_WID(mac);
	//printf("over LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL");
	return reply;
}
//fengwenchao add end

DBusMessage * wid_dbus_interface_show_neighbor_ap_list_bywtpid(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	//printf("#### 0000 #######################\n");
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter  iter_array;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int wtpid = 0;
	int state = 0;
	int i = 0;
	int j = 0;
	//char length = 0;
	//Neighbor_AP_INFOS *rogueaplist = NULL;
	struct Neighbor_AP_ELE *phead;
	int rouge_ap_count = 0;
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&state,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	CWThreadMutexLock(&(gWTPs[wtpid].RRMThreadMutex));

	if(wtpid >= WTP_NUM)
		ret = WTP_ID_LARGE_THAN_MAX;
	else{
	//	CWThreadMutexLock(&(gACChannelMutex));

		//printf("received wtpid:%d state:%d\n",wtpid,state);
		if(gapscanset.opstate == 0)
		{
			ret = WID_AP_SCANNING_DISABLE;
		}
		else
		{

			if(AC_WTP[wtpid] == NULL)
			{
				ret = WTP_ID_NOT_EXIST;
			}

			else if((AC_WTP[wtpid]->NeighborAPInfos == NULL)||(AC_WTP[wtpid]->NeighborAPInfos->neighborapInfosCount == 0))
			{
				ret = WTP_NO_NEIGHBORAP;
			}
		 	else 
			{

			}
		}
	}
	//printf("##wid_dbus_interface_show_rogue_ap_list_bywtpid ret = %d##\n",ret);

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);

	if(ret == WID_DBUS_SUCCESS)
	{	
		// Total slot count
		//printf("##wid_dbus_interface_show_rogue_ap_list_bywtpid rouge_ap_count = %d##\n",AC_WTP[wtpid]->rouge_ap_infos->neighborapInfosCount);
		if(AC_WTP[wtpid]->NeighborAPInfos != NULL)
		{
			rouge_ap_count = AC_WTP[wtpid]->NeighborAPInfos->neighborapInfosCount;
			phead = AC_WTP[wtpid]->NeighborAPInfos->neighborapInfos;
		}else{
		       wid_syslog_debug_debug(WID_DEFAULT," AC_WTP[%d]->NeighborAPInfos  =  NULL\n",wtpid);	
		}
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &rouge_ap_count);
		
		
		dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_UINT32_AS_STRING //wtpid
											DBUS_TYPE_UINT16_AS_STRING //rate
											
											DBUS_TYPE_BYTE_AS_STRING //channel
											DBUS_TYPE_BYTE_AS_STRING //rssi
											DBUS_TYPE_BYTE_AS_STRING //noise
											DBUS_TYPE_BYTE_AS_STRING //beacon interval
											
											DBUS_TYPE_BYTE_AS_STRING //status
											DBUS_TYPE_BYTE_AS_STRING //oprate status
											DBUS_TYPE_UINT16_AS_STRING //capability
											
											DBUS_TYPE_ARRAY_AS_STRING
											DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
											DBUS_STRUCT_END_CHAR_AS_STRING
											DBUS_TYPE_STRING_AS_STRING //ie infor

									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);		

		for(i = 0; (i < rouge_ap_count)&&(phead); i++)
		{	
			
			
			DBusMessageIter iter_struct;
			DBusMessageIter iter_sub_array;
			dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);

			//printf("assemble data num = %d, mac = %s\n",i,phead->BSSID);
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BSSID[0]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BSSID[1]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BSSID[2]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BSSID[3]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BSSID[4]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BSSID[5]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(phead->wtpid));

			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT16,
						  &(phead->Rate));
			
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->Channel));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->RSSI));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->NOISE));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BEACON_INT));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->status));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->opstatus));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT16,
						  &(phead->capabilityinfo));
			
			dbus_message_iter_open_container (&iter_struct,
								   DBUS_TYPE_ARRAY,
								   DBUS_STRUCT_BEGIN_CHAR_AS_STRING  
									  DBUS_TYPE_BYTE_AS_STRING
								   DBUS_STRUCT_END_CHAR_AS_STRING, 
								   &iter_sub_array);
			for(j=0;j<ESSID_DEFAULT_LEN+1;j++)
			{
				DBusMessageIter iter_sub_struct;				
				dbus_message_iter_open_container (&iter_sub_array,
													DBUS_TYPE_STRUCT,
													NULL,
												  &iter_sub_struct);
				dbus_message_iter_append_basic
							(&iter_sub_struct,
							  DBUS_TYPE_BYTE,
							  &(phead->ESSID[j]));
				dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);
			}
			dbus_message_iter_close_container (&iter_struct, &iter_sub_array);	

			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_STRING,
						  &(phead->IEs_INFO));

			dbus_message_iter_close_container (&iter_array, &iter_struct);

			phead = phead->next;

		}
				
		dbus_message_iter_close_container (&iter, &iter_array);
	}			
	//CWThreadMutexUnlock(&gACChannelMutex);	
	CWThreadMutexUnlock(&(gWTPs[wtpid].RRMThreadMutex));
	//printf("##wid_dbus_interface_show_rogue_ap_list_bywtpid end ###########\n");	
	return reply;		

}

DBusMessage * wid_dbus_interface_show_neighbor_ap_list_bywtpid2(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	//printf("#### 0000 #######################\n");
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter  iter_array;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int wtpid = 0;
	int state = 0;
	int i = 0;
	int j = 0;
	//char length = 0;
	//Neighbor_AP_INFOS *rogueaplist = NULL;
	struct Neighbor_AP_ELE *phead;
	int rouge_ap_count = 0;
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&state,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	CWThreadMutexLock(&(gWTPs[wtpid].RRMThreadMutex));

	if(wtpid >= WTP_NUM)
		ret = WTP_ID_LARGE_THAN_MAX;
	else{
	//	CWThreadMutexLock(&(gACChannelMutex));

		//printf("received wtpid:%d state:%d\n",wtpid,state);
		if(gapscanset.opstate == 0)
		{
			ret = WID_AP_SCANNING_DISABLE;
		}
		else
		{

			if(AC_WTP[wtpid] == NULL)
			{
				ret = WTP_ID_NOT_EXIST;
			}

			else if((AC_WTP[wtpid]->NeighborAPInfos2 == NULL)||(AC_WTP[wtpid]->NeighborAPInfos2->neighborapInfosCount == 0))
			{
				ret = WTP_NO_NEIGHBORAP;
			}
		 	else 
			{

			}
		}
	}
	//printf("##wid_dbus_interface_show_rogue_ap_list_bywtpid ret = %d##\n",ret);

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);

	if(ret == WID_DBUS_SUCCESS)
	{	
		// Total slot count
		//printf("##wid_dbus_interface_show_rogue_ap_list_bywtpid rouge_ap_count = %d##\n",AC_WTP[wtpid]->rouge_ap_infos->neighborapInfosCount);
		if(AC_WTP[wtpid]->NeighborAPInfos2 != NULL)
		{
			rouge_ap_count = AC_WTP[wtpid]->NeighborAPInfos2->neighborapInfosCount;
			phead = AC_WTP[wtpid]->NeighborAPInfos2->neighborapInfos;
		}else{
			wid_syslog_debug_debug(WID_DEFAULT," AC_WTP[%d]->NeighborAPInfos2  =  NULL\n",wtpid);			
		}
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &rouge_ap_count);
		
		
		dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_UINT32_AS_STRING //wtpid
											DBUS_TYPE_UINT16_AS_STRING //rate
											
											DBUS_TYPE_BYTE_AS_STRING //channel
											DBUS_TYPE_BYTE_AS_STRING //rssi
											DBUS_TYPE_BYTE_AS_STRING //noise
											DBUS_TYPE_BYTE_AS_STRING //beacon interval
											
											DBUS_TYPE_BYTE_AS_STRING //status
											DBUS_TYPE_BYTE_AS_STRING //oprate status
											DBUS_TYPE_UINT16_AS_STRING //capability
											
											DBUS_TYPE_ARRAY_AS_STRING
											DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
											DBUS_STRUCT_END_CHAR_AS_STRING
											DBUS_TYPE_STRING_AS_STRING //ie infor

									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);		

		for(i = 0; i < rouge_ap_count; i++)
		{	
			
			
			DBusMessageIter iter_struct;
			DBusMessageIter iter_sub_array;
			dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);

			//printf("assemble data num = %d, mac = %s\n",i,phead->BSSID);
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BSSID[0]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BSSID[1]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BSSID[2]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BSSID[3]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BSSID[4]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BSSID[5]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(phead->wtpid));

			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT16,
						  &(phead->Rate));
			
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->Channel));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->RSSI));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->NOISE));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->BEACON_INT));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->status));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->opstatus));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT16,
						  &(phead->capabilityinfo));
			
			dbus_message_iter_open_container (&iter_struct,
								   DBUS_TYPE_ARRAY,
								   DBUS_STRUCT_BEGIN_CHAR_AS_STRING  
									  DBUS_TYPE_BYTE_AS_STRING
								   DBUS_STRUCT_END_CHAR_AS_STRING, 
								   &iter_sub_array);
			for(j=0;j<ESSID_DEFAULT_LEN+1;j++)
			{
				DBusMessageIter iter_sub_struct;				
				dbus_message_iter_open_container (&iter_sub_array,
													DBUS_TYPE_STRUCT,
													NULL,
												  &iter_sub_struct);
				dbus_message_iter_append_basic
							(&iter_sub_struct,
							  DBUS_TYPE_BYTE,
							  &(phead->ESSID[j]));
				dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);
			}
			dbus_message_iter_close_container (&iter_struct, &iter_sub_array);	

			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_STRING,
						  &(phead->IEs_INFO));

			dbus_message_iter_close_container (&iter_array, &iter_struct);

			phead = phead->next;

		}
				
		dbus_message_iter_close_container (&iter, &iter_array);
	}			
	//CWThreadMutexUnlock(&gACChannelMutex);	
	CWThreadMutexUnlock(&(gWTPs[wtpid].RRMThreadMutex));
	//printf("##wid_dbus_interface_show_rogue_ap_list_bywtpid end ###########\n");	
	return reply;		

}


DBusMessage * wid_dbus_interface_show_wids_statistics_list_bywtpid(DBusConnection *conn, DBusMessage *msg, void *user_data)
{

	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);	
	
	int ret = WID_DBUS_SUCCESS;
	int wtpid = 0;
	int state = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&state,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid >= WTP_NUM)
	{
		ret = WTP_ID_LARGE_THAN_MAX;
	}
	
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}


	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	if(ret == WID_DBUS_SUCCESS)
	{	
		//  00001 1 0 0 
		//printf("00001 %d %d %d \n",AC_WTP[wtpid]->wids_statist.floodingcount,AC_WTP[wtpid]->wids_statist.sproofcount,AC_WTP[wtpid]->wids_statist.weakivcount);
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &(AC_WTP[wtpid]->wids_statist.floodingcount));	

		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &(AC_WTP[wtpid]->wids_statist.sproofcount));	
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &(AC_WTP[wtpid]->wids_statist.weakivcount));	
	}


	return reply;		

}

DBusMessage * wid_dbus_interface_clear_wids_statistics_list_bywtpid(DBusConnection *conn, DBusMessage *msg, void *user_data)
{

	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);	
	
	int ret = WID_DBUS_SUCCESS;
	int wtpid = 0;
	int state = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&state,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid >= WTP_NUM)
	{
		ret = WTP_ID_LARGE_THAN_MAX;
	}
	
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}


	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	if(ret == WID_DBUS_SUCCESS)
	{	
		AC_WTP[wtpid]->wids_statist.floodingcount = 0;
		AC_WTP[wtpid]->wids_statist.sproofcount = 0;
		AC_WTP[wtpid]->wids_statist.weakivcount = 0;
	}


	return reply;		

}

DBusMessage * wid_dbus_interface_show_wids_statistics_list(DBusConnection *conn, DBusMessage *msg, void *user_data)
{

	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);	
	
	int ret = WID_DBUS_SUCCESS;
	int wtpid = 0;
	int state = 0;
	int i = 0;

	wid_wids_statistics gwidsstics = {0};;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&state,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	for(i=0;i<WTP_NUM;i++)
	{
		if(AC_WTP[i] != NULL)
		{
			gwidsstics.floodingcount += AC_WTP[i]->wids_statist.floodingcount;
			gwidsstics.sproofcount+= AC_WTP[i]->wids_statist.sproofcount;
			gwidsstics.weakivcount+= AC_WTP[i]->wids_statist.weakivcount;
		}
	}


	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	if(ret == WID_DBUS_SUCCESS)
	{	
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &(gwidsstics.floodingcount));	

		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &(gwidsstics.sproofcount));	
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &(gwidsstics.weakivcount));	
	}


	return reply;		

}

DBusMessage * wid_dbus_interface_clear_wids_statistics_list(DBusConnection *conn, DBusMessage *msg, void *user_data)
{

	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);	
	
	int ret = WID_DBUS_SUCCESS;
	int wtpid = 0;
	int state = 0;
	int i = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&state,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	for(i=0;i<WTP_NUM;i++)
	{
		if(AC_WTP[i] != NULL)
		{
			AC_WTP[i]->wids_statist.floodingcount = 0;
			AC_WTP[i]->wids_statist.sproofcount = 0;
			AC_WTP[i]->wids_statist.weakivcount = 0;
		}
	}



	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);

	return reply;		

}

DBusMessage * wid_dbus_interface_clear_wids_device_list_bywtpid(DBusConnection *conn, DBusMessage *msg, void *user_data)
{

	DBusMessage* reply; 
	DBusMessageIter  iter;
	DBusError err;
	dbus_error_init(&err);	
	
	int ret = WID_DBUS_SUCCESS;
	int wtpid = 0;
	int state = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&state,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(wtpid >= WTP_NUM)
	{
		ret = WTP_ID_LARGE_THAN_MAX;
	}
	
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	
	if(ret == WID_DBUS_SUCCESS)
	{
		if((AC_WTP[wtpid]->wids_device_list) != NULL)
		{
			CWThreadMutexLock(&(gWTPs[wtpid].WIDSThreadMutex));
			delete_wids_list(&(AC_WTP[wtpid]->wids_device_list));
			CWThreadMutexUnlock(&(gWTPs[wtpid].WIDSThreadMutex));
		}
	}

						

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);

	return reply;		

}

DBusMessage * wid_dbus_interface_clear_wids_device_list(DBusConnection *conn, DBusMessage *msg, void *user_data)
{

	DBusMessage* reply; 
	DBusMessageIter  iter;
	DBusError err;
	dbus_error_init(&err);	
	
	int ret = WID_DBUS_SUCCESS;
	int wtpid = 0;
	int state = 0;
	int i = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&state,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	for(i=0;i<WTP_NUM;i++)
	{
		if((AC_WTP[i] != NULL)&&((AC_WTP[i]->wids_device_list) != NULL))
		{
			CWThreadMutexLock(&(gWTPs[i].WIDSThreadMutex));
			delete_wids_list(&(AC_WTP[i]->wids_device_list));
			CWThreadMutexUnlock(&(gWTPs[i].WIDSThreadMutex));
		}
	}



	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);

	return reply;		

}
DBusMessage * wid_dbus_interface_show_wids_device_list_bywtpid(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	
	DBusMessage* reply; 
	DBusMessageIter  iter;
	DBusMessageIter  iter_array;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int wtpid = 0;
	int state = 0;
	int i = 0;

	struct tag_wids_device_ele *phead;
	int wids_count = 0;
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&state,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid >= WTP_NUM)
	{
		ret = WTP_ID_LARGE_THAN_MAX;
	}
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if((AC_WTP[wtpid]->wids_device_list == NULL)||(AC_WTP[wtpid]->wids_device_list->count == 0))
	{
		ret = NO_WIDS_DEVICE;
	}
	else 
	{
	}
	

	CWThreadMutexLock(&(gWTPs[wtpid].WIDSThreadMutex));

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);

	if(ret == WID_DBUS_SUCCESS)
	{	
	
		wids_count = AC_WTP[wtpid]->wids_device_list->count;
		phead = AC_WTP[wtpid]->wids_device_list->wids_device_info;


		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &wids_count);
		
		
		dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac

											
											DBUS_TYPE_BYTE_AS_STRING //attacktype
											DBUS_TYPE_BYTE_AS_STRING //frametype

											
											DBUS_TYPE_UINT32_AS_STRING //attackcount;
											DBUS_TYPE_UINT32_AS_STRING //fst_attack
											DBUS_TYPE_UINT32_AS_STRING //lst_attack

									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);		

		for(i = 0; i < wids_count; i++)
		{	
			
			
			DBusMessageIter iter_struct;
				
			dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->bssid[0]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->bssid[1]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->bssid[2]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->bssid[3]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->bssid[4]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->bssid[5]));
	
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->attacktype));

			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->frametype));
			
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(phead->attackcount));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(phead->fst_attack));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(phead->lst_attack));

			dbus_message_iter_close_container (&iter_array, &iter_struct);

			phead = phead->next;

		}
				
		dbus_message_iter_close_container (&iter, &iter_array);
	}			


	CWThreadMutexUnlock(&(gWTPs[wtpid].WIDSThreadMutex));
	


	return reply;		

}

//fengwenchao add 20101227
DBusMessage * wid_dbus_interface_show_wids_device_of_all(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 
	DBusMessageIter  iter;
	DBusMessageIter  iter_array;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int state = 0;
	int i = 0;
	unsigned int lasttime = 0;
	struct tag_wids_device_ele *phead;
	wid_wids_device *pwidslist = NULL;
	int wids_count = 0;
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&state,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	pwidslist = wid_check_wids_device_all();
	lasttime = glasttimeinblack;
	if(pwidslist == NULL)
	{
		ret = NO_WIDS_DEVICE;
	}

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);

	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);

	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &lasttime);	
		
	if(ret == WID_DBUS_SUCCESS)
	{	
		
		wids_count = pwidslist->count;
		phead = pwidslist->wids_device_info;
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &wids_count);
		
		
		dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_UINT32_AS_STRING //fst_attack              //fengwenchao add 20110513
											DBUS_TYPE_UINT32_AS_STRING //lst_attack	             //fengwenchao add 20110513
											
										/*	DBUS_TYPE_BYTE_AS_STRING //attacktype
											DBUS_TYPE_BYTE_AS_STRING //frametype
	
											
											DBUS_TYPE_UINT32_AS_STRING //attackcount;
											DBUS_TYPE_UINT32_AS_STRING //fst_attack
											DBUS_TYPE_UINT32_AS_STRING //lst_attack
											DBUS_TYPE_BYTE_AS_STRING //channel
											DBUS_TYPE_BYTE_AS_STRING //rssi 										
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac*/
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);		
	
		for(i = 0; i < wids_count; i++)
		{	
			
			
			DBusMessageIter iter_struct;
				
			dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->bssid[0]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->bssid[1]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->bssid[2]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->bssid[3]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->bssid[4]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->bssid[5]));
			/*fengwenchao add 20110513*/
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(phead->fst_attack));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(phead->lst_attack));
			/*fengwenchao add end*/
		/*	dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->rssi));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->vapbssid[0]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->vapbssid[1]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->vapbssid[2]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->vapbssid[3]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->vapbssid[4]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->vapbssid[5]));*/
	
			dbus_message_iter_close_container (&iter_array, &iter_struct);
	
			phead = phead->next;
	
		}
				
		dbus_message_iter_close_container (&iter, &iter_array);
	}	
	
	if(pwidslist != NULL)
	{
		delete_wids_list(&pwidslist);
	}
	
	return reply;		
	
}
//fengwenchao add end
DBusMessage * wid_dbus_interface_show_wids_device_list(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 
	DBusMessageIter  iter;
	DBusMessageIter  iter_array;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int wtpid = 0;
	int state = 0;
	int i = 0;

	struct tag_wids_device_ele *phead;
	wid_wids_device *pwidslist = NULL;
	int wids_count = 0;
	wid_wids_set wids = {0};  //fengwenchao add 20110415
	wids = gwids; //fengwenchao add 20110415
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&state,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	pwidslist = wid_check_wids_device_all();

	//display_wids_info_list(pwidslist);

	if(pwidslist == NULL)
	{
		ret = NO_WIDS_DEVICE;
	}

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);

	if(ret == WID_DBUS_SUCCESS)
	{	
		
		wids_count = pwidslist->count;
		phead = pwidslist->wids_device_info;
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &wids_count);
		
		
		dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac

											
											DBUS_TYPE_BYTE_AS_STRING //attacktype
											DBUS_TYPE_BYTE_AS_STRING //frametype

											
											DBUS_TYPE_UINT32_AS_STRING //attackcount;
											DBUS_TYPE_UINT32_AS_STRING //fst_attack
											DBUS_TYPE_UINT32_AS_STRING //lst_attack
											DBUS_TYPE_BYTE_AS_STRING //channel
											DBUS_TYPE_BYTE_AS_STRING //rssi											
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);		

		for(i = 0; i < wids_count; i++)
		{	
			
			
			DBusMessageIter iter_struct;
				
			dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->bssid[0]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->bssid[1]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->bssid[2]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->bssid[3]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->bssid[4]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->bssid[5]));
	
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->attacktype));

			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->frametype));
			
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(phead->attackcount));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(phead->fst_attack));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(phead->lst_attack));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->channel));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->rssi));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->vapbssid[0]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->vapbssid[1]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->vapbssid[2]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->vapbssid[3]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->vapbssid[4]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(phead->vapbssid[5]));

			/*fengwenchao add 20110415*/
			
			dbus_message_iter_append_basic (&iter_struct,
											 DBUS_TYPE_BYTE,
											 &wids.weakiv); 	
			/*fengwenchao add end*/


			dbus_message_iter_close_container (&iter_array, &iter_struct);

			phead = phead->next;

		}
				
		dbus_message_iter_close_container (&iter, &iter_array);
	}	
	
	if(pwidslist != NULL)
	{
		delete_wids_list(&pwidslist);
	}

	return reply;		

}




DBusMessage * wid_dbus_interface_set_country_code(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
	int i = 0;
	int j = 0;
	int ret = COUNTRY_CODE_SUCCESS;
	int wtpid = 0 ;
	int radioid = 0;
	int country_code = COUNTRY_USA_US;//default value;
	//printf("country code1 %d\n",country_code);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&country_code,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&radioid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	//printf("country code2 %d\n",country_code);
	/*if (country_code == gCOUNTRYCODE)
	{
		ret = COUNTRY_CODE_NO_CHANGE;
	}

	else 
	{
		gCOUNTRYCODE = country_code;
	
		for(i=0;i<G_RADIO_NUM;i++)
		{
			if(AC_RADIO[i] != NULL)
				ret = WID_RADIO_SET_COUNTRYCODE(i);
		}
	
			
	}*/
	//printf("country code3 %d\n",gCOUNTRYCODE);
	//check wtp channel,decide whether to change
	//now system default value is us,so close this area

	/*wcl add for OSDEVTDPB-31*/
	if((wtpid == 0) && (radioid == 0))
	{
	
	gCOUNTRYCODE = country_code;
		for(j=0;j<WTP_NUM;j++){
			if(AC_WTP[j] != NULL){
				for(i=0;(i < AC_WTP[j]->RadioCount)&&(i < L_RADIO_NUM);i++){
					if(AC_WTP[j]->WTP_Radio[i] !=  NULL){
						if((AC_WTP[j]->WTP_Radio[i]->Radio_country_code == gCOUNTRYCODE)&&(country_code == gCOUNTRYCODE)){
							ret = COUNTRY_CODE_SUCCESS;
						}
						else
							{
							AC_WTP[j]->WTP_Radio[i]->Radio_country_code = country_code;
							ret = WID_RADIO_SET_COUNTRYCODE(j*4+i);
							WID_SET_COUNTRY_CODE_CHECK_CHAN(j*4+i);
						}
					}
				}
			}
		}
					
	}else if(wtpid != 0){
		if(AC_WTP[wtpid] != NULL)
		{
			for(i=0;(i < AC_WTP[wtpid]->RadioCount)&&(i<L_RADIO_NUM);i++)
			{
				if (country_code == AC_WTP[wtpid]->WTP_Radio[i]->Radio_country_code)
				{
					ret = COUNTRY_CODE_SUCCESS;
				}

				else 
				{
				
						if(AC_WTP[wtpid]->WTP_Radio[i] !=  NULL){
							AC_WTP[wtpid]->WTP_Radio[i]->Radio_country_code = country_code;
							ret = WID_RADIO_SET_COUNTRYCODE(wtpid*4+i);
							WID_SET_COUNTRY_CODE_CHECK_CHAN(wtpid*4+i);
						}
				}
			}
		}

	}else{
		if(AC_RADIO[radioid] != NULL)
		{
			if (country_code == AC_RADIO[radioid]->Radio_country_code)
			{
				ret = COUNTRY_CODE_SUCCESS;
			}

			else 
			{
				
				AC_RADIO[radioid]->Radio_country_code = country_code;
				ret = WID_RADIO_SET_COUNTRYCODE(radioid);		
				WID_SET_COUNTRY_CODE_CHECK_CHAN(radioid);
										
			}			
		}
	}
	/*end*/
/*	
	if (gCOUNTRYCODE == COUNTRY_USA_US)
	{
	wid_syslog_debug_debug(WID_DBUS,"111111111111111111111111\n");
		for(i=0;i<G_RADIO_NUM;i++)
		{	
		//wid_syslog_debug_debug(WID_DBUS,"2222222222222222222222\n");
			if(AC_RADIO[i] != NULL)
			{
			wid_syslog_debug_debug(WID_DBUS,"333333333333333333333333333\n");
				if(AC_RADIO[i]->Radio_Chan > 11)
				{
					wid_syslog_debug_debug(WID_DBUS,"444444444444444444444444444\n");
					ret1 = WID_RADIO_SET_CHAN(i,channel_change);
					wid_syslog_debug_debug(WID_DBUS,"555555555555555555555555555555\n");
				}
			}
		}
	}*//*wcl modify for OSDEVTDPB-31*/
	wid_set_country_code_a8();
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	
	wid_syslog_debug_debug(WID_DBUS,"set system country code %d\n",country_code);
	
	return reply;	
}
DBusMessage * wid_dbus_interface_undo_country_code(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
	int ret = COUNTRY_CODE_SUCCESS;
	int i = 0;
	int ret1 = 0;
	unsigned char channel_change = 11;
	int country_code = COUNTRY_USA_US;//default value
	//printf("country code1 %d\n",country_code);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&country_code,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	//printf("country code2 %d\n",country_code);
	if (country_code == gCOUNTRYCODE)
	{
		ret = COUNTRY_CODE_NO_CHANGE;
	}

	else 
	{
		gCOUNTRYCODE = country_code;//here global country code changes
	}

	
	if (gCOUNTRYCODE == COUNTRY_USA_US)
	{
	
		for(i=0;i<G_RADIO_NUM;i++)
		{	
			if(AC_RADIO[i] != NULL)
			{
				if(AC_RADIO[i]->Radio_Chan > 11)
				{
					
					ret1 = WID_RADIO_SET_CHAN(i,channel_change);
				}
			}
		}
	}
	//printf("country code3 %d\n",gCOUNTRYCODE);
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	
	wid_syslog_debug_debug(WID_DBUS,"set system country code %d\n",country_code);
	
	return reply;	
}
//////////////////////////auto ap area
DBusMessage * wid_dbus_interface_set_wid_auto_ap_login_switch(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
		
	int ret = WID_DBUS_SUCCESS;
	unsigned int dynamic_ap_login_switch = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&dynamic_ap_login_switch,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(dynamic_ap_login_switch == 1)
	{
		if((g_auto_ap_login.ifnum == 0)||(g_auto_ap_login.auto_ap_if == NULL))
		{
			ret = AUTO_AP_LOGIN_INTERFACE_NOT_SET;
		}
		else
		{
			g_auto_ap_login.auto_ap_switch = 1;
			ret = WID_DBUS_SUCCESS;
		}
		wid_syslog_debug_debug(WID_DBUS,"set wid auto_ap_login_switch %d\n",dynamic_ap_login_switch);
	}
	else if(dynamic_ap_login_switch == 0)
	{
		g_auto_ap_login.auto_ap_switch = 0;
		ret = WID_DBUS_SUCCESS;
		wid_syslog_debug_debug(WID_DBUS,"set wid auto_ap_login_switch %d\n",dynamic_ap_login_switch);
	}
	else
	{
		ret = WID_DBUS_ERROR;
	}

	
	reply = dbus_message_new_method_return(msg);
			
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	
	return reply;	

}
DBusMessage * wid_dbus_interface_set_wid_memory_trace_switch(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 
	DBusMessageIter  iter;
	DBusError err;
	dbus_error_init(&err);
		
	int ret = WID_DBUS_SUCCESS;
	unsigned int log_switch = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&log_switch,
								DBUS_TYPE_INVALID))){

		wid_syslog_err("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			wid_syslog_err("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	wid_memory_trace_switch = log_switch;
	wid_syslog_debug_debug(WID_DEFAULT, "set wid memory leak trace switch %s successfully\n", log_switch ? "enable" : "disable");
	ret = WID_DBUS_SUCCESS;

	
	reply = dbus_message_new_method_return(msg);
			
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;	

}

DBusMessage * wid_dbus_interface_set_wid_auto_ap_login_binding_l3_interface(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
	WTPQUITREASON quitreason = WTP_INIT;
	int ret = WID_DBUS_SUCCESS;
	int nocheck = 0;
	char* ifname;
	unsigned char policy = 2;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&policy,
								DBUS_TYPE_STRING,&ifname,
								DBUS_TYPE_UINT32,&nocheck,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	unsigned char ret_flag = 0;
	char *name;
	name = (char*)WID_MALLOC(strlen(ifname)+5);
	memset(name,0,strlen(ifname)+5);
	if(check_ve_interface(ifname,name)){
		wid_syslog_debug_debug(WID_DBUS,"input ve interface dosen't exist!\n");
		ret = APPLY_IF_FAIL;
		ret_flag = 1;
	}
	
	if(ret_flag == 0){
	if(g_auto_ap_login.auto_ap_switch == 1)
	{
		ret = SWITCH_IS_DISABLE;//config required to disable the switch
	}
	else
	{
		if(policy == 1)
		{
		//add for load auto_ap_login config
			if(1 == nocheck){
				isNoCheck = 1;
				wid_syslog_info("%s,%d,now is config load,not check if binding flag.\n",__func__,__LINE__);
			}
			ret = Check_And_Bind_Interface_For_WID(name);
			if(ret == 0)
				ret = wid_auto_ap_login_insert_iflist(name);
			if(0 != isNoCheck){
				isNoCheck = 0;
				wid_syslog_info("%s,%d,reset isNoCheck.\n",__func__,__LINE__);
			}
		}
		else if(policy == 0)
		{
			if(g_auto_ap_login.ifnum != 0)
			{
				ret = wid_auto_ap_login_remove_iflist(name);	
			}
			else
			{
				ret = INTERFACE_NOT_BE_BINDED;
			}
		}
	}
	}
	reply = dbus_message_new_method_return(msg);
			
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &quitreason);
	wid_syslog_debug_debug(WID_DBUS,"set wid auto_ap_login_interface %s\n",name);
	WID_FREE(name);
	name = NULL;
	//printf("set wid auto_ap_login_interface %s\n",g_AUTO_AP_LOGIN_BINDING_L3_INTERFACE);
	return reply;	

}
DBusMessage * wid_dbus_interface_set_wid_listen_l3_interface(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
	WTPQUITREASON quitreason = WTP_INIT;
	int ret = WID_DBUS_SUCCESS;
	char* ifname;
	unsigned char policy = 2;
	unsigned int nocheck = 0;
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&policy,
								DBUS_TYPE_STRING,&ifname,
								DBUS_TYPE_UINT32,&nocheck,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	unsigned char ret_flag = 0;
	char *name;
	name = (char*)WID_MALLOC(strlen(ifname)+5);
	memset(name,0,strlen(ifname));
	if(check_ve_interface(ifname,name)){
		wid_syslog_debug_debug(WID_DBUS,"input ve interface dosen't exist!\n");
		ret = APPLY_IF_FAIL;
		ret_flag = 1;
	}
	
	if(ret_flag == 0){
	if(policy == 1){
		#if 0
		int m=0,n=0;
		struct CWMultiHomedInterface *p=NULL,*p_next = NULL,*ptr=NULL;
		p = gListenningIF.interfaces;
		if(p != NULL)
			p_next = p->if_next;
		while(p_next !=NULL){
			m = strlen(ifname);n= strlen(p_next->ifname);
			if((m==n)&&(strcmp(ifname,p_next->ifname)==0)){
				ptr = p_next;
				ret = IF_HAS_BEEN_LISTENNING;
				break;
			}
			p_next = p_next->if_next;
		}
		#endif		
		if(ret == 0){
			if(1 == nocheck){
				isNoCheck = 1;
				wid_syslog_info("%s,%d,now is config load,not check if binding flag.\n",__func__,__LINE__);
			}
			ret = Check_And_Bind_Interface_For_WID(name);
			if(0 != isNoCheck){
				isNoCheck = 0;
				wid_syslog_info("%s,%d,reset isNoCheck.\n",__func__,__LINE__);
			}
			
			
		}
	}else{
		ret = DELETE_LISTENNING_INTERFACE(name);
		if (ret != 0)
			ret = INTERFACE_NOT_EXIST;
	}

	if(ret == 0)
	{
		if(policy == 1)
		{
		}
		else if(policy == 0)
		{
		}
	}
	}
	reply = dbus_message_new_method_return(msg);
			
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &quitreason);
	wid_syslog_debug_debug(WID_DBUS,"set wid auto_ap_login_interface %s\n",name);
	//printf("set wid auto_ap_login_interface %s\n",g_AUTO_AP_LOGIN_BINDING_L3_INTERFACE);
	WID_FREE(name);
	name = NULL;
	return reply;	

}

DBusMessage * wid_dbus_interface_set_wid_listen_ip(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
	WTPQUITREASON quitreason = WTP_INIT;
	int ret = WID_DBUS_SUCCESS;
	unsigned int ip = 0;
	unsigned char policy = 2;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&policy,
								DBUS_TYPE_UINT32,&ip,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(policy == 1){
		char tmp_name[IFI_NAME];
		memset(tmp_name,0,IFI_NAME);
		memcpy(tmp_name,"NONE",strlen("NONE"));
		ret = Check_Listenning_Ip(tmp_name,ip,DOWN_LINK_IP_TYPE,0);
		
		if(ret == 0){
			ret = Check_And_Bind_Ipaddr_For_WID(ip,DOWN_LINK_IP_TYPE);
		}
	}else{
		ret = DELETE_LISTENNING_IPADDR(ip,DOWN_LINK_IP_TYPE);
		if (ret != 0)
			ret = INTERFACE_NOT_EXIST;
	}

	if(ret == 0)
	{
		if(policy == 1)
		{
		}
		else if(policy == 0)
		{
		}
	}
	
	reply = dbus_message_new_method_return(msg);
			
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &quitreason);
	wid_syslog_debug_debug(WID_DBUS,"set wid listenning ip %d.%d.%d.%d.\n",(ip>>24)&0xFF,(ip>>16)&0xFF,(ip>>8)&0xFF,(ip)&0xFF);
	return reply;	

}

DBusMessage * wid_dbus_show_wid_listen_l3_interface(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
    DBusMessage * reply;
	DBusMessageIter  iter;
	DBusMessageIter  iter_array;
	DBusError err;
//	int ret = 0;
	int L_if_count = 0;
	int i = 0;
	dbus_error_init(&err);	
	reply = dbus_message_new_method_return(msg);
	struct CWMultiHomedInterface* inf = gListenningIF.interfaces;
	L_if_count = gListenningIF.count;
	char * name = NULL;
	unsigned int ipaddr = 0;
	char tmpname[IFI_NAME];
	LISTEN_FLAG lic_type = 0;
	memset(tmpname,0,IFI_NAME);
	dbus_message_iter_init_append(reply, &iter);

	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &L_if_count);

	dbus_message_iter_open_container (&iter,
								DBUS_TYPE_ARRAY,
								DBUS_STRUCT_BEGIN_CHAR_AS_STRING
									DBUS_TYPE_STRING_AS_STRING //ie infor
									DBUS_TYPE_UINT32_AS_STRING
									DBUS_TYPE_UINT32_AS_STRING
								DBUS_STRUCT_END_CHAR_AS_STRING,
								&iter_array);		
	
	for(i=0;i<L_if_count;i++){
		
		if(inf != NULL){
			DBusMessageIter iter_struct;
			if(name != NULL){
				WID_FREE(name);
				name = NULL;
			}else{
			}
			name = (char *)WID_MALLOC(sizeof(inf->ifname)+1);
			memset(name,0,(sizeof(inf->ifname)+1));
			wid_syslog_info("name=%s,inf->ifname=%s,tmpname=%s.\n",name,inf->ifname,tmpname);
			if((memcmp(tmpname,inf->ifname,IFI_NAME) == 0) || (memcmp(tmpname,"NONE",strlen("NONE")) == 0)){
				memcpy(name,"NONE",strlen("NONE"));
			}else{
				memcpy(name,inf->ifname,sizeof(inf->ifname));
			}
			ipaddr = ((struct sockaddr_in *)&(inf->addr))->sin_addr.s_addr;
			lic_type = inf->lic_flag;
			dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_STRING,
						  &name);
			wid_syslog_info("1,%s.\n",name);
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &ipaddr);
			wid_syslog_info("2,%d.%d.%d.%d.\n",(ipaddr>>24)&0xFF,(ipaddr>>16)&0xFF,(ipaddr>>8)&0xFF,(ipaddr)&0xFF);
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &lic_type);
			dbus_message_iter_close_container (&iter_array, &iter_struct);
			inf = inf->if_next;
			WID_FREE(name);
			name = NULL;
		}
	}
	
	dbus_message_iter_close_container (&iter, &iter_array);

	return reply;

}


DBusMessage * wid_dbus_interface_set_wid_auto_ap_login_binding_wlan(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
	
	int ret = WID_DBUS_SUCCESS;
	int result = 0;
	unsigned int wlanid = 0;
	int len1 = 0;
	int len2 = 0;
	char* ifname;
	int i = 0;
	
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wlanid,
								DBUS_TYPE_STRING,&ifname,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	unsigned char ret_flag = 0;
	char *name;
	name = (char*)WID_MALLOC(strlen(ifname)+5);
	memset(name,0,strlen(ifname)+5);
	if(check_ve_interface(ifname,name)){
		wid_syslog_debug_debug(WID_DBUS,"input ve interface dosen't exist!\n");
		ret = APPLY_IF_FAIL;
		ret_flag = 1;
	}
	if(ret_flag == 0){
	if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else if((g_auto_ap_login.ifnum == 0)||(g_auto_ap_login.auto_ap_if == NULL))
	{
		ret = AUTO_AP_LOGIN_INTERFACE_NOT_SET;
	}
	else if(g_auto_ap_login.auto_ap_switch == 1)
	{
		ret = SWITCH_IS_DISABLE;//config required to disable the switch
	}
	//check wlan iflist
	/*else if(AC_WLAN[wlanid]->Wlan_Ifi != NULL)  //fengwenchao comment 20111123
	{
		struct ifi * wlan_ifi = AC_WLAN[wlanid]->Wlan_Ifi;
		while(wlan_ifi != NULL)
		{
			len1 = strlen(ifname);
			len2 = strlen(wlan_ifi->ifi_name);
			if(len1 == len2)
			{
				if(memcmp(ifname,wlan_ifi->ifi_name,strlen(ifname)) == 0)
				{
					ret = WID_DBUS_SUCCESS;
					break;
				}
			}
			wlan_ifi = wlan_ifi->ifi_next;
		}
		
		if(wlan_ifi == NULL)
		{
			ret = Wlan_IF_NOT_BE_BINDED;
		}
	}
	else
	{
		ret = Wlan_IF_NOT_BE_BINDED;
	}	*/
	//find ifname in the list,add wlanid to the if
	if(ret == WID_DBUS_SUCCESS)
	{
		wid_auto_ap_if *iflist = NULL;
		iflist = g_auto_ap_login.auto_ap_if;
		while(iflist != NULL)
		{
			len1 = strlen(name);
			len2 = strlen(iflist->ifname);
			if(len1 == len2)
			{
				if(memcmp(name,iflist->ifname,strlen(name)) == 0)
				{
					if(iflist->wlannum >= L_BSS_NUM)
					{
						ret = WTP_OVER_MAX_BSS_NUM;
						break;
					}
					else
					{
						for(i=0;i<L_BSS_NUM;i++)
						{
							if(iflist->wlanid[i] == wlanid)
							{
								//printf("wlan is already in the list\n");
								result = 1;
								break;
							}
						}
						if(result != 1)
						{
							for(i=0;i<L_BSS_NUM;i++)
							{
								if(iflist->wlanid[i] == 0)
								{
									iflist->wlanid[i] = wlanid;
									iflist->wlannum++;
									//printf("add wlan %d at i %d\n",wlanid,i);
									break;
								}
							}
						}
						break;
					}
				}
			}
			iflist = iflist->ifnext;
		}
		if(iflist == NULL)
		{
			ret = AUTO_AP_LOGIN_INTERFACE_ERROR;
		}
	}
	}
	reply = dbus_message_new_method_return(msg);
			
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	WID_FREE(name);
	name = NULL;
	return reply;	

}
DBusMessage * wid_dbus_interface_del_wid_auto_ap_login_binding_wlan(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
	
	int ret = WID_DBUS_SUCCESS;
	int result = 0;
	unsigned int wlanid = 0;
	int len1 = 0;
	int len2 = 0;
	char* ifname;
	int i = 0;
	
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wlanid,
								DBUS_TYPE_STRING,&ifname,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	unsigned char ret_flag = 0;
	char *name;
	name = (char*)WID_MALLOC(strlen(ifname)+5);
	memset(name,0,strlen(ifname)+5);
	if(check_ve_interface(ifname,name)){
		wid_syslog_debug_debug(WID_DBUS,"input ve interface dosen't exist!\n");
		ret = APPLY_IF_FAIL;
		ret_flag = 1;
	}
	if(ret_flag == 0){
		if(AC_WLAN[wlanid] == NULL)
		{
			ret = WLAN_ID_NOT_EXIST;
		}
		else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
		{
			ret = WID_WANT_TO_DELETE_WLAN;
		}
		else if((g_auto_ap_login.ifnum == 0)||(g_auto_ap_login.auto_ap_if == NULL))
		{
			ret = AUTO_AP_LOGIN_INTERFACE_NOT_SET;
		}
		else if(g_auto_ap_login.auto_ap_switch == 1)
		{
			ret = SWITCH_IS_DISABLE;//config required to disable the switch
		}
		//no use
		/*
		//check wlan iflist
		else if(AC_WLAN[wlanid]->Wlan_Ifi != NULL)
		{
			struct ifi * wlan_ifi = AC_WLAN[wlanid]->Wlan_Ifi;
			while(wlan_ifi != NULL)
			{
				len1 = strlen(name);
				len2 = strlen(wlan_ifi->ifi_name);
				if(len1 == len2)
				{
					if(memcmp(name,wlan_ifi->ifi_name,strlen(name)) == 0)
					{
						ret = WID_DBUS_SUCCESS;
						break;
					}
				}
				wlan_ifi = wlan_ifi->ifi_next;
			}
			
			if(wlan_ifi == NULL)
			{
				ret = Wlan_IF_NOT_BE_BINDED;
			}
		}
		else
		{
			ret = Wlan_IF_NOT_BE_BINDED;
		}	
		//find ifname in the list,del wlanid from the if
		*/
		if(ret == WID_DBUS_SUCCESS)
		{
			wid_auto_ap_if *iflist = NULL;
			iflist = g_auto_ap_login.auto_ap_if;
			while(iflist != NULL)
			{
				len1 = strlen(name);
				len2 = strlen(iflist->ifname);
				if(len1 == len2)
				{
					if(memcmp(name,iflist->ifname,strlen(name)) == 0)
					{
						if(iflist->wlannum == 0)
						{
							ret = WTP_OVER_MAX_BSS_NUM;
							break;
						}
						else
						{
							for(i=0;i<L_BSS_NUM;i++)
							{
								if(iflist->wlanid[i] == wlanid)
								{
									//printf("wlan is  in the list,del it\n");
									iflist->wlanid[i] = 0;
									iflist->wlannum--;
									result = 1;
									break;
								}
							}
						}
					}
				}
				iflist = iflist->ifnext;
			}
			if(result == 0)
			{
				ret = AUTO_AP_LOGIN_INTERFACE_ERROR;
			}
		}
	}
	wid_syslog_notice("del wid auto_ap_login_binding wlanid %d ret %d\n",wlanid,ret);
	reply = dbus_message_new_method_return(msg);
			
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	WID_FREE(name);
	name = NULL;
	
	return reply;	

}

DBusMessage * wid_dbus_interface_set_wid_auto_ap_login_save_config_switch(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	unsigned int save_config_switch = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&save_config_switch,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(g_auto_ap_login.auto_ap_switch == 1)
	{
		ret = SWITCH_IS_DISABLE;//config required to disable the switch
	}
	//save parameter

	else if(save_config_switch == 1)
	{
		g_auto_ap_login.save_switch = 1;	
	}
	else if(save_config_switch == 0)
	{
		g_auto_ap_login.save_switch = 0;		
	}
	else
	{
		ret = WID_DBUS_ERROR;
	}
	
	reply = dbus_message_new_method_return(msg);
			
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	wid_syslog_debug_debug(WID_DBUS,"set wid auto_ap_login_save_config_switch %d\n",save_config_switch);
	//printf("set wid auto_ap_login_save_config_switch %d\n",g_AUTO_AP_LOGIN_SAVE_CONFIG_SWITCH);
	
	return reply;	

}
DBusMessage * wid_dbus_interface_show_wid_auto_ap_login_config(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;
	DBusMessageIter  iter_array;
//	DBusMessageIter  iter_sub_array;
	dbus_error_init(&err);	
	int i = 0;
	int j = 0;
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);

	dbus_message_iter_append_basic(&iter,DBUS_TYPE_BYTE,&g_auto_ap_login.auto_ap_switch);

	dbus_message_iter_append_basic(&iter,DBUS_TYPE_BYTE,&g_auto_ap_login.save_switch);

	dbus_message_iter_append_basic(&iter,DBUS_TYPE_BYTE,&g_auto_ap_login.ifnum);

	wid_auto_ap_if *ifi= NULL;
	ifi = g_auto_ap_login.auto_ap_if;
	char *name = NULL;
	name = (char *)WID_MALLOC(ETH_IF_NAME_LEN+1);
	unsigned char ifnum = g_auto_ap_login.ifnum;
#if 0
	for(i=0;i<g_auto_ap_login.ifnum;i++)
	{
		memset(name,0,(ETH_IF_NAME_LEN+1));
		memcpy(name,ifi->ifname,ETH_IF_NAME_LEN);
		
		dbus_message_iter_append_basic(&iter,DBUS_TYPE_STRING,&name);

		dbus_message_iter_append_basic(&iter,DBUS_TYPE_UINT32,&ifi->ifindex);

		dbus_message_iter_append_basic(&iter,DBUS_TYPE_BYTE,&ifi->wlannum);

		for(j=0;j<L_BSS_NUM;j++)
		{
			dbus_message_iter_append_basic(&iter,DBUS_TYPE_BYTE,&ifi->wlanid[j]);
		}
		ifi = ifi->ifnext;
	}
#endif
		dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
										DBUS_TYPE_STRING_AS_STRING 
										DBUS_TYPE_UINT32_AS_STRING
										DBUS_TYPE_BYTE_AS_STRING
										DBUS_TYPE_ARRAY_AS_STRING
											DBUS_STRUCT_BEGIN_CHAR_AS_STRING
													DBUS_TYPE_BYTE_AS_STRING
											DBUS_STRUCT_END_CHAR_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);		
		for(i=0;i<ifnum;i++)
		{
			DBusMessageIter iter_struct;
//			DBusMessageIter iter_sub_struct;				
			DBusMessageIter iter_sub_array;
			memset(name,0,(ETH_IF_NAME_LEN+1));
			memcpy(name,ifi->ifname,ETH_IF_NAME_LEN);
			dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_STRING,
						  &name);
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &ifi->ifindex);
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &ifi->wlannum);
			dbus_message_iter_open_container (&iter_struct,
									   DBUS_TYPE_ARRAY,
									   DBUS_STRUCT_BEGIN_CHAR_AS_STRING  
									 	  DBUS_TYPE_BYTE_AS_STRING
									   DBUS_STRUCT_END_CHAR_AS_STRING, 
									   &iter_sub_array);
			for(j=0;j<L_BSS_NUM;j++)
			{
				DBusMessageIter iter_sub_struct;				
				dbus_message_iter_open_container (&iter_sub_array,
													DBUS_TYPE_STRUCT,
													NULL,
												  &iter_sub_struct);
				dbus_message_iter_append_basic
							(&iter_sub_struct,
							  DBUS_TYPE_BYTE,
							  &ifi->wlanid[j]);
				dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);
			}
			dbus_message_iter_close_container (&iter_struct, &iter_sub_array);	
			dbus_message_iter_close_container (&iter_array, &iter_struct);
			ifi = ifi->ifnext;
		}
		dbus_message_iter_close_container (&iter, &iter_array);
	
	WID_FREE(name);
	name = NULL;
	return reply;
			
}
DBusMessage * wid_dbus_interface_clear_wid_auto_ap_login_config(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;
	dbus_error_init(&err);	

	int ret = WID_DBUS_SUCCESS;

	{
		g_auto_ap_login.save_switch = 1;     /*fengwenchao modify 20110316*/
		g_auto_ap_login.auto_ap_switch = 0;
		g_auto_ap_login.ifnum = 0;
		
		if(g_auto_ap_login.auto_ap_if != NULL)
		{
			wid_auto_ap_if *phead = NULL;
			wid_auto_ap_if *pnext = NULL;
			phead = g_auto_ap_login.auto_ap_if;
			g_auto_ap_login.auto_ap_if = NULL;

			while(phead != NULL)
			{	
				
				pnext = phead->ifnext;

				CW_FREE_OBJECT_WID(phead);

				phead = pnext;

			}			
			CW_FREE_OBJECT_WID(g_auto_ap_login.auto_ap_if);
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);

	dbus_message_iter_append_basic(&iter,DBUS_TYPE_UINT32,&ret);

	return reply;
			
}
/*xiaodawei add, 20110318*/
DBusMessage * wid_dbus_interface_set_ap_data_exclude_multicast(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	unsigned char datatype = 0;
	unsigned char policy = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&datatype,
								DBUS_TYPE_BYTE,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(datatype)	//wired
	{
		if(policy!=wireddata_switch)
			wireddata_switch = policy;
	}
	else			//wireless
	{
		if(policy!=wirelessdata_switch)
			wirelessdata_switch = policy;
	}

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	
	
	wid_syslog_debug_debug(WID_DBUS,"set ap data_exclude_multicast %d successfully\n",policy);
	
	return reply;	

}

/*END*/

//////////////////////////
DBusMessage * wid_dbus_interface_set_ap_statistics(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int policy = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}


	//printf("received statistics policy:%d\n",policy);
	
	if(policy != apstatistics)
	{	
		apstatistics = policy;
		ret = wid_set_ap_statistics(policy);
	}
	if(apstatistics != 0){//enable switch
		/*send to ap interval when switch is enable*/
		ret = wid_set_ap_statistics_interval(0,apstatisticsinterval);
	}

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	
	
	wid_syslog_debug_debug(WID_DBUS,"set ap statsistics %d successfully\n",policy);
	
	return reply;	

}

DBusMessage * wid_dbus_interface_set_ap_statistics_interval(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	unsigned int interval = 0;
	unsigned int wtpid = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&interval,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid == 0){
		if(apstatisticsinterval != interval){
			apstatisticsinterval = interval;
			ret = wid_set_ap_statistics_interval(wtpid,interval);
		}
	}else if((wtpid > 0)&&(wtpid < WTP_NUM-1)){
		if(AC_WTP[wtpid] != NULL){
			if(AC_WTP[wtpid]->apstatisticsinterval != interval){
				AC_WTP[wtpid]->apstatisticsinterval = interval;
				ret = wid_set_ap_statistics_interval(wtpid,interval);
			}
		}
	}else{
		ret = WID_DBUS_ERROR;
	}

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	
	
	wid_syslog_debug_debug(WID_DBUS,"set ap statsistics interval %d successfully\n",interval);
	
	return reply;	

}


/* 
  **********************************************************
  *
  * NOTES:	set BakCheckInterval's value, and return a DBusMessage value with it
  * INPUT:	conn:	DBus connection
  *			msg:	DBusMessage
  *			user_data:	
  * OUTPUT:	 
  * return:	a new DBusMessage type value
  *  
  * author: 		Huang Leilei
  * begin time:	2012-10-22 12:00 
  * finish time:		2012-10-24 19:00 
  * history:
  *
  ********************************************************** 
  */
DBusMessage * 
wid_dbus_interface_set_bak_check_interval(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int interval = 0;
	
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_INT32, &interval,
								DBUS_TYPE_INVALID))){
		printf("Unable to get input args\n");
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if (BakCheckInterval != interval)
		BakCheckInterval = interval;
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_INT32, &ret);
	
	wid_syslog_debug_debug(WID_DBUS,"set BakCheckInterval %d successfuly\n", BakCheckInterval);
	
	return reply;	
}


/* 
  **********************************************************
  *
  * NOTES:	get BakCheckInterval's value, and return a DBusMessage value with it
  * INPUT:	conn:	DBus connection
  *			msg:	DBusMessage
  *			user_data:	
  * OUTPUT:	 
  * return:	a new DBusMessage type value
  *  
  * author: 		Huang Leilei
  * begin time:	2012-10-24 9:00 
  * finish time:		2012-10-24 11:00 
  * history:		
  *
  ********************************************************** 
  */
DBusMessage * 
wid_dbus_interface_show_bak_check_interval(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);	
	int interval = BakCheckInterval;

	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_INT32, &interval);
	
	wid_syslog_debug_debug(WID_DBUS,"show BakCheckInterval %d successfuly\n", interval);
	
	return reply;	
}

/* 
  *****************************************************************************
  *
  * NOTES:	set LicBakInterval's value, and return a DBusMessage value with it
  * INPUT:	conn:	DBus connection
  *			msg:	DBusMessage
  *			user_data:	
  * OUTPUT:	 
  * return:	a new DBusMessage type value
  *  
  * author: 		Huang Leilei
  * begin time:	2012-10-25 14:15
  * finish time:		2012-10-25 15:30
  * history:
  *
  *****************************************************************************
  */
DBusMessage * 
wid_dbus_interface_set_lic_bak_req_interval(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int interval = 0;
	
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_INT32, &interval,
								DBUS_TYPE_INVALID))){
		printf("Unable to get input args\n");
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if (LicBakReqInterval != interval)
		LicBakReqInterval= interval;
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_INT32, &ret);
	
	wid_syslog_debug_debug(WID_DBUS,"set LicBakReqInterval %d successfuly\n", LicBakReqInterval);
	
	return reply;	
}

/* 
  *****************************************************************************
  *
  * NOTES:	get LicBakInterval's value, and return a DBusMessage value with it
  * INPUT:	conn:	DBus connection
  *			msg:	DBusMessage
  *			user_data:
  * OUTPUT:	 
  * return:	a new DBusMessage type value
  *  
  * author: 		Huang Leilei
  * begin time:	2012-10-25 14:15
  * finish time:		2012-10-25 15:30
  * history:		
  *
  *****************************************************************************
  */
DBusMessage * 
wid_dbus_interface_show_lic_bak_req_interval(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);	
	int interval = LicBakReqInterval;

	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_INT32, &interval);
	
	wid_syslog_debug_debug(WID_DBUS,"show LicBakReqInterval %d successfuly\n", interval);
	
	return reply;	
}

DBusMessage * wid_dbus_interface_set_ap_hotreboot(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int policy = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}



	if(policy != aphotreboot)
	{	
		aphotreboot = policy;
		ret = wid_set_ap_hotreboot(policy);
	}


	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	
	
	wid_syslog_debug_debug(WID_DBUS,"set ap hotreboot %d successfully\n",policy);
	
	return reply;	

}

DBusMessage * wid_dbus_interface_show_ap_statistics(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 
	DBusMessageIter  iter;
	DBusMessageIter  iter_array;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int wtpid = 0;
	int i = 0;
	int radiocount = 0;
	
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid >= WTP_NUM)
		ret = WTP_ID_LARGE_THAN_MAX;
	else{
		if(AC_WTP[wtpid] == NULL)
		{
			ret = WTP_ID_NOT_EXIST;
		}
		else
		{
			for(i=0; i<TOTAL_AP_IF_NUM; i++)
			{
				if(AC_WTP[wtpid]->apstatsinfo[i].radioId < TOTAL_AP_IF_NUM+1)
					radiocount++;
			}
			if(radiocount == 0)
				ret = WID_AP_NO_STATICS;	
		}
	}
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);

	if(ret == WID_DBUS_SUCCESS)
	{	
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &radiocount);
		
		
		dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING //type
											DBUS_TYPE_BYTE_AS_STRING //radio id
											DBUS_TYPE_BYTE_AS_STRING	//wlan id											
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_BYTE_AS_STRING //mac
											DBUS_TYPE_UINT32_AS_STRING //rx_packets;
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING //rx_errors;
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_UINT64_AS_STRING //rx_bytes;
											DBUS_TYPE_UINT64_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING //tx_rate;
											DBUS_TYPE_UINT32_AS_STRING					
											DBUS_TYPE_UINT32_AS_STRING					
											DBUS_TYPE_UINT32_AS_STRING					
											DBUS_TYPE_UINT32_AS_STRING					
											DBUS_TYPE_UINT32_AS_STRING	
											/* zhangshu add from 1.2, 2010-09-13 */
											DBUS_TYPE_UINT32_AS_STRING//	 rx_frame					
											DBUS_TYPE_UINT32_AS_STRING// tx_frame	
											DBUS_TYPE_UINT32_AS_STRING// rx_error_frame
											DBUS_TYPE_UINT32_AS_STRING// tx_error_frame
											DBUS_TYPE_UINT32_AS_STRING// rx_drop_frame
											DBUS_TYPE_UINT32_AS_STRING// tx_drop_frame
											DBUS_TYPE_UINT64_AS_STRING// rx_unicast    zhangshu modify 2010-09-02
											DBUS_TYPE_UINT64_AS_STRING// tx_unicast    zhangshu modify 2010-09-02
											DBUS_TYPE_UINT32_AS_STRING// rx_multicast
											DBUS_TYPE_UINT32_AS_STRING// tx_multicast
											DBUS_TYPE_UINT32_AS_STRING// rx_broadcast
											DBUS_TYPE_UINT32_AS_STRING// tx_broadcast
											DBUS_TYPE_UINT32_AS_STRING// rx_pkt_unicast
											DBUS_TYPE_UINT32_AS_STRING// tx_pkt_unicast
											DBUS_TYPE_UINT32_AS_STRING// rx_pkt_multicast
											DBUS_TYPE_UINT32_AS_STRING// tx_pkt_multicast
											DBUS_TYPE_UINT32_AS_STRING// rx_pkt_broadcast
											DBUS_TYPE_UINT32_AS_STRING// tx_pkt_broadcast
											DBUS_TYPE_UINT32_AS_STRING// rx_pkt_retry
											DBUS_TYPE_UINT32_AS_STRING// tx_pkt_retry
											DBUS_TYPE_UINT32_AS_STRING// rx_pkt_data
											DBUS_TYPE_UINT32_AS_STRING// tx_pkt_data
											DBUS_TYPE_UINT32_AS_STRING// rx_retry
											DBUS_TYPE_UINT32_AS_STRING// tx_retry
											
											DBUS_TYPE_UINT32_AS_STRING	//rx drop				
											DBUS_TYPE_UINT32_AS_STRING	//tx drop
											DBUS_TYPE_UINT32_AS_STRING	//rx_pkt_mgmt     zhangshu modify 2010-09-13
											DBUS_TYPE_UINT32_AS_STRING	//tx_pkt_mgmt     zhangshu modify 2010-09-13
											DBUS_TYPE_UINT64_AS_STRING	//rx_mgmt
											DBUS_TYPE_UINT64_AS_STRING	//tx_mgmt

											/* zhangshu append 2010-09-13 */
											DBUS_TYPE_UINT64_AS_STRING	//rx_sum_bytes
											DBUS_TYPE_UINT64_AS_STRING	//tx_sum_bytes
											DBUS_TYPE_UINT32_AS_STRING   //rx_pkt_control
											DBUS_TYPE_UINT32_AS_STRING   //tx_pkt_control
											/* zhangshu append 2010-09-26 */
											DBUS_TYPE_UINT32_AS_STRING   //rx_errors_frames

									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);		

		for(i = 0; i < radiocount; i++)
		{	
			
			
			DBusMessageIter iter_struct;
				
			dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(AC_WTP[wtpid]->apstatsinfo[i].type));

			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(AC_WTP[wtpid]->apstatsinfo[i].radioId));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(AC_WTP[wtpid]->apstatsinfo[i].wlanId));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(AC_WTP[wtpid]->apstatsinfo[i].mac[0]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(AC_WTP[wtpid]->apstatsinfo[i].mac[1]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(AC_WTP[wtpid]->apstatsinfo[i].mac[2]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(AC_WTP[wtpid]->apstatsinfo[i].mac[3]));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(AC_WTP[wtpid]->apstatsinfo[i].mac[4]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(AC_WTP[wtpid]->apstatsinfo[i].mac[5]));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].rx_packets));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].tx_packets));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].rx_errors));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].tx_errors));

			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT64,
						  &(AC_WTP[wtpid]->apstatsinfo[i].rx_bytes));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT64,
						  &(AC_WTP[wtpid]->apstatsinfo[i].tx_bytes));	
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].rx_rate));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].tx_rate));	
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].ast_rx_crcerr));	
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].ast_rx_badcrypt));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].ast_rx_badmic));	
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].ast_rx_phyerr));	

			/*zhaoruijia,apwlan_stats_info_profilestart*/

		  dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].rx_frame));	
		   dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].tx_frame));
		   dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].rx_error_frame));
		   dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].tx_error_frame));
		    dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].rx_drop_frame));
			 dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].tx_drop_frame));
		    // zhangshu modify 2010-09-02
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT64,
						  &(AC_WTP[wtpid]->apstatsinfo[i].rx_unicast));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT64,
						  &(AC_WTP[wtpid]->apstatsinfo[i].tx_unicast));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].rx_multicast));
            dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].tx_multicast));
			 dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].rx_broadcast));
			 dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].tx_broadcast));
			 dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].rx_pkt_unicast));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].tx_pkt_unicast));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].rx_pkt_multicast));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].tx_pkt_multicast));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].rx_pkt_broadcast));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].tx_pkt_broadcast));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].rx_pkt_retry));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].tx_pkt_retry));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].rx_pkt_data));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].tx_pkt_data));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].rx_retry));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].tx_retry));
        			
        	/*zhaoruijia,apwlan_stats_info_profileend*/
	
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].rx_drop));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].tx_drop));	
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].rx_pkt_mgmt));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].tx_pkt_mgmt));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT64,
						  &(AC_WTP[wtpid]->apstatsinfo[i].rx_mgmt));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT64,
						  &(AC_WTP[wtpid]->apstatsinfo[i].tx_mgmt));
			/* zhangshu append 2010-08-28 */
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT64,
						  &(AC_WTP[wtpid]->apstatsinfo[i].rx_sum_bytes));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT64,
						  &(AC_WTP[wtpid]->apstatsinfo[i].tx_sum_bytes));
			/*zhaoruijia,20100907,rx_pkt_controltx_pkt_control,start*/
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].rx_pkt_control));	
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].tx_pkt_control));	
			/*zhaoruijia,20100907,rx_pkt_controltx_pkt_control,end*/
			
			/*zhangshu,2010-09-26,rx_errors_frames */
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(AC_WTP[wtpid]->apstatsinfo[i].rx_errors_frames));

			dbus_message_iter_close_container (&iter_array, &iter_struct);			

		}
				
		dbus_message_iter_close_container (&iter, &iter_array);
	}			

	return reply;		

}
DBusMessage * wid_dbus_interface_show_ap_ipaddr(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 
	DBusMessageIter  iter;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int wtpid = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(wtpid >= WTP_NUM)
		ret = WTP_ID_LARGE_THAN_MAX;
	else{
		if(AC_WTP[wtpid] == NULL)
		{
			ret = WTP_ID_NOT_EXIST;
		}
	}
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);

	if(ret == WID_DBUS_SUCCESS)
	{	
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &AC_WTP[wtpid]->ap_ipadd);
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &AC_WTP[wtpid]->ap_mask);
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &AC_WTP[wtpid]->ap_gateway);

	}

	return reply;		

}

DBusMessage * wid_dbus_interface_show_ap_network(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 
	DBusMessageIter  iter;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int wtpid = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(wtpid >= WTP_NUM)
		ret = WTP_ID_LARGE_THAN_MAX;
	else{
		if(AC_WTP[wtpid] == NULL)
		{
			ret = WTP_ID_NOT_EXIST;
		}
	}
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);

	if(ret == WID_DBUS_SUCCESS)
	{	
	
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_STRING,
										 &AC_WTP[wtpid]->WTPIP);
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &AC_WTP[wtpid]->ap_mask_new);
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &AC_WTP[wtpid]->ap_gateway);
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &AC_WTP[wtpid]->ap_dnsfirst);
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &AC_WTP[wtpid]->ap_dnssecend);	

	}

	return reply;		

}

/*wuwl add 09/12/03*/
DBusMessage * wid_dbus_interface_ac_load_balance(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	unsigned char method=0;
	unsigned char wlanid=0;
//	int wlannum = 0;
	
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&method,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(/*method <0 || */method >2) 
		ret=WID_DBUS_ERROR;
	else {
		ac_flow_num_balance_flag.state = method;
		for(wlanid = 1; wlanid < WLAN_NUM; wlanid++){
			if(AC_WLAN[wlanid] != NULL){
				if(method == 0){
					AC_WLAN[wlanid]->balance_switch=0;
					AC_WLAN[wlanid]->balance_method=0;
					balance_probe_extend_command(wlanid,0);
					if(1!=AsdWsm_WLANOp(wlanid,WID_MODIFY,0))
						ret=WID_DBUS_ERROR;
					}else{
					AC_WLAN[wlanid]->balance_switch=1;
					AC_WLAN[wlanid]->balance_method=method;
					balance_probe_extend_command(wlanid,1);
					if(1!=AsdWsm_WLANOp(wlanid,WID_MODIFY,0))
						ret=WID_DBUS_ERROR;
					}
			}
		}

	}

	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 
	return reply;

}

/*ht add 10.3.5*/
DBusMessage * wid_dbus_interface_set_ac_load_balance_para(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	unsigned char method=0;
	unsigned char wlanid=0;
	unsigned int  balance_para = 0;
//	int wlannum = 0;
	
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&method,
								DBUS_TYPE_UINT32,&balance_para,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	printf("method :%d para :%d\n",method,balance_para);
	if(method == 1) {
		ac_flow_num_balance_flag.num_balance_para = balance_para;
		for(wlanid = 1; wlanid < WLAN_NUM; wlanid++){
			if(AC_WLAN[wlanid] != NULL){
				AC_WLAN[wlanid]->balance_para = balance_para;
				if(1!=AsdWsm_WLANOp(wlanid,WID_MODIFY,0))
					ret=WID_DBUS_ERROR;
				}
		}
	}else if(method == 2){
		ac_flow_num_balance_flag.flow_balance_para = balance_para;
		for(wlanid = 1; wlanid < WLAN_NUM; wlanid++){
			if(AC_WLAN[wlanid] != NULL){
				AC_WLAN[wlanid]->flow_balance_para = balance_para;
				if(1!=AsdWsm_WLANOp(wlanid,WID_MODIFY,0))
					ret=WID_DBUS_ERROR;
				}
		}
	}
	
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 
	printf("%s ret = %d\n",__func__,ret);
	return reply;

}
DBusMessage * wid_dbus_interface_show_ac_balance_configuration(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);

	int ret = WID_DBUS_SUCCESS;
	unsigned int state = 0;	
 	unsigned int num = 0;
 	unsigned int flow = 0;

	state = ac_flow_num_balance_flag.state;
	num = ac_flow_num_balance_flag.num_balance_para;
	flow = ac_flow_num_balance_flag.flow_balance_para;
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);

	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&state);

	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&num);

	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&flow);
	return reply;	

}
/*nl add 20100316*/
DBusMessage * wid_dbus_interface_set_ac_extension_infomation_enable(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int i = 0;
	unsigned int num = 0;
	int policy = 0;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(policy <0 || policy >1) 
		ret=WID_DBUS_ERROR;
	
	else{
		g_AC_ALL_EXTENTION_INFORMATION_SWITCH = policy;

		for(i = 0;i < WTP_NUM;i++){
			
			if((AC_WTP[i] != NULL)&&(gWTPs[i].currentState == CW_ENTER_RUN)){
				num ++;
				if(AC_WTP[i]->wifi_extension_reportswitch == policy)
					continue;
				else{
					AC_WTP[i]->wifi_extension_reportswitch = policy;
					if(0 != wid_send_to_ap_extension_infomation(i))
						ret=WID_DBUS_ERROR;		
				}
			}
		}
	}
		
	if(num == 0)
		ret = WTP_ID_NOT_EXIST;
	
	reply = dbus_message_new_method_return(msg);

	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	return reply;
	
}

DBusMessage * wid_dbus_interface_set_ap_timestamp(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 
	DBusMessageIter  iter;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int timestamp = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&timestamp,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	printf("received timestamp is:%d\n",timestamp);
	

	ret = wid_set_ap_timestamp(timestamp);


	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;		

}


DBusMessage * wid_dbus_interface_radio_set_bss_max_sta(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	int k1 = 0 ;  //fengwenchao add 20110511
	unsigned char wlanid = 0;   //fengwenchao add 20110512
	unsigned int /*bss_index=0,*/bss_max=0,radio_id=0;

	/* zhangshu add for sending bss max number to ap, 2010-09-26 */
	char apcmd[WID_SYSTEM_CMD_LENTH];
	memset(apcmd,0,WID_SYSTEM_CMD_LENTH);

	dbus_error_init(&err);
	
	if (!(dbus_message_get_args ( msg, &err,
		                        DBUS_TYPE_UINT32,&radio_id,
								DBUS_TYPE_BYTE,&wlanid,            //fengwenchao modify 20110512
								DBUS_TYPE_UINT32,&bss_max,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	/*we need know how many sta has accessed,first
	struct hapd_interfaces *interfaces = (struct hapd_interfaces*) eloop.user_data;
	if(interfaces->iface[radio_id]->bss[bss_index-1]->num_sta>bss_max){
		ret=ASD_BSS_VALUE_INVALIDE;
	}
	else if(ASD_BSS[radio_id*4+bss_index-1]!=NULL)
		ASD_BSS[radio_id*4+bss_index-1]->bss_max_allowed_sta_num=bss_max;
	else
		ret=ASD_BSS_NOT_EXIST;
	*/
	if(AC_RADIO[radio_id] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	/*fengwenchao modify begin  , 20110511*/
	else if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	if(ret == WID_DBUS_SUCCESS)
	{
		ret = Wlan_IF_NOT_BE_BINDED;
		for(k1 = 0; k1 < L_BSS_NUM; k1++)
		{
			if((AC_RADIO[radio_id]->BSS[k1] != NULL)&&(AC_BSS[radio_id*L_BSS_NUM+k1] != NULL)&&(AC_RADIO[radio_id]->BSS[k1]->WlanID ==wlanid))
			{
				ret = WID_DBUS_SUCCESS;
				break;
			}
			continue;
		}
		if(ret == WID_DBUS_SUCCESS)
		{
			AC_RADIO[radio_id]->BSS[k1]->bss_max_allowed_sta_num=bss_max;
			AC_BSS[radio_id*L_BSS_NUM+k1]->bss_max_allowed_sta_num=bss_max;
			if(1!=AsdWsm_BSSOp(radio_id*L_BSS_NUM+k1,WID_MODIFY,0))
				ret=WID_DBUS_ERROR;
				
			/* zhangshu add for sending bss max number to ap, 2010-09-26 */
			sprintf(apcmd,"echo %d > /proc/sys/net/ath.%d-%d/maxaid",bss_max,AC_RADIO[radio_id]->Radio_L_ID,AC_RADIO[radio_id]->BSS[k1]->WlanID);
		    	wid_syslog_debug_debug(WID_DEFAULT,"wid_set_radio_txantenna apcmd %s\n",apcmd);
		    	ret = wid_radio_set_extension_command(AC_RADIO[radio_id]->WTPID,apcmd);
		    	//printf("wtpid = %d\n",AC_RADIO[radio_id]->WTPID);
		    	//printf("echo %d > /proc/sys/net/ath.%d-%d/maxaid\n",bss_max,AC_RADIO[radio_id]->Radio_L_ID,AC_RADIO[radio_id]->BSS[bss_index-1]->WlanID);
		    	/* -------end--------- */			
		}
	}	
	/*fengwenchao modify end*/
	reply = dbus_message_new_method_return(msg);		
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 
	return reply;	

}

//////////////////////////
DBusMessage * wid_dbus_interface_show_radiolist(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	unsigned int num=0;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	int i=0,j=0;
	WID_WTP_RADIO **RADIO;	
	RADIO = WID_MALLOC(G_RADIO_NUM*(sizeof(WID_WTP_RADIO *)));
	while(i<WTP_NUM){		
		if(AC_WTP[i] != NULL)
		{	int n=0,m=0;
			n = AC_WTP[i]->RadioCount;
			m = AC_WTP[i]->WFR_Index;
			for(j=0;j<n;j++){
				RADIO[num] = AC_RADIO[m];
				m++;
				num++;
			}
		}
		i++;
	}
	if(num == 0)
		ret = RADIO_ID_NOT_EXIST;
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
		// Total slot count
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
		
	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_UINT16_AS_STRING//
											DBUS_TYPE_UINT16_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_UINT16_AS_STRING//
											DBUS_TYPE_BYTE_AS_STRING//short retry
											DBUS_TYPE_BYTE_AS_STRING//long retry
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_UINT16_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);
	for(i = 0; i < num; i++){			
		DBusMessageIter iter_struct;
			
		dbus_message_iter_open_container (&iter_array,
										DBUS_TYPE_STRUCT,
										NULL,
										&iter_struct);
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_UINT32,
					  &(RADIO[i]->WTPID));
			
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_UINT32,
					  &(RADIO[i]->Radio_G_ID));
			
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_UINT32,
					  &(RADIO[i]->Radio_Type));
		dbus_message_iter_append_basic
			(&iter_struct,
			  DBUS_TYPE_UINT32,
			  &(RADIO[i]->Support_Rate_Count));//sz change
		
		dbus_message_iter_append_basic
			(&iter_struct,
			  DBUS_TYPE_UINT16,
			  &(RADIO[i]->FragThreshold));
		
		dbus_message_iter_append_basic
			(&iter_struct,
			  DBUS_TYPE_UINT16,
			  &(RADIO[i]->BeaconPeriod));

		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(RADIO[i]->IsShortPreamble));
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(RADIO[i]->DTIMPeriod));
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_UINT16,
					  &(RADIO[i]->rtsthreshold));
		dbus_message_iter_append_basic
			(&iter_struct,
			  DBUS_TYPE_BYTE,
			  &(RADIO[i]->ShortRetry));
		
		dbus_message_iter_append_basic
			 (&iter_struct,
			  DBUS_TYPE_BYTE,
			  &(RADIO[i]->LongRetry));

		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(RADIO[i]->Radio_Chan));
		
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_UINT16,
					  &(RADIO[i]->Radio_TXP));

		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(RADIO[i]->AdStat));
		
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(RADIO[i]->OpStat));

		dbus_message_iter_close_container (&iter_array, &iter_struct);


	}
				
	dbus_message_iter_close_container (&iter, &iter_array);
				
	WID_FREE(RADIO);
	return reply;	
	

}

DBusMessage * wid_dbus_interface_show_radioconf(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	unsigned char num=0;
	unsigned int radioID;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	int i=0;
	int j=0;
	int bwlannum = 0;
	WID_BSS *BSS[L_BSS_NUM];
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(radioID >= G_RADIO_NUM){
		ret = RADIO_ID_LARGE_THAN_MAX;
	}
	else if(AC_RADIO[radioID] == NULL){
		wid_syslog_debug_debug(WID_DBUS,"AC_RADIO[%d] id empty!!!\n",radioID);
		ret = RADIO_ID_NOT_EXIST;
		num = 0;
	}else{		
		while(i<L_BSS_NUM){
			if(AC_RADIO[radioID]->BSS[i] != NULL)
			{
				BSS[num] = AC_RADIO[radioID]->BSS[i];
				num++;
			}
			i++;
		}
		
	}
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	if(ret == 0){	

		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &(AC_RADIO[radioID]->WTPID));
		
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(AC_RADIO[radioID]->Radio_L_ID));
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &(AC_RADIO[radioID]->Radio_G_ID));
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &(AC_RADIO[radioID]->Radio_Type));
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &(AC_RADIO[radioID]->Support_Rate_Count));
		j = length_of_rate_list(AC_RADIO[radioID]->Radio_Rate);
		//j = AC_RADIO[radioID]->Support_Rate_Count;
		struct Support_Rate_List *p = NULL;
		p = AC_RADIO[radioID]->Radio_Rate;
		for (i=0;i<j;i++)
		{
			dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &p->Rate);
			p = p->next;
			
		}	

		#if TEST_SWITCH_WAY
		
		struct wlanid* pwlanid = AC_RADIO[radioID]->Wlan_Id;
		while(pwlanid != NULL){
			bwlannum++;
			pwlanid = pwlanid->next;
		}
		
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &bwlannum);
		
		pwlanid = AC_RADIO[radioID]->Wlan_Id;
		
		char *essid;
		dbus_message_iter_open_container (&iter,
								DBUS_TYPE_ARRAY,
								DBUS_STRUCT_BEGIN_CHAR_AS_STRING
										DBUS_TYPE_BYTE_AS_STRING
										DBUS_TYPE_ARRAY_AS_STRING
											DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
											DBUS_STRUCT_END_CHAR_AS_STRING
								DBUS_STRUCT_END_CHAR_AS_STRING,
								&iter_array);
		
		for(i = 0; i < bwlannum; i++){
			DBusMessageIter iter_struct;
			DBusMessageIter  iter_sub_array;
			dbus_message_iter_open_container (&iter_array,
										DBUS_TYPE_STRUCT,
										NULL,
										&iter_struct);
			
			dbus_message_iter_append_basic (&iter_struct,
											 DBUS_TYPE_BYTE,
											 &(pwlanid->wlanid));
			
			dbus_message_iter_open_container (&iter_struct,
							   DBUS_TYPE_ARRAY,
							   DBUS_STRUCT_BEGIN_CHAR_AS_STRING  
								  DBUS_TYPE_BYTE_AS_STRING
							   DBUS_STRUCT_END_CHAR_AS_STRING, 
							   &iter_sub_array);

			if(NULL == pwlanid->ESSID){
				return NULL;
			} else{
				essid = (char *)WID_MALLOC(ESSID_DEFAULT_LEN + 1);
				memset(essid,0,(ESSID_DEFAULT_LEN + 1));
				memcpy(essid,pwlanid->ESSID,strlen(pwlanid->ESSID));
			}
			for(j=0;j<ESSID_DEFAULT_LEN;j++)
			{
				DBusMessageIter iter_sub_struct;				
				dbus_message_iter_open_container (&iter_sub_array,
													DBUS_TYPE_STRUCT,
													NULL,
												  &iter_sub_struct);
				dbus_message_iter_append_basic
							(&iter_sub_struct,
							  DBUS_TYPE_BYTE,
							  &essid[j]);
				dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);
			}
			dbus_message_iter_close_container (&iter_struct, &iter_sub_array);
			WID_FREE(essid);
			pwlanid = pwlanid->next;

			dbus_message_iter_close_container(&iter_array, &iter_struct);
			
		}
		dbus_message_iter_close_container(&iter, &iter_array);
		#endif

		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT16,
										 &(AC_RADIO[radioID]->FragThreshold));
		dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT16,
									 &(AC_RADIO[radioID]->BeaconPeriod));
		dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_BYTE,
									 &(AC_RADIO[radioID]->IsShortPreamble));
		dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_BYTE,
									 &(AC_RADIO[radioID]->DTIMPeriod));
		dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT16,
									 &(AC_RADIO[radioID]->rtsthreshold));	
		dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT16,
									 &(AC_RADIO[radioID]->ShortRetry));	
		dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT16,
									 &(AC_RADIO[radioID]->LongRetry));	
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(AC_RADIO[radioID]->Radio_Chan));
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT16,
										 &(AC_RADIO[radioID]->Radio_TXP));
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(AC_RADIO[radioID]->AdStat));
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(AC_RADIO[radioID]->OpStat));
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &(AC_RADIO[radioID]->upcount));
		//qiuchen add for test
		//wid_syslog_debug_debug(WID_DEFAULT,"append upcount is %d.\n",AC_RADIO[radioID]->upcount);
		//wid_syslog_debug_debug(WID_DEFAULT,"Adstatus is %d.\n",AC_RADIO[radioID]->AdStat);
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &(AC_RADIO[radioID]->downcount));		
		// Total slot count
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
									 &(AC_RADIO[radioID]->auto_channel_cont));		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &num);
		
		
		dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING/////// xm
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);
		

	for(i = 0; i < num; i++){	
		
		
		DBusMessageIter iter_struct;
			
		dbus_message_iter_open_container (&iter_array,
										DBUS_TYPE_STRUCT,
										NULL,
										&iter_struct);
		
		dbus_message_iter_append_basic (&iter_struct,
										 DBUS_TYPE_UINT32,
					&(BSS[i]->bss_max_allowed_sta_num));
		
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(BSS[i]->WlanID));
		
			
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_UINT32,
					  &(BSS[i]->Radio_G_ID));
		
			
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(BSS[i]->BSSID[0]));
		
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(BSS[i]->BSSID[1]));
		
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(BSS[i]->BSSID[2]));
		
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(BSS[i]->BSSID[3]));
		
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(BSS[i]->BSSID[4]));
		
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(BSS[i]->BSSID[5]));
		
			
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(BSS[i]->State));
		dbus_message_iter_append_basic
			(&iter_struct,
			  DBUS_TYPE_BYTE,
			  &(BSS[i]->BSS_IF_POLICY));
		dbus_message_iter_append_basic
			(&iter_struct,
			  DBUS_TYPE_BYTE,
			  &(BSS[i]->keyindex));
		dbus_message_iter_append_basic
			(&iter_struct,
			  DBUS_TYPE_UINT32,
			  &(BSS[i]->upcount));
		dbus_message_iter_append_basic
			(&iter_struct,
			  DBUS_TYPE_UINT32,
			  &(BSS[i]->downcount));		
		dbus_message_iter_append_basic
			(&iter_struct,
			  DBUS_TYPE_UINT32,
			  &(BSS[i]->WDSStat));
		
		dbus_message_iter_close_container (&iter_array, &iter_struct);
	}
	
				
	dbus_message_iter_close_container (&iter, &iter_array);

	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_BYTE,
									 &(AC_RADIO[radioID]->channel_offset));
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_BYTE,
									 &(AC_RADIO[radioID]->chainmask_num));
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_BYTE,
									 &(AC_RADIO[radioID]->tx_chainmask_state_value));
    /* zhangshu add for rx_chainmask, 2010-10-09 */
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_BYTE,
									 &(AC_RADIO[radioID]->rx_chainmask_state_value));
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_BYTE,
									 &(AC_RADIO[radioID]->Ampdu.Able));
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &(AC_RADIO[radioID]->Ampdu.AmpduLimit));
    /* zhangshu add for ampdu & amsdu show , 2010-10-09 */
    dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_BYTE,
									 &(AC_RADIO[radioID]->Ampdu.subframe));
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_BYTE,
									 &(AC_RADIO[radioID]->Amsdu.Able));
    dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &(AC_RADIO[radioID]->Amsdu.AmsduLimit));
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_BYTE,
									 &(AC_RADIO[radioID]->Amsdu.subframe));
	/*end*/
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_BYTE,
									 &(AC_RADIO[radioID]->MixedGreenfield.Mixed_Greenfield));


	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_BYTE,
									 &(AC_RADIO[radioID]->txpowerautostate));

	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT16,
									 &(AC_RADIO[radioID]->guardinterval));
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT16,
									 &(AC_RADIO[radioID]->cwmode));

	//qiuchen change it 2012.09.19
	
	dbus_message_iter_append_basic(&iter,
									DBUS_TYPE_UINT32,
									&(AC_RADIO[radioID]->mcs_count));
	//wid_syslog_debug_debug(WID_DEFAULT,"show radio mcs count is %d\n",AC_RADIO[radioID]->mcs_count);
	
	for(i=0;i<AC_RADIO[radioID]->mcs_count;i++){
		
	
		dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_BYTE,
									 &(AC_RADIO[radioID]->mcs_list[i]));


	} 
	//qiuchen add end
	dbus_message_iter_append_basic (&iter,                          //fengwenchao add 20110329
									 DBUS_TYPE_UINT16,          
									 &(AC_RADIO[radioID]->txpowerstep));
	dbus_message_iter_append_basic (&iter,                          /*wcl add for OSDEVTDPB-31*/
									 DBUS_TYPE_UINT32,          
									 &(AC_RADIO[radioID]->Radio_country_code));

	
	}			
	
	
	return reply;	
}

DBusMessage * wid_dbus_interface_dynamic_channel_selection(DBusConnection *conn, DBusMessage *msg, void *user_data)
	{
		DBusMessage* reply; 
		DBusMessageIter  iter;
		DBusError err;
		dbus_error_init(&err);	
		int ret = WID_DBUS_SUCCESS;
		int policy = 0;
	
		if (!(dbus_message_get_args ( msg, &err,
									DBUS_TYPE_UINT32,&policy,
									DBUS_TYPE_INVALID))){
	
			printf("Unable to get input args\n");
					
			if (dbus_error_is_set(&err)) {
				printf("%s raised: %s",err.name,err.message);
				dbus_error_free(&err);
			}
			return NULL;
		}
	
	
		//printf("received policy:%d\n",policy);
		
		if(1 == gapscanset.opstate)
		{
			if((channel_state != policy)&&(1 == policy)){
				CWThreadMutexLock(&(gACChannelMutex));
					channel_state = policy;
					//printf("111111");
					CWSignalThreadCondition(&gACChannelWait);
				CWThreadMutexUnlock(&gACChannelMutex);
			}else if((channel_state != policy)&&(0 == policy)){
				CWThreadMutexLock(&(gACChannelMutex));
					channel_state = policy;
				CWThreadMutexUnlock(&gACChannelMutex);
			}
		}
		else if(policy == 1){ 
			ret = WID_DBUS_ERROR;
		}
		
	
	
		reply = dbus_message_new_method_return(msg);
			
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
		
		
		wid_syslog_debug_debug(WID_DBUS,"set ap scanning %d successfully\n",policy);
		
		return reply;	
	
	}

DBusMessage * wid_dbus_interface_dynamic_channel_selection_range(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 
	DBusMessageIter  iter;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int num = 0;
	unsigned char channel[4] = {0,0,0,0};
	int i;
	dbus_message_iter_init(msg,&iter);
	dbus_message_iter_get_basic(&iter,&num);
	for(i = 0; i < num; i++){
		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&channel[i]);
	}
	memcpy(channelRange, channel, 4);
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	wid_syslog_debug_debug(WID_DBUS,"set channel range %d %d %d %d successfully\n",channel[0],channel[1],channel[2],channel[3]);
	
	return reply;	

}



DBusMessage * wid_dbus_interface_set_nas_id(DBusConnection *conn, DBusMessage *msg, void *user_data)
{	
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;
	unsigned char WlanID;
	//unsigned int wtpid;
	char *if_name;	
	char *nas_id;
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&WlanID,
								DBUS_TYPE_STRING,&if_name,								
								DBUS_TYPE_STRING,&nas_id,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}
	unsigned char ret_flag = 0;
	char *name;
	name = (char*)WID_MALLOC(strlen(if_name)+5);
	memset(name,0,strlen(if_name)+5);
	if(check_ve_interface(if_name,name)){
		wid_syslog_debug_debug(WID_DBUS,"input ve interface doesn't exist!\n"); 
		ret = APPLY_IF_FAIL;
		ret_flag = 1;
	}
	if(ret_flag == 0){
		if(AC_WLAN[WlanID] == NULL)
		{
			ret = WLAN_ID_NOT_EXIST;
		}
		else if (AC_WLAN[WlanID]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
		{
			ret = WID_WANT_TO_DELETE_WLAN;
		}
		else
		{
		//printf get values
		//printf("***** Input wtp id is %d\n",wtpid);
		//printf("***** Input wtp id binding interface name is %s\n",if_name);
		wid_syslog_debug_debug(WID_DBUS,"<wid_dbus_interface_set_nas_id> interface name is %s",if_name);	
		wid_syslog_debug_debug(WID_DBUS,"<wid_dbus_interface_set_nas_id> nas id is %s",nas_id);

		ret = WID_INTERFACE_SET_NASID(WlanID,name,nas_id);

		}
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &ret);
	WID_FREE(name);
	name = NULL;
	return reply;

}
DBusMessage * wid_dbus_interface_remove_nas_id(DBusConnection *conn, DBusMessage *msg, void *user_data)
{	
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;
	WTPQUITREASON quitreason = WTP_INIT;
	unsigned char WlanID;
	char *if_name;	

	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&WlanID,
								DBUS_TYPE_STRING,&if_name,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}
	unsigned char ret_flag = 0;
	char *name;
	name = (char*)WID_MALLOC(strlen(if_name)+5);
	memset(name,0,strlen(if_name)+5);
	if(check_ve_interface(if_name,name)){
		wid_syslog_debug_debug(WID_DBUS,"input ve interface dosen't exist!\n");
		ret = APPLY_IF_FAIL;
		ret_flag = 1;
	}
	if(ret_flag ==0){
		if(AC_WLAN[WlanID] == NULL)
		{
			ret = WLAN_ID_NOT_EXIST;
		}
		else if (AC_WLAN[WlanID]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
		{
			ret = WID_WANT_TO_DELETE_WLAN;
		}
		else if(AC_WLAN[WlanID]->Status == 0)
		{
			ret = WLAN_BE_ENABLE;
		}
		else if(AC_WLAN[WlanID]->Wlan_Ifi == NULL)
		{
			ret = WLAN_NOT_BINDING_IF;
		}
		else
		{
			ret = Check_Interface_Exist(name,&quitreason);
			if(ret == WID_DBUS_SUCCESS)
			{
				struct ifi *wlanif = NULL;
				wlanif = AC_WLAN[WlanID]->Wlan_Ifi;
				int len1 = 0;
				int len2 = 0;
				int isfind = 0;
				int isnasid = 0;
				len1 = strlen(name);
	
				while(wlanif != NULL)
				{
					len2 = strlen(wlanif->ifi_name);
					if((len1 == len2)&&(strcmp(name,wlanif->ifi_name) == 0))
					{
						isfind = 1;
						if(wlanif->nas_id_len != 0)
						{
							isnasid = 1;
						}
						break;
					}

					wlanif = wlanif->ifi_next;
				}

				if(isfind == 0)
				{
					ret = WLAN_NOT_BINDING_IF;
				}
				else if(isnasid == 0)
				{
					ret = WLAN_NOT_NEED_NAS;
				}
				else
				{
					ret = wid_remove_wlan_interface_nasid(WlanID,name);
					wid_syslog_debug_debug(WID_DBUS,"wid_dbus_interface_remove_nas_id wlanid %d interface %s\n",WlanID,if_name);	
				}
			}
		}

	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &ret);
	WID_FREE(name);
	name = NULL;
	
	return reply;

}

DBusMessage * wid_dbus_interface_set_roaming_policy(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	unsigned char state=0;
	unsigned char wlanid=0;
	
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_BYTE,&state,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(AC_WLAN[wlanid]!=NULL){
		if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
		{
			ret = WID_WANT_TO_DELETE_WLAN;
		}
		else
		{
		if(AC_WLAN[wlanid]->Status != 0){
			if(AC_WLAN[wlanid]->Roaming_Policy != state)
			{
				AC_WLAN[wlanid]->Roaming_Policy = state;
				if(1!=AsdWsm_WLANOp(wlanid,WID_MODIFY,0))
					ret=WID_DBUS_ERROR;
			}
		}
		else
			ret = WLAN_BE_ENABLE;
		}
	}
	else
		ret=WLAN_ID_NOT_EXIST;
	
		
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 
	return reply;

} 
DBusMessage * wid_dbus_interface_set_wlan_br_isolation(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	unsigned char state = 0;
	unsigned char wlanid = 0;
	
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_BYTE,&state,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if (AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	//else if (AC_WLAN[wlanid]->Status != 1)
	//{ 
	//	ret = WLAN_BE_ENABLE;
	//}
	else if (AC_WLAN[wlanid]->wlan_if_policy != WLAN_INTERFACE)
	{
		ret = IF_POLICY_CONFLICT;
	}
	else if (AC_WLAN[wlanid]->sameportswitch == 1)
	{
		ret = ISOLATION_CONFLICT;
	}
	else if (AC_WLAN[wlanid]->SecurityID <= 0)
	{
		wid_syslog_debug_debug(WID_DBUS, "AC_WLAN[%d]'s Security not exist\n", wlanid);
		ret = WLAN_APPLY_SECURITY_FIRST;
	}
	else
	{
			ret = wid_set_wlan_br_isolation(wlanid,state);
	}	
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 

	return reply;

}
DBusMessage * wid_dbus_interface_set_wlan_br_multicast_isolation(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	unsigned char state = 0;
	unsigned char wlanid = 0;
	
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_BYTE,&state,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if (AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	//else if (AC_WLAN[wlanid]->Status != 1)
	//{ 
	//	ret = WLAN_BE_ENABLE;
	//}
	else if (AC_WLAN[wlanid]->wlan_if_policy != WLAN_INTERFACE)
	{
		ret = IF_POLICY_CONFLICT;
	}
	else if (AC_WLAN[wlanid]->sameportswitch == 1)
	{
		ret = ISOLATION_CONFLICT;
	}
	else if (AC_WLAN[wlanid]->SecurityID <= 0)
	{		
		wid_syslog_debug_debug(WID_DBUS, "AC_WLAN[%d]'s Security not exist\n", wlanid);
		ret = WLAN_APPLY_SECURITY_FIRST;
	}
	else
	{
			ret = wid_set_wlan_br_multicast_isolation(wlanid,state);
	}	
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 

	return reply;

}








/*
  *****************************************************************************
  *  
  * NOTES:	 
  * INPUT:	   
  * OUTPUT:	  
  * return:	  
  *  
  * author: 		Huang Leilei 
  * begin time:	2012-11-12 9:00  
  * finish time:		2012-11-15 11:00 
  * history:	
  * 
  **************************************************************************** 
  */
DBusMessage * 
wid_dbus_interface_set_wlan_ebr_br_ucast_solicit(DBusConnection *conn, DBusMessage *msg, void *user_data)

{
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	unsigned char state = 0;
	unsigned int Wlan_Ebr_ID = 0;
	unsigned char Wlan_Ebr_flag = 0;
	
	dbus_error_init(&err);
	
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32, &Wlan_Ebr_ID,
								DBUS_TYPE_BYTE, &state,
								DBUS_TYPE_BYTE, &Wlan_Ebr_flag,
								DBUS_TYPE_INVALID)))
	{
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) 
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if (state != 0 && state != 1)
	{
		wid_syslog_err("%s %d: <error> state:%d\n", __func__, __LINE__, state);
		return NULL;
	}

	if (Wlan_Ebr_flag == 0)			/* wlan config mode */
	{
		if (AC_WLAN[Wlan_Ebr_ID] == NULL)
		{
			wid_syslog_debug_debug(WID_DBUS, "AC_WLAN[%d] not exist\n", Wlan_Ebr_ID);
			ret = WLAN_ID_NOT_EXIST;
		}
		else if (AC_WLAN[Wlan_Ebr_ID]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
		{
			ret = WID_WANT_TO_DELETE_WLAN;
		}
		else if (AC_WLAN[Wlan_Ebr_ID]->wlan_if_policy != WLAN_INTERFACE)
		{
			wid_syslog_debug_debug(WID_DBUS, "AC_WLAN[%d] is not L3 interface\n", Wlan_Ebr_ID);
			ret = IF_POLICY_CONFLICT;
		}
		else if (AC_WLAN[Wlan_Ebr_ID]->SecurityID <= 0)
		{
			wid_syslog_debug_debug(WID_DBUS, "AC_WLAN[%d]'s Security not exist\n", Wlan_Ebr_ID);
			ret = WLAN_APPLY_SECURITY_FIRST;
		}
		else
		{
			if (AC_WLAN[Wlan_Ebr_ID]->bridge_ucast_solicit_stat == state)
			{
				reply = dbus_message_new_method_return(msg);
							
				dbus_message_iter_init_append (reply, &iter);	
				dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 

				wid_syslog_debug_debug(WID_DBUS,"===== %s %d AC_WLAN[%d]->bridge_ucast_solicit_stat:%d =====\n",
								__func__, 
								__LINE__, 
								Wlan_Ebr_ID,
								AC_WLAN[Wlan_Ebr_ID]->bridge_ucast_solicit_stat);
				
				return reply;
			}
		}
	}
	else if (Wlan_Ebr_flag == 1)		/* ebr config mode */
	{
		if (WID_EBR[Wlan_Ebr_ID] == NULL)
		{
			wid_syslog_debug_debug(WID_DBUS, "WID_EBR[%d] not exist\n", Wlan_Ebr_ID);
			ret = WID_EBR_NOT_EXIST;
		}
		else
		{
			if (WID_EBR[Wlan_Ebr_ID]->bridge_ucast_solicit_stat == state)
			{
				reply = dbus_message_new_method_return(msg);
							
				dbus_message_iter_init_append (reply, &iter);	
				dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 
				
				wid_syslog_debug_debug(WID_DBUS, "===== %s %d WID_EBR[%d]->bridge_ucast_solicit_stat:%d =====\n", 
								__func__,
								__LINE__,
								Wlan_Ebr_ID,
								WID_EBR[Wlan_Ebr_ID]->bridge_ucast_solicit_stat);

				return reply;
			}
		}
	}
	else
	{
		wid_syslog_err("%s %d: <error> Wlan_Ebr_flag:%d\n", __func__, __LINE__, Wlan_Ebr_flag);
	}
	
	if (ret == WID_DBUS_SUCCESS)
		ret = wid_set_wlan_ebr_br_ucast_solicit(Wlan_Ebr_ID, state, Wlan_Ebr_flag);
	
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 

	return reply;

}

/*
  *****************************************************************************
  *  
  * NOTES:	 
  * INPUT:	   
  * OUTPUT:	  
  * return:	  
  *  
  * author: 		Huang Leilei 
  * begin time:	2012-11-12 9:00  
  * finish time:		2012-11-15 11:00 
  * history:	
  * 
  **************************************************************************** 
  */
DBusMessage * 
wid_dbus_interface_set_wlan_ebr_br_mcast_solicit(DBusConnection *conn, DBusMessage *msg, void *user_data)

{
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	unsigned char state = 0;
	unsigned int Wlan_Ebr_ID = 0;
	unsigned char Wlan_Ebr_flag = 0;
	
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32, &Wlan_Ebr_ID,
								DBUS_TYPE_BYTE, &state,
								DBUS_TYPE_BYTE, &Wlan_Ebr_flag,
								DBUS_TYPE_INVALID)))
	{
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) 
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if (state != 0 && state != 1)
	{
		wid_syslog_err("%s %d: <error> state:%d\n", __func__, __LINE__, state);
		return NULL;
	}
	
	if (Wlan_Ebr_flag == 0)				/* wlan config mode */
	{
		if (AC_WLAN[Wlan_Ebr_ID] == NULL)
		{
			wid_syslog_debug_debug(WID_DBUS, "AC_WLAN[%d] not exist\n", Wlan_Ebr_ID);
			ret = WLAN_ID_NOT_EXIST;
		}
		else if (AC_WLAN[Wlan_Ebr_ID]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
		{
			ret = WID_WANT_TO_DELETE_WLAN;
		}
		else if (AC_WLAN[Wlan_Ebr_ID]->wlan_if_policy != WLAN_INTERFACE)
		{			
			wid_syslog_debug_debug(WID_DBUS, "AC_WLAN[%d] is not L3 interface\n", Wlan_Ebr_ID);
			ret = IF_POLICY_CONFLICT;
		}
		else if (AC_WLAN[Wlan_Ebr_ID]->SecurityID <= 0)
		{
			wid_syslog_debug_debug(WID_DBUS, "AC_WLAN[%d]'s Security not exist\n", Wlan_Ebr_ID);
			ret = WLAN_APPLY_SECURITY_FIRST;
		}
		else
		{
			if (AC_WLAN[Wlan_Ebr_ID]->bridge_mcast_solicit_stat == state)
			{
				reply = dbus_message_new_method_return(msg);
							
				dbus_message_iter_init_append (reply, &iter);	
				dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 

				wid_syslog_debug_debug(WID_DBUS, "===== %s %d AC_WLAN[%d]->bridge_mcast_solicit_stat:%d =====\n", 
								__func__,
								__LINE__,
								Wlan_Ebr_ID,
								AC_WLAN[Wlan_Ebr_ID]->bridge_mcast_solicit_stat);

				return reply;
			}
		}
	}
	else if (Wlan_Ebr_flag == 1)		/* ebr config mode */
	{
		if (WID_EBR[Wlan_Ebr_ID] == NULL)
		{
			wid_syslog_debug_debug(WID_DBUS, "WID_EBR[%d] not exist\n", Wlan_Ebr_ID);
			ret = WID_EBR_NOT_EXIST;
		}
		else 
		{
			if (WID_EBR[Wlan_Ebr_ID]->bridge_mcast_solicit_stat == state)
			{
				reply = dbus_message_new_method_return(msg);
						
				dbus_message_iter_init_append (reply, &iter);	
				dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 

				wid_syslog_debug_debug(WID_DBUS, "===== %s %d WID_EBR[%d]->bridge_mcast_solicit_stat:%d =====\n", 
								__func__,
								__LINE__,
								Wlan_Ebr_ID,
								WID_EBR[Wlan_Ebr_ID]->bridge_mcast_solicit_stat);

				return reply;
			}
		}
	}
	else
	{
		wid_syslog_err("%s %d: <error> Wlan_Ebr_flag:%d\n", __func__, __LINE__, Wlan_Ebr_flag);
	}
	
	if (ret == WID_DBUS_SUCCESS)
		ret = wid_set_wlan_ebr_br_mcast_solicit(Wlan_Ebr_ID, state, Wlan_Ebr_flag);
	
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 

	return reply;

}






















DBusMessage * wid_dbus_interface_set_wlan_br_sameportswitch(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	unsigned char state = 0;
	unsigned char wlanid = 0;
	
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_BYTE,&state,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if (AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	//else if (AC_WLAN[wlanid]->Status != 1)
	//{ 
	//	ret = WLAN_BE_ENABLE;
	//}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else if (AC_WLAN[wlanid]->wlan_if_policy != WLAN_INTERFACE)
	{
		ret = IF_POLICY_CONFLICT;
	}
	else if((AC_WLAN[wlanid]->isolation_policy == 1)||(AC_WLAN[wlanid]->multicast_isolation_policy == 1))
	{
		ret = ISOLATION_CONFLICT;
	}
	else if (AC_WLAN[wlanid]->SecurityID <= 0)
	{
		wid_syslog_debug_debug(WID_DBUS, "AC_WLAN[%d]'s Security not exist\n", wlanid);
		ret = WLAN_APPLY_SECURITY_FIRST;
	}
	else
	{
			ret = wid_set_wlan_br_sameportswitch(wlanid,state);
	}	
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 

	return reply;

}

DBusMessage * wid_dbus_interface_show_wlan_br_isolation_info(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	
	
	unsigned char wlanid = 0;
	
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if (AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	
	ret = WID_CHECK_ID(WID_WLAN_CHECK,(unsigned int)wlanid);
		
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 
	if(ret == WID_DBUS_SUCCESS)
	{
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_BYTE,&AC_WLAN[wlanid]->isolation_policy); 

		dbus_message_iter_append_basic (&iter,DBUS_TYPE_BYTE,&AC_WLAN[wlanid]->multicast_isolation_policy); 

		dbus_message_iter_append_basic (&iter,DBUS_TYPE_BYTE,&AC_WLAN[wlanid]->sameportswitch); 
	}
	//wid_syslog_info("wid_dbus_interface_show_wlan_br_isolation_info end\n");
	return reply;

}

DBusMessage * wid_dbus_interface_set_tunnel_wlan_vlan(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	char * name;
	unsigned char wlanid = 0;
	unsigned int state = 0;
	WTPQUITREASON quitreason = WTP_INIT;
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&state,
								DBUS_TYPE_STRING,&name,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	//printf("receive wlanid %d ifname %s\n",wlanid,name);
	
	if (AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else if (AC_WLAN[wlanid]->Status != 1)
	{ 
		ret = WLAN_BE_ENABLE;
	}
	else if (AC_WLAN[wlanid]->wlan_if_policy != WLAN_INTERFACE)
	{
		ret = WLAN_CREATE_BR_FAIL;
	}
	/*else if (AC_WLAN[wlanid]->vlanid != 0)         //fengwenchao comment 20110506 for bug:autelan-2298
	{
		ret = IF_POLICY_CONFLICT;
	}*/
	else
	{
		
		ret = Check_Interface_Config(name,&quitreason);
		
		if(ret == WID_DBUS_SUCCESS)
		{
			if(state == 1)
			{
				ret = wid_set_tunnel_wlan_vlan(wlanid,name);
			}
			else if(state == 0)
			{
				ret = wid_undo_tunnel_wlan_vlan(wlanid,name);
			}
		}
		else
		{
			if(state == 0)
			{
				struct WID_TUNNEL_WLAN_VLAN *wif;
				struct WID_TUNNEL_WLAN_VLAN *wifnext;

				wifnext = AC_WLAN[wlanid]->tunnel_wlan_vlan;
				
				if(AC_WLAN[wlanid]->tunnel_wlan_vlan != NULL)
				{
					if(strncmp(wifnext->ifname,name,strlen(name)) == 0)
					{
						AC_WLAN[wlanid]->tunnel_wlan_vlan = wifnext->ifnext;
						WID_FREE(wifnext);
						wifnext = NULL;		
//						printf("delete ifname from list\n");
					}
					else
					{
						while(wifnext->ifnext != NULL)
						{	
							if(strncmp(wifnext->ifnext->ifname,name,strlen(name)) == 0)
							{
								wif = wifnext->ifnext;
								wifnext->ifnext = wifnext->ifnext->ifnext;
								WID_FREE(wif);
								wif = NULL;				
//								printf("delete ifname from list\n");
							}
							wifnext = wifnext->ifnext;
						}
					}
				}
			}
		}	
	}
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 

	return reply;

}
DBusMessage * wid_dbus_interface_show_tunnel_wlan_vlan(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	unsigned int num = 0;
	unsigned char wlanid = 0;
	
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if (AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else if (AC_WLAN[wlanid]->Status != 1)
	{ 
		ret = WLAN_BE_ENABLE;
	}
	else if (AC_WLAN[wlanid]->wlan_if_policy != WLAN_INTERFACE)
	{
		ret = WLAN_CREATE_BR_FAIL;
	}
	/*else if (AC_WLAN[wlanid]->vlanid != 0)           //fengwenchao comment 20110505 for bug : autelan-2298
	{
		ret = IF_POLICY_CONFLICT;
	}*/
		
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append(reply, &iter);	
	dbus_message_iter_append_basic(&iter,DBUS_TYPE_UINT32,&ret); 
	if(ret == WID_DBUS_SUCCESS)
	{
		int i;
		WID_WLAN *WLAN = AC_WLAN[wlanid];
		struct WID_TUNNEL_WLAN_VLAN *ifi = WLAN->tunnel_wlan_vlan;
		while(ifi != NULL)
		{
			num++;
			ifi = ifi->ifnext;
		}
		//printf("num %d\n",num);
		dbus_message_iter_append_basic(&iter,DBUS_TYPE_UINT32,&num);
			
		ifi = WLAN->tunnel_wlan_vlan;		
		char *name;
		name = (char*)WID_MALLOC(ETH_IF_NAME_LEN+1);

		for(i = 0; i < num; i++){			
			
			memset(name,0,(ETH_IF_NAME_LEN+1));
			if(ifi->ifname != NULL)
			{
				memcpy(name,ifi->ifname,ETH_IF_NAME_LEN);
			}else{
				memcpy(name," ",1);
			}
					
			//printf("name %s ifname %s\n",name,ifi->ifname);
			dbus_message_iter_append_basic(&iter,DBUS_TYPE_STRING,&name);
			
			ifi = ifi->ifnext;
		}
		WID_FREE(name);
		name = NULL;
	}
	return reply;

}

DBusMessage * wid_dbus_interface_set_wlan_vlanid(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	unsigned int vlanid = 0;
	unsigned char wlanid = 0;
	
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&vlanid,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if (AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else if (AC_WLAN[wlanid]->Status != 1)
	{ 
		ret = WLAN_BE_ENABLE;
	}
/*	else if (AC_WLAN[wlanid]->wlan_if_policy != 0)
	{
		ret = IF_POLICY_CONFLICT;
	}
	else if (AC_WLAN[wlanid]->tunnel_wlan_vlan != NULL)
	{
		ret = SYSTEM_CMD_ERROR;
	}*///zhanglei cancel the limit of vlanid in tunnel
	else
	{
			ret = wid_set_wlan_vlanid(wlanid,vlanid);
	}	
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 

	return reply;

}

//mahz add 2011.5.25
DBusMessage * wid_dbus_interface_set_nas_port_id(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	char* nas_port_id = NULL;
	unsigned char wlanid = 0;
	
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_STRING,&nas_port_id,
								DBUS_TYPE_INVALID))){
	
		wid_syslog_debug_debug(WID_DBUS,"Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			wid_syslog_debug_info("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if (AC_WLAN[wlanid] == NULL){
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else if (AC_WLAN[wlanid]->Status != 1){ 
		ret = WLAN_BE_ENABLE;
	}
	else{
		memset(AC_WLAN[wlanid]->nas_port_id,0,sizeof(AC_WLAN[wlanid]->nas_port_id));
		memcpy(AC_WLAN[wlanid]->nas_port_id,nas_port_id,strlen(nas_port_id));

		wid_syslog_debug_info("AC_WLAN->nas_port_id : %s\n",AC_WLAN[wlanid]->nas_port_id);	//for test
	}
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 

	return reply;

}
//
DBusMessage * wid_dbus_interface_set_wlan_hotspotid(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	unsigned  int hotspotid = 0;
	unsigned char wlanid = 0;
	
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&hotspotid,
								DBUS_TYPE_INVALID))){
	
		wid_syslog_debug_debug(WID_DBUS,"Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			wid_syslog_debug_info("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if (AC_WLAN[wlanid] == NULL){
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else if (AC_WLAN[wlanid]->Status != 1){ 
		ret = WLAN_BE_ENABLE;
	}
	else{
		wid_set_wlan_hotspotid(wlanid,hotspotid);
		wid_syslog_debug_debug(WID_DEFAULT,"AC_WLAN[%d]->hotspot_id = %d\n",wlanid,AC_WLAN[wlanid]->hotspot_id);
	}
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 

	return reply;

}

DBusMessage * wid_dbus_interface_clean_wlan_hotspotid(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	unsigned char wlanid = 0;
	
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_INVALID))){
	
		wid_syslog_debug_debug(WID_DBUS,"Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			wid_syslog_debug_info("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if (AC_WLAN[wlanid] == NULL){
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else if (AC_WLAN[wlanid]->Status != 1){ 
		ret = WLAN_BE_ENABLE;
	}
	else{
		wid_set_wlan_hotspotid(wlanid,0);
		wid_syslog_debug_debug(WID_DEFAULT,"AC_WLAN[%d]->hotspot_id = %d\n",wlanid,AC_WLAN[wlanid]->hotspot_id);
	}
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 

	return reply;

}

DBusMessage * wid_dbus_interface_set_wlan_essid(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;

	char *essid = NULL,*tmp_essid = NULL;
	unsigned char wlanid = 0;
	int i = 0,j=0;
	
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_STRING,&essid,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if (AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else if (AC_WLAN[wlanid]->Status != 1)
	{ 
		ret = WLAN_BE_ENABLE;
	}
	else
	{
		tmp_essid = (char *)malloc(strlen(AC_WLAN[wlanid]->ESSID)+1);
		memset(tmp_essid,0,strlen(AC_WLAN[wlanid]->ESSID)+1);
		memcpy(tmp_essid,AC_WLAN[wlanid]->ESSID,strlen(AC_WLAN[wlanid]->ESSID));
		CW_FREE_OBJECT_WID(AC_WLAN[wlanid]->ESSID);
		AC_WLAN[wlanid]->ESSID = (char *)WID_MALLOC(strlen(essid)+1);
		memset(AC_WLAN[wlanid]->ESSID, 0, strlen(essid)+1);
		memcpy(AC_WLAN[wlanid]->ESSID,essid,strlen(essid));

		AsdWsm_WLANOp(wlanid,WID_MODIFY,0);

		for(i = 0; i<WTP_NUM;i++)
		{
			if(AC_WTP[i] != NULL)
			{
				for(j=0;j<L_RADIO_NUM;j++)
				{
					if((AC_WTP[i]->WTP_Radio[j] != NULL) && (AC_WTP[i]->WTP_Radio[j]->isBinddingWlan == 1))
					{
						struct wlanid *wlan_id = AC_WTP[i]->WTP_Radio[j]->Wlan_Id;
						while(wlan_id != NULL)
						{
							if(wlan_id->wlanid == wlanid)
							{
								if(strcmp(wlan_id->ESSID,tmp_essid) == 0)
								{
									CW_FREE_OBJECT_WID(wlan_id->ESSID);
									wlan_id->ESSID = (char *)WID_MALLOC(strlen(essid) + 1);
									memset(wlan_id->ESSID,0,strlen(essid)+1);
									memcpy(wlan_id->ESSID,essid,strlen(essid));
								}
								break;
							}
							wlan_id = wlan_id->next;
						}
					}
				}
			}
		}

		CW_FREE_OBJECT_WID(tmp_essid);
		
		wid_syslog_debug_debug(WID_DBUS,"change wlan %d essid %s\n",wlanid,AC_WLAN[wlanid]->ESSID);
	
	}
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 

	return reply;

}
//fengwenchao add 20110307 for autelan-2194
DBusMessage * wid_dbus_interface_set_wlan_ascii_essid(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;

	unsigned char ESSID[ESSID_DEFAULT_LEN+1];
	char *tmp_essid = NULL;
	memset(ESSID,0,ESSID_DEFAULT_LEN+1);
	unsigned char wlanid = 0;
	int i = 0,j = 0;
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_BYTE,&ESSID[0],
								DBUS_TYPE_BYTE,&ESSID[1],
								DBUS_TYPE_BYTE,&ESSID[2],
								DBUS_TYPE_BYTE,&ESSID[3],
								DBUS_TYPE_BYTE,&ESSID[4],
								
								DBUS_TYPE_BYTE,&ESSID[5],
								DBUS_TYPE_BYTE,&ESSID[6],
								DBUS_TYPE_BYTE,&ESSID[7],
								DBUS_TYPE_BYTE,&ESSID[8],
								DBUS_TYPE_BYTE,&ESSID[9],
								
								DBUS_TYPE_BYTE,&ESSID[10],
								DBUS_TYPE_BYTE,&ESSID[11],
								DBUS_TYPE_BYTE,&ESSID[12],
								DBUS_TYPE_BYTE,&ESSID[13],
								DBUS_TYPE_BYTE,&ESSID[14],
								
								DBUS_TYPE_BYTE,&ESSID[15],
								DBUS_TYPE_BYTE,&ESSID[16],
								DBUS_TYPE_BYTE,&ESSID[17],
								DBUS_TYPE_BYTE,&ESSID[18],
								DBUS_TYPE_BYTE,&ESSID[19],
								
								DBUS_TYPE_BYTE,&ESSID[20],
								DBUS_TYPE_BYTE,&ESSID[21],
								DBUS_TYPE_BYTE,&ESSID[22],
								DBUS_TYPE_BYTE,&ESSID[23],
								DBUS_TYPE_BYTE,&ESSID[24],
								
								DBUS_TYPE_BYTE,&ESSID[25],
								DBUS_TYPE_BYTE,&ESSID[26],
								DBUS_TYPE_BYTE,&ESSID[27],
								DBUS_TYPE_BYTE,&ESSID[28],
								DBUS_TYPE_BYTE,&ESSID[29],
								
								DBUS_TYPE_BYTE,&ESSID[30],
								DBUS_TYPE_BYTE,&ESSID[31],
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	wid_syslog_debug_debug(WID_DBUS,"ESSID = %s \n",ESSID);
	char essid_str2[ESSID_DEFAULT_LEN+1];
	char *s1=NULL;
	s1 = (char*)WID_MALLOC(1+1);

	memset(essid_str2,0,ESSID_DEFAULT_LEN+1);
	
	for(j = 0;j < ESSID_DEFAULT_LEN; j++ ){

		if((j>0)&&(ESSID[j] == 0)){
			break;

		}else{
			memset(s1,0,1+1);
			sprintf(s1,"%x",ESSID[j]);
			wid_syslog_debug_debug(WID_DBUS,"s1:%s\n",s1);			
			strncat(essid_str2,s1,strlen(s1));
		}
	}
	wid_syslog_debug_debug(WID_DBUS,"essid_str2 = %s \n",essid_str2);
	if (AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else if (AC_WLAN[wlanid]->Status != 1)
	{ 
		ret = WLAN_BE_ENABLE;
	}
	else
	{
		tmp_essid = (char *)malloc(strlen(AC_WLAN[wlanid]->ESSID)+1);
		memset(tmp_essid,0,strlen(AC_WLAN[wlanid]->ESSID)+1);
		memcpy(tmp_essid,AC_WLAN[wlanid]->ESSID,strlen(AC_WLAN[wlanid]->ESSID));
		CW_FREE_OBJECT_WID(AC_WLAN[wlanid]->ESSID);
		CW_FREE_OBJECT_WID(AC_WLAN[wlanid]->ESSID_CN_STR);
		AC_WLAN[wlanid]->ESSID = (char *)WID_MALLOC(strlen((char*)ESSID)+1);
		memset(AC_WLAN[wlanid]->ESSID, 0, strlen((char*)ESSID)+1);
		memcpy(AC_WLAN[wlanid]->ESSID,ESSID,strlen((char*)ESSID));

		AC_WLAN[wlanid]->chinaEssid = 1;

		AC_WLAN[wlanid]->ESSID_CN_STR = (unsigned char *)WID_MALLOC(strlen(essid_str2)+1);
		memset(AC_WLAN[wlanid]->ESSID_CN_STR, 0, strlen(essid_str2)+1);
		memcpy(AC_WLAN[wlanid]->ESSID_CN_STR,essid_str2,strlen(essid_str2));		

		AsdWsm_WLANOp(wlanid,WID_MODIFY,0);

		for(i = 0; i<WTP_NUM;i++)
		{
			if(AC_WTP[i] != NULL)
			{
				for(j=0;j<L_RADIO_NUM;j++)
				{
					if((AC_WTP[i]->WTP_Radio[j] != NULL) && (AC_WTP[i]->WTP_Radio[j]->isBinddingWlan == 1))
					{
						struct wlanid *wlan_id = AC_WTP[i]->WTP_Radio[j]->Wlan_Id;
						while(wlan_id != NULL)
						{
							if(wlan_id->wlanid == wlanid)
							{
								if(strcmp(wlan_id->ESSID,tmp_essid) == 0)
								{
									CW_FREE_OBJECT_WID(wlan_id->ESSID);
									wlan_id->ESSID = (char *)WID_MALLOC(strlen((char*)ESSID) + 1);
									memset(wlan_id->ESSID,0,strlen((char*)ESSID)+1);
									memcpy(wlan_id->ESSID,ESSID,strlen((char*)ESSID));
								}
								break;
							}
							wlan_id = wlan_id->next;
						}
					}
				}
			}
		}

		CW_FREE_OBJECT_WID(tmp_essid);
		
		wid_syslog_debug_debug(WID_DBUS,"change wlan %d essid %s\n",wlanid,AC_WLAN[wlanid]->ESSID);
	
	}
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 
	if(s1 !=NULL){
		CW_FREE_OBJECT_WID(s1);
	}

	return reply;	
}
//fengwenchao add end
DBusMessage * wid_dbus_interface_undo_wlan_vlanid(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	unsigned int vlanid = 0;
	unsigned char wlanid = 0;
	
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if (AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else if (AC_WLAN[wlanid]->Status != 1)
	{ 
		ret = WLAN_BE_ENABLE;
	}
	else if (AC_WLAN[wlanid]->wlan_if_policy != 0)
	{
		ret = IF_POLICY_CONFLICT;
	}
	else
	{
		if (AC_WLAN[wlanid]->vlanid == 0)
		{
			ret = WID_DBUS_SUCCESS;
		}
		else 
		{
			ret = wid_set_wlan_vlanid(wlanid,vlanid);
		}
	}	
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 

	return reply;

}

DBusMessage * wid_dbus_interface_set_wlan_vlan_priority(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int priority = 0;
	unsigned char wlanid = 0;
	
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&priority,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if (AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else if (AC_WLAN[wlanid]->Status != 1)
	{ 
		ret = WLAN_BE_ENABLE;
	}
	else if (AC_WLAN[wlanid]->wlan_if_policy != 0)
	{
		ret = IF_POLICY_CONFLICT;
	}
	else
	{
		if(AC_WLAN[wlanid]->vlanid == 0)
		{
			ret = WLAN_NOT_BINDING_VLAN;
		}
		else 
		{
			ret = wid_set_wlan_vlan_priority(wlanid,priority);
		}
	}
		
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 
	return reply;

}
DBusMessage * wid_dbus_interface_show_wlan_vlan_info(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	
	
	unsigned char wlanid = 0;
	
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	ret = WID_CHECK_ID(WID_WLAN_CHECK,(unsigned int)wlanid);
	
	if (AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
		
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 
	if(ret == 0)
	{
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&AC_WLAN[wlanid]->vlanid); 

		dbus_message_iter_append_basic (&iter,DBUS_TYPE_BYTE,&AC_WLAN[wlanid]->wlan_1p_priority); 
	}
	//wid_syslog_info("wid_dbus_interface_show_wlan_vlan_info end\n");
	return reply;

}

DBusMessage * wid_dbus_interface_show_wtp_wlan_vlan_infomation(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply = NULL;
	DBusError err;
	DBusMessageIter  iter;
	DBusMessageIter iter_array;
	DBusMessageIter iter_struct;
	int ret = WID_DBUS_SUCCESS;
	unsigned int vlanid = 0;
	unsigned char wlan_1p_priority =0;
	unsigned int wtpid = 0;
	unsigned char id[ACDBUS_WLAN_VLAN_LEN];
	memset(id,0,ACDBUS_WLAN_VLAN_LEN);
	int i = 0;
	int num = 0;
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if (wtpid >= WTP_NUM)
	{
		ret = WTP_ID_LARGE_THAN_MAX;
	}
	else if (AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	//parse wlan num
	else if(AC_WTP[wtpid]->WTP_Radio[0]->isBinddingWlan== 1)
	{
		struct wlanid *wlan_id = AC_WTP[wtpid]->WTP_Radio[0]->Wlan_Id;
		while(wlan_id != NULL)
		{	
			if(AC_WLAN[wlan_id->wlanid]){
				id[i] = wlan_id->wlanid;
				i++;
				wlan_id = wlan_id->next;
			}
		}
		num = i;
		//printf("num %d\n",num);
		
	}
	else
	{
		num = 0;
	}
					
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 

	if(ret == 0)
	{
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&num); 
		/*fengwenchao modify 20120428 for autelan-2917*/
		if(num > 0)
		{
			dbus_message_iter_open_container (&iter,
											DBUS_TYPE_ARRAY,
											DBUS_STRUCT_BEGIN_CHAR_AS_STRING
													DBUS_TYPE_BYTE_AS_STRING	//wlanid
													DBUS_TYPE_UINT32_AS_STRING	//vlanid
													DBUS_TYPE_BYTE_AS_STRING	//wlan_1p_priority
											DBUS_STRUCT_END_CHAR_AS_STRING,
											&iter_array);
			
			for (i=0;i<num;i++)
			{
				dbus_message_iter_open_container (&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
																																	
				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&id[i]); 
				
				if(AC_WLAN[(id[i])]){
					vlanid = AC_WLAN[(id[i])]->vlanid;
				}else{
					vlanid = 0;
					wid_syslog_err("<error>%s,%d,AC_WLAN[%d] is NULL,vlanid,wlan num:%d.\n",__func__,__LINE__,id[i],num);
				}
				
				if(AC_WLAN[(id[i])]){
					wlan_1p_priority = AC_WLAN[(id[i])]->wlan_1p_priority;
				}else{
					wlan_1p_priority = 0;
					wid_syslog_err("<error>%s,%d,AC_WLAN[%d] is NULL,wlan_1p_priority,wlan num:%d.\n",__func__,__LINE__,id[i],num);
				}
				
				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_UINT32,&vlanid);

				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&wlan_1p_priority);
				
				dbus_message_iter_close_container (&iter_array, &iter_struct);
			}
			dbus_message_iter_close_container (&iter, &iter_array);
		}
	}
	return reply;

}
DBusMessage * wid_dbus_interface_show_wtp_eth_if_infomation(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int wtpid = 0;
	unsigned int modelindex = 0;
	char model[ACDBUS_MODEL_LEN];
	memset(model,0,ACDBUS_MODEL_LEN);
	unsigned char ethnum = 0;
	unsigned char state = 0;
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	ret = WID_CHECK_ID(WID_WTP_CHECK,wtpid);
	
	if(ret == WID_DBUS_SUCCESS){
		if (AC_WTP[wtpid] == NULL)
		{
			ret = WTP_ID_NOT_EXIST;
		}
		else{
			memcpy(model,AC_WTP[wtpid]->WTPModel,strlen(AC_WTP[wtpid]->WTPModel));

			if ((!strncmp(model,"2010",4))||(!strncmp(model,"1110T",5))||(!strncmp(model,"AQ1000",6))||(!strncmp(model,"AQ1000-H",8))||(!strncmp(model,"AQ3110-H",8))||(!strncmp(model,"AQ3120-H",8)))
			{
				ethnum = 1;
			}
			else if (!strncmp(model,"2110",4))
			{
				ethnum = 2;
			}
			else
			{
				ret = VERSION_NOT_SUPPORTED;
			}

			if (!strcmp(model,"1110T"))
			{
				modelindex = 1;	
			}
			else if (!strcmp(model,"2010"))
			{
				modelindex = 2;	
			}
			else if (!strcmp(model,"2110"))
			{
				modelindex = 3;	
			}
			else if (!strcmp(model,"AQ1000"))
			{
				modelindex = 4;	
			}
			else if (!strcmp(model,"AQ1000-H"))
			{
				modelindex = 5;	
			}
			else if (!strcmp(model,"AQ3110-H"))
			{
				modelindex = 6;	
			}
			else if (!strcmp(model,"AQ3120-H"))
			{
				modelindex = 7;	
			}
			else
			{
				modelindex = 0;
			}

			if(gWTPs[wtpid].currentState == CW_ENTER_RUN)
			{
				state = 1;
			}
		}
	}
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 

	if(ret == 0)
	{
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_BYTE,&ethnum); 
		
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_BYTE,&state); 

		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&modelindex);

		dbus_message_iter_append_basic (&iter,DBUS_TYPE_STRING,&AC_WTP[wtpid]->WTPNAME); 
	
	}
	return reply;

}
DBusMessage * wid_dbus_interface_transmit_power_control(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 
	DBusMessageIter  iter;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int policy = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}


//	printf("transmit power control policy:%d\n",policy);
	
	if(1 == gapscanset.opstate)
	{
		if((txpower_state != policy)&&(1 == policy))
		{
			CWThreadMutexLock(&(gACTxpowerMutex));
			txpower_state = policy;

			CWSignalThreadCondition(&gACTxpowerWait);
			CWThreadMutexUnlock(&gACTxpowerMutex);
		}
		else if((txpower_state != policy)&&(0 == policy))
		{
			CWThreadMutexLock(&(gACTxpowerMutex));
			txpower_state = policy;
			CWThreadMutexUnlock(&gACTxpowerMutex);
		}
	}
	else if(policy == 1)
	{ 
		ret = WID_DBUS_ERROR;
	}
	

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;	

}
DBusMessage * wid_dbus_interface_txpower_threshold(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 
	DBusMessageIter  iter;
	DBusError err;
	dbus_error_init(&err);	
	
	int ret = WID_DBUS_SUCCESS;
	int txpower_thre = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&txpower_thre,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

//	printf("txpower threshold:%d\n",txpower_thre);
	
	CWThreadMutexLock(&(gACChannelMutex));
	tx_power_threshold = txpower_thre;	
	CWThreadMutexUnlock(&gACChannelMutex);		

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;	

}
DBusMessage * wid_dbus_interface_rogue_ap_trap_threshold(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 
	DBusMessageIter  iter;
	DBusError err;
	dbus_error_init(&err);	
	
	int ret = WID_DBUS_SUCCESS;
	int rogue_ap_trap_thre = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&rogue_ap_trap_thre,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(gapscanset.opstate == 0)
	{
		ret = WID_AP_SCANNING_DISABLE;
	}else
	{
		neighborrogueapcount = rogue_ap_trap_thre;	
	}

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;	

}

DBusMessage * wid_dbus_interface_coverage_threshold(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 
	DBusMessageIter  iter;
	DBusError err;
	dbus_error_init(&err);	
	
	int ret = WID_DBUS_SUCCESS;
	int coverage_thre = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&coverage_thre,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

//	printf("txpower threshold:%d\n",coverage_thre);
	
	CWThreadMutexLock(&(gACChannelMutex));
	coverage_threshold = coverage_thre;	
	CWThreadMutexUnlock(&gACChannelMutex);	


	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;	

}

DBusMessage * wid_dbus_interface_control_scope(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 
	DBusMessageIter  iter;
	DBusError err;
	dbus_error_init(&err);	
	
	int ret = WID_DBUS_SUCCESS;
	unsigned char scope = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&scope,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

//	printf("scanning scope:%d\n",scope);
	
	CWThreadMutexLock(&(gACChannelMutex));
	control_scope = scope; 
	CWThreadMutexUnlock(&gACChannelMutex);

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;	

}

DBusMessage * wid_dbus_interface_show_neighbor_rssi(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);	
	
	int ret = WID_DBUS_SUCCESS;
	int wtpid = 0;
	transmit_power_control power_control_info = {0};

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid >= WTP_NUM)
		ret = WTP_ID_LARGE_THAN_MAX;
	else{
		//CWThreadMutexLock(&(gACChannelMutex));
		CWThreadMutexLock(&(gWTPs[wtpid].RRMThreadMutex));

		if(gapscanset.opstate == 0)
		{
			ret = WID_AP_SCANNING_DISABLE;
		}
		else
		{

			if(AC_WTP[wtpid] == NULL)
			{
				ret = WTP_ID_NOT_EXIST;
			}

			else if((AC_WTP[wtpid]->NeighborAPInfos == NULL)||(AC_WTP[wtpid]->NeighborAPInfos->neighborapInfosCount == 0))
			{
				ret = WTP_NO_NEIGHBORAP;
			}
		 	else 
			{
				power_control_info.wtpid = wtpid;
				power_control_info.txpower= AC_WTP[wtpid]->WTP_Radio[0]->Radio_TXP;
				power_control_info.pre_txpower =power_control_info.txpower;
				get_power_control_info(&power_control_info, AC_WTP[wtpid]->NeighborAPInfos);
			}
		}
		
		//CWThreadMutexUnlock(&gACChannelMutex);
		CWThreadMutexUnlock(&(gWTPs[wtpid].RRMThreadMutex));
	}
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);

	if(ret == WID_DBUS_SUCCESS)
	{	

		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &power_control_info.txpower);
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &power_control_info.neighbor_rssi[0]);

		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &power_control_info.neighbor_rssi[1]);
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &power_control_info.neighbor_rssi[2]);
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &power_control_info.neighbor_rssi[3]);

	}			

	return reply;		

}


DBusMessage * wid_dbus_interface_wlan_enable(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
//	printf("wid_dbus_interface_show_radiosconf\n");
	DBusMessage * reply;
	DBusMessageIter	 iter;
	unsigned char WlanID;
	unsigned char DisWlan;
	DBusError err;	
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&WlanID,
								DBUS_TYPE_BYTE,&DisWlan,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(AC_WLAN[WlanID] != NULL){
		if (AC_WLAN[WlanID]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
		{
			ret = WID_WANT_TO_DELETE_WLAN;
		}
		else
		{
		if(AC_WLAN[WlanID]->SecurityID != 0)
		{
		if(DisWlan)
			ret = WID_DISABLE_WLAN(WlanID);
		else
			ret = WID_ENABLE_WLAN(WlanID);
		}
		else 
			ret = WID_DBUS_ERROR;
		}
	}else{
			ret = WLAN_ID_NOT_EXIST;
	}

	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
}

DBusMessage * wid_dbus_interface_wds_enable(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter	 iter;
	unsigned char WlanID;
	unsigned char wds_state;
	DBusError err;	
	int ret = WID_DBUS_SUCCESS;
	unsigned char wds_mesh = 0;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&WlanID,
								DBUS_TYPE_BYTE,&wds_mesh,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	wds_state = wds_mesh&0x01;
	if(AC_WLAN[WlanID] != NULL)
	{
		if (AC_WLAN[WlanID]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
		{
			ret = WID_WANT_TO_DELETE_WLAN;
		}
		else
		{
		if(wds_state == 1)
			ret = WID_wds_enable(WlanID,wds_mesh);
		else
			ret = WID_wds_disable(WlanID,wds_mesh);
		}

	}
	else
	{
			ret = WLAN_ID_NOT_EXIST;
	}

	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
}

DBusMessage * wid_dbus_interface_wlan_apply_if (DBusConnection *conn, DBusMessage *msg, void *user_data){

	
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	unsigned char WlanID;
	unsigned char if_count;
	int i,ret = WID_DBUS_SUCCESS;
	if (NULL == msg) {
		printf("failed get msg.\n");
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
	}
	dbus_message_iter_init(msg, &iter);	
	dbus_message_iter_get_basic(&iter,&WlanID);
	if(AC_WLAN[WlanID] == NULL){
		ret = WLAN_ID_NOT_EXIST;
	}else{
		dbus_message_iter_next(&iter);				
		dbus_message_iter_get_basic(&iter,&if_count);
		
		dbus_message_iter_next(&iter);
		
		dbus_message_iter_recurse(&iter,&iter_array);
		
		for (i = 0; i < if_count; i++){
			char *if_name;
			
			dbus_message_iter_get_basic(&iter_array,&if_name);
			
			ret = WID_ADD_IF_APPLY_WLAN(WlanID,if_name);
			
			dbus_message_iter_next(&iter_array);
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;

}

//receive terminal wlan message binding special interface weiay 200805604
DBusMessage * wid_dbus_interface_wlan_apply_ifname (DBusConnection *conn, DBusMessage *msg, void *user_data)
{	
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;

	unsigned char wlanid = 0;
	char *if_name = NULL;
	int ret = WID_DBUS_SUCCESS;
	int retv6 = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_STRING,&if_name,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}

	unsigned char ret_flag = 0;
	char * name;
	name = (char*)WID_MALLOC(strlen(if_name)+5);
	memset(name, 0, strlen(if_name)+5);

	if(check_ve_interface(if_name, name)){
		wid_syslog_debug_debug(WID_DBUS,"input ve interface doesn't exist!\n"); 
		ret = APPLY_IF_FAIL;
		retv6 = APPLY_IF_FAIL;
		ret_flag = 1;
	}

	//printf get values
	//printf("***** Input wlan id is %d\n",wlanid);
	//printf("***** Input wlan id binding interface name is %s\n",if_name);
	wid_syslog_debug_debug(WID_DBUS,"***** Input wlan id is %d",wlanid);
	wid_syslog_debug_debug(WID_DBUS,"***** Input wlan id binding interface name is %s",name);
	wid_syslog_info(" interface name is %s",name);
	if(AC_WLAN[wlanid] == NULL && ret_flag == 0)
	{
		ret = WLAN_ID_NOT_EXIST;
		retv6 = WLAN_ID_NOT_EXIST;
	}
	else if(ret_flag == 0)
	{
		if (AC_WLAN[wlanid] != NULL && AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
		{
			ret = WID_WANT_TO_DELETE_WLAN;
			retv6 = WID_WANT_TO_DELETE_WLAN;
		}
		else
		{
		//just binding one interface we 
		ret = WID_ADD_IF_APPLY_WLAN(wlanid,name);

		//delete by weianying because get ipv6 address by if_net6 file
		//now we use io ctrl
		
		//retv6 = WID_ADD_IF_APPLY_WLAN_ipv6(wlanid,if_name);
		
		retv6 =	WID_ADD_IF_APPLY_WLAN_ipv6_ioctl(wlanid,name);
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &ret);
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &retv6);
	
	WID_FREE(name);
	name = NULL;
	return reply;


}


DBusMessage * wid_dbus_interface_wlan_apply_ifname_ipv6(DBusConnection *conn, DBusMessage *msg, void *user_data)
{	
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;

	unsigned char wlanid = 0;
	char *if_name = NULL;
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_STRING,&if_name,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}
	unsigned char ret_flag = 0;
	char *name;
	name = (char *)WID_MALLOC(strlen(if_name)+1);
	memset(name,0,strlen(if_name)+1);
	if(check_ve_interface(if_name,name)){
		wid_syslog_debug_debug(WID_DBUS,"input ve interface dosen't exist!\n");
		ret = APPLY_IF_FAIL;
		ret_flag = 1;
		}

	//printf get values
	//printf("***** Input wlan id is %d\n",wlanid);
	//printf("***** Input wlan id binding interface name is %s\n",if_name);
	wid_syslog_debug_debug(WID_DBUS,"***** Input wlan id is %d",wlanid);
	wid_syslog_debug_debug(WID_DBUS,"***** Input wlan id binding interface name is %s",name);
	if(ret_flag == 0){
		if(AC_WLAN[wlanid] == NULL)
		{
			ret = WLAN_ID_NOT_EXIST;
		}
		else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
		{
			ret = WID_WANT_TO_DELETE_WLAN;
		}
		else
		{
			//just binding one interface we 
			ret = WID_ADD_IF_APPLY_WLAN_ipv6(wlanid,name);
		}
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &ret);
	WID_FREE(name);
	name = NULL;
	
	return reply;


}	

/* zhangshu add for set eap mac,2010-10-22 */
DBusMessage * wid_dbus_interface_wlan_set_eap_mac(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
    DBusMessage* reply;
    DBusError err;
    DBusMessageIter  iter;
    int ret = WID_DBUS_SUCCESS;
    
    unsigned char eap_switch = 0;
    unsigned char wlanid = 0;
    char *eap_mac = NULL;
//    int i = 0;
//    int j = 0;
//    unsigned int wtp_num = 0;

    WID_WTP **WTP;
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	if( WTP == NULL){
		wid_syslog_debug_debug(WID_DBUS,"%s :malloc fail.\n",__func__);
		exit(1);
	}
	memset(WTP,0,WTP_NUM*(sizeof(WID_WTP *)));

//	struct wlanid *wlanidlist = NULL;
    
    dbus_error_init(&err);
        
    if (!(dbus_message_get_args ( msg, &err,
                                DBUS_TYPE_BYTE,&wlanid,
                                DBUS_TYPE_BYTE,&eap_switch,
                                DBUS_TYPE_STRING,&eap_mac,
                                DBUS_TYPE_INVALID))){
    
        printf("Unable to get input args\n");
                    
        if (dbus_error_is_set(&err)) {
            printf("%s raised: %s",err.name,err.message);
            dbus_error_free(&err);
        }
		CW_FREE_OBJECT_WID(WTP);						  
        return NULL;
    }
    //printf("eap_mac_len = %d\n",strlen(eap_mac));
    //printf("eap_mac = %s\n",eap_mac);
    //printf("1111111111111111111\n");
        if (AC_WLAN[wlanid] != NULL && AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else if((AC_WLAN[wlanid]!=NULL)&&(AC_WLAN[wlanid]->Status == 0)){
        ret= WLAN_BE_ENABLE;//enable
	}
    else if(AC_WLAN[wlanid]!=NULL)
    {   
        //printf("22222222222222222222\n");
        AC_WLAN[wlanid]->eap_mac_switch = eap_switch;
        if(AC_WLAN[wlanid]->eap_mac != NULL)
        {
            memset(AC_WLAN[wlanid]->eap_mac,0,18);
            memcpy(AC_WLAN[wlanid]->eap_mac,eap_mac,strlen(eap_mac));
            memset(AC_WLAN[wlanid]->eap_mac2,0,MAC_LEN);
            if((eap_switch == 0)&&(eap_mac != NULL)&&(strcmp(eap_mac,"0") == 0))
            {}
            else
            {
                ret = parse_mac_addr(eap_mac,(MACADDR*)&(AC_WLAN[wlanid]->eap_mac2));
    			if(ret < 0)
    			{
    				wid_syslog_err("***<err>%s,line:%d eap_mac ret:%d ***\n",__func__,__LINE__,ret);
    			}
    			wid_syslog_debug_debug(WID_DBUS,"AC_WLAN[%d]->eap_mac2=%02X:%02X:%02X:%02X:%02X:%02X.\n",wlanid,AC_WLAN[wlanid]->eap_mac2[0],AC_WLAN[wlanid]->eap_mac2[1],AC_WLAN[wlanid]->eap_mac2[2],AC_WLAN[wlanid]->eap_mac2[3],AC_WLAN[wlanid]->eap_mac2[4],AC_WLAN[wlanid]->eap_mac2[5]);
            }
        }
        //printf("333333333333333333333333\n");
        #if 0
        wtp_num = Wid_Find_Wtp(WTP);
        //printf("wtp_num = %d\n",wtp_num);
        for(i = 0; i < wtp_num; i++)
        {
            //printf("444444444444444444444444\n");
            for(j=0; j<(WTP[i]->RadioCount); j++)
		    {
    			if(WTP[i]->WTP_Radio[j] != NULL && WTP[i]->WTP_Radio[j]->isBinddingWlan == 1)
    			{
    			    //printf("55555555555555555555555\n");
    				wlanidlist = WTP[i]->WTP_Radio[j]->Wlan_Id;
    				
    				while(wlanidlist != NULL)
    				{
    					if(wlanidlist->wlanid == wlanid)
    					{
                        	break;
    					}
    					
    					wlanidlist = wlanidlist->next;
    					
    				}
    				if(wlanidlist != NULL)
    				{
    				    //printf("6666666666666666666666666\n");
    				    /* send eap switch & mac to ap */
                    	char apcmd[WID_SYSTEM_CMD_LENTH] = {0};
                        //printf("7777777777777777777777777777\n");
                    	if(eap_switch == 1)
                    	{
                		    sprintf(apcmd,"set_eap_mac ath.%d-%d %s",j,wlanid,eap_mac);
                		}
                		else
                		{
                		    sprintf(apcmd,"set_eap_mac ath.%d-%d 0",j,wlanid);
                		}
                		//printf("apcmd = %s\n",apcmd);
                		//printf("8888888888888888888888888888\n");
                    	wid_syslog_debug_debug(WID_DEFAULT,"set eap mac cmd %s\n",apcmd);
                    	ret = wid_radio_set_extension_command(WTP[i]->WTP_Radio[j]->WTPID,apcmd);
                    	//printf("999999999999999999999999999\n");
                    	/* end */
    				}
    				
    			}
    		}
        }
        #endif
    }
    else
    {
        ret=WLAN_ID_NOT_EXIST;
    }
    
    reply = dbus_message_new_method_return(msg);
                    
    dbus_message_iter_init_append (reply, &iter);   
    dbus_message_iter_append_basic (&iter,
                                    DBUS_TYPE_UINT32,
                                    &ret); 
    //printf("@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
    CW_FREE_OBJECT_WID(WTP);                          
    return reply;

}
/* zhangshu add end */

//xm add 08/12/29
DBusMessage * wid_dbus_interface_wlan_balance_switch(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	
	unsigned char method=0;
	unsigned char wlanid=0;
	
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_BYTE,&method,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(AC_WLAN[wlanid]!=NULL){				
		if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
		{
			ret = WID_WANT_TO_DELETE_WLAN;
		}
		else
		{
		if(method==0){				
			if(AC_WLAN[wlanid]->balance_switch != 0){
				balance_probe_extend_command(wlanid,0);
				AC_WLAN[wlanid]->balance_switch=0;
				AC_WLAN[wlanid]->balance_method=0;

				if(1!=AsdWsm_WLANOp(wlanid,WID_MODIFY,0))
					ret=WID_DBUS_ERROR;
			}
		}else{
			if((AC_WLAN[wlanid]->balance_switch != 1) || (AC_WLAN[wlanid]->balance_method != method)){
				balance_probe_extend_command(wlanid,1);
				AC_WLAN[wlanid]->balance_switch=1;
				AC_WLAN[wlanid]->balance_method=method;
			    if(1!=AsdWsm_WLANOp(wlanid,WID_MODIFY,0))
					ret=WID_DBUS_ERROR;
				}
			}
		}
	}else
		ret=WLAN_ID_NOT_EXIST;
	
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 
	return reply;

}

DBusMessage * wid_dbus_interface_wlan_flow_balance_para(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int para=0;
	unsigned char wlanid=0;
	
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&para,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(AC_WLAN[wlanid]!=NULL){
		if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
		{
			ret = WID_WANT_TO_DELETE_WLAN;
		}
		else
		{
		AC_WLAN[wlanid]->flow_balance_para=para;
		if(1!=AsdWsm_WLANOp(wlanid,WID_MODIFY,0))
			ret=WID_DBUS_ERROR;
		}
	}
	else
		ret=WLAN_ID_NOT_EXIST;
	
		
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 
	return reply;

	

}

//weichao add 2011.10.28
DBusMessage *wid_dbus_interface_wlan_flow_check(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	unsigned char wlanid=0;
	unsigned short state;
	
	wid_syslog_debug_debug(WID_DBUS,"********************************NOW IN wid_dbus_interface_wlan_flow_check\n");
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT16,&state,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	wid_syslog_debug_debug(WID_DBUS,"AC_WLAN->flow_check = %d,status = %d\n",state,AC_WLAN[wlanid]->Status );
	if(AC_WLAN[wlanid]!=NULL){
		if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
		{
			ret = WID_WANT_TO_DELETE_WLAN;
		}
		else if(AC_WLAN[wlanid]->flow_check  != state){
			AC_WLAN[wlanid]->flow_check = state;
			
			if(1!=AsdWsm_WLANOp(wlanid,WID_MODIFY,0))
				ret=WID_DBUS_ERROR;
			if(AC_WLAN[wlanid]->Status == 0)
				WLAN_FLOW_CHECK(wlanid);
			
		}
	}
	else
		ret=WLAN_ID_NOT_EXIST;

	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 
	return reply;
	
}
//weichao add 2011.10.31
DBusMessage *wid_dbus_interface_wlan_no_flow_time(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	unsigned char wlanid=0;
	unsigned int flow_time;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&flow_time,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(AC_WLAN[wlanid]!=NULL){
		if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
		{
			ret = WID_WANT_TO_DELETE_WLAN;
		}
		else
		{
		AC_WLAN[wlanid]->no_flow_time=flow_time;
		
		if(1!=AsdWsm_WLANOp(wlanid,WID_MODIFY,0))
			ret=WID_DBUS_ERROR;
		 if(AC_WLAN[wlanid]->flow_check == 0){
			ret = FLOW_CHECK_BE_DISABLE;
		
		}
		 else if(AC_WLAN[wlanid]->Status == 0){
			WLAN_FLOW_CHECK(wlanid);
			}		
		}		
		
	}
	else
		ret=WLAN_ID_NOT_EXIST;
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 
	return reply;
	
}

//weichao add 2011.10.31
DBusMessage *wid_dbus_interface_wlan_limit_min_flow(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	unsigned char wlanid=0;
	unsigned int  limit_flow;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&limit_flow,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(AC_WLAN[wlanid]!=NULL){
		if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
		{
			ret = WID_WANT_TO_DELETE_WLAN;
		}
		else
		{
		AC_WLAN[wlanid]->limit_flow=limit_flow;
		
		if(1!=AsdWsm_WLANOp(wlanid,WID_MODIFY,0))
			ret=WID_DBUS_ERROR;
		 if(AC_WLAN[wlanid]->flow_check == 0){
			ret = FLOW_CHECK_BE_DISABLE;
		
		}
		else if(AC_WLAN[wlanid]->Status == 0){
			WLAN_FLOW_CHECK(wlanid);
			}
		}		
	}
	else
		ret=WLAN_ID_NOT_EXIST;

	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 
	return reply;
	
}

//xm add 08/12/29
DBusMessage * wid_dbus_interface_wlan_balance_para(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int para=0;
	unsigned char wlanid=0;
	
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&para,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(AC_WLAN[wlanid]!=NULL){
		if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
		{
			ret = WID_WANT_TO_DELETE_WLAN;
		}
		else
		{
		AC_WLAN[wlanid]->balance_para=para;
		if(1!=AsdWsm_WLANOp(wlanid,WID_MODIFY,0))
			ret=WID_DBUS_ERROR;
		}
	}
	else
		ret=WLAN_ID_NOT_EXIST;
	
		
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 
	return reply;

	
}

/*fengwenchao add 20120323*/
DBusMessage * wid_dbus_interface_wlan_access_sta_limit_rssi(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply = NULL;
	DBusError err;
	DBusMessageIter  iter;
	dbus_error_init(&err);

	int ret = 0;
	unsigned char wlanid = 0;
	unsigned char rssi = 0;
	int i =0;
	int j =0;
	int k1 =0;
	//int k2= 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_BYTE,&rssi,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	//wid_syslog_info("maddersky wlanid = %d \n",wlanid);
	if(wlanid == 0)
	{
		//wid_syslog_info("maddersky %d \n",__LINE__);
		gWLAN_LIMIT_STA_RSSI = rssi;
	 	for(i=1;i<WTP_NUM;i++)
	 	{
			if(AC_WTP[i] != NULL)
			{
				int radionum = AC_WTP[i]->RadioCount;
				for(j=0;j<radionum;j++)
				{
					for(k1 =0;k1 < WLAN_NUM;k1++)
					{
						if(AC_WLAN[k1] != NULL)
						{
							//wid_syslog_info("maddersky %d \n",__LINE__);
							if (AC_WLAN[k1]->want_to_delete != 1)		/* Huangleilei add for ASXXZFI-1622 */
							{
							AC_WLAN[k1]->wlan_limit_sta_rssi =rssi;
							int bssindex = AC_WLAN[k1]->S_WTP_BSS_List[i][j];
							if(check_bssid_func(bssindex))
							{
								if(AC_BSS[bssindex]->limit_sta_rssi != rssi)
								{
									char command[WID_SYSTEM_CMD_LENTH] = {0};
									sprintf(command,"iwpriv ath.%d-%d set_rssithre %d",j,wlanid,rssi);
									wid_radio_set_extension_command(i, command);
									AC_BSS[bssindex]->limit_sta_rssi = rssi;
								}
							}
						}
					}
				}
			}
		}
	}
	}
	else if((wlanid > 0)&&(AC_WLAN[wlanid] != NULL) && (AC_WLAN[wlanid]->want_to_delete != 1))		/* Huangleilei add for ASXXZFI-1622 */
	{
		//wid_syslog_info("maddersky %d \n",__LINE__);
	 	for(i=1;i<WTP_NUM;i++)
	 	{
			if(AC_WTP[i] != NULL)
			{
				int radionum = AC_WTP[i]->RadioCount;
				for(j=0;j<radionum;j++)
				{
					//wid_syslog_info("maddersky %d \n",__LINE__);
					if (AC_WLAN[wlanid]->want_to_delete != 1)		/* Huangleilei add for ASXXZFI-1622 */
					{
					AC_WLAN[wlanid]->wlan_limit_sta_rssi =rssi;
					int bssindex = AC_WLAN[wlanid]->S_WTP_BSS_List[i][j];
					if(check_bssid_func(bssindex))
					{
						if(AC_BSS[bssindex]->limit_sta_rssi != rssi)
						{
							char command[WID_SYSTEM_CMD_LENTH] = {0};
							sprintf(command,"iwpriv ath.%d-%d set_rssithre %d",j,wlanid,rssi);
							wid_radio_set_extension_command(i, command);
							AC_BSS[bssindex]->limit_sta_rssi = rssi;
						}
					}
				}
			}
		}
		}

	}
	if (wlanid > 0 && (AC_WLAN[wlanid] != NULL) && (AC_WLAN[wlanid]->want_to_delete == 1))		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}

	reply = dbus_message_new_method_return(msg);		
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 
	return reply;	
}

DBusMessage * wid_dbus_interface_wlan_sta_static_arp(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply = NULL;
	DBusError err;
	DBusMessageIter  iter;
	dbus_error_init(&err);
	char *ifname = NULL;
	int ret = 0;
	unsigned char wlanid = 0;
	unsigned int able = 0;
	int i =0;
	int j =0;
	int k1 =0;
	//int k2= 0;
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&able,
								DBUS_TYPE_STRING,&ifname,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	unsigned char ret_flag = 0;
	char *name;
	name = (char*)WID_MALLOC(strlen(ifname)+5);
	memset(name,0,strlen(ifname)+5);
	if(check_ve_interface(ifname,name)){
		wid_syslog_debug_debug(WID_DBUS,"intput ve interface dosen't exist!\n");
		ret = APPLY_IF_FAIL;
		ret_flag = 1;
	}
	if(ret_flag == 0){
	if(wlanid == 0)
	{
		gWLAN_STA_STATIC_ARP_POLICY.policy = able;
		if(strlen(name) < ETH_IF_NAME_LEN)
		{
			memset(gWLAN_STA_STATIC_ARP_POLICY.arp_ifname,0,ETH_IF_NAME_LEN);
			memcpy(gWLAN_STA_STATIC_ARP_POLICY.arp_ifname,name, strlen(name));
		}
		else
		{
			gWLAN_STA_STATIC_ARP_POLICY.policy = 0;
		}

		for(i=1;i<WTP_NUM;i++)
		{
			if(AC_WTP[i] != NULL)
			{
				int radionum = AC_WTP[i]->RadioCount;
				for(j=0;j<radionum;j++)
				{
					if(AC_WTP[i]->WTP_Radio[j] != NULL)
					{
						for(k1=0;k1<WLAN_NUM;k1++)
						{
							if(AC_WLAN[k1] != NULL && AC_WLAN[k1]->want_to_delete != 1)		/* Huangleilei add for ASXXZFI-1622 */
							{
								AC_WLAN[k1]->wlan_sta_static_arp_policy = able;
								if(strlen(name) < ETH_IF_NAME_LEN)
								{
									memset(AC_WLAN[k1]->wlan_arp_ifname,0,ETH_IF_NAME_LEN);
									memcpy(AC_WLAN[k1]->wlan_arp_ifname,name, strlen(name));
								}
								else
									AC_WLAN[k1]->wlan_sta_static_arp_policy = 0;
								int bssindex = AC_WLAN[k1]->S_WTP_BSS_List[i][j];
								if((bssindex > 0)&&(AC_BSS[bssindex] != NULL))
								{
									AC_BSS[bssindex]->sta_static_arp_policy = able;
									if(strlen(name) < ETH_IF_NAME_LEN){
										memset(AC_BSS[bssindex]->arp_ifname,0,ETH_IF_NAME_LEN);
										memcpy(AC_BSS[bssindex]->arp_ifname,name, strlen(name));
									}else{
										AC_BSS[bssindex]->sta_static_arp_policy = 0;
									}
									if(AC_BSS[bssindex]->State == 1){
										AsdWsm_BSSOp(bssindex, WID_MODIFY, 0);						
									}									
								}
							}
						}
					}
				}
			}
		}
	}
	else if((wlanid > 0)&&(AC_WLAN[wlanid] != NULL) && (AC_WLAN[wlanid]->want_to_delete != 1))		/* Huangleilei add for ASXXZFI-1622 */
	{
		AC_WLAN[wlanid]->wlan_sta_static_arp_policy = able;
		if(strlen(name) < ETH_IF_NAME_LEN)
		{
			memset(AC_WLAN[wlanid]->wlan_arp_ifname,0,ETH_IF_NAME_LEN);
			memcpy(AC_WLAN[wlanid]->wlan_arp_ifname,name, strlen(name));
		}
		else
			AC_WLAN[wlanid]->wlan_sta_static_arp_policy = 0;
		
		for(i=1;i<WTP_NUM;i++)
		{
			if(AC_WTP[i] != NULL)
			{
				int radionum = AC_WTP[i]->RadioCount;
				for(j=0;j<radionum;j++)
				{
					if(AC_WTP[i]->WTP_Radio[j] != NULL)
					{						
						int bssindex = AC_WLAN[wlanid]->S_WTP_BSS_List[i][j];
						if((bssindex > 0)&&(AC_BSS[bssindex] != NULL))
						{
							AC_BSS[bssindex]->sta_static_arp_policy = able;
							if(strlen(name) < ETH_IF_NAME_LEN){
								memset(AC_BSS[bssindex]->arp_ifname,0,ETH_IF_NAME_LEN);
								memcpy(AC_BSS[bssindex]->arp_ifname,name, strlen(name));
							}else{
								AC_BSS[bssindex]->sta_static_arp_policy = 0;
							}
							if(AC_BSS[bssindex]->State == 1){
								AsdWsm_BSSOp(bssindex, WID_MODIFY, 0);						
							}									
						}
					}
				}
			}
		}

	}
	}
	if (wlanid != 0 && AC_WLAN[wlanid] != NULL && AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}

	reply = dbus_message_new_method_return(msg);		
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret);
	WID_FREE(name);
	name = NULL;
	return reply;	
}

DBusMessage * wid_dbus_interface_wlan_l2_isolation_new(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply = NULL;
	DBusError err;
	DBusMessageIter  iter;
	unsigned int able =0;
	unsigned char wlanid= 0;
	unsigned int ret = 0;
	int i =0;
	int j =0;
	int k1 =0;
	//int k2 = 0;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&able,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(wlanid ==0)
	{
		gWLAN_ATH_L2_ISOLATION = able;
		for(i=1;i<WTP_NUM;i++)
		{
			if(AC_WTP[i] != NULL)
			{
				int radionum = AC_WTP[i]->RadioCount;
				for(j=0;j < radionum;j++)
				{
					if(AC_WTP[i]->WTP_Radio[j])
					{
						for(k1=0;k1 < WLAN_NUM;k1++)
						{
							if((AC_WLAN[k1] != NULL) && (AC_WLAN[k1]->want_to_delete != 1))		/* Huangleilei add for ASXXZFI-1622 */
							{
								struct wlanid *wlan_id = AC_WTP[i]->WTP_Radio[j]->Wlan_Id;
								while(wlan_id != NULL)
								{	
									if(wlan_id->wlanid == k1)
									{
										if(able == 1)
										{
											wid_set_radio_l2_isolation_enable(i,j,k1);
										}
										else
										{
											wid_set_radio_l2_isolation_disable(i,j,k1);
										}	
										AC_WLAN[k1]->wlan_ath_l2_isolation = able;
										break;
									}
									wlan_id = wlan_id->next;
								}
							}
						}
					}
				}
			}
		}
	}
	else if((wlanid > 0)&&(AC_WLAN[wlanid] != NULL)&&(AC_WLAN[wlanid]->wlan_ath_l2_isolation != able) && (AC_WLAN[wlanid]->want_to_delete != 1))		/* Huangleilei add for ASXXZFI-1622 */
	{
		for(i=1;i<WTP_NUM;i++)
		{
			if(AC_WTP[i] != NULL)
			{
				int radionum = AC_WTP[i]->RadioCount;
				for(j=0;j < radionum;j++)
				{
					if(AC_WTP[i]->WTP_Radio[j])
					{
						struct wlanid *wlan_id = AC_WTP[i]->WTP_Radio[j]->Wlan_Id;
						while(wlan_id != NULL)
						{	
							if(wlan_id->wlanid == wlanid)
							{
								if(able == 1)
								{
									wid_set_radio_l2_isolation_enable(i,j,wlanid);
								}
								else
								{
									wid_set_radio_l2_isolation_disable(i,j,wlanid);
								}	
								AC_WLAN[wlanid]->wlan_ath_l2_isolation = able;
								break;
							}
							wlan_id = wlan_id->next;
						}
						
					}
				}
			}
		}

	}
	if (wlanid != 0 && (AC_WLAN[wlanid] != NULL) && (AC_WLAN[wlanid]->want_to_delete != 0))		/* Huangleilei add for ASXXZFI-1622, check for AXSSZFI-1701 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	reply = dbus_message_new_method_return(msg);		
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 
	return reply;
}

DBusMessage * wid_dbus_interface_wlan_max_sta_new(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply= NULL;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	int ret1 = WID_DBUS_SUCCESS;
	unsigned int sta_num = 0;
	unsigned int wlan_num = 0;
	unsigned int wlanid[WLAN_NUM] = {0};
	unsigned int fail_wlan[WLAN_NUM] = {0};
	unsigned char type = 0;
	int fail_num = 0;
	int i = 0;
	int j = 0;
	int k1 =0;
	int k2 = 0;
	char apcmd[WID_SYSTEM_CMD_LENTH];
	
	dbus_error_init(&err);

	dbus_message_iter_init(msg,&iter);
	dbus_message_iter_get_basic(&iter,&type);
	dbus_message_iter_next(&iter);
	dbus_message_iter_get_basic(&iter,&sta_num);
	dbus_message_iter_next(&iter);
	dbus_message_iter_get_basic(&iter,&wlan_num);
	dbus_message_iter_next(&iter);

	if(type == 0)
		gWLAN_MAX_ALLOWED_STA_NUM_FOR_BSS = sta_num;

	for(i =0; i < wlan_num;i ++)
	{			
		dbus_message_iter_get_basic(&iter,&wlanid[i]);	
		dbus_message_iter_next(&iter);
		if(AC_WLAN[wlanid[i]] != NULL && (AC_WLAN[wlanid[i]]->want_to_delete != 1))		/* Huangleilei add for ASXXZFI-1622 */
		{
			AC_WLAN[wlanid[i]]->bss_allow_max_sta_num = sta_num;
		}
	}

	for(i = 1; i < WTP_NUM;i++)
	{
		if(AC_WTP[i] != NULL)
		{
			int radio_num = AC_WTP[i]->RadioCount;
			for(j = 0; j <radio_num;j++)
			{
				if(AC_WTP[i]->WTP_Radio[j] != NULL)
				{
					unsigned int radio_id = AC_WTP[i]->WTP_Radio[j]->Radio_G_ID;
					for(k1 =0; k1 < L_BSS_NUM;k1++)
					{
						if((AC_RADIO[radio_id] != NULL)&&(AC_RADIO[radio_id]->BSS[k1] != NULL)&&(AC_BSS[radio_id*L_BSS_NUM+k1] != NULL))
						{
							for(k2 = 0; k2 < wlan_num; k2++)
							{
								if(AC_RADIO[radio_id]->BSS[k1]->WlanID == wlanid[k2] && (AC_WLAN[wlanid[k2]] != NULL && AC_WLAN[wlanid[k2]]->want_to_delete != 1))		/* Huangleilei add for ASXXZFI-1622 */
								{
									AC_RADIO[radio_id]->BSS[k1]->bss_max_allowed_sta_num = AC_WLAN[wlanid[k2]]->bss_allow_max_sta_num;
									AC_BSS[radio_id*L_BSS_NUM+k1]->bss_max_allowed_sta_num = AC_WLAN[wlanid[k2]]->bss_allow_max_sta_num;
									if(1!=AsdWsm_BSSOp(radio_id*L_BSS_NUM+k1,WID_MODIFY,0))
										ret1 =WID_DBUS_ERROR;
									memset(apcmd,0,WID_SYSTEM_CMD_LENTH);	
									sprintf(apcmd,"echo %d > /proc/sys/net/ath.%d-%d/maxaid",AC_WLAN[wlanid[k2]]->bss_allow_max_sta_num,AC_RADIO[radio_id]->Radio_L_ID,AC_RADIO[radio_id]->BSS[k1]->WlanID);
									wid_syslog_debug_debug(WID_DEFAULT,"wid_set_radio_txantenna apcmd %s\n",apcmd);
									ret1 = wid_radio_set_extension_command(AC_RADIO[radio_id]->WTPID,apcmd);
									if(ret1 != 0)
									{
										fail_wlan[fail_num] = wlanid[k2];
										fail_num++;
									}
								}
							}							
						}
					}
				}
			}
		}
	}

	reply = dbus_message_new_method_return(msg);		
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&fail_num); 
	for(i=0;i<fail_num;i++)
	{
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&fail_wlan[i]); 
	}
	return reply;	

}

/*fengwenchao add end*/
//xm add 08/12/04
DBusMessage * wid_dbus_interface_wlan_max_sta(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int wlan_max=0;
	unsigned char wlanid=0;
	//struct hostapd_data *bss[240];
	//unsigned int num = 0;
	//unsigned int sta_num=0;
	//int i=0;
	
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&wlan_max,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	
	/*we need know how many sta has accessed,first*/
	//num = ASD_SEARCH_WLAN_STA(wlanid, bss);
	//for(i=0;i<num;i++)
	//	sta_num+=bss[i]->num_sta;
		
	//if(sta_num>wlan_max){
		//ret=ASD_WLAN_VALUE_INVALIDE;
	//}
	//else 
	if(AC_WLAN[wlanid]!=NULL){
		if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
		{
			ret = WID_WANT_TO_DELETE_WLAN;
		}
		else
		{
		AC_WLAN[wlanid]->wlan_max_allowed_sta_num=wlan_max;
		if(1!=AsdWsm_WLANOp(wlanid,WID_MODIFY,0))
			ret=WID_DBUS_ERROR;
		}
	}
	else
		ret=WLAN_ID_NOT_EXIST;
	
		
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 
	return reply;	

}





//receive terminal wtp message binding special interface weiay 200805604

//added by weiay 20080701
DBusMessage * wid_dbus_interface_wlan_delete_ifname (DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;

	unsigned char wlanid = 0;
	char *if_name = NULL;
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_STRING,&if_name,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}
	unsigned char ret_flag = 0;
	char *name;
	name = (char *)WID_MALLOC(strlen(if_name)+5);
	memset(name,0,strlen(if_name)+5);
	if(check_ve_interface(if_name,name)){
		wid_syslog_debug_debug(WID_DBUS,"input ve interface dosen't exist!\n");
		ret = APPLY_IF_FAIL;
		ret_flag = 1;
	}
	if(ret_flag == 0){
		if(AC_WLAN[wlanid] == NULL)
		{
			ret = WLAN_ID_NOT_EXIST;
		}
		else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
		{
			ret = WID_WANT_TO_DELETE_WLAN;
		}
		else
		{
			if(AC_WLAN[wlanid]->Status == 0)
			{
				ret = WLAN_BE_ENABLE;
			}else
			ret = WID_DELETE_IF_APPLY_WLAN(wlanid,name);
		}
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &ret);
	WID_FREE(name);
	name = NULL;
	
	return reply;	
}
DBusMessage * wid_dbus_interface_wlan_hide_essid (DBusConnection *conn, DBusMessage *msg, void *user_data)
{

	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;
	unsigned char wlanid = 0;
	unsigned char hideessid = 0;
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_BYTE,&hideessid,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}

	if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else
	{
		if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
		{
			ret = WID_WANT_TO_DELETE_WLAN;
		}
		else
		{
		ret = WID_WLAN_HIDE_ESSID(wlanid,hideessid);
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;	
}
DBusMessage * wid_dbus_interface_wlan_l3if_policy(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;
	unsigned char wlanid = 0;
	unsigned char wlan_policy = 0;
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_BYTE,&wlan_policy,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}

	if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else
	{
		if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
		{
			ret = WID_WANT_TO_DELETE_WLAN;
		}
		else
		{
		ret = WID_WLAN_L3IF_POLICY(wlanid,wlan_policy);
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;	

}
DBusMessage * wid_dbus_interface_wlan_l3if_policy2(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply = NULL;
	DBusError err;
	DBusMessageIter	 iter;
	unsigned int wlanid = 0;
	unsigned int wtpid = 0;
	unsigned int radioid = 0;
	unsigned int g_radioid = 0;
	unsigned char wlan_policy = 0;
	int ret = WID_DBUS_ERROR;
	int ret1 = -1;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wlanid,
								DBUS_TYPE_BYTE,&wlan_policy,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&radioid,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}
	wid_syslog_debug_debug(WID_DBUS,"received wtpid:%d,wlanid:%d,radioid:%d,wlan_policy:%d\n",wtpid,wlanid,radioid,wlan_policy);
	// get g_radioid
	g_radioid = wtpid*L_RADIO_NUM + radioid ;//1-0.1 means radio 4
	int bssid = 0;
	if(wtpid >= WTP_NUM)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(wlanid >= WLAN_NUM)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* hll add for AXSSZFI-1742 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else if (AC_RADIO[g_radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	/*else if(check_whether_in_ebr(vrrid,wtpid,radioid,wlanid,&ebr_id))
	{
		ret = RADIO_IN_EBR;
	}*/
	else if (AC_WTP[wtpid]->WTP_Radio[radioid]->BindingWlanCount != 0)
	{
			struct wlanid *wlan_id = AC_WTP[wtpid]->WTP_Radio[radioid]->Wlan_Id;
			while(wlan_id != NULL)
			{	
				if(wlan_id->wlanid == wlanid)
				{
					ret1 = 0;
					break;
				}
				wlan_id = wlan_id->next;
			}
			if(ret1 != 0)
			{
			 	ret = WTP_WLAN_BINDING_NOT_MATCH;
			}	
			else
			{
				/*
				for(i=0;i<AC_WTP[wtpid]->RadioCount;i++)
				{
					if(AC_WTP[wtpid]->WTP_Radio[i] != NULL)
					{
						for(j=0;j<L_BSS_NUM;j++)
						{
							if(AC_WTP[wtpid]->WTP_Radio[i]->BSS[j] != NULL)
							{
								if(AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->WlanID == wlanid)
								{
									bssid = j;
									ret2 = 0;
									break;
								}
							}
						}
					}
					if(ret2 == 0)
					{
						break;
					}
				}
				*/
				unsigned int bssindex = 0;
				bssindex = AC_WLAN[wlanid]->S_WTP_BSS_List[wtpid][radioid];
				 if(!check_bssid_func(bssindex)){
					 wid_syslog_err("%s\n",__func__);
					 ret = BSS_NOT_EXIST;
					 //return CW_FALSE;
				 }else{
				 
					 bssid = (bssindex%(L_RADIO_NUM*L_BSS_NUM))%L_BSS_NUM;
					 wid_syslog_debug_debug(WID_DBUS,"wtpid %d,radioid %d,wlanid %d,bssid %d\n",wtpid,radioid,wlanid,bssid);
					 if(bssindex != 0)
					 {
						 ret = WID_BSS_L3IF_POLICY(wlanid,wtpid,radioid,bssid,wlan_policy);
					 }
					 else
					 {
						 ret = WTP_WLAN_BINDING_NOT_MATCH;
					 }
				}
			}
	}
	else
	{
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;	

}
DBusMessage * wid_dbus_interface_wlan_l3if_policy_br(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;
	unsigned char wlanid = 0;
	unsigned char wlan_policy = 0;
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_BYTE,&wlan_policy,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}

	if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else
	{
		ret = WID_WLAN_L3IF_POLICY_BR(wlanid,wlan_policy);
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;	

}
DBusMessage * wid_dbus_interface_wlan_l3if_policy2_br(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;
	unsigned int wlanid = 0;
	unsigned int wtpid = 0;
	unsigned int radioid = 0;
	unsigned int g_radioid = 0;
	unsigned char wlan_policy = 0;
	int ret = WID_DBUS_ERROR;
	int ret1 = -1;
	int ret2 = -1;
	int i=0;
	int j=0;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wlanid,
								DBUS_TYPE_BYTE,&wlan_policy,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&radioid,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}
//	printf("received wtpid:%d,wlanid:%d,radioid:%d,wlan_policy:%d\n",wtpid,wlanid,radioid,wlan_policy);
	// get g_radioid
	g_radioid = wtpid*L_RADIO_NUM + radioid ;//1-0.1 means radio 4
	int bssid = 0;
		
	//parse the validity and binding state
	if (AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_RADIO[g_radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if (AC_WTP[wtpid]->WTP_Radio[radioid]->BindingWlanCount != 0)
	{
			struct wlanid *wlan_id = AC_WTP[wtpid]->WTP_Radio[radioid]->Wlan_Id;
			while(wlan_id != NULL)
			{	
				if(wlan_id->wlanid == wlanid)
				{
					ret1 = 0;
					break;
				}
				wlan_id = wlan_id->next;
			}
			if(ret1 != 0)
			{
			 	ret = WTP_WLAN_BINDING_NOT_MATCH;
			}	
			else
			{
				for(i=0;i<AC_WTP[wtpid]->RadioCount;i++)
				{
					if(AC_WTP[wtpid]->WTP_Radio[i] != NULL)
					{
						for(j=0;j<L_BSS_NUM;j++)
						{
							if(AC_WTP[wtpid]->WTP_Radio[i]->BSS[j] != NULL)
							{
								if(AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->WlanID == wlanid)
								{
									bssid = j;
									ret2 = 0;
									break;
								}
							}
						}
					}
					if(ret2 == 0)
					{
						break;
					}
				}
				ret = WID_BSS_L3IF_POLICY(wlanid,wtpid,radioid,bssid,wlan_policy);
			}
	}
	else
	{
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;	

}

DBusMessage * wid_dbus_interface_wlan_tunnel_mode(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	unsigned int modeflag = 0;
	unsigned int wlanid = 0;
	unsigned int wtpid = 0;
	unsigned int radioid = 0;
	unsigned int g_radioid = 0;
	unsigned int forwardmode = 0;
	char nodeFlag = 0;
	int ret = WID_DBUS_ERROR;
	int ret1 = -1;
	//int ret2 = -1;
	int j=0;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&modeflag,
								DBUS_TYPE_UINT32,&wlanid,
								DBUS_TYPE_UINT32,&forwardmode,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&radioid,
								DBUS_TYPE_BYTE,&nodeFlag,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}
	if((0 == wlanid)&&(2 == modeflag)){
		wid_syslog_debug_debug(WID_DBUS,"%s,%d,set all wlan tunnel mode %d.\n",__func__,__LINE__,forwardmode);
		for(j=1;j<WLAN_NUM;j++){
			if(AC_WLAN[j] && (AC_WLAN[j]->want_to_delete != 1)){		/* Huangleilei add for ASXXZFI-1622 */
				WID_RADIO_WLAN_TUNNEL_MODE(j,forwardmode,nodeFlag);
			}
		}
		ret = WID_DBUS_SUCCESS;
	}else{
		g_radioid = wtpid*L_RADIO_NUM + radioid ;
		int bssid = 0;
		if(1 == modeflag){
			//parse the validity and binding state
			if (AC_WTP[wtpid] == NULL)
			{
				ret = WTP_ID_NOT_EXIST;
			}
			else if (AC_WLAN[wlanid] == NULL)
			{
				ret = WLAN_ID_NOT_EXIST;
			}
			else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
			{
				ret = WID_WANT_TO_DELETE_WLAN;
			}
			else if (AC_RADIO[g_radioid] == NULL)
			{
				ret = RADIO_ID_NOT_EXIST;
			}
			else if (AC_WTP[wtpid]->WTP_Radio[radioid]->BindingWlanCount != 0)
			{
					struct wlanid *wlan_id = AC_WTP[wtpid]->WTP_Radio[radioid]->Wlan_Id;
					while(wlan_id != NULL)
					{	
						if(wlan_id->wlanid == wlanid)
						{
							ret1 = 0;
							break;
						}
						wlan_id = wlan_id->next;
					}
					if(ret1 != 0)
					{
						ret = WTP_WLAN_BINDING_NOT_MATCH;
					}	
					else
					{
		
						if(AC_WLAN[wlanid]->S_WTP_BSS_List[wtpid][radioid] != 0)
						{
							unsigned int bssidindex = AC_WLAN[wlanid]->S_WTP_BSS_List[wtpid][radioid];
							if(!check_bssid_func(bssidindex)){
								wid_syslog_err("%s\n",__func__);
								ret = BSS_NOT_EXIST;
								//return CW_FALSE;
							}else{
								bssid = (bssidindex%(L_RADIO_NUM*L_BSS_NUM))%L_BSS_NUM;
								ret = WID_RADIO_BSS_TUNNEL_MODE(wlanid,wtpid,radioid,bssid,forwardmode,nodeFlag);
							}
						}
					}
			}
			else
			{
				ret = WTP_IS_NOT_BINDING_WLAN_ID;
			}
		}else if (2 == modeflag){
			if (AC_WLAN[wlanid] != NULL && (AC_WLAN[wlanid]->want_to_delete != 1))		/* Huangleilei add for ASXXZFI-1622 */
			{
			ret = WID_RADIO_WLAN_TUNNEL_MODE(wlanid,forwardmode,nodeFlag);
			}
			else if (AC_WLAN[wlanid] != NULL && (AC_WLAN[wlanid]->want_to_delete == 1))		/* Huangleilei add for ASXXZFI-1622 */
			{
				ret = WID_WANT_TO_DELETE_WLAN;
			}
			else 
			{
			}
		}	
	}

	if(ret == WID_DBUS_SUCCESS)
		g_WLAN_TUNNEL_POLICY = forwardmode;
		
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;	

}


DBusMessage * wid_dbus_interface_wlan_forward_mode(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;
	unsigned int wlanid = 0;
	unsigned int wtpid = 0;
	unsigned int radioid = 0;
	unsigned int g_radioid = 0;
	unsigned int forwardmode = 0;
	int ret = WID_DBUS_ERROR;
	int ret1 = -1;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wlanid,
								DBUS_TYPE_UINT32,&forwardmode,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&radioid,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}
//	printf("received wtpid:%d,wlanid:%d,radioid:%d,wlan_policy:%d\n",wtpid,wlanid,radioid,forwardmode);

	g_radioid = wtpid*L_RADIO_NUM + radioid ;
	int bssid = 0;
		
	//parse the validity and binding state
	if (AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_RADIO[g_radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if (AC_WTP[wtpid]->WTP_Radio[radioid]->BindingWlanCount != 0)
	{
			struct wlanid *wlan_id = AC_WTP[wtpid]->WTP_Radio[radioid]->Wlan_Id;
			while(wlan_id != NULL)
			{	
				if(wlan_id->wlanid == wlanid)
				{
					ret1 = 0;
					break;
				}
				wlan_id = wlan_id->next;
			}
			if(ret1 != 0)
			{
			 	ret = WTP_WLAN_BINDING_NOT_MATCH;
			}	
			else
			{

				if(AC_WLAN[wlanid]->S_WTP_BSS_List[wtpid][radioid] != 0)
				{
					unsigned int bssidindex = AC_WLAN[wlanid]->S_WTP_BSS_List[wtpid][radioid];
					if(!check_bssid_func(bssidindex)){
						wid_syslog_err("%s\n",__func__);
						ret = BSS_NOT_EXIST;
						//return CW_FALSE;
					}else{
						bssid = (bssidindex%(L_RADIO_NUM*L_BSS_NUM))%L_BSS_NUM;
	//					printf("bssindex:%d,bssid :%d\n",bssidindex,bssid);
						ret = WID_RADIO_BSS_FORWARD_MODE(wlanid,wtpid,radioid,bssid,forwardmode);
					}
				}
			}
	}
	else
	{
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;	

}
/*nl add 20100318*/
DBusMessage * wid_dbus_interface_set_whole_wlan_traffic_limit_value(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	unsigned char wlanid;
	unsigned int value;
	unsigned int ret = WID_DBUS_SUCCESS;
	unsigned char issend = 0;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&value,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else
	{
		AC_WLAN[wlanid]->wlan_traffic_limit = value;
	}
	if(ret == WID_DBUS_SUCCESS){
		ret = wid_radio_set_whole_wlan_traffic_limit_value(wlanid,value,issend);
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}
/*nl add 20100318*/
DBusMessage * wid_dbus_interface_set_whole_wlan_send_traffic_limit_value(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	unsigned char wlanid;
	unsigned int value;
	unsigned int ret = WID_DBUS_SUCCESS;
	unsigned char issend = 1;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&value,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else
	{
		AC_WLAN[wlanid]->wlan_send_traffic_limit = value;
	}
	if(ret == WID_DBUS_SUCCESS){
		ret = wid_radio_set_whole_wlan_traffic_limit_value(wlanid,value,issend);
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}

/*nl add 20100401*/
DBusMessage * wid_dbus_interface_set_whole_wlan_station_average_traffic_limit_value(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	unsigned char wlanid;
	unsigned int value;
	unsigned int ret = WID_DBUS_SUCCESS;
	unsigned char issend = 0;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&value,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else
	{
		AC_WLAN[wlanid]->wlan_station_average_traffic_limit= value;
	}
	if(ret == WID_DBUS_SUCCESS){
		ret = wid_radio_set_whole_wlan_station_average_traffic_limit_value(wlanid,value,issend);
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}
/*nl add 20100401*/
DBusMessage * wid_dbus_interface_set_whole_wlan_station_average_send_traffic_limit_value(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	unsigned char wlanid;
	unsigned int value;
	unsigned int ret = WID_DBUS_SUCCESS;
	unsigned char issend = 1;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&value,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else
	{
		AC_WLAN[wlanid]->wlan_station_average_send_traffic_limit= value;
	}
	if(ret == WID_DBUS_SUCCESS){
		ret = wid_radio_set_whole_wlan_station_average_traffic_limit_value(wlanid,value,issend);
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}

#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_wtp_flow_triger(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusError err;
	DBusMessageIter	 iter;
	DBusMessage* reply = NULL;

	int i =0;
	unsigned int ID = 0;
	unsigned int num = 0;
	unsigned int type = 0;

	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	unsigned int triger=0;
	struct Wtp_List * wtp_head =NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
		
	dbus_error_init(&err);
			
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&triger,
								DBUS_TYPE_INVALID))){
		
		printf("Unable to get input args\n");
						
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(type == 0){
		if(ID == 0){
			if(triger>1024){
				ret=APPLY_IF_FAIL;
			}else {
				gWTP_FLOW_TRIGER = triger;
				for(i=0;i<WTP_NUM;i++){
					if(AC_WTP[i]!=NULL){
						AC_WTP[i]->wtp_flow_triger=triger;
						if(1!=AsdWsm_WTPOp(i,WID_MODIFY))
						ret=WID_DBUS_ERROR;
					}
				}
			}
		}/*wcl modify for globle variable*/
		else if(triger>1024){
			ret=APPLY_IF_FAIL;

		}
		else if(AC_WTP[ID]!=NULL){
			AC_WTP[ID]->wtp_flow_triger=triger;
			if(1!=AsdWsm_WTPOp(ID,WID_MODIFY))
				ret=WID_DBUS_ERROR;
		}
		else
			ret=WTP_ID_NOT_EXIST;
		
	}
	
	else if (type == 1){
		printf("******** type == 1 *****\n");
		if(triger>1024){
			ret = APPLY_IF_FAIL;
		}
		else if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
			tmp = WTP_GROUP[ID]->WTP_M;
			wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
			
			while(tmp){
				ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
				
				if(ret_check == WID_DBUS_SUCCESS){
					if(1!=AsdWsm_WTPOp(tmp->WTPID,WID_MODIFY)){
						ret2 = WID_DBUS_ERROR;
					}
					else{
						AC_WTP[tmp->WTPID]->wtp_flow_triger=triger;
						ret2 = WID_DBUS_SUCCESS;
					}

					if(ret2 != WID_DBUS_SUCCESS){
						wtp_head[num].WtpId = tmp->WTPID;
						wtp_head[num].FailReason = ret2;
						num++;
					}
					tmp = tmp->next;
				}
			}
			ret = WID_DBUS_SUCCESS;
		}
		
		else{
			ret = GROUP_ID_NOT_EXIST;
		}
	}
		
	reply = dbus_message_new_method_return(msg);
						
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 

	if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &num);

		for(i = 0; i < num; i++){
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_UINT32,
												 &(wtp_head[i].WtpId ));
			
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_BYTE,
												 &(wtp_head[i].FailReason));
			
		}	
	}

	if(wtp_head!=NULL){
		WID_FREE(wtp_head);
		wtp_head = NULL;	
	}
	
	return reply;	

}

#else
DBusMessage * wid_dbus_interface_wtp_flow_triger(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	int i = 0;/*wcl add for globle variable*/
	unsigned int triger=0;
	unsigned int wtpid=0;

		
	dbus_error_init(&err);
			
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&triger,
								DBUS_TYPE_INVALID))){
		
		printf("Unable to get input args\n");
						
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(wtpid == 0){
		if(triger>1024){
			ret=APPLY_IF_FAIL;
		}else {
			gWTP_FLOW_TRIGER = triger;
			for(i=0;i<WTP_NUM;i++){
				if(AC_WTP[i]!=NULL){
					AC_WTP[i]->wtp_flow_triger=triger;
					if(1!=AsdWsm_WTPOp(i,WID_MODIFY))
					ret=WID_DBUS_ERROR;
				}
			}
		}
	}/*wcl modify for globle variable*/
	else if(triger>1024){
		ret=APPLY_IF_FAIL;

	}else if(AC_WTP[wtpid]!=NULL){
		AC_WTP[wtpid]->wtp_flow_triger=triger;
		if(1!=AsdWsm_WTPOp(wtpid,WID_MODIFY))
			ret=WID_DBUS_ERROR;
	}
	else
		ret=WTP_ID_NOT_EXIST;
		
	reply = dbus_message_new_method_return(msg);
						
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 
	return reply;	

}

#endif

#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_wtp_triger(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusError err;
	DBusMessageIter	 iter;
	DBusMessage* reply = NULL;

	int i =0;
	unsigned int ID = 0;
	unsigned int num = 0;
	unsigned int type = 0;

	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	unsigned int triger=0;
	struct Wtp_List * wtp_head =NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
		
	dbus_error_init(&err);
			
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&triger,
								DBUS_TYPE_INVALID))){
		
		printf("Unable to get input args\n");
						
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(type == 0){
		if(AC_WTP[ID]!=NULL&&
	  	 (triger>AC_WTP[ID]->wtp_allowed_max_sta_num)){
			ret=APPLY_IF_FAIL;
	}
	else if(AC_WTP[ID]!=NULL){
		AC_WTP[ID]->wtp_triger_num=triger;
		if(1!=AsdWsm_WTPOp(ID,WID_MODIFY))
			ret=WID_DBUS_ERROR;
	}
	else
		ret=WTP_ID_NOT_EXIST;
	}

	else if (type == 1){
		printf("******** type == 1 *****\n");
		
		if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
			tmp = WTP_GROUP[ID]->WTP_M;
			wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
			
			while(tmp){
				ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
				
				if(ret_check == WID_DBUS_SUCCESS){
					if(triger>AC_WTP[tmp->WTPID]->wtp_allowed_max_sta_num){
						ret2 = APPLY_IF_FAIL;
					}
					else {
						if(1!=AsdWsm_WTPOp(tmp->WTPID,WID_MODIFY)){
							ret2 = WID_DBUS_ERROR;
						}
						else{
							AC_WTP[tmp->WTPID]->wtp_triger_num=triger;
							ret2 = WID_DBUS_SUCCESS;
						}
					}
					if(ret2 != WID_DBUS_SUCCESS){
						wtp_head[num].WtpId = tmp->WTPID;
						wtp_head[num].FailReason = ret2;
						num++;
					}
					tmp = tmp->next;
				}
			}
			ret = WID_DBUS_SUCCESS;
		}
		
		else{
			ret = GROUP_ID_NOT_EXIST;
		}
	}
	
	reply = dbus_message_new_method_return(msg);
						
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 

	if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &num);

		for(i = 0; i < num; i++){
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_UINT32,
												 &(wtp_head[i].WtpId ));
			
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_BYTE,
												 &(wtp_head[i].FailReason));
			
		}	
	}

	if(wtp_head!=NULL){
		WID_FREE(wtp_head);
		wtp_head = NULL;	
	}
	
	return reply;	

}
#else
DBusMessage * wid_dbus_interface_wtp_triger(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
		
	unsigned int triger=0;
	unsigned int wtpid=0;

		
	dbus_error_init(&err);
			
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&triger,
								DBUS_TYPE_INVALID))){
		
		printf("Unable to get input args\n");
						
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}


	if(AC_WTP[wtpid]!=NULL&&
	   (triger>AC_WTP[wtpid]->wtp_allowed_max_sta_num)){
		ret=APPLY_IF_FAIL;

	}else if(AC_WTP[wtpid]!=NULL){
		AC_WTP[wtpid]->wtp_triger_num=triger;
//		printf("AC_WTP[%d]->wtp_triger_num=%d\n",wtpid,AC_WTP[wtpid]->wtp_triger_num);////////////
		if(1!=AsdWsm_WTPOp(wtpid,WID_MODIFY))
			ret=WID_DBUS_ERROR;
	}
	else
		ret=WTP_ID_NOT_EXIST;
		
	reply = dbus_message_new_method_return(msg);
						
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 
	return reply;	

}
#endif

DBusMessage * wid_dbus_interface_wtp_check_wlanid(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
//	unsigned int wlanid=0;
//	unsigned char state = 0;
	unsigned char uplinkState = 0;
	unsigned char uplinkWlanId = 0;
	char * uplink_addr = NULL;

	dbus_error_init(&err);
			
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&uplinkWlanId,
								DBUS_TYPE_STRING,&uplink_addr,
								DBUS_TYPE_BYTE,&uplinkState,
								DBUS_TYPE_INVALID))){
		
		printf("Unable to get input args\n");
						
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
		
	if(AC_WLAN[uplinkWlanId] != NULL){
		if((AC_WLAN[uplinkWlanId]->uplink_addr != NULL)&&(AC_WLAN[uplinkWlanId]->uplinkState == uplinkState)){
			ret = WID_DBUS_SUCCESS;
		}
		if(ret == WID_DBUS_SUCCESS){
			if(AC_WLAN[uplinkWlanId]->uplink_addr != NULL){
				WID_FREE(AC_WLAN[uplinkWlanId]->uplink_addr);
				AC_WLAN[uplinkWlanId]->uplink_addr = NULL;
			}	
			AC_WLAN[uplinkWlanId]->uplink_addr = (char *)WID_MALLOC(strlen(uplink_addr)+1);
			memset(AC_WLAN[uplinkWlanId]->uplink_addr, 0, strlen(uplink_addr)+1);
			memcpy(AC_WLAN[uplinkWlanId]->uplink_addr,uplink_addr,strlen(uplink_addr));
			AC_WLAN[uplinkWlanId]->uplinkState = uplinkState;
			AC_WLAN[uplinkWlanId]->uplinkWlanId = uplinkWlanId;
		}
	}else{
		ret = WLAN_ID_NOT_EXIST;
	}	

	reply = dbus_message_new_method_return(msg);
						
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 
	return reply;	

}

DBusMessage * wid_dbus_interface_check_wtp_sta(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int i =0;
	int ret = WID_DBUS_SUCCESS;
	unsigned int ID = 0;
	unsigned int num = 0;
	unsigned int type = 0;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Wtp_List * wtp_head =NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
		
	printf("check wtp sta\n");
		
	dbus_error_init(&err);
			
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_INVALID))){
		
		printf("Unable to get input args\n");
						
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	printf("!!!!!!!!!!!!!\n");
 if(type==0)
 {
		
	if(AC_WTP[ID]!=NULL)
		{	
		    wtp_head = (struct Wtp_List *)WID_MALLOC(sizeof(struct Wtp_List));
			wtp_head->WtpId = ID;
			printf("asd id %d\n",ID);
		}
	ret= WID_DBUS_SUCCESS;
	printf("lalal asd id %d\n",ID);
	printf("type000\n");
 }

		
 if (type == 1)
	{
	   if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
	   	{
			tmp = WTP_GROUP[ID]->WTP_M;
			wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
				
			while(tmp)
				{
					ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
					if(ret_check == WID_DBUS_SUCCESS)
						{
                        	wtp_head[num].WtpId = tmp->WTPID;
						
							num++;
					
						
					    }
					tmp = tmp->next;
				}
			
		}
			
		ret = WID_DBUS_SUCCESS;
	}
			
		reply = dbus_message_new_method_return(msg);
							
		dbus_message_iter_init_append (reply, &iter);	
		dbus_message_iter_append_basic (&iter,
										DBUS_TYPE_UINT32,
										&ret); 
		printf("0000000000000\n");
		if(type == 0)
			{
			   dbus_message_iter_append_basic (&iter,
											   DBUS_TYPE_UINT32,
												 &num);
			   dbus_message_iter_append_basic (&iter,
											   DBUS_TYPE_UINT32,
											   &(wtp_head->WtpId));
			}
			
		if(type == 1)
			{
			  dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_UINT32,
												 &num);
		
			  for(i = 0; i < num; i++)
			  	{
				 dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
													 &(wtp_head[i].WtpId ));	
			    }	
		    }
		
		if(wtp_head!=NULL){
			WID_FREE(wtp_head);
			wtp_head = NULL;	
		}
		
		return reply;	
}

#if _GROUP_POLICY
//xm add 08/12/04
DBusMessage * wid_dbus_interface_wtp_max_sta(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	int i =0;
	unsigned int ID = 0;

	unsigned int wtp_max_sta = 0;
	//unsigned int type = 0;
	//int ret_check = WID_DBUS_SUCCESS;
	
	//struct Wtp_List * wtp_head =NULL;
	//struct WTP_GROUP_MEMBER *tmp = NULL;
		
	printf("access set wtp max sta\n");
		
	dbus_error_init(&err);
			
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtp_max_sta,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_INVALID))){
		
		printf("Unable to get input args\n");
						
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(ID == 0){
		gWTP_MAX_STA = wtp_max_sta;
		for(i=0;i<WTP_NUM;i++){
			if(AC_WTP[i] != NULL){
				AC_WTP[i]->wtp_allowed_max_sta_num=wtp_max_sta;
				if(1!=AsdWsm_WTPOp(i,WID_MODIFY))
				ret=WID_DBUS_ERROR;
			}
		}
	}/*wcl modify for globle variable*/
	else if(AC_WTP[ID]!=NULL){
			AC_WTP[ID]->wtp_allowed_max_sta_num=wtp_max_sta;
			wid_syslog_debug_debug(WID_DEFAULT,"WTP%d SET WTP MAX STA SUCCESSFUL\n",ID);
			if(1!=AsdWsm_WTPOp(ID,WID_MODIFY))
				ret=WID_DBUS_ERROR;
	}
	else
		{
			ret=WTP_ID_NOT_EXIST;
			wid_syslog_debug_debug(WID_DEFAULT,"WTP%d IS NOT EXIST\n",ID);
		}
		
		
			
	reply = dbus_message_new_method_return(msg);
						
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 
	return reply;	


}

#else
//xm add 08/12/04
DBusMessage * wid_dbus_interface_wtp_max_sta(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	int i = 0;/*wcl add for globle variable*/
	unsigned int wtp_max=0;
	unsigned int wtpid=0;
		
	dbus_error_init(&err);
			
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&wtp_max,
								DBUS_TYPE_INVALID))){
		
		printf("Unable to get input args\n");
						
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
		
	if(wtpid == 0){
		gWTP_MAX_STA = wtp_max;
		for(i=0;i<WTP_NUM;i++){
			if(AC_WTP[i] != NULL){
				AC_WTP[i]->wtp_allowed_max_sta_num=wtp_max;
				if(1!=AsdWsm_WTPOp(i,WID_MODIFY))
				ret=WID_DBUS_ERROR;
			}
		}
	}/*wcl modify for globle variable*/
	else if(AC_WTP[wtpid]!=NULL){
			AC_WTP[wtpid]->wtp_allowed_max_sta_num=wtp_max;
			if(1!=AsdWsm_WTPOp(wtpid,WID_MODIFY))
				ret=WID_DBUS_ERROR;
	}
	else
		ret=WTP_ID_NOT_EXIST;
		
			
	reply = dbus_message_new_method_return(msg);
						
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 
	return reply;	

}
#endif
/*
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_wtp_apply_ifname(DBusConnection *conn, DBusMessage *msg, void *user_data)
{	
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;

	unsigned int *wtp_list = NULL ;
	char *if_name;
	int ret = WID_DBUS_SUCCESS;
	int retv6 = WID_DBUS_SUCCESS;
	unsigned int type = 0;
	unsigned int id = 0;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	unsigned int num = 0;
	int i =0;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&id,
								DBUS_TYPE_STRING,&if_name,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}

	//printf get values
	//printf("***** Input wtp id is %d\n",wtpid);
	//printf("***** Input wtp id binding interface name is %s\n",if_name);
	wid_syslog_debug_debug(WID_DBUS,"***** Input wtp id is %d",id);	
	wid_syslog_debug_debug(WID_DBUS,"***** Input wtp id binding interface name is %s",if_name);
	if(type == 0){
		if(AC_WTP[id] == NULL)
		{
			ret = WLAN_ID_NOT_EXIST;
		}
		else
		{
			ret = WID_BINDING_IF_APPLY_WTP(id,if_name);
			if(ret == APPLY_IF_FAIL){
				retv6 = APPLY_IF_FAIL;
			}
			//delete by weianying for we use ioctl get ipv6 address
			//retv6 = WID_BINDING_IF_APPLY_WTP_ipv6(wtpid,if_name);
			//retv6 = WID_BINDING_IF_APPLY_WTP_ipv6_ioctl(wtpid,if_name);
		}
	}else if(type == 1){
		if(WTP_GROUP[id] != NULL){
			tmp = WTP_GROUP[id]->WTP_M;
			wtp_list = (unsigned int *)malloc(WTP_GROUP[id]->WTP_COUNT *(sizeof(unsigned int)));
			while(tmp){
				if(AC_WTP[tmp->WTPID] != NULL){
					ret = WID_BINDING_IF_APPLY_WTP(tmp->WTPID,if_name);
				}else{
					ret = WTP_ID_NOT_EXIST;
				}
				if(ret != WID_DBUS_SUCCESS){
					wtp_list[num] = tmp->WTPID;
					num++;
				}
				tmp = tmp->next;
			}
			ret = WID_DBUS_SUCCESS;
		}else{
			ret = GROUP_ID_NOT_EXIST;
		}
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &ret);
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &retv6);	
	if(type == 1){
		
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &num);
		for(i = 0; i < num; i++){
			
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_UINT32,
												 &(wtp_list[i]));
		}	
		free(wtp_list);
		wtp_list = NULL;	
	}
	return reply;

}
*/
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_wtp_apply_ifname(DBusConnection *conn, DBusMessage *msg, void *user_data)
{	
	//printf("## wid_dbus_interface_wtp_apply_ifname ### \n ");
	DBusError err;
	DBusMessageIter  iter;
	DBusMessage* reply =NULL;

	int i =0;
	unsigned int id = 0;
	unsigned int num = 0;
	unsigned int type = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int retv6 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	char *if_name = NULL;
	struct Wtp_List * wtp_head =NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&id,
								DBUS_TYPE_STRING,&if_name,
								DBUS_TYPE_INVALID)))
	{
		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}
	unsigned char ret_flag = 0;
	char * name;
	name = (char*)WID_MALLOC(strlen(if_name)+5);
	memset(name, 0, strlen(if_name)+5);

	if(check_ve_interface(if_name, name)){
		wid_syslog_debug_debug(WID_DBUS,"input ve interface doesn't exist!\n"); 
		ret = APPLY_IF_FAIL;
		retv6 = APPLY_IF_FAIL;
		ret_flag = 1;
	}
	
	wid_syslog_debug_debug(WID_DBUS,"***** Input wtp id is %d",id); 
	wid_syslog_debug_debug(WID_DBUS,"***** Input wtp id binding interface name is %s",name);
	if(ret_flag == 0)
	{
		if(type == 0)
		{
			if(AC_WTP[id] == NULL)
			{
				ret = WLAN_ID_NOT_EXIST;
			}
			else
			{
				ret = WID_BINDING_IF_APPLY_WTP(id,name);
				if(ret == APPLY_IF_FAIL){
				retv6 = APPLY_IF_FAIL;
				}
			}
		}
	
		else if(type == 1)
		{
			if(WTP_GROUP[id] != NULL)
			{
				tmp = WTP_GROUP[id]->WTP_M;
				wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[id]->WTP_COUNT *(sizeof(struct Wtp_List)));
			
				while(tmp)
				{
					ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
				
					if(ret_check == WID_DBUS_SUCCESS)
					{
						ret2 = WID_BINDING_IF_APPLY_WTP(tmp->WTPID,name);
					}else
					{
						ret2 = WTP_ID_NOT_EXIST;
					}
					if(ret2 != WID_DBUS_SUCCESS)
					{
						wtp_head[num].WtpId = tmp->WTPID;
						wtp_head[num].FailReason = ret2;
						num++;
					}
					tmp = tmp->next;
				}
			
				ret = WID_DBUS_SUCCESS;
			}
		
			else
			{
				ret = GROUP_ID_NOT_EXIST;
			}
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &ret);
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &retv6);	
	
	if(type == 1){
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &num);

		for(i = 0; i < num; i++){
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_UINT32,
												 &(wtp_head[i].WtpId ));
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_BYTE,
												 &(wtp_head[i].FailReason));
			
		}	
	}

	if(wtp_head!=NULL){
		WID_FREE(wtp_head);
		wtp_head = NULL;	
	}
	WID_FREE(name);
	name = NULL;
	return reply;
}

#else
DBusMessage * wid_dbus_interface_wtp_apply_ifname(DBusConnection *conn, DBusMessage *msg, void *user_data)
{	
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;

	unsigned int wtpid;
	char *if_name;
	int ret = WID_DBUS_SUCCESS;
	int retv6 = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_STRING,&if_name,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}

	unsigned char ret_flag = 0;
	char *name;
	name = (char*)WID_MALLOC(strlen(if_name)+5);
	memset(name, 0, strlen(if_name)+5);
	if(check_ve_interface(if_name,name))
	{
		wid_syslog_debug_debug(WID_DBUS,"input ve interface doesn't exist!\n");
		ret = APPLY_IF_FAIL;
		retv6 = APPLY_IF_FAIL;
		ret_flag = 1;
	}
	//printf get values
	//printf("***** Input wtp id is %d\n",wtpid);
	//printf("***** Input wtp id binding interface name is %s\n",if_name);
	wid_syslog_debug_debug(WID_DBUS,"***** Input wtp id is %d",wtpid);	
	wid_syslog_debug_debug(WID_DBUS,"***** Input wtp id binding interface name is %s",name);
	if(ret_flag == 0){
		if(AC_WTP[wtpid] == NULL)
		{
			ret = WLAN_ID_NOT_EXIST;
		}
		else
		{
			ret = WID_BINDING_IF_APPLY_WTP(wtpid,name);
			/*ipv4 logic same to ipv6*/
			/*
			if(ret == APPLY_IF_FAIL){
				retv6 = APPLY_IF_FAIL;
			}
			*/
			retv6 = ret;
		//delete by weianying for we use ioctl get ipv6 address
		//retv6 = WID_BINDING_IF_APPLY_WTP_ipv6(wtpid,if_name);
		//retv6 = WID_BINDING_IF_APPLY_WTP_ipv6_ioctl(wtpid,if_name);
		}
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &ret);
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &retv6);	
	WID_FREE(name);
	name = NULL;
	return reply;

}
#endif

DBusMessage * wid_dbus_interface_wtp_apply_ifname_ipv6(DBusConnection *conn, DBusMessage *msg, void *user_data)
{	
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;

	unsigned int wtpid;
	char *if_name;
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_STRING,&if_name,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}
	unsigned char ret_flag = 0;
	char *name;
	name = (char*)WID_MALLOC(strlen(if_name)+5);
	memset(name,0,strlen(if_name)+5);
	if(check_ve_interface(if_name,name))
	{
		wid_syslog_debug_debug(WID_DBUS,"input ve interface dosen't exist!\n");
		ret = APPLY_IF_FAIL;
		ret_flag = 1;
	}
		
	//printf get values
	//printf("***** Input wtp id is %d\n",wtpid);
	//printf("***** Input wtp id binding interface name is %s\n",if_name);
	wid_syslog_debug_debug(WID_DBUS,"***** Input wtp id is %d",wtpid);	
	wid_syslog_debug_debug(WID_DBUS,"***** Input wtp id binding interface name is %s",name);
	if(ret_flag == 0){
		if(AC_WTP[wtpid] == NULL)
		{
			ret = WLAN_ID_NOT_EXIST;
		}
		else
		{
			ret = WID_BINDING_IF_APPLY_WTP_ipv6(wtpid,name);
		}
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &ret);
	WID_FREE(name);
	name =  NULL;
	return reply;

}	

//added by weiay 20080623
DBusMessage * wid_dbus_interface_wtp_delete_wlanid(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;

	unsigned int wtpid = 0;
	unsigned char wlanid = 0;
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}
		
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if(wlanid == 0)
	{
		ret = delete_wlan_all_bss(wtpid);
	}
	else
	{
		ret = WID_DELETE_WLAN_APPLY_WTP(wtpid,wlanid);
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;

}
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_wtp_disable_wlanid(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusError err;
	DBusMessageIter	 iter;
	DBusMessage* reply = NULL;

	int i =0;
	unsigned int ID = 0;
	unsigned int num = 0;
	unsigned int type = 0;
	unsigned char wlanid = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	

	struct Wtp_List * wtp_head =NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_INVALID)))
	{
		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}
	
	if(type == 0){
		if(AC_WTP[ID] == NULL){
			ret = WLAN_ID_NOT_EXIST;
		}
		else{
			ret = WID_DISABLE_WLAN_APPLY_WTP(ID,wlanid);
		}
	}
	else if (type == 1){
		printf("******** type == 1 *****\n");
		if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
			tmp = WTP_GROUP[ID]->WTP_M;
			wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
			
			while(tmp){
				ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
				
				if(ret_check == WID_DBUS_SUCCESS){
					ret2 = WID_DISABLE_WLAN_APPLY_WTP(tmp->WTPID,wlanid);

					if(ret2 != WID_DBUS_SUCCESS){
						wtp_head[num].WtpId = tmp->WTPID;
						wtp_head[num].FailReason = ret2;
						num++;
					}
					tmp = tmp->next;
				}
				ret = WID_DBUS_SUCCESS;
			}
		}
		
		else{
			ret = GROUP_ID_NOT_EXIST;
		}

	}

	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &ret);

	if(type == 1){
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
		
		for(i = 0; i < num; i++){
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &(wtp_head[i].WtpId ));
			
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_BYTE,
											 &(wtp_head[i].FailReason));
		}	
	}
	
	if(wtp_head!=NULL){
		WID_FREE(wtp_head);
		wtp_head = NULL;	
	}
	
	return reply;

}
#else
DBusMessage * wid_dbus_interface_wtp_disable_wlanid(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;

	unsigned int wtpid = 0;
	unsigned char wlanid = 0;
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}
		
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else
	{
		ret = WID_DISABLE_WLAN_APPLY_WTP(wtpid,wlanid);
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;

}
#endif

#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_wtp_enable_wlanid(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusError err;
	DBusMessageIter  iter;
	DBusMessage* reply = NULL;

	int i =0;
	unsigned int ID = 0;
	unsigned int num = 0;
	unsigned int type = 0;
	unsigned char wlanid = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	

	struct Wtp_List * wtp_head =NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_INVALID)))
	{
		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}

	if(type ==0){
		if(AC_WTP[ID] == NULL){
			ret = WLAN_ID_NOT_EXIST;
		}
		else{
			ret = WID_ENABLE_WLAN_APPLY_WTP(ID,wlanid);
		}
	}

	else if (type == 1){
		printf("******** type == 1 *****\n");
		if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
			tmp = WTP_GROUP[ID]->WTP_M;
			wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
			
			while(tmp){
				ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
				
				if(ret_check == WID_DBUS_SUCCESS){
					ret2 = WID_ENABLE_WLAN_APPLY_WTP(tmp->WTPID,wlanid);

					if(ret2 != WID_DBUS_SUCCESS){
						wtp_head[num].WtpId = tmp->WTPID;
						wtp_head[num].FailReason = ret2;
						num++;
					}
					tmp = tmp->next;
				}
				ret = WID_DBUS_SUCCESS;
			}
		}
		
		else{
			ret = GROUP_ID_NOT_EXIST;
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &ret);

	if(type == 1){
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
		
		for(i = 0; i < num; i++){
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &(wtp_head[i].WtpId ));
			
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_BYTE,
											 &(wtp_head[i].FailReason));
		}	
	}
	
	if(wtp_head!=NULL){
		WID_FREE(wtp_head);
		wtp_head = NULL;	
	}
	
	return reply;

}
#else
DBusMessage * wid_dbus_interface_wtp_enable_wlanid(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;

	unsigned int wtpid = 0;
	unsigned char wlanid = 0;
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}
		
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else
	{
		ret = WID_ENABLE_WLAN_APPLY_WTP(wtpid,wlanid);
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;

}
#endif

#if _GROUP_POLICY
//for ap group 2010-09-03 by nl
DBusMessage * wid_dbus_interface_wtp_apply_wlanid(DBusConnection *conn, DBusMessage *msg, void *user_data)
{	
	//printf("******wid_dbus_interface_wtp_apply_wlanid inner************\n");
	DBusError err;
	DBusMessageIter	 iter;
	DBusMessage* reply = NULL;

	int i = 0;
	int num = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned char wlanid = 0;
	
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	//unsigned int *wtp_list = NULL;
	struct Wtp_List * wtp_head =NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}

	//printf get values
	//printf("***** Input wtp id is %d\n",wtpid);
	//printf("***** Input wtp id binding wlan id is %d\n",wlanid);
	wid_syslog_debug_debug(WID_DBUS,"***** Input wtp id is %d",ID);
	wid_syslog_debug_debug(WID_DBUS,"***** Input wtp id binding wlan id is %d",wlanid);	
	
	if(type == 0){
		if(AC_WTP[ID] == NULL){
			ret = WLAN_ID_NOT_EXIST;
		}
		else{
			ret = WID_BINDING_WLAN_APPLY_WTP(ID,wlanid);
		}
	}	

	else if(type == 1){
		printf("##### type == 1 #####\n");
		if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M)){
			tmp = WTP_GROUP[ID]->WTP_M;
			wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List )));
			while(tmp){
				ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
				printf("ret %d   \n",ret);

				if(ret_check == WID_DBUS_SUCCESS){
					ret2 = WID_BINDING_WLAN_APPLY_WTP(tmp->WTPID,wlanid);
						
					if(ret2 != WID_DBUS_SUCCESS){
						wtp_head[num].WtpId = tmp->WTPID;
						wtp_head[num].FailReason = ret2;
						num++;
					}
				}
				tmp = tmp->next;
			}
			ret = WID_DBUS_SUCCESS;
		}
		
		else{
			ret = GROUP_ID_NOT_EXIST;
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &ret);
	
	if(type == 1){
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &num);
		
		for(i = 0; i < num; i++){
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_UINT32,
												 &(wtp_head[i].WtpId));
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_BYTE,
												 &(wtp_head[i].FailReason));
		}	
		
		if(wtp_head!=NULL){
			WID_FREE(wtp_head);
			wtp_head = NULL;	
		}
	}
	
	return reply;

}
#else

//receive terminal message binding special wlanid weiay 200805604
DBusMessage * wid_dbus_interface_wtp_apply_wlanid(DBusConnection *conn, DBusMessage *msg, void *user_data)
{	
	//printf("******wid_dbus_interface_wtp_apply_wlanid inner************\n");
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;

	unsigned int wtpid = 0;
	unsigned char wlanid = 0;
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}

	//printf get values
	//printf("***** Input wtp id is %d\n",wtpid);
	//printf("***** Input wtp id binding wlan id is %d\n",wlanid);
	wid_syslog_debug_debug(WID_DBUS,"***** Input wtp id is %d",wtpid);
	wid_syslog_debug_debug(WID_DBUS,"***** Input wtp id binding wlan id is %d",wlanid);	
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else
	{
		ret = WID_BINDING_WLAN_APPLY_WTP(wtpid,wlanid);
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;

}
#endif

#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_wtp_used(DBusConnection *conn, DBusMessage *msg, void *user_data){
	printf("******** wid_dbus_interface_wtp_used *****\n");
	
	DBusError err;	
	DBusMessageIter	 iter;
 	DBusMessage * reply = NULL;
	
	int i = 0;
	int num =0 ;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned int DisWtp = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Wtp_List  *wtp_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&DisWtp,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type == 0){
		if(AC_WTP[ID] != NULL){
			if(DisWtp)
				ret = WID_UNUSED_WTP(ID);
			else
				ret = WID_USED_WTP(ID);
		}else{
				wid_syslog_err("******* WTP_ID_NOT_EXIST *****\n");
				ret = WTP_ID_NOT_EXIST;
		}
	}
	else if(type == 1){
		printf("******** type == 1 *****\n");
		if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
			tmp = WTP_GROUP[ID]->WTP_M;
			wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
			
			while(tmp){
				ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
				
				if(ret_check == WID_DBUS_SUCCESS){
					if(DisWtp){
						ret2 = WID_UNUSED_WTP(tmp->WTPID);
					}
					else{
						ret2 = WID_USED_WTP(tmp->WTPID);
					}
				
					if(ret2 != WID_DBUS_SUCCESS){
						wtp_head[num].WtpId = tmp->WTPID;
						wtp_head[num].FailReason = ret2;
						num++;
					}
					tmp = tmp->next;
				}
				ret = WID_DBUS_SUCCESS;
			}
		}
			
		else{
			ret = GROUP_ID_NOT_EXIST;
		}
	}

	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	if(type == 1){
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &num);
		for(i = 0; i < num; i++){
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_UINT32,
												 &(wtp_head[i].WtpId));
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_BYTE,
												 &(wtp_head[i].FailReason));
		}	
		
		if(wtp_head!=NULL){
			WID_FREE(wtp_head);
			wtp_head = NULL;	
		}
	}
	return reply;
}

#else
DBusMessage * wid_dbus_interface_wtp_used(DBusConnection *conn, DBusMessage *msg, void *user_data){

	//printf("******** wid_dbus_interface_wtp_used *****\n");
	
	DBusMessage * reply;
	DBusMessageIter	 iter;
	unsigned int WtpID;
	unsigned int DisWtp;
	DBusError err;	
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&WtpID,
								DBUS_TYPE_UINT32,&DisWtp,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(AC_WTP[WtpID] != NULL){
		if(DisWtp)
			ret = WID_UNUSED_WTP(WtpID);
		else
			ret = WID_USED_WTP(WtpID);
	}else{
			wid_syslog_err("******* WTP_ID_NOT_EXIST *****\n");
			ret = WTP_ID_NOT_EXIST;
	}

	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
}
#endif

//xm 08/08/29

DBusMessage * wid_dbus_interface_wtp_set_ap_version_path(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter	 iter;
	DBusError err;	
	int ret = WID_NO_SURPORT_MODEL;

	char *chmodel;
	char *vs,*pt;
	unsigned char radionum;
	unsigned char bssnum;

	dbus_error_init(&err);


	if (!(dbus_message_get_args ( msg, &err,
				DBUS_TYPE_STRING,&chmodel,
				DBUS_TYPE_STRING,&vs,
				DBUS_TYPE_STRING,&pt,
				DBUS_TYPE_BYTE,&radionum,
				DBUS_TYPE_BYTE,&bssnum,
				DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}
	CWThreadMutexLock(&(gAllThreadMutex));		

	CWConfigVersionInfo *pnode = gConfigVersionInfo;
	while(pnode != NULL)
	{
		if(strcmp(pnode->str_ap_model,chmodel) == 0)
		{
		/*	free(pnode->str_ap_version_name);
			pnode->str_ap_version_name = NULL;
			free(pnode->str_ap_version_path);
			pnode->str_ap_version_path = NULL;
			
			CW_CREATE_STRING_ERR(pnode->str_ap_version_name,strlen(vs),return NULL;);
			CW_CREATE_STRING_ERR(pnode->str_ap_version_path,strlen(pt),return NULL;);
			
			strcpy(pnode->str_ap_version_name,vs);
			strcpy(pnode->str_ap_version_path,pt);
		*/
			pnode->radio_num = radionum;
			pnode->bss_num = bssnum;
			pnode->ischanged = CW_TRUE;
			
			ret = WID_DBUS_SUCCESS;
			break;
		}
		pnode = pnode->next;
	}
	CWThreadMutexUnlock(&(gAllThreadMutex));		

	/*
	if(ret != WID_DBUS_SUCCESS)
	{
		pnode = NULL;
		CW_CREATE_OBJECT_ERR(pnode, CWConfigVersionInfo, return NULL;);	

		CW_CREATE_STRING_ERR(pnode->str_ap_model,strlen(chmodel),return NULL;);
		CW_CREATE_STRING_ERR(pnode->str_ap_version_name,strlen(vs),return NULL;);
		CW_CREATE_STRING_ERR(pnode->str_ap_version_path,strlen(pt),return NULL;);
		CW_CREATE_STRING_ERR(pnode->str_ap_code,strlen(chmodel),return NULL;);
		
		strcpy(pnode->str_ap_model,chmodel);
		strcpy(pnode->str_ap_version_name,vs);
		strcpy(pnode->str_ap_version_path,pt);
		strcpy(pnode->str_ap_code,chmodel);
		
		pnode->radio_num = radionum;
		pnode->bss_num = bssnum;
		pnode->ischanged = CW_TRUE;
		pnode->next = gConfigVersionInfo;
		gConfigVersionInfo = pnode;

		ret = WID_DBUS_SUCCESS;
			
	}
	*/
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	return reply;	
}

#if 0
DBusMessage * wid_dbus_interface_wtp_set_ap_update_path(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter	 iter;
	DBusError err;	
	int ret = WID_NO_SURPORT_MODEL;

	char *chmodel;
	char *vs,*pt;
	unsigned char count_onetime;

	dbus_error_init(&err);


	if (!(dbus_message_get_args ( msg, &err,
				DBUS_TYPE_STRING,&chmodel,
				DBUS_TYPE_STRING,&vs,
				DBUS_TYPE_STRING,&pt,
				DBUS_TYPE_BYTE,&count_onetime,
				DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}

	if(gConfigVersionUpdateInfo != NULL)
	{
		ret = UPDATE_PROCESS;
	}
	else
	{
		
		CWThreadMutexLock(&(gAllThreadMutex));		
		CWConfigVersionInfo *pnode = gConfigVersionInfo;
		while(pnode != NULL)
		{
			if(strcmp(pnode->str_ap_model,chmodel) == 0)
			{
				CW_CREATE_OBJECT_ERR_WID(gConfigVersionUpdateInfo, CWConfigVersionInfo, return NULL;);	
				memset(gConfigVersionUpdateInfo,0,sizeof(CWConfigVersionInfo));
				
				CW_CREATE_STRING_ERR_WID(gConfigVersionUpdateInfo->str_ap_version_name,strlen(vs),return NULL;);
				CW_CREATE_STRING_ERR_WID(gConfigVersionUpdateInfo->str_ap_version_path,strlen(pt),return NULL;);
				CW_CREATE_STRING_ERR_WID(gConfigVersionUpdateInfo->str_ap_model,strlen(chmodel),return NULL;);
				CW_CREATE_STRING_ERR_WID(gConfigVersionUpdateInfo->str_ap_code,sizeof(char)*20,return NULL;);
				
				memset(gConfigVersionUpdateInfo->str_ap_version_name,0,strlen(vs));
				memset(gConfigVersionUpdateInfo->str_ap_version_path,0,strlen(pt));
				memset(gConfigVersionUpdateInfo->str_ap_model,0,strlen(chmodel));
				memset(gConfigVersionUpdateInfo->str_ap_code,0,sizeof(char)*20);
				
				strcpy(gConfigVersionUpdateInfo->str_ap_version_name,vs);
				strcpy(gConfigVersionUpdateInfo->str_ap_version_path,pt);
				strcpy(gConfigVersionUpdateInfo->str_ap_model,chmodel);
				strcpy(gConfigVersionUpdateInfo->str_ap_code,"         ");

				gupdateCountOneTime = count_onetime;
				checkwtpcount = 0;
				
				update_current_wtp();
				if(updatewtplist == NULL)
				{
					WID_FREE(gConfigVersionUpdateInfo->str_ap_model);
					gConfigVersionUpdateInfo->str_ap_model = NULL;
					
					WID_FREE(gConfigVersionUpdateInfo->str_ap_version_name);
					gConfigVersionUpdateInfo->str_ap_version_name = NULL;
					
					WID_FREE(gConfigVersionUpdateInfo->str_ap_version_path);
					gConfigVersionUpdateInfo->str_ap_version_path = NULL;

								
					WID_FREE(gConfigVersionUpdateInfo);
					gConfigVersionUpdateInfo = NULL;
							
					checkwtpcount =0;					
				}
				
				ret = WID_DBUS_SUCCESS;
				break;
			}
			pnode = pnode->next;
		}		
		CWThreadMutexUnlock(&(gAllThreadMutex));		
	}
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	return reply;	
}
#endif

/*mahz add for ap upgrade automatically*/
DBusMessage * wid_dbus_interface_wtp_bind_model_with_file(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter	 iter;
	DBusError err;	
	int ret = MODEL_NO_EXIST;

	char *chmodel;
	char *file_name;
	unsigned char model_exist = 0;
	unsigned char ret_flag = 0;
	unsigned char i = 0;
    unsigned int file_len = 0;
	int result = 1;

	dbus_error_init(&err);

	if (!(dbus_message_get_args ( msg, &err,
				DBUS_TYPE_STRING,&chmodel,
				DBUS_TYPE_STRING,&file_name,
				DBUS_TYPE_INVALID)))
	{
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(gConfigVersionInfo == NULL){
		ret = MODEL_NO_EXIST;
		ret_flag = 1;
	}else{
		CWConfigVersionInfo *pnode = gConfigVersionInfo;
		while(pnode != NULL){
			if(strcmp(pnode->str_ap_model,chmodel) == 0){	
				model_exist = 1;
				ret = WID_DBUS_SUCCESS;
				break;
			}
			pnode = pnode->next;
		}
		if(model_exist != 1){
			ret = MODEL_NO_EXIST;
			ret_flag = 1;
		}
	}
	
	if(ret_flag != 1){
		for(i=0;i<BATCH_UPGRADE_AP_NUM;i++){
			if((gConfigVersionUpdateInfo[i] != NULL)&&(strcmp(gConfigVersionUpdateInfo[i]->str_ap_model,chmodel) == 0))
			{
				ret = UPDATE_PROCESS;
				ret_flag = 1;
				break;
			}
		}
	}
	/*Sth should be done if this model has been binded ever,don't forget it*/
	if((ret_flag != 1)&&(gConfigVerInfo != NULL)){
		CWConfigVersionInfo_new *tmpnode = gConfigVerInfo;
		while(tmpnode != NULL){
			if(strcmp(tmpnode->str_ap_model,chmodel) == 0){
				wid_syslog_debug_debug(WID_DBUS,"the model has been bound ever\n");
				ret = MODEL_BIND_EVER;
				ret_flag = 1;
				break;
			}
			tmpnode = tmpnode->next;
		}
	}

	/*first get the size of the *.tar.bz2 file,then check whether there's enough memory for unpacking this file,
	then unpack the *.tar.bz2 file as its format is known*/
	char buf_path[WID_SYSTEM_CMD_LENTH];
	memset(buf_path,0,WID_SYSTEM_CMD_LENTH);
	sprintf(buf_path,"/mnt/wtp/%s",file_name);

	file_len = getfilesize(buf_path);
	wid_syslog_debug_debug(WID_DBUS,"file_len = %d\n",file_len);
	
	if((ret_flag != 1)&&(WIDCheckFreeMem(file_len, buf_path) < 0)){
		ret = MALLOC_ERROR;
		ret_flag = 1;
		wid_syslog_err("memory is not enough\n");
	}

	wid_syslog_debug_debug(WID_DBUS,"ret = %d\n",ret);
	if(ret != WID_DBUS_SUCCESS){
		reply = dbus_message_new_method_return(msg);
		dbus_message_iter_init_append(reply, &iter);
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
		return reply;
	}
	else{
		/*unpack the tar file here*/
		
		
		DIR *dir = NULL;
		char TmpDir[] = "/mnt/wtp/tmp";
		char cmd[128] = {0};
		dir = opendir(TmpDir);
		if(dir == NULL){
			sprintf(cmd,"sudo mkdir -p %s",TmpDir);
			system(cmd);
			memset(cmd, 0, 128);
			sprintf(cmd,"sudo chmod 777 %s",TmpDir);
			system(cmd);
			memset(cmd, 0, 128);
		}else{
			closedir(dir);
		}
		
		//cp is better than mv,so use cp here,and rm the tar file in delete cmd
		sprintf(cmd,"sudo cp %s %s",buf_path,TmpDir);
		system(cmd);

		wid_syslog_debug_debug(WID_DBUS,"the tar file path is: %s/%s\n",TmpDir,file_name);	//for test
		memset(cmd, 0, 128);
		sprintf(cmd,"cd %s;sudo tar -xjvf %s",TmpDir,file_name);	/*the tar file has been moved to tmp directory*/
		system(cmd);
		
		wid_syslog_debug_debug(WID_DBUS,"already unpacked the file,cp apimg.xml file\n");	//for test
		memset(cmd, 0, 128);
		sprintf(cmd,"cp /mnt/wtp/tmp/apimg.xml /mnt/wtp");
		system(cmd);
		memset(cmd, 0, 128);

		wid_syslog_debug_debug(WID_DBUS,"ready to parse apimg.xml file\n");
		result = CWParseApimgXML(&gConfigVerInfo,chmodel);/*there's sth should be done if parse is failed*/
		if(0 == result){
			ret = MODEL_NO_EXIST;
			ret_flag = 1;
		}
	
		/*copy the apimg file to /mnt/wtp*/
		wid_syslog_debug_debug(WID_DBUS,"ready to copy apimg file\n");
		CWConfigVersionInfo_new *confignode = gConfigVerInfo;
		while((ret_flag != 1)&&(confignode != NULL)){
		/*make sure that the model parsed from apimg.xml file is same with the model input from cmd line*/	
			wid_syslog_debug_debug(WID_DBUS,"gConfigVerInfo is not NULL\n");	//for test
			if(strcmp(confignode->str_ap_model,chmodel) == 0){
				/*store the tar file name here,which is going to be used in show cmd*/
				wid_syslog_debug_debug(WID_DBUS,"the model exists in apimg.xml\n");	//for test
				confignode->tar_file_name = (char*)WID_MALLOC(strlen(file_name)+1);
				memset(confignode->tar_file_name,0,strlen(file_name)+1);
				memcpy(confignode->tar_file_name,file_name,strlen(file_name)); 	
				
				CWCodeInfo *codenode = confignode->code_info;
				while(codenode != NULL){
					memset(cmd, 0, 128);
					sprintf(cmd,"cp /mnt/wtp/tmp/%s /mnt/wtp",codenode->str_ap_version_path);
					system(cmd);

					codenode = codenode->next;
				}
				break;
			}
			else{
				confignode = confignode->next;
			}
		}
		/*rm the tmp file here after everything is done, and leave the job rm apimg file in delete bind cmd*/
		wid_syslog_debug_debug(WID_DBUS,"ready to rm tmp file\n");
		memset(cmd, 0, 128);
		sprintf(cmd,"cd /mnt/wtp;rm -rf /mnt/wtp/tmp");
		system(cmd);
		
		reply = dbus_message_new_method_return(msg);
		dbus_message_iter_init_append(reply, &iter);
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
		return reply;	
	}
}

DBusMessage * wid_dbus_interface_wtp_set_ap_update_base_model(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;	
	int ret = WID_NO_SURPORT_MODEL;

	char *chmodel;
	char i = 0;
	//unsigned char count_onetime;
	unsigned char ret_flag = 0;

	dbus_error_init(&err);


	if (!(dbus_message_get_args ( msg, &err,
				DBUS_TYPE_STRING,&chmodel,
			//	DBUS_TYPE_BYTE,&count_onetime,
				DBUS_TYPE_INVALID)))
	{
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	for(i=0;i<BATCH_UPGRADE_AP_NUM;i++){
		if((gConfigVersionUpdateInfo[i] != NULL)&&(strcmp(gConfigVersionUpdateInfo[i]->str_ap_model,chmodel) == 0))
		{
			ret = MODEL_BIND_EVER;
			ret_flag = 1;
			break;
		}
	}
	if((ret_flag != 1)&&(gupdateControl == 1)){
		ret = UPDATE_PROCESS;
		ret_flag = 1;
	}
	if(ret_flag != 1)
	{
		CWThreadMutexLock(&(gAllThreadMutex));		
		CWConfigVersionInfo *pnode = gConfigVersionInfo;
		CWConfigVersionInfo_new *new_pnode = gConfigVerInfo;
		
		wid_syslog_debug_debug(WID_DBUS,"ready to find the model in wtpcompatible.xml\n");
		while(pnode != NULL){
			if(strcmp(pnode->str_ap_model,chmodel) == 0){
				/*the model exists in wtpcompatible.xml*/
				wid_syslog_debug_debug(WID_DBUS,"ready to find the model in apimg.xml\n");
				while(new_pnode != NULL){
					if(strcmp(new_pnode->str_ap_model,chmodel) == 0){
					/*the model exists in apimg.xml*/
						CWCodeInfo *code_node = new_pnode->code_info;
						wid_syslog_debug_debug(WID_DBUS,"ready to find the code in apimg.xml\n");
						while(code_node != NULL){
							CWConfigVersionInfo *update_node = NULL;
							CW_CREATE_OBJECT_ERR_WID(update_node, CWConfigVersionInfo, return NULL;);	
							memset(update_node,0,sizeof(CWConfigVersionInfo));
							update_node->next = NULL;

							CW_CREATE_STRING_ERR_WID(update_node->str_ap_version_name,strlen(code_node->str_ap_version_name),CW_FREE_OBJECT_WID(update_node); return NULL;);
							CW_CREATE_STRING_ERR_WID(update_node->str_ap_version_path,strlen(code_node->str_ap_version_path),CW_FREE_OBJECT_WID(update_node->str_ap_version_name);CW_FREE_OBJECT_WID(update_node); return NULL;);
							CW_CREATE_STRING_ERR_WID(update_node->str_ap_model,strlen(chmodel),CW_FREE_OBJECT_WID(update_node->str_ap_version_path);CW_FREE_OBJECT_WID(update_node->str_ap_version_name);CW_FREE_OBJECT_WID(update_node); return NULL;);
							CW_CREATE_STRING_ERR_WID(update_node->str_ap_code,strlen(code_node->str_ap_version_code),CW_FREE_OBJECT_WID(update_node->str_ap_model);CW_FREE_OBJECT_WID(update_node->str_ap_version_path);CW_FREE_OBJECT_WID(update_node->str_ap_version_name);CW_FREE_OBJECT_WID(update_node); return NULL;);
							memset(update_node->str_ap_version_name,0,strlen(code_node->str_ap_version_name));
							memset(update_node->str_ap_version_path,0,strlen(code_node->str_ap_version_path));
							memset(update_node->str_ap_model,0,strlen(chmodel));
							memset(update_node->str_ap_code,0,strlen(code_node->str_ap_version_code));

							strcpy(update_node->str_ap_version_name,code_node->str_ap_version_name);
							strcpy(update_node->str_ap_version_path,code_node->str_ap_version_path);
							strcpy(update_node->str_ap_model,chmodel);
							strcpy(update_node->str_ap_code,code_node->str_ap_version_code);

							for(i=0;i<BATCH_UPGRADE_AP_NUM;i++){
								if(gConfigVersionUpdateInfo[i] == NULL){
									gConfigVersionUpdateInfo[i] = update_node;
									ret = WID_DBUS_SUCCESS;
									break;
								}else if((gConfigVersionUpdateInfo[i] != NULL)&&(strcmp(gConfigVersionUpdateInfo[i]->str_ap_model,chmodel) == 0)){
									update_node->next = gConfigVersionUpdateInfo[i];
									gConfigVersionUpdateInfo[i] = update_node;
									ret = WID_DBUS_SUCCESS;
									break;
								} else {
									CW_FREE_OBJECT_WID(update_node->str_ap_code);
									CW_FREE_OBJECT_WID(update_node->str_ap_model);
									CW_FREE_OBJECT_WID(update_node->str_ap_version_path);
									CW_FREE_OBJECT_WID(update_node->str_ap_version_name);
									CW_FREE_OBJECT_WID(update_node);
								}
							}
							if(i == BATCH_UPGRADE_AP_NUM){
								ret = WID_UPGRADE_NUM_OVERFLOW;
								ret_flag = 1;
							}

							code_node = code_node->next;
						}
					/*	gupdateCountOneTime = count_onetime;
						checkwtpcount = 0;
						if(ret_flag != 1){
							update_current_wtp();
						}
					*/	
						break;
					}
					new_pnode = new_pnode->next;
				}
				break;
			}
			pnode = pnode->next;
		}
		
	/*	if(updatewtplist == NULL)
		{
			for(i=0;i<BATCH_UPGRADE_AP_NUM;i++){
				CWConfigVersionInfo *tmp_node = gConfigVersionUpdateInfo[i];
				while(tmp_node != NULL){
					CWConfigVersionInfo *free_node = tmp_node;
					tmp_node = tmp_node->next;
					
					CW_FREE_OBJECT(free_node->str_ap_model);		
					CW_FREE_OBJECT(free_node->str_ap_version_name); 	
					CW_FREE_OBJECT(free_node->str_ap_version_path); 	
					CW_FREE_OBJECT(free_node->str_ap_code); 	
					CW_FREE_OBJECT(free_node);		
				}
				gConfigVersionUpdateInfo[i] = NULL;
			}
			checkwtpcount =0;		
		}
	*/	
		CWThreadMutexUnlock(&(gAllThreadMutex));		
	}
	
	//for test here
	for(i=0;i<BATCH_UPGRADE_AP_NUM;i++){
		CWConfigVersionInfo *tmp_node = gConfigVersionUpdateInfo[i];
		while(tmp_node != NULL){
			wid_syslog_debug_debug(WID_DBUS,"output the upgrade info\n");
			wid_syslog_debug_debug(WID_DBUS,"model: %s\n",tmp_node->str_ap_model);
			wid_syslog_debug_debug(WID_DBUS,"code: %s\n",tmp_node->str_ap_code);
			wid_syslog_debug_debug(WID_DBUS,"path: %s\n",tmp_node->str_ap_version_path);
			wid_syslog_debug_debug(WID_DBUS,"name: %s\n",tmp_node->str_ap_version_name);

			tmp_node = tmp_node->next;
		}
	}
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	return reply;	
}

DBusMessage * wid_dbus_interface_show_model_bind_info(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 
	DBusMessageIter  iter;
	DBusMessageIter  iter_array;
	DBusError err;
	dbus_error_init(&err);
	
	int ret = WID_DBUS_SUCCESS;
	int num=0;
	int i=0;
	char *str_ap_model = NULL;
	char *file_name = NULL;
	CWThreadMutexLock(&(gAllThreadMutex));		
	
	CWConfigVersionInfo_new *pnode = gConfigVerInfo;
	while(pnode != NULL)
	{
		num++;
		pnode = pnode->next;
	}
	pnode = gConfigVerInfo;
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);

	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
		
	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for(i = 0; i < num; i++){	
		DBusMessageIter iter_struct;
			
		dbus_message_iter_open_container (&iter_array,
										DBUS_TYPE_STRUCT,
										NULL,
										&iter_struct);

		if(pnode->str_ap_model != NULL)
		{
			str_ap_model = (char*)WID_MALLOC(strlen(pnode->str_ap_model)+1);
			memset(str_ap_model,0,strlen(pnode->str_ap_model)+1);
			memcpy(str_ap_model,pnode->str_ap_model,strlen(pnode->str_ap_model));		
		}else{
			str_ap_model = (char*)WID_MALLOC(2);
			memset(str_ap_model,0,2);
			memcpy(str_ap_model," ",1); 				
		}

		if(pnode->tar_file_name != NULL)
		{
			file_name = (char*)WID_MALLOC(strlen(pnode->tar_file_name)+1);
			memset(file_name,0,strlen(pnode->tar_file_name)+1);
			memcpy(file_name,pnode->tar_file_name,strlen(pnode->tar_file_name));		
		}else{
			file_name = (char*)WID_MALLOC(2);
			memset(file_name,0,2);
			memcpy(file_name," ",1); 				
		}
		
		dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_STRING, &(str_ap_model));
		dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_STRING, &(file_name));
		dbus_message_iter_close_container (&iter_array, &iter_struct);

		pnode = pnode->next;
		
		CW_FREE_OBJECT_WID(str_ap_model);		
		CW_FREE_OBJECT_WID(file_name);		
	}
				
	dbus_message_iter_close_container (&iter, &iter_array);
	CWThreadMutexUnlock(&(gAllThreadMutex));		
				
	return reply;	
}

DBusMessage * wid_dbus_interface_delete_model_bind_info(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;	
	int ret = MODEL_NO_EXIST;

	char *chmodel;
	unsigned char model_exist_wtpxml = 0;
	unsigned char model_exist_imgxml = 0;
	unsigned char ret_flag = 0;
	unsigned char i = 0;

	dbus_error_init(&err);

	if (!(dbus_message_get_args ( msg, &err,
				DBUS_TYPE_STRING,&chmodel,
				DBUS_TYPE_INVALID)))
	{
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(gConfigVersionInfo == NULL){
		ret = MODEL_NO_EXIST;
		ret_flag = 1;
	}else{
		CWConfigVersionInfo *pnode = gConfigVersionInfo;
		while(pnode != NULL){
			if(strcmp(pnode->str_ap_model,chmodel) == 0)
			{	model_exist_wtpxml = 1;
				ret = WID_DBUS_SUCCESS;
				break;
			}
			pnode = pnode->next;
		}
		if(model_exist_wtpxml != 1){
			ret = MODEL_NO_EXIST;
			ret_flag = 1;
		}
	}

	if(ret_flag != 1){
		for(i=0;i<BATCH_UPGRADE_AP_NUM;i++){
			if((gConfigVersionUpdateInfo[i] != NULL)&&(strcmp(gConfigVersionUpdateInfo[i]->str_ap_model,chmodel) == 0))
			{
				ret = UPDATE_PROCESS;
				ret_flag = 1;
				break;
			}
		}
	}
	if((ret_flag != 1)&&(gupdateControl == 1)){
		ret = UPDATE_PROCESS;
		ret_flag = 1;
	}
	/*Sth should be done if this model has never been binded ever*/
	if((ret_flag != 1)&&(gConfigVerInfo == NULL)){
		ret = MODEL_BIND_NEVER;
		ret_flag = 1;
	}
	if(ret == WID_DBUS_SUCCESS){
		/*since the tmp file which is used to store unpacked files has already been deleted in bind cmd,
		it just needs to delete apimg files and node info in list of  gConfigVerInfo,and the apimg.xml file
		should be reserved*/
		
		char TmpDir[] = "/mnt/wtp";
		char cmd[128] = {0};
		sprintf(cmd,"cd %s",TmpDir);
		system(cmd);

		wid_syslog_debug_debug(WID_DBUS,"ready to find model in gConfigVerInfo\n");
		
		CWConfigVersionInfo_new *confignode = gConfigVerInfo;
		CWConfigVersionInfo_new *tmp = confignode;
		/*the head node*/
		if(strcmp(gConfigVerInfo->str_ap_model,chmodel) == 0){
			model_exist_imgxml = 1;
			ret = WID_DBUS_SUCCESS;
			gConfigVerInfo = gConfigVerInfo->next;
			if(confignode->str_ap_model){
				WID_FREE(confignode->str_ap_model);
				confignode->str_ap_model = NULL;
			}
			if(confignode->tar_file_name){
			/*	memset(cmd, 0, 128);
				sprintf(cmd,"rm /mnt/wtp/%s",confignode->tar_file_name);
				system(cmd);
			*/	
				WID_FREE(confignode->tar_file_name);
				confignode->tar_file_name = NULL;
			}
			//rm apimg.xml
			memset(cmd, 0, 128);
			sprintf(cmd,"rm /mnt/wtp/apimg.xml");
			system(cmd);

			if(confignode->code_info){
				CWCodeInfo *codenode = confignode->code_info;
				CWCodeInfo *tmpcodenode = codenode;
				while(codenode != NULL){
					tmpcodenode = codenode;
					codenode = codenode->next;
					
					memset(cmd, 0, 128);
					sprintf(cmd,"rm /mnt/wtp/%s",tmpcodenode->str_ap_version_path);
					system(cmd);

					if(tmpcodenode->str_ap_version_code){
						WID_FREE(tmpcodenode->str_ap_version_code);
						tmpcodenode->str_ap_version_code = NULL;
					}
					if(tmpcodenode->str_ap_version_name){
						WID_FREE(tmpcodenode->str_ap_version_name);
						tmpcodenode->str_ap_version_name = NULL;
					}
					if(tmpcodenode->str_ap_version_path){
						WID_FREE(tmpcodenode->str_ap_version_path);
						tmpcodenode->str_ap_version_path = NULL;
					}
					if(tmpcodenode){
						WID_FREE(tmpcodenode);
						tmpcodenode = NULL;
					}
				}
				confignode->code_info = NULL;
				confignode->code_num = 0;
			}
		}
		else while(confignode->next != NULL){
			/*make sure that the model input from cmd line exists in list*/	
			tmp = confignode->next;
			if(strcmp(tmp->str_ap_model,chmodel) == 0){
				model_exist_imgxml = 1;
				ret = WID_DBUS_SUCCESS;
				confignode->next = tmp->next;
				
				if(tmp->str_ap_model){
					WID_FREE(tmp->str_ap_model);
					tmp->str_ap_model = NULL;
				}
				if(tmp->tar_file_name){
				/*	memset(cmd, 0, 128);
					sprintf(cmd,"rm /mnt/wtp/%s",confignode->tar_file_name);
					system(cmd);
				*/	
					WID_FREE(tmp->tar_file_name);
					tmp->tar_file_name = NULL;
				}

				//rm apimg.xml
				memset(cmd, 0, 128);
				sprintf(cmd,"rm /mnt/wtp/apimg.xml");
				system(cmd);

				if(tmp->code_info){
					CWCodeInfo *codenode = tmp->code_info;
					CWCodeInfo *tmpcodenode = codenode;
					while(codenode != NULL){
						tmpcodenode = codenode;
						codenode = codenode->next;
						
						memset(cmd, 0, 128);
						sprintf(cmd,"rm /mnt/wtp/%s",tmpcodenode->str_ap_version_path);
						system(cmd);
			
						if(tmpcodenode->str_ap_version_code){
							WID_FREE(tmpcodenode->str_ap_version_code);
							tmpcodenode->str_ap_version_code = NULL;
						}
						if(tmpcodenode->str_ap_version_name){
							WID_FREE(tmpcodenode->str_ap_version_name);
							tmpcodenode->str_ap_version_name = NULL;
						}
						if(tmpcodenode->str_ap_version_path){
							WID_FREE(tmpcodenode->str_ap_version_path);
							tmpcodenode->str_ap_version_path = NULL;
						}
						if(tmpcodenode){
							WID_FREE(tmpcodenode);
							tmpcodenode = NULL;
						}
					}
					tmp->code_info = NULL;
					tmp->code_num = 0;
				}
				
				if(tmp){
					WID_FREE(tmp);
					tmp = NULL;
				}
				break;
			}
			confignode = confignode->next;
		}
	}
	
	if((ret_flag != 1)&&(model_exist_imgxml != 1))
		ret = MODEL_NO_EXIST;
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;	
}

DBusMessage * wid_dbus_interface_wtp_set_ap_update_count_onetime(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter	 iter;
	DBusError err;	
	int ret = WID_DBUS_SUCCESS;

	unsigned char count_onetime;

	dbus_error_init(&err);


	if (!(dbus_message_get_args ( msg, &err,
				DBUS_TYPE_BYTE,&count_onetime,
				DBUS_TYPE_INVALID)))
	{
		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(gupdateControl == 1){
		ret = UPDATE_PROCESS;
	}else{
		gupdateCountOneTime = count_onetime;
	}
	wid_syslog_debug_debug(WID_DBUS,"gupdateCountOneTime = %d\n",gupdateCountOneTime);
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	return reply;	
}

DBusMessage * wid_dbus_interface_wtp_set_ap_update_control(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;	
	int ret = WID_NO_SURPORT_MODEL;

	unsigned char policy;
	unsigned char i=0,ret_flag=0;

	dbus_error_init(&err);


	if (!(dbus_message_get_args ( msg, &err,
				DBUS_TYPE_BYTE,&policy,
				DBUS_TYPE_INVALID)))
	{
		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	gupdateControl = policy;
	wid_syslog_debug_debug(WID_DBUS,"gupdateControl = %d,1 means start and 2 means stop\n",gupdateControl);

	for(i=0;i<BATCH_UPGRADE_AP_NUM;i++)
	{
		if(gConfigVersionUpdateInfo[i] != NULL)
		{
			ret_flag = 1;
			ret = WID_DBUS_SUCCESS;		
			break;
		}
	}

	if((ret_flag == 1)&&(gupdateControl == 1)){
		checkwtpcount = 0;
		update_current_wtp();
	}else if(gupdateControl == 2){
		ret = WID_DBUS_SUCCESS; 	
		destroy_wtp_list();		
		checkwtpcount = 0;
	}
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	return reply;	
}

DBusMessage * wid_dbus_interface_wtp_clear_ap_one_model_update_path(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;	
	int ret = WID_DBUS_SUCCESS;
	char i=0,ret_flag=0;
	char *chmodel = NULL;
	CWConfigVersionInfo *tmp_node = NULL;

	dbus_error_init(&err);

	if (!(dbus_message_get_args ( msg, &err,
				DBUS_TYPE_STRING,&chmodel,
				DBUS_TYPE_INVALID)))
	{
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(gupdateControl == 1){
		ret = UPDATE_PROCESS;
		ret_flag = 1;
	}

	if(ret_flag != 1){
		for(i=0;i<BATCH_UPGRADE_AP_NUM;i++)
		{
			if((gConfigVersionUpdateInfo[i] != NULL)&&(strcmp(gConfigVersionUpdateInfo[i]->str_ap_model,chmodel) == 0))
			{
				tmp_node = gConfigVersionUpdateInfo[i];
				break;
			}
		}
		if(i == BATCH_UPGRADE_AP_NUM){
			ret = WID_DBUS_ERROR;		
			ret_flag = 1;
		}
	}
	
	if(ret_flag != 1)
	{
		while(tmp_node != NULL){
			CWConfigVersionInfo *free_node = tmp_node;
			tmp_node = tmp_node->next;
		
			CW_FREE_OBJECT_WID(free_node->str_ap_model);		
			CW_FREE_OBJECT_WID(free_node->str_ap_version_name);		
			CW_FREE_OBJECT_WID(free_node->str_ap_version_path);		
			CW_FREE_OBJECT_WID(free_node->str_ap_code);		
			CW_FREE_OBJECT_WID(free_node);		
		}
		gConfigVersionUpdateInfo[i] = NULL;
	}
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	return reply;	
}

DBusMessage * wid_dbus_interface_show_model_detail_bind_info(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 
	DBusMessageIter  iter;
	DBusMessageIter  iter_array;
	DBusError err;
	dbus_error_init(&err);
	
	int ret = WID_DBUS_SUCCESS;
	int num=0;
	int i=0,j=0;
	char *str_ap_model = NULL;
	char *str_ap_version_name;
	char *str_ap_version_path;
	char *str_ap_version_code;
	CWThreadMutexLock(&(gAllThreadMutex));		
	
	CWConfigVersionInfo_new *pnode = gConfigVerInfo;
	while(pnode != NULL)
	{
		num++;
		pnode = pnode->next;
	}
	pnode = gConfigVerInfo;
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);

	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
		
	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
									 DBUS_TYPE_BYTE_AS_STRING
									 DBUS_TYPE_ARRAY_AS_STRING
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
							 			 DBUS_TYPE_STRING_AS_STRING
							 			 DBUS_TYPE_STRING_AS_STRING
							 			 DBUS_TYPE_STRING_AS_STRING
							 			 DBUS_TYPE_STRING_AS_STRING
										DBUS_STRUCT_END_CHAR_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for(i = 0; i < num; i++){	
		DBusMessageIter iter_struct;
		DBusMessageIter iter_sub_array;
		CWCodeInfo *codenode = pnode->code_info;
		
		if(pnode->str_ap_model != NULL)
		{
			str_ap_model = (char*)WID_MALLOC(strlen(pnode->str_ap_model)+1);
			memset(str_ap_model,0,strlen(pnode->str_ap_model)+1);
			memcpy(str_ap_model,pnode->str_ap_model,strlen(pnode->str_ap_model));		
		}else{
			str_ap_model = (char*)WID_MALLOC(2);
			memset(str_ap_model,0,2);
			memcpy(str_ap_model," ",1); 				
		}
			
		dbus_message_iter_open_container (&iter_array,
										DBUS_TYPE_STRUCT,
										NULL,
										&iter_struct);

		dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_BYTE, &(pnode->code_num));

		dbus_message_iter_open_container (&iter_struct,
								   DBUS_TYPE_ARRAY,
								   DBUS_STRUCT_BEGIN_CHAR_AS_STRING  
									DBUS_TYPE_STRING_AS_STRING
									DBUS_TYPE_STRING_AS_STRING
									DBUS_TYPE_STRING_AS_STRING
									DBUS_TYPE_STRING_AS_STRING
								   DBUS_STRUCT_END_CHAR_AS_STRING, 
								   &iter_sub_array);
		
		for(j=0;j<pnode->code_num;j++)
		{
			DBusMessageIter iter_sub_struct;				
			dbus_message_iter_open_container (&iter_sub_array,
												DBUS_TYPE_STRUCT,
												NULL,
											  &iter_sub_struct);

			if((codenode != NULL)&&(codenode->str_ap_version_name != NULL))
			{
				str_ap_version_name = (char*)WID_MALLOC(strlen(codenode->str_ap_version_name)+1);
				memset(str_ap_version_name,0,strlen(codenode->str_ap_version_name)+1);
				memcpy(str_ap_version_name,codenode->str_ap_version_name,strlen(codenode->str_ap_version_name));		
			}else{
				str_ap_version_name = (char*)WID_MALLOC(2);
				memset(str_ap_version_name,0,2);
				memcpy(str_ap_version_name," ",1);				
			}
			
			if((codenode != NULL)&&(codenode->str_ap_version_path != NULL))
			{
				str_ap_version_path = (char*)WID_MALLOC(strlen(codenode->str_ap_version_path)+1);
				memset(str_ap_version_path,0,strlen(codenode->str_ap_version_path)+1);
				memcpy(str_ap_version_path,codenode->str_ap_version_path,strlen(codenode->str_ap_version_path));		
			}else{
				str_ap_version_path = (char*)WID_MALLOC(2);
				memset(str_ap_version_path,0,2);
				memcpy(str_ap_version_path," ",1);				
			}
			
			if((codenode != NULL)&&(codenode->str_ap_version_code != NULL))
			{
				str_ap_version_code = (char*)WID_MALLOC(strlen(codenode->str_ap_version_code)+1);
				memset(str_ap_version_code,0,strlen(codenode->str_ap_version_code)+1);
				memcpy(str_ap_version_code,codenode->str_ap_version_code,strlen(codenode->str_ap_version_code));		
			}else{
				str_ap_version_code = (char*)WID_MALLOC(2);
				memset(str_ap_version_code,0,2);
				memcpy(str_ap_version_code," ",1);				
			}

			dbus_message_iter_append_basic(&iter_sub_struct, DBUS_TYPE_STRING, &(str_ap_model));
			dbus_message_iter_append_basic(&iter_sub_struct, DBUS_TYPE_STRING, &(str_ap_version_code));
			dbus_message_iter_append_basic(&iter_sub_struct, DBUS_TYPE_STRING, &(str_ap_version_name));
			dbus_message_iter_append_basic(&iter_sub_struct, DBUS_TYPE_STRING, &(str_ap_version_path));
			dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);
			
			if(codenode != NULL)
				codenode = codenode->next;
			CW_FREE_OBJECT_WID(str_ap_version_code);		
			CW_FREE_OBJECT_WID(str_ap_version_name);		
			CW_FREE_OBJECT_WID(str_ap_version_path);		
		}

		dbus_message_iter_close_container (&iter_struct, &iter_sub_array);	
		dbus_message_iter_close_container (&iter_array, &iter_struct);
		pnode = pnode->next;
		
		CW_FREE_OBJECT_WID(str_ap_model);		
	}
				
	dbus_message_iter_close_container (&iter, &iter_array);
	CWThreadMutexUnlock(&(gAllThreadMutex));		
				
	return reply;	
}

DBusMessage * wid_dbus_interface_wtp_show_ap_upgrade_result(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 
	DBusMessageIter  iter;
	DBusMessageIter  iter_array;
	DBusError err;
	dbus_error_init(&err);
	
	int ret = WID_DBUS_SUCCESS;
	int num_succ=0,num_fail=0,num_other=0;
	int i=0,j=0;
	int result1=0,result2=0,result3=0;
	char *wtp_ip = NULL;
	char *wtp_model = NULL;
	
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);		
	if( mac == NULL){
		wid_syslog_debug_debug(WID_DBUS,"%s :malloc fail.\n",__func__);
		return NULL;
	}
	memset(mac,0,MAC_LEN+1);

	WID_WTP **WTP_SUCC = NULL;
	WID_WTP **WTP_FAIL = NULL;
	WID_WTP **WTP_OTHE = NULL;
	WTP_SUCC = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	if( WTP_SUCC == NULL){
		wid_syslog_err("%s %d:malloc fail.\n",__func__,__LINE__);
		CW_FREE_OBJECT_WID(mac);
		return NULL;
	}
	memset(WTP_SUCC,0,WTP_NUM*(sizeof(WID_WTP *)));

	WTP_FAIL = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	if( WTP_FAIL == NULL){
		wid_syslog_err("%s %d:malloc fail.\n",__func__,__LINE__);
		CW_FREE_OBJECT_WID(mac);
		CW_FREE_OBJECT_WID(WTP_SUCC);
		return NULL;
	}
	memset(WTP_FAIL,0,WTP_NUM*(sizeof(WID_WTP *)));

	WTP_OTHE = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	if( WTP_OTHE == NULL){
		wid_syslog_err("%s %d:malloc fail.\n",__func__,__LINE__);
		CW_FREE_OBJECT_WID(mac);
		CW_FREE_OBJECT_WID(WTP_SUCC);
		CW_FREE_OBJECT_WID(WTP_FAIL);
		return NULL;
	}
	memset(WTP_OTHE,0,WTP_NUM*(sizeof(WID_WTP *)));

	CWThreadMutexLock(&(gAllThreadMutex));		
	for(i = 0; i < WTP_NUM; i++){
		if(AC_WTP[i] != NULL){
			result1 = CW_FALSE;
			for(j = 0; j < BATCH_UPGRADE_AP_NUM; j++)
			{
				if((gConfigVersionUpdateInfo[j] != NULL)&&(strcmp(AC_WTP[i]->WTPModel,gConfigVersionUpdateInfo[j]->str_ap_model) == 0))
				{
					result1 = CW_TRUE;
					result2 = CW_FALSE;
					CWConfigVersionInfo *tmpnode = gConfigVersionUpdateInfo[j];
					while(tmpnode != NULL){
						wid_syslog_debug_debug(WID_WTPINFO,"**** match code operation1111 ****\n"); //for test
						if(strcmp(tmpnode->str_ap_code,AC_WTP[i]->APCode) == 0){
							result2 = CW_TRUE;
							result3 = CW_FALSE;
							if((AC_WTP[i]->codever == NULL)&&(AC_WTP[i]->ver != NULL)&&(strcmp(AC_WTP[i]->ver,tmpnode->str_ap_version_name) == 0))				
							{
								wid_syslog_debug_debug(WID_WTPINFO,"ap model match 222\n"); 	//for test
								result3 = CW_TRUE;
								WTP_SUCC[num_succ++] = AC_WTP[i];
							}
							else if((AC_WTP[i]->codever != NULL)&&(strcmp(tmpnode->str_ap_version_name,AC_WTP[i]->codever) == 0))
							{
								wid_syslog_debug_debug(WID_WTPINFO,"ap model match 333\n"); 	//for test
								result3 = CW_TRUE;
								WTP_SUCC[num_succ++] = AC_WTP[i];
							}
							break;
						}
						tmpnode = tmpnode->next;
					}

					if(result2 != CW_TRUE){
						WTP_OTHE[num_other++] = AC_WTP[i];
					}
					if((result2 == CW_TRUE)&&(result3 != CW_TRUE)){
						WTP_FAIL[num_fail++] = AC_WTP[i];
					}
					break;
				}
			}
			
			if(result1 != CW_TRUE){
				WTP_OTHE[num_other++] = AC_WTP[i];
			}
		}
	}
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);

	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num_succ);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num_fail);
	
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num_other);

	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for(i = 0; ((i < num_succ)&&(WTP_SUCC[i] != NULL)); i++){			
		DBusMessageIter iter_struct;
		dbus_message_iter_open_container(&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_UINT32,&(WTP_SUCC[i]->WTPID));

		memset(mac,0,MAC_LEN+1);
		if(WTP_SUCC[i]->WTPMAC != NULL){
			memcpy(mac,WTP_SUCC[i]->WTPMAC,MAC_LEN);
		}else{
		}
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[0]));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[1]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[2]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[3]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[4]));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[5]));

		if(WTP_SUCC[i]->WTPIP != NULL)
		{
			wtp_ip = (char*)WID_MALLOC(strlen(WTP_SUCC[i]->WTPIP)+1);
			memset(wtp_ip,0,strlen(WTP_SUCC[i]->WTPIP)+1);
			memcpy(wtp_ip,WTP_SUCC[i]->WTPIP,strlen(WTP_SUCC[i]->WTPIP));	
		}else{
			wtp_ip = (char*)WID_MALLOC(2);
			memset(wtp_ip,0,2);
			memcpy(wtp_ip," ",1);
		}
		
		if(WTP_SUCC[i]->WTPModel != NULL)
		{
			wtp_model = (char*)WID_MALLOC(strlen(WTP_SUCC[i]->WTPModel)+1);
			memset(wtp_model,0,strlen(WTP_SUCC[i]->WTPModel)+1);
			memcpy(wtp_model,WTP_SUCC[i]->WTPModel,strlen(WTP_SUCC[i]->WTPModel));		
		}else{
			wtp_model = (char*)WID_MALLOC(2);
			memset(wtp_model,0,2);
			memcpy(wtp_model," ",1);					
		}
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&(wtp_ip));
			
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&(wtp_model));
		
		dbus_message_iter_close_container (&iter_array, &iter_struct);

		CW_FREE_OBJECT_WID(wtp_ip);
		CW_FREE_OBJECT_WID(wtp_model);
	}
				
	for(i = 0; ((i < num_fail)&&(WTP_FAIL[i] != NULL)); i++){			
		DBusMessageIter iter_struct;
		dbus_message_iter_open_container(&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_UINT32,&(WTP_FAIL[i]->WTPID));
	
		memset(mac,0,MAC_LEN+1);
		if(WTP_FAIL[i]->WTPMAC != NULL){
			memcpy(mac,WTP_FAIL[i]->WTPMAC,MAC_LEN);
		}else{
		}
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[0]));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[1]));
	
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[2]));
	
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[3]));
	
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[4]));
	
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[5]));
	
		if(WTP_FAIL[i]->WTPIP != NULL)
		{
			wtp_ip = (char*)WID_MALLOC(strlen(WTP_FAIL[i]->WTPIP)+1);
			memset(wtp_ip,0,strlen(WTP_FAIL[i]->WTPIP)+1);
			memcpy(wtp_ip,WTP_FAIL[i]->WTPIP,strlen(WTP_FAIL[i]->WTPIP));	
		}else{
			wtp_ip = (char*)WID_MALLOC(2);
			memset(wtp_ip,0,2);
			memcpy(wtp_ip," ",1);
		}
		
		if(WTP_FAIL[i]->WTPModel != NULL)
		{
			wtp_model = (char*)WID_MALLOC(strlen(WTP_FAIL[i]->WTPModel)+1);
			memset(wtp_model,0,strlen(WTP_FAIL[i]->WTPModel)+1);
			memcpy(wtp_model,WTP_FAIL[i]->WTPModel,strlen(WTP_FAIL[i]->WTPModel));		
		}else{
			wtp_model = (char*)WID_MALLOC(2);
			memset(wtp_model,0,2);
			memcpy(wtp_model," ",1);					
		}
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&(wtp_ip));
			
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&(wtp_model));
		
		dbus_message_iter_close_container (&iter_array, &iter_struct);
	
		CW_FREE_OBJECT_WID(wtp_ip);
		CW_FREE_OBJECT_WID(wtp_model);
	}
	
	for(i = 0; ((i < num_other)&&(WTP_OTHE[i] != NULL)); i++){			
		DBusMessageIter iter_struct;
		dbus_message_iter_open_container(&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_UINT32,&(WTP_OTHE[i]->WTPID));
	
		memset(mac,0,MAC_LEN+1);
		if(WTP_OTHE[i]->WTPMAC != NULL){
			memcpy(mac,WTP_OTHE[i]->WTPMAC,MAC_LEN);
		}else{
		}
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[0]));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[1]));
	
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[2]));
	
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[3]));
	
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[4]));
	
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(mac[5]));
	
		if(WTP_OTHE[i]->WTPIP != NULL)
		{
			wtp_ip = (char*)WID_MALLOC(strlen(WTP_OTHE[i]->WTPIP)+1);
			memset(wtp_ip,0,strlen(WTP_OTHE[i]->WTPIP)+1);
			memcpy(wtp_ip,WTP_OTHE[i]->WTPIP,strlen(WTP_OTHE[i]->WTPIP));	
		}else{
			wtp_ip = (char*)WID_MALLOC(2);
			memset(wtp_ip,0,2);
			memcpy(wtp_ip," ",1);
		}
		
		if(WTP_OTHE[i]->WTPModel != NULL)
		{
			wtp_model = (char*)WID_MALLOC(strlen(WTP_OTHE[i]->WTPModel)+1);
			memset(wtp_model,0,strlen(WTP_OTHE[i]->WTPModel)+1);
			memcpy(wtp_model,WTP_OTHE[i]->WTPModel,strlen(WTP_OTHE[i]->WTPModel));		
		}else{
			wtp_model = (char*)WID_MALLOC(2);
			memset(wtp_model,0,2);
			memcpy(wtp_model," ",1);					
		}
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&(wtp_ip));
			
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&(wtp_model));
		
		dbus_message_iter_close_container (&iter_array, &iter_struct);
	
		CW_FREE_OBJECT_WID(wtp_ip);
		CW_FREE_OBJECT_WID(wtp_model);
	}

	dbus_message_iter_close_container (&iter, &iter_array);
				
	CWThreadMutexUnlock(&(gAllThreadMutex));		
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(WTP_SUCC);
	CW_FREE_OBJECT_WID(WTP_FAIL);
	CW_FREE_OBJECT_WID(WTP_OTHE);
	return reply;	
}

DBusMessage * wid_dbus_interface_wtp_show_ap_update_path(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter	 iter;
	DBusError err;	
	int ret = WID_DBUS_SUCCESS;
	char *str_ap_model = NULL;
	char *str_ap_version_name = NULL;
	char *str_ap_version_path = NULL;
	//char *chmodel;
	//char *vs,*pt;
	//unsigned char count_onetime;
	CWConfigVersionInfo *UpdateWTPInfo[BATCH_UPGRADE_AP_NUM] = {NULL};
	CWConfigVersionInfo *tmpnode = NULL;
	char i=0,j=0,k=0,m=0;
	
	dbus_error_init(&err);

	for(i=0;i<BATCH_UPGRADE_AP_NUM;i++)
	{
		if(gConfigVersionUpdateInfo[i] != NULL)
		{
			UpdateWTPInfo[j++] = gConfigVersionUpdateInfo[i];
		}
	}
	if(j==0){
		ret = WID_DBUS_ERROR;		
	}
	wid_syslog_debug_debug(WID_DBUS,"j = %d\n",j);
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if(ret == WID_DBUS_SUCCESS)
	{
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &gupdateCountOneTime);
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &j);
		
		for(i=0;i<j;i++){
			k=0;
			tmpnode = UpdateWTPInfo[i];
			while(tmpnode != NULL){
				k++;
				tmpnode = tmpnode->next;
			}
			tmpnode = UpdateWTPInfo[i];
			
			wid_syslog_debug_debug(WID_DBUS,"i = %d, k = %d\n",i,k);
			dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &k);
			for(m=0;m<k;m++){
				if(tmpnode->str_ap_model != NULL)
				{
					str_ap_model= (char*)WID_MALLOC(strlen(tmpnode->str_ap_model)+1);
					memset(str_ap_model,0,strlen(tmpnode->str_ap_model)+1);
					memcpy(str_ap_model,tmpnode->str_ap_model,strlen(tmpnode->str_ap_model));		
				}else{
					str_ap_model = (char*)WID_MALLOC(2);
					memset(str_ap_model,0,2);
					memcpy(str_ap_model," ",1);					
				}
				
				if(tmpnode->str_ap_version_name != NULL)
				{
					str_ap_version_name= (char*)WID_MALLOC(strlen(tmpnode->str_ap_version_name)+1);
					memset(str_ap_version_name,0,strlen(tmpnode->str_ap_version_name)+1);
					memcpy(str_ap_version_name,tmpnode->str_ap_version_name,strlen(tmpnode->str_ap_version_name));		
				}else{
					str_ap_version_name = (char*)WID_MALLOC(2);
					memset(str_ap_version_name,0,2);
					memcpy(str_ap_version_name," ",1);					
				}
				
				if(tmpnode->str_ap_version_path != NULL)
				{
					str_ap_version_path= (char*)WID_MALLOC(strlen(tmpnode->str_ap_version_path)+1);
					memset(str_ap_version_path,0,strlen(tmpnode->str_ap_version_path)+1);
					memcpy(str_ap_version_path,tmpnode->str_ap_version_path,strlen(tmpnode->str_ap_version_path));		
				}else{
					str_ap_version_path = (char*)WID_MALLOC(2);
					memset(str_ap_version_path,0,2);
					memcpy(str_ap_version_path," ",1);					
				}		
				dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &str_ap_model);
				dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &str_ap_version_name);
				dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &str_ap_version_path);
				tmpnode = tmpnode->next;
				
				CW_FREE_OBJECT_WID(str_ap_model);
				CW_FREE_OBJECT_WID(str_ap_version_name);
				CW_FREE_OBJECT_WID(str_ap_version_path);
			}
		}
	}

	return reply;	
}

DBusMessage * wid_dbus_interface_wtp_clear_ap_update_path(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter	 iter;
	DBusError err;	
	int ret = WID_DBUS_SUCCESS;
	char i=0,j=0,ret_flag=0;

	//char *chmodel;
	//char *vs,*pt;
	//unsigned char count_onetime;

	dbus_error_init(&err);

	if(gupdateControl == 1){
		ret = UPDATE_PROCESS;
		ret_flag = 1;
	}

	if(ret_flag != 1){
		for(i=0;i<BATCH_UPGRADE_AP_NUM;i++)
		{
			if(gConfigVersionUpdateInfo[i] == NULL)
			{
				j++;
			}
		}
		wid_syslog_debug_debug(WID_DBUS,"i = %d, j = %d\n",i,j);
		if(j == BATCH_UPGRADE_AP_NUM){
			ret = WID_DBUS_ERROR;		
			ret_flag = 1;
		}
	}
	
	if(ret_flag != 1)	
	{

		destroy_wtp_list();		
		
		/*mahz modified to match ap upgrade automatically*/
		for(i=0;i<BATCH_UPGRADE_AP_NUM;i++){
			CWConfigVersionInfo *tmp_node = gConfigVersionUpdateInfo[i];
			while(tmp_node != NULL){
				CWConfigVersionInfo *free_node = tmp_node;
				tmp_node = tmp_node->next;
			
				WID_FREE(free_node->str_ap_model);
				free_node->str_ap_model = NULL;
				
				WID_FREE(free_node->str_ap_version_name);
				free_node->str_ap_version_name = NULL;
				
				WID_FREE(free_node->str_ap_version_path);
				free_node->str_ap_version_path = NULL;
			
				WID_FREE(free_node->str_ap_code);
				free_node->str_ap_code = NULL;
				
				WID_FREE(free_node);
				free_node = NULL;
			}
			gConfigVersionUpdateInfo[i] = NULL;
		}
				
		checkwtpcount =0;
		
	}
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);


	return reply;	
}

DBusMessage * wid_dbus_interface_wtp_delete_ap_model(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter	 iter;
	DBusError err;	
	int ret = WID_NO_SURPORT_MODEL;
	int modelcount = 0;
	int circlecount = 0;

	char *chmodel;

	dbus_error_init(&err);


	if (!(dbus_message_get_args ( msg, &err,
				DBUS_TYPE_STRING,&chmodel,
				DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}
	CWThreadMutexLock(&(gAllThreadMutex));		

	CWConfigVersionInfo *pnode = gConfigVersionInfo;
	CWConfigVersionInfo *deletenode = NULL;

	while(pnode != NULL)
	{
		modelcount++;
		pnode = pnode->next;
	}

	pnode = gConfigVersionInfo;
	circlecount = modelcount;
	wid_syslog_debug_debug(WID_DBUS,"modelcount = %d, gModelCount = %d, circlecount = %d\n",modelcount,gModelCount,circlecount);

	if(pnode == NULL)
	{
		
	}
	else if(strcmp(pnode->str_ap_model,chmodel) == 0)
	{
		if((pnode->next != NULL)&&(circlecount>0))
		{
			gConfigVersionInfo = pnode->next;

			WID_FREE(pnode->str_ap_model);
			pnode->str_ap_model = NULL;
		//	free(pnode->str_ap_version_name);
		//	pnode->str_ap_version_name = NULL;
		//	free(pnode->str_ap_version_path);
		//	pnode->str_ap_version_path = NULL;
			WID_FREE(pnode);
			pnode = NULL;

			ret = WID_DBUS_SUCCESS;
		}
		else
		{
			ret = WID_NO_SURPORT_MODEL;
		}
	}
	else
	{
		circlecount--;
		while(pnode->next != NULL)
		{
			if((circlecount>0)&&(strcmp(pnode->next->str_ap_model,chmodel) == 0))
			{
				deletenode = pnode->next;
				pnode->next = pnode->next->next;
				
				WID_FREE(deletenode->str_ap_model);
				deletenode->str_ap_model = NULL;
			//	free(deletenode->str_ap_version_name);
			//	deletenode->str_ap_version_name = NULL;
			//	free(deletenode->str_ap_version_path);
			//	deletenode->str_ap_version_path = NULL;
				WID_FREE(deletenode);
				deletenode = NULL;	
				
				ret = WID_DBUS_SUCCESS;
				break;
			}
			pnode = pnode->next;
			circlecount--;
		}
	}
	
	CWThreadMutexUnlock(&(gAllThreadMutex));		
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	return reply;	


}

DBusMessage * wid_dbus_interface_wtp_set_ap_echotimer(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter	 iter;
	DBusError err;	
	dbus_error_init(&err);
	
	int ret = WID_DBUS_SUCCESS;
	unsigned int wtpid = 0;
	int echotimer = 10;
	int i = 0;
	if (!(dbus_message_get_args ( msg, &err,
				DBUS_TYPE_UINT32,&wtpid,
				DBUS_TYPE_UINT32,&echotimer,
				DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}

	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	if(wtpid == 0){
		gEchoRequestTimer = echotimer;
		for(i = 0; i < WTP_NUM; i++){
			if(AC_WTP[i] != NULL){
				AC_WTP[i]->EchoTimer = echotimer;	
			}
		}
	}else{
		if(wtpid < WTP_NUM && AC_WTP[wtpid] != NULL){
			AC_WTP[wtpid]->EchoTimer = echotimer;
		}
	}

	return reply;	

}

DBusMessage * wid_dbus_interface_wtp_set_ap_checktimer(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter	 iter;
	DBusError err;	
	dbus_error_init(&err);
	
	int ret = WID_DBUS_SUCCESS;
	unsigned int wtpid = 0;
	int checktimer = 10;
	if (!(dbus_message_get_args ( msg, &err,
				DBUS_TYPE_UINT32,&wtpid,
				DBUS_TYPE_UINT32,&checktimer,
				DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}

	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	gCheckRequestTimer = checktimer;

	return reply;	

}

DBusMessage * wid_dbus_interface_wtp_set_ap_collect_time(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter	 iter;
	DBusError err;	
	dbus_error_init(&err);
	
	int ret = WID_DBUS_SUCCESS;
	unsigned int wtpid = 0;
	int collect_time = 3500;
	int i = 0;
	if (!(dbus_message_get_args ( msg, &err,
				DBUS_TYPE_UINT32,&wtpid,
				DBUS_TYPE_UINT32,&collect_time,
				DBUS_TYPE_INVALID))){
				
		printf("Unable to get input args\n");
		if (dbus_error_is_set(&err)){
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	if(wtpid == 0){
		cpu_mem_collect_time=collect_time;
		for(i = 0; i < WTP_NUM; i++){
			if(AC_WTP[i] != NULL){
				AC_WTP[i]->collect_time = collect_time;	
			}
		}
	}
	else{
		if((wtpid < WTP_NUM) && (AC_WTP[wtpid] != NULL)){
			AC_WTP[wtpid]->collect_time= collect_time;
		}
	}

	return reply;	

}

#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_radio_set_txp(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply = NULL;	
	DBusMessageIter	 iter;
	DBusError err;	
	
	int i = 0;
	int num =0 ;
	int radionum = 0;

	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned short RadioTxp = 0;

	int ret = WID_DBUS_SUCCESS;
	int ret1 = COUNTRY_CODE_SUCCESS;	
	int ret2 = WID_DBUS_SUCCESS;
	int ret3 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT16,&RadioTxp,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(type==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else
				{
					//append to country code ,decide txpower
					//if((gCOUNTRYCODE == COUNTRY_FRANCE_FR)||(gCOUNTRYCODE == COUNTRY_SPAIN_ES))
					if((AC_RADIO[ID]->Radio_country_code == COUNTRY_FRANCE_FR)||(AC_RADIO[ID]->Radio_country_code == COUNTRY_SPAIN_ES))/*wcl moify for OSDEVTDPB-31*/
						{
							if((RadioTxp > 14)&&(RadioTxp != 100))/*100 is auto*/
								{
									ret1 = COUNTRY_CODE_ERROR;
								}
						}

					if(ret1 != COUNTRY_CODE_SUCCESS)//txpower conflict
						{
							reply = dbus_message_new_method_return(msg);
			
							dbus_message_iter_init_append (reply, &iter);
			
							dbus_message_iter_append_basic (&iter,
											 			DBUS_TYPE_UINT32,
											 				&ret);
							dbus_message_iter_append_basic (&iter,
											 			DBUS_TYPE_UINT32,
											 				&ret1);
							return reply;
						}	
	
					ret = WID_RADIO_SET_TXP(ID,RadioTxp,CW_FALSE);	
					AC_RADIO[ID]->radio_countermeasures_flag = 0;   //AP,fengwenchao add 20110325
				}
	
			reply = dbus_message_new_method_return(msg);
	
			dbus_message_iter_init_append (reply, &iter);
	
			dbus_message_iter_append_basic (&iter,
									 		DBUS_TYPE_UINT32,
											 &ret);
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
									 		&ret1);
			return reply;
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));

					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
								//printf("!!!!!!!!!!!!!!\n");
							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]==NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;	
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}

										else
											{
												//RadioTxpof = t_RadioTxpof* AC_WTP[tmp->WTPID]->WTP_Radio[i]->txpowerstep; 
												//append to country code ,decide txpower
												//if((gCOUNTRYCODE == COUNTRY_FRANCE_FR)||(gCOUNTRYCODE == COUNTRY_SPAIN_ES))
												if((AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_country_code == COUNTRY_FRANCE_FR)||(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_country_code == COUNTRY_SPAIN_ES))/*wcl modify for OSDEVTDPB-31*/
													{
														if((RadioTxp > 14)&&(RadioTxp != 100))
															{
																ret1 = COUNTRY_CODE_ERROR;
															}
													}
										
												if(ret1 == COUNTRY_CODE_SUCCESS)
													{
														ret3 = WID_RADIO_SET_TXP(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,RadioTxp,CW_FALSE);
														wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d access into set txp\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
														AC_WTP[tmp->WTPID]->WTP_Radio[i]->radio_countermeasures_flag = 0;   //APfengwenchao add 20110325
													}
											}
										printf("111111111111\n");
										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
										else if((ret2 == WID_DBUS_SUCCESS)&&(ret1 == COUNTRY_CODE_SUCCESS)&&(ret3 != WID_DBUS_SUCCESS))
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret3;
												num++;
											}
										else if((ret2 == WID_DBUS_SUCCESS)&&(ret1 == COUNTRY_CODE_ERROR))
											{
												//huxf
												ret1 = RADIO_SET_TXPOF_COUNTRY_CODE_ERROR; 
												radio_head[num].RadioId= AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason=ret1;
												num++;
											}
										printf("ret2 = %d\n",ret2);

									}

								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
	
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if(ret == WID_DBUS_SUCCESS)
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}

			}
			return reply;

	} else {
		return reply;
	}
}

#else
DBusMessage * wid_dbus_interface_radio_set_txp(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	unsigned int RadioID;	
	unsigned short RadioTxp;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	int ret1 = COUNTRY_CODE_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_UINT16,&RadioTxp,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_RADIO[RadioID] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else
	{
	//append to country code ,decide txpower
		//if((gCOUNTRYCODE == COUNTRY_FRANCE_FR)||(gCOUNTRYCODE == COUNTRY_SPAIN_ES))
		if((AC_RADIO[RadioID]->Radio_country_code == COUNTRY_FRANCE_FR)||(AC_RADIO[RadioID]->Radio_country_code == COUNTRY_SPAIN_ES))/*wcl modify for OSDEVTDPB-31*/
		{
			if((RadioTxp > 14)&&(RadioTxp != 100))/*100 is auto*/
			{
				ret1 = COUNTRY_CODE_ERROR;
			}
		}

		if(ret1 != COUNTRY_CODE_SUCCESS)//txpower conflict
		{
			reply = dbus_message_new_method_return(msg);
			
			dbus_message_iter_init_append (reply, &iter);
			
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &ret);
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &ret1);
			return reply;
		}
	
		ret = WID_RADIO_SET_TXP(RadioID,RadioTxp,CW_FALSE);
		AC_RADIO[RadioID]->radio_countermeasures_flag = 0 ;	  //AP,fengwenchao add 20110325
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret1);
	return reply;	
}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_radio_set_txpof(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply = NULL;	
	DBusMessageIter	 iter;
	DBusError err;

	int i = 0;
	int num =0 ;
	int radionum = 0;

	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned short RadioTxpof = 0;
	unsigned short t_RadioTxpof = 0;

	int ret = WID_DBUS_SUCCESS;
	int ret1 = COUNTRY_CODE_SUCCESS;	
	int ret2 = WID_DBUS_SUCCESS;
	int ret3 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;
	//struct Radio_List *radio_country_fail = NULL;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT16,&t_RadioTxpof,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	printf("12121211111122\n");
	if(type==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			/*	else if((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11N) > 0)
				{
					ret = RADIO_MODE_IS_11N;
				}*/
				
			else if(AC_RADIO[ID]->isBinddingWlan == 0)
				{
					ret = RADIO_NO_BINDING_WLAN;
				}
			else
				{
					//printf("222222222222222222222222222222222\n");
					RadioTxpof = t_RadioTxpof* AC_RADIO[ID]->txpowerstep; 
					if(AC_RADIO[ID]->ishighpower == 1)
					{
						if(RadioTxpof>26)
							ret = TXPOWEROFF_LARGER_THAN_MAX;
					}
					else
					{
						if(RadioTxpof>19)
							ret = TXPOWEROFF_LARGER_THAN_MAX;
					}
					printf("t_RadioTxpof = %d \n",t_RadioTxpof);
					printf("AC_RADIO[ID]->txpowerstep = %d \n",AC_RADIO[ID]->txpowerstep);
					//append to country code ,decide txpower
					printf("RadioTxpof = %d \n",RadioTxpof);
				//	if((gCOUNTRYCODE == COUNTRY_FRANCE_FR)||(gCOUNTRYCODE == COUNTRY_SPAIN_ES))
				// huxf
					if((AC_RADIO[ID]->Radio_country_code == COUNTRY_FRANCE_FR)||(AC_RADIO[ID]->Radio_country_code == COUNTRY_SPAIN_ES))/*wcl modify for OSDEVTDPB-31*/
						{
							if(RadioTxpof > 14)
								{
									ret1 = COUNTRY_CODE_ERROR;
								}
						}

					if(ret1 != COUNTRY_CODE_SUCCESS)//txpower conflict
						{
							reply = dbus_message_new_method_return(msg);
			
							dbus_message_iter_init_append (reply, &iter);
			
							dbus_message_iter_append_basic (&iter,
											 				DBUS_TYPE_UINT32,
											 				&ret);
							dbus_message_iter_append_basic (&iter,
											 				DBUS_TYPE_UINT32,
															 &ret1);
							return reply;
						}
					//printf("33333333333333333333333333333333333\n");
					if(ret != TXPOWEROFF_LARGER_THAN_MAX)
						ret = WID_RADIO_SET_TXP(ID,t_RadioTxpof,CW_TRUE);
				printf("ret = %d\n",ret);
				printf("ret1 = %d\n",ret1);
				}
	
				reply = dbus_message_new_method_return(msg);
	
				dbus_message_iter_init_append (reply, &iter);
	
				dbus_message_iter_append_basic (&iter,
												DBUS_TYPE_UINT32,
									 			&ret);
				dbus_message_iter_append_basic (&iter,
												DBUS_TYPE_UINT32,
									 			&ret1);
				return reply;	
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					//radio_country_fail = (struct Radio_List *)malloc(radionum*(sizeof(struct Radio_List)));
					printf("@@@@@@@@@@@@@@@@@@@\n");
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
								printf("!!!!!!!!!!!!!!\n");
							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]==NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;	
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->isBinddingWlan==0)
											{
												ret2 = RADIO_NO_BINDING_WLAN;
												printf("#################\n");
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is not bind wlan\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else
											{
												RadioTxpof = t_RadioTxpof* AC_WTP[tmp->WTPID]->WTP_Radio[i]->txpowerstep; 
												
												if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->ishighpower == 1)
												{
													if(RadioTxpof>26)
														ret3 = TXPOWEROFF_LARGER_THAN_MAX;
												}
												else
												{
													if(RadioTxpof>19)
														ret3 = TXPOWEROFF_LARGER_THAN_MAX;
												}
												//append to country code ,decide txpower
												//if((gCOUNTRYCODE == COUNTRY_FRANCE_FR)||(gCOUNTRYCODE == COUNTRY_SPAIN_ES))
												if((AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_country_code == COUNTRY_FRANCE_FR)||(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_country_code == COUNTRY_SPAIN_ES))/*wcl modify for OSDEVTDPB-31*/
													{
														if(RadioTxpof > 14)
															{
																ret1 = COUNTRY_CODE_ERROR;
															}
														printf("QQQQQQQQQQQQQQQQQQQQQQ\n");
													}
										
												if(ret1 == COUNTRY_CODE_SUCCESS)
													{	
														if(ret3!=TXPOWEROFF_LARGER_THAN_MAX)
														{
															ret3 = WID_RADIO_SET_TXP(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,RadioTxpof,CW_TRUE);
															printf("WWWWWWWWWWWWWWWWWWWWWWWWWWWWW\n");
															wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d access into set txp\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
														}

													}
											}
										printf("111111111111\n");
										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
										else if((ret2 == WID_DBUS_SUCCESS)&&(ret1 == COUNTRY_CODE_SUCCESS)&&(ret3 != WID_DBUS_SUCCESS))
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret3;
												num++;
											}
										else if((ret2 == WID_DBUS_SUCCESS)&&(ret1 == COUNTRY_CODE_ERROR))
											{
											//huxf
												ret1 = RADIO_SET_TXPOF_COUNTRY_CODE_ERROR; //huxf
												radio_head[num].RadioId= AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason=ret1;
												num++;
												//country_error_num++;
											}
										printf("ret2 = %d\n",ret2);

									}

								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
	
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if(ret == WID_DBUS_SUCCESS)
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}

			}
			return reply;

		} else {
			return reply;
		}
	//return reply;
}

#else
DBusMessage * wid_dbus_interface_radio_set_txpof(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	unsigned int RadioID;	
	unsigned short RadioTxpof;
	unsigned short t_RadioTxpof;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	int ret1 = COUNTRY_CODE_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_UINT16,&t_RadioTxpof,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_RADIO[RadioID] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
/*	else if((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11N) > 0)
	{
		ret = RADIO_MODE_IS_11N;
	}*/
	else if(AC_RADIO[RadioID]->isBinddingWlan == 0)
	{
		ret = RADIO_NO_BINDING_WLAN;
	}
	else
	{
	RadioTxpof = t_RadioTxpof* AC_RADIO[RadioID]->txpowerstep; 
		if(AC_RADIO[RadioID]->ishighpower == 1)
		{
			if(RadioTxpof>26)
				ret = TXPOWEROFF_LARGER_THAN_MAX;
		}
		else
		{
			if(RadioTxpof>19)
				ret = TXPOWEROFF_LARGER_THAN_MAX;
		}
	//append to country code ,decide txpower
		//if((gCOUNTRYCODE == COUNTRY_FRANCE_FR)||(gCOUNTRYCODE == COUNTRY_SPAIN_ES))
		if((AC_RADIO[RadioID]->Radio_country_code == COUNTRY_FRANCE_FR)||(AC_RADIO[RadioID]->Radio_country_code == COUNTRY_SPAIN_ES))/*wcl modify for OSDEVTDPB-31*/
		{
			if(RadioTxpof > 14)
			{
				ret1 = COUNTRY_CODE_ERROR;
			}
		}

		if(ret1 != COUNTRY_CODE_SUCCESS)//txpower conflict
		{
			reply = dbus_message_new_method_return(msg);
			
			dbus_message_iter_init_append (reply, &iter);
			
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &ret);
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &ret1);
			return reply;
		}
		if(ret != TXPOWEROFF_LARGER_THAN_MAX)
			ret = WID_RADIO_SET_TXP(RadioID,t_RadioTxpof,CW_TRUE);	//xiaodawei modify, 20110519
				
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret1);
	return reply;	
}
#endif
#if _GROUP_POLICY
//zhaoruijia,20100917,add radio txpower step
DBusMessage * wid_dbus_interface_radio_set_txpower_step(DBusConnection *conn, DBusMessage *msg, void *user_data){
     DBusMessage * reply;	
	 DBusMessageIter	 iter;
	 DBusError err;
	 int i = 0;
	 int num =0 ;
	 int radionum = 0;
	 unsigned int ID = 0;
	 unsigned int type = 0;
	 unsigned short RadioTxpwstp = 0;
	 int ret = WID_DBUS_SUCCESS;
	 int ret2 = WID_DBUS_SUCCESS;
	 int ret_check = WID_DBUS_SUCCESS;
	
	 struct Radio_List  *radio_head = NULL;
	 struct WTP_GROUP_MEMBER *tmp = NULL;
	 struct WTP_GROUP_MEMBER *radiotmp = NULL;		
	 
     dbus_error_init(&err);
	 if (!(dbus_message_get_args ( msg, &err,
	 							DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT16,&RadioTxpwstp,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(type == 0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID]->isBinddingWlan == 0)
				{
					ret = RADIO_NO_BINDING_WLAN;
				}
			else
				{
        			AC_RADIO[ID]->txpowerstep = RadioTxpwstp;
				}	
		}
	
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]==NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;	
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->isBinddingWlan==0)
											{
												ret2 = RADIO_NO_BINDING_WLAN;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is not bind wlan\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else
											{
												AC_WTP[tmp->WTPID]->WTP_Radio[i]->txpowerstep=RadioTxpwstp;
												ret2 = WID_DBUS_SUCCESS;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d set txpowerstep successful\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);

											}
										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;
}

#else
//zhaoruijia,20100917,add radio txpower step
DBusMessage * wid_dbus_interface_radio_set_txpower_step(DBusConnection *conn, DBusMessage *msg, void *user_data){
     DBusMessage * reply;	
	 DBusMessageIter	 iter;
	 unsigned int RadioID;	
	 unsigned short RadioTxpwstp;
	 DBusError err;
	 int ret = WID_DBUS_SUCCESS;
     dbus_error_init(&err);
	 if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_UINT16,&RadioTxpwstp,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}


	
	if(AC_RADIO[RadioID] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_RADIO[RadioID]->isBinddingWlan == 0)
	{
		ret = RADIO_NO_BINDING_WLAN;
	}
	else
	{
        AC_RADIO[RadioID]->txpowerstep = RadioTxpwstp;
		if(AC_RADIO[RadioID]->Radio_TXP != 100)  //fengwenchao add 20111013
		{
		if(AC_RADIO[RadioID]->ishighpower == 1)
		{
			AC_RADIO[RadioID]->Radio_TXPOF = (27-AC_RADIO[RadioID]->Radio_TXP)/AC_RADIO[RadioID]->txpowerstep;
		}
		else
			AC_RADIO[RadioID]->Radio_TXPOF = (20-AC_RADIO[RadioID]->Radio_TXP)/AC_RADIO[RadioID]->txpowerstep;
		}
	}
   	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	
}

#endif

/*fengwenchao add 20120222 for RDIR-25*/
DBusMessage *wid_dbus_interface_radio_set_radio_wlan_limit_rssi_access_sta(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply = NULL;   
	DBusMessageIter 	iter;
	DBusError err;
	unsigned int wtpid = 0;
	unsigned int radioid = 0;
	unsigned char l_radioid = 0;
	unsigned char wlanid =0;
	unsigned char rssi = 0;
	int ret = WID_DBUS_SUCCESS;
	char command[WID_SYSTEM_CMD_LENTH] = {0};
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
							DBUS_TYPE_UINT32,&radioid,
							DBUS_TYPE_BYTE,&wlanid,
							DBUS_TYPE_BYTE,&rssi,
							DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
			
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	wtpid = radioid/L_RADIO_NUM;
	l_radioid = radioid%L_RADIO_NUM;
	if(AC_WTP[wtpid] == NULL)
		ret = WTP_ID_NOT_EXIST;
	else if(AC_RADIO[radioid] == NULL)
		ret = RADIO_ID_NOT_EXIST;
	else if(AC_WLAN[wlanid] == NULL)
		ret = WLAN_ID_NOT_EXIST;
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	if(ret == WID_DBUS_SUCCESS)
	{
		struct wlanid	*tmp = AC_RADIO[radioid]->Wlan_Id;
		while(tmp)
		{
			if(tmp->wlanid == wlanid)
				break;
			tmp = tmp->next;
		}
		if(tmp != NULL)
		{	
			if((AC_WLAN[wlanid])&&(AC_WLAN[wlanid]->S_WTP_BSS_List[wtpid][l_radioid] != 0))
			{

				//printf("ret = %d \n",ret);
				unsigned int bssindex = AC_WLAN[wlanid]->S_WTP_BSS_List[wtpid][l_radioid];
				if(check_bssid_func(bssindex))
				{
					if(AC_BSS[bssindex]->limit_sta_rssi != rssi)
					{
						sprintf(command,"iwpriv ath.%d-%d set_rssithre %d",l_radioid,wlanid,rssi);
						ret = wid_radio_set_extension_command(wtpid, command);
						AC_BSS[bssindex]->limit_sta_rssi = rssi;
					}
					if(AC_WLAN[wlanid]->Status == 1)
						ret = WLAN_BE_DISABLE;
				}
				else
					ret = BSS_NOT_EXIST;
			}
		}
		else
			ret = Wlan_IF_NOT_BE_BINDED;
	}
	 reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	//printf("ret = %d \n",ret);
	return reply;	
}
/*fengwenchao add end*/

#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_radio_set_chan(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply = NULL;	
	DBusMessageIter	 iter;
	DBusError err;
		
	unsigned char RadioChan = 0;
	unsigned int max_chanenl = 5;
	unsigned int min_channel = 7;
	int check_channel = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret1 = COUNTRY_CODE_SUCCESS;
	int ret2 = CHANNEL_CWMODE_SUCCESS;
	int ret3 = WID_DBUS_SUCCESS;
	int i = 0;
	int num =0 ;
	int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;		
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&RadioChan,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	check_channel = (int)RadioChan;

	if(type==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else 
				{
					switch(AC_RADIO[ID]->Radio_country_code)/*wcl modify for AUTELAN-2765*/
					{
						case COUNTRY_CHINA_CN : 
												if(check_channel >= 14)
													{
														ret1 = COUNTRY_CHINA_CN;
													}
												if (((AC_RADIO[ID]->Radio_Type&IEEE80211_11A)||(AC_RADIO[ID]->Radio_Type == 10))&&((check_channel == 149)||(check_channel == 153)||(check_channel == 157)||(check_channel == 161)||(check_channel == 165)) )
													{
														ret1 = COUNTRY_CODE_SUCCESS;
														max_chanenl = 159;
														min_channel = 7;
													}
												else
													{
														max_chanenl = 7;
														min_channel = 7;
													}

												break;
									
						case COUNTRY_EUROPE_EU : 
												if(check_channel >= 14)
													{
														ret1 = COUNTRY_EUROPE_EU;
													}
												if (((AC_RADIO[ID]->Radio_Type&IEEE80211_11A)||(AC_RADIO[ID]->Radio_Type == 10))&&((check_channel == 36)||(check_channel == 40)||(check_channel == 44)||(check_channel == 48)||(check_channel == 52)\
												||(check_channel == 56)||(check_channel == 58)||(check_channel == 60)||(check_channel == 100)||(check_channel == 104)||(check_channel == 108)||(check_channel == 112)||(check_channel == 116)\
												||(check_channel == 120)||(check_channel == 124)||(check_channel == 128)||(check_channel == 132)||(check_channel == 136)||(check_channel == 140))) 
													{
														ret1 = COUNTRY_CODE_SUCCESS;
														max_chanenl = 134;
														min_channel = 7;
													}
												else
													{
														max_chanenl = 7;
														min_channel = 7;
													}	
												break;
																	
						case COUNTRY_USA_US : 
											if((check_channel >= 12))
												{
													ret1 = COUNTRY_USA_US;
												}
											if (((AC_RADIO[ID]->Radio_Type&IEEE80211_11A)||(AC_RADIO[ID]->Radio_Type == 10))&&((check_channel == 36)||(check_channel == 40)||(check_channel == 44)||(check_channel == 48)||(check_channel == 52)\
												||(check_channel == 56)||(check_channel == 60)||(check_channel == 64)||(check_channel == 100)||(check_channel == 104)||(check_channel == 108)||(check_channel == 112)||(check_channel == 116)\
												||(check_channel == 120)||(check_channel == 124)||(check_channel == 128)||(check_channel == 132)||(check_channel == 136)||(check_channel == 140)||(check_channel == 149)||(check_channel == 153)||(check_channel == 157)||(check_channel == 161)||(check_channel == 165)) )/*wcl modify for AUTELAN-2765*/
												{
													ret1 = COUNTRY_CODE_SUCCESS;
													max_chanenl = 159;
													min_channel = 7;
												}
											else
												{
													max_chanenl = 5;
													min_channel = 7;
												}
											break;
																	
						case COUNTRY_JAPAN_JP : 
											if((check_channel >= 15))
												{
													ret1 = COUNTRY_JAPAN_JP;
												}
											if (((AC_RADIO[ID]->Radio_Type&IEEE80211_11A)||(AC_RADIO[ID]->Radio_Type == 10))&&((check_channel == 36)||(check_channel == 40)||(check_channel == 44)||(check_channel == 48)||(check_channel == 52)\
												||(check_channel == 56)||(check_channel == 60)||(check_channel == 64)||(check_channel == 100)||(check_channel == 104)||(check_channel == 108)||(check_channel == 112)||(check_channel == 116)\
												||(check_channel == 120)||(check_channel == 124)||(check_channel == 128)||(check_channel == 132)||(check_channel == 136)||(check_channel == 140)||(check_channel == 184)||(check_channel == 188)||(check_channel == 192)||(check_channel == 196)) )/*wcl modify for AUTELAN-2765*/
												{
													ret1 = COUNTRY_CODE_SUCCESS;
													max_chanenl = 40;
													min_channel = 7;
												}
											else
												{
													max_chanenl = 8;
													min_channel = 7;
												}										
											break;
																	
						case COUNTRY_FRANCE_FR : 
											if((check_channel != 0)&&(check_channel != 10)&&(check_channel != 11)&&(check_channel != 12)&&(check_channel != 13))
												{
													ret1 = COUNTRY_FRANCE_FR;
												}
											if (((AC_RADIO[ID]->Radio_Type&IEEE80211_11A)||(AC_RADIO[ID]->Radio_Type == 10))&&((check_channel == 36)||(check_channel == 40)||(check_channel == 44)||(check_channel == 48)||(check_channel == 52)\
												||(check_channel == 56)||(check_channel == 60)||(check_channel == 64)||(check_channel == 100)||(check_channel == 104)||(check_channel == 108)||(check_channel == 112)||(check_channel == 116)\
												||(check_channel == 120)||(check_channel == 124)||(check_channel == 128)||(check_channel == 132)||(check_channel == 136)||(check_channel == 140))) /*wcl modify for AUTELAN-2765*/
												{
												ret1 = COUNTRY_CODE_SUCCESS;
												max_chanenl = 134;
												min_channel = 7;
												}
											else
												{
													max_chanenl = 7;
													min_channel = 7;
												}	
											break;
																	
						case COUNTRY_SPAIN_ES : 
											if((check_channel != 0)&&(check_channel != 10)&&(check_channel != 11))
												{
													ret1 = COUNTRY_SPAIN_ES;
												}
											if (((AC_RADIO[ID]->Radio_Type&IEEE80211_11A)||(AC_RADIO[ID]->Radio_Type == 10))&&((check_channel == 36)||(check_channel == 40)||(check_channel == 44)||(check_channel == 48)||(check_channel == 52)\
												||(check_channel == 56)||(check_channel == 60)||(check_channel == 64)||(check_channel == 100)||(check_channel == 104)||(check_channel == 108)||(check_channel == 112)||(check_channel == 116)\
												||(check_channel == 120)||(check_channel == 124)||(check_channel == 128)||(check_channel == 132)||(check_channel == 136)||(check_channel == 140))) /*wcl modify for AUTELAN-2765*/
												{
													ret1 = COUNTRY_CODE_SUCCESS;
													max_chanenl = 134;
													min_channel = 7;
												}
											else
												{
													max_chanenl = 5;
													min_channel = 7;
												}	
											break;

						default : ret1 = COUNTRY_CODE_SUCCESS;break;
				}
		/*11n channel offset check*/
			if(AC_RADIO[ID]->Radio_Type&IEEE80211_11N)
				{
					ret2 = WID_RADIO_CHANNEL_OFFSET_CWMODE_CHECK(ID,check_channel,max_chanenl,min_channel);
				}

			if(ret2 == CHANNEL_CWMODE_SUCCESS)
				{
					if (ret1 == COUNTRY_CODE_SUCCESS)
						{
							ret = WID_RADIO_SET_CHAN(ID,RadioChan);
						}	
				}
			}
	
		reply = dbus_message_new_method_return(msg);
	
		dbus_message_iter_init_append (reply, &iter);
	
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret1);
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret2);
		if(ret2 != CHANNEL_CWMODE_SUCCESS)
			{
				dbus_message_iter_append_basic (&iter,
										 		DBUS_TYPE_UINT16,
												 &AC_RADIO[ID]->cwmode);
				dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_BYTE,
												 &AC_RADIO[ID]->channel_offset);

			}	
		return reply;
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]==NULL)
											{
												ret3 = RADIO_ID_NOT_EXIST;	
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
											else 
												{
													switch(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_country_code)/*wcl modify for AUTELAN-2765*/
													{
														case COUNTRY_CHINA_CN : 
																				if(check_channel >= 14)
																					{
																						ret1 = COUNTRY_CHINA_CN;
																					}
																				if (((AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_Type&IEEE80211_11A)||(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_Type == 10))&&((check_channel == 149)||(check_channel == 153)||(check_channel == 157)||(check_channel == 161)||(check_channel == 165)) )
																					{
																						ret1 = COUNTRY_CODE_SUCCESS;
																						max_chanenl = 159;
																						min_channel = 7;
																					}
																				else
																					{
																						max_chanenl = 7;
																						min_channel = 7;
																					}
										
																				break;
																	
														case COUNTRY_EUROPE_EU : 
																				if(check_channel >= 14)
																					{
																						ret1 = COUNTRY_EUROPE_EU;
																					}
																				if (((AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_Type&IEEE80211_11A)||(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_Type == 10))&&((check_channel == 36)||(check_channel == 40)||(check_channel == 44)||(check_channel == 48)||(check_channel == 52)\
																				||(check_channel == 56)||(check_channel == 60)||(check_channel == 64)||(check_channel == 100)||(check_channel == 104)||(check_channel == 108)||(check_channel == 112)||(check_channel == 116)\
																				||(check_channel == 120)||(check_channel == 124)||(check_channel == 128)||(check_channel == 132)||(check_channel == 136)||(check_channel == 140))) /*wcl modify for AUTELAN-2765*/
																					{
																						ret1 = COUNTRY_CODE_SUCCESS;
																						max_chanenl = 134;
																						min_channel = 7;
																					}
																				else
																					{
																						max_chanenl = 7;
																						min_channel = 7;
																					}	
																				break;
																									
														case COUNTRY_USA_US : 
																			if((check_channel >= 12))
																				{
																					ret1 = COUNTRY_USA_US;
																				}
																			if (((AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_Type&IEEE80211_11A)||(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_Type == 10))&&((check_channel == 36)||(check_channel == 40)||(check_channel == 44)||(check_channel == 48)||(check_channel == 52)\
												||(check_channel == 56)||(check_channel == 60)||(check_channel == 64)||(check_channel == 100)||(check_channel == 104)||(check_channel == 108)||(check_channel == 112)||(check_channel == 116)\
												||(check_channel == 120)||(check_channel == 124)||(check_channel == 128)||(check_channel == 132)||(check_channel == 136)||(check_channel == 140)||(check_channel == 149)||(check_channel == 153)||(check_channel == 157)||(check_channel == 161)||(check_channel == 165)) )/*wcl modify for AUTELAN-2765*/
																				{
																					ret1 = COUNTRY_CODE_SUCCESS;
																					max_chanenl = 159;
																					min_channel = 7;
																				}
																			else
																				{
																					max_chanenl = 5;
																					min_channel = 7;
																				}
																			break;
																									
														case COUNTRY_JAPAN_JP : 
																			if((check_channel >= 15))
																				{
																					ret1 = COUNTRY_JAPAN_JP;
																				}
																			if (((AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_Type&IEEE80211_11A)||(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_Type == 10))&&((check_channel == 36)||(check_channel == 40)||(check_channel == 44)||(check_channel == 48)||(check_channel == 52)\
												||(check_channel == 56)||(check_channel == 60)||(check_channel == 64)||(check_channel == 100)||(check_channel == 104)||(check_channel == 108)||(check_channel == 112)||(check_channel == 116)\
												||(check_channel == 120)||(check_channel == 124)||(check_channel == 128)||(check_channel == 132)||(check_channel == 136)||(check_channel == 140)||(check_channel == 184)||(check_channel == 188)||(check_channel == 192)||(check_channel == 196)) )/*wcl modify for AUTELAN-2765*/
																				{
																					ret1 = COUNTRY_CODE_SUCCESS;
																					max_chanenl = 40;
																					min_channel = 7;
																				}
																			else
																				{
																					max_chanenl = 8;
																					min_channel = 7;
																				}										
																			break;
																									
														case COUNTRY_FRANCE_FR : 
																			if((check_channel != 0)&&(check_channel != 10)&&(check_channel != 11)&&(check_channel != 12)&&(check_channel != 13))
																				{
																					ret1 = COUNTRY_FRANCE_FR;
																				}
																			if (((AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_Type&IEEE80211_11A)||(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_Type == 10))&&((check_channel == 36)||(check_channel == 40)||(check_channel == 44)||(check_channel == 48)||(check_channel == 52)\
																			||(check_channel == 56)||(check_channel == 60)||(check_channel == 64)||(check_channel == 100)||(check_channel == 104)||(check_channel == 108)||(check_channel == 112)||(check_channel == 116)\
																			||(check_channel == 120)||(check_channel == 124)||(check_channel == 128)||(check_channel == 132)||(check_channel == 136)||(check_channel == 140))) /*wcl modify for AUTELAN-2765*/
																				{
																				ret1 = COUNTRY_CODE_SUCCESS;
																				max_chanenl = 134;
																				min_channel = 7;
																				}
																			else
																				{
																					max_chanenl = 7;
																					min_channel = 7;
																				}	
																			break;
																									
														case COUNTRY_SPAIN_ES : 
																			if((check_channel != 0)&&(check_channel != 10)&&(check_channel != 11))
																				{
																					ret1 = COUNTRY_SPAIN_ES;
																				}
																			if (((AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_Type&IEEE80211_11A)||(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_Type == 10))&&((check_channel == 36)||(check_channel == 40)||(check_channel == 44)||(check_channel == 48)||(check_channel == 52)\
																				||(check_channel == 56)||(check_channel == 60)||(check_channel == 64)||(check_channel == 100)||(check_channel == 104)||(check_channel == 108)||(check_channel == 112)||(check_channel == 116)\
																				||(check_channel == 120)||(check_channel == 124)||(check_channel == 128)||(check_channel == 132)||(check_channel == 136)||(check_channel == 140))) /*wcl modify for AUTELAN-2765*/
																				{
																					ret1 = COUNTRY_CODE_SUCCESS;
																					max_chanenl = 134;
																					min_channel = 7;
																				}
																			else
																				{
																					max_chanenl = 5;
																					min_channel = 7;
																				}	
																			break;
										
														default : ret1 = COUNTRY_CODE_SUCCESS;break;
												}
										/*11n channel offset check*/
											if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_Type&IEEE80211_11N)
												{
													ret2 = WID_RADIO_CHANNEL_OFFSET_CWMODE_CHECK(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,check_channel,max_chanenl,min_channel);
												}
										
											if(ret2 == CHANNEL_CWMODE_SUCCESS)
												{
													if (ret1 == COUNTRY_CODE_SUCCESS)
														{
															ret3 = WID_RADIO_SET_CHAN(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,RadioChan);
															wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d access into set channel\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
														}
													else
														{
															ret1 = CHECK_COUNTRY_CODE_FAIL; // huxf
														}
												}
											else
												{
													ret2 =	CHECK_CHANNEL_CWMODE_FAIL;  // huxf
												}
											}
										/*if(ret2 != CHANNEL_CWMODE_SUCCESS)
											{
												dbus_message_iter_append_basic (&iter,
																				DBUS_TYPE_UINT16,
																				 &AC_WTP[tmp->WTPID]->WTP_Radio[i]->cwmode);
												dbus_message_iter_append_basic (&iter,
																				 DBUS_TYPE_BYTE,
																				 &AC_WTP[tmp->WTPID]->WTP_Radio[i]->channel_offset);
										
											}	*/
										if(ret3 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret3;
												num++;
											}
										else if(ret1 != COUNTRY_CODE_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret1;
												num++;
											}
										else if(ret2 != CHANNEL_CWMODE_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;												
											}
										printf("ret1 = %d,ret2 = %d,ret3 =%d\n",ret1,ret2,ret3);
										
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
		
		return reply;	
	} else {
		return reply;
	}
}

#else
DBusMessage * wid_dbus_interface_radio_set_chan(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	unsigned int RadioID;	
	unsigned char RadioChan;
	unsigned int max_chanenl = 5;
	unsigned int min_channel = 7;
	int check_channel = 0;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	int ret1 = COUNTRY_CODE_SUCCESS;
	int ret2 = CHANNEL_CWMODE_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_BYTE,&RadioChan,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	check_channel = (int)RadioChan;
	if(AC_RADIO[RadioID] == NULL){
		ret = RADIO_ID_NOT_EXIST;
	}
	else 
	{
		switch(AC_RADIO[RadioID]->Radio_country_code)/*wcl modify for AUTELAN-2765*/
		{
			case COUNTRY_CHINA_CN : 
									if(check_channel >= 14)
									{
										ret1 = COUNTRY_CHINA_CN;
									}
									if (((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11A)||(AC_RADIO[RadioID]->Radio_Type == 10))&&((check_channel == 149)||(check_channel == 153)||(check_channel == 157)||(check_channel == 161)||(check_channel == 165)) )
									{
										ret1 = COUNTRY_CODE_SUCCESS;
										max_chanenl = 159;
										min_channel = 7;
									}else{
										max_chanenl = 9;
										min_channel = 5;
									}

									break;
									
			case COUNTRY_EUROPE_EU : 
									if(check_channel >= 14)
									{
										ret1 = COUNTRY_EUROPE_EU;
									}
									if (((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11A)||(AC_RADIO[RadioID]->Radio_Type == 10))&&((check_channel == 36)||(check_channel == 40)||(check_channel == 44)||(check_channel == 48)||(check_channel == 52)\
										||(check_channel == 56)||(check_channel == 60)||(check_channel == 64)||(check_channel == 100)||(check_channel == 104)||(check_channel == 108)||(check_channel == 112)||(check_channel == 116)\
										||(check_channel == 120)||(check_channel == 124)||(check_channel == 128)||(check_channel == 132)||(check_channel == 136)||(check_channel == 140))) /*wcl modify for AUTELAN-2765*/
									{
										ret1 = COUNTRY_CODE_SUCCESS;
										max_chanenl = 134;
										min_channel = 7;
									}else{
										max_chanenl = 9;
										min_channel = 5;
									}	
									break;
																	
			case COUNTRY_USA_US : 
									if((check_channel >= 12))
									{
										ret1 = COUNTRY_USA_US;
									}
									if (((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11A)||(AC_RADIO[RadioID]->Radio_Type == 10))&&((check_channel == 36)||(check_channel == 40)||(check_channel == 44)||(check_channel == 48)||(check_channel == 52)\
												||(check_channel == 56)||(check_channel == 60)||(check_channel == 64)||(check_channel == 100)||(check_channel == 104)||(check_channel == 108)||(check_channel == 112)||(check_channel == 116)\
												||(check_channel == 120)||(check_channel == 124)||(check_channel == 128)||(check_channel == 132)||(check_channel == 136)||(check_channel == 140)||(check_channel == 149)||(check_channel == 153)||(check_channel == 157)||(check_channel == 161)||(check_channel == 165)) )/*wcl modify for AUTELAN-2765*/
									{
										ret1 = COUNTRY_CODE_SUCCESS;
										max_chanenl = 159;
										min_channel = 7;
									}else{
										max_chanenl = 7;
										min_channel = 5;
									}
									break;
																	
			case COUNTRY_JAPAN_JP : 
									if((check_channel >= 15))
									{
										ret1 = COUNTRY_JAPAN_JP;
									}
									if (((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11A)||(AC_RADIO[RadioID]->Radio_Type == 10))&&((check_channel == 36)||(check_channel == 40)||(check_channel == 44)||(check_channel == 48)||(check_channel == 52)\
												||(check_channel == 56)||(check_channel == 60)||(check_channel == 64)||(check_channel == 100)||(check_channel == 104)||(check_channel == 108)||(check_channel == 112)||(check_channel == 116)\
												||(check_channel == 120)||(check_channel == 124)||(check_channel == 128)||(check_channel == 132)||(check_channel == 136)||(check_channel == 140)||(check_channel == 184)||(check_channel == 188)||(check_channel == 192)||(check_channel == 196)) )/*wcl modify for AUTELAN-2765*/
									{
										ret1 = COUNTRY_CODE_SUCCESS;
										max_chanenl = 40;
										min_channel = 7;
									}else{
										max_chanenl = 10;
										min_channel = 5;
									}										
									break;
																	
			case COUNTRY_FRANCE_FR : 
									if((check_channel != 0)&&(check_channel != 10)&&(check_channel != 11)&&(check_channel != 12)&&(check_channel != 13))
									{
										ret1 = COUNTRY_FRANCE_FR;
									}
									if (((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11A)||(AC_RADIO[RadioID]->Radio_Type == 10))&&((check_channel == 36)||(check_channel == 40)||(check_channel == 44)||(check_channel == 48)||(check_channel == 52)\
										||(check_channel == 56)||(check_channel == 60)||(check_channel == 64)||(check_channel == 100)||(check_channel == 104)||(check_channel == 108)||(check_channel == 112)||(check_channel == 116)\
										||(check_channel == 120)||(check_channel == 124)||(check_channel == 128)||(check_channel == 132)||(check_channel == 136)||(check_channel == 140))) /*wcl modify for AUTELAN-2765*/
									{
										ret1 = COUNTRY_CODE_SUCCESS;
										max_chanenl = 134;
										min_channel = 7;
									}else{
										max_chanenl = 7;
										min_channel = 7;
									}	
									break;
																	
			case COUNTRY_SPAIN_ES : 
									if((check_channel != 0)&&(check_channel != 10)&&(check_channel != 11))
									{
										ret1 = COUNTRY_SPAIN_ES;
									}
									if (((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11A)||(AC_RADIO[RadioID]->Radio_Type == 10))&&((check_channel == 36)||(check_channel == 40)||(check_channel == 44)||(check_channel == 48)||(check_channel == 52)\
										||(check_channel == 56)||(check_channel == 60)||(check_channel == 64)||(check_channel == 100)||(check_channel == 104)||(check_channel == 108)||(check_channel == 112)||(check_channel == 116)\
										||(check_channel == 120)||(check_channel == 124)||(check_channel == 128)||(check_channel == 132)||(check_channel == 136)||(check_channel == 140))) /*wcl modify for AUTELAN-2765*/
									{
										ret1 = COUNTRY_CODE_SUCCESS;
										max_chanenl = 134;
										min_channel = 7;
									}else{
										max_chanenl = 5;
										min_channel = 7;
									}	
									break;

			default : ret1 = COUNTRY_CODE_SUCCESS;break;
		}
		/*11n channel offset check*/
		if(AC_RADIO[RadioID]->Radio_Type&IEEE80211_11N){
			ret2 = WID_RADIO_CHANNEL_OFFSET_CWMODE_CHECK(RadioID,check_channel,max_chanenl,min_channel);
		}

		if(ret2 == CHANNEL_CWMODE_SUCCESS){
			if (ret1 == COUNTRY_CODE_SUCCESS)
			{
				ret = WID_RADIO_SET_CHAN(RadioID,RadioChan);
			}	
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret1);
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret2);
	if(ret2 != CHANNEL_CWMODE_SUCCESS){
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT16,
										 &AC_RADIO[RadioID]->cwmode);
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &AC_RADIO[RadioID]->channel_offset);

	}
	return reply;	
}
#endif

#if _GROUP_POLICY

DBusMessage * wid_dbus_interface_radio_apply_wlan(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;
//	DBusMessageIter	 iter_array;

	//unsigned char wlan_count;
	int i = 0;
	int num =0 ;
	int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned char WlanID = 0;

	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;
	//int i=0;

	/*
	if (NULL == msg) {
		printf("failed get msg.\n");
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
	}*/
	////////////////
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&WlanID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
//	printf("receive radioid %d wlanid %d\n",RadioID,WlanID);		
	if(type==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_WLAN[WlanID] == NULL)
				{
					ret = WLAN_ID_NOT_EXIST;
				}
			else
				{
					ret = WID_ADD_WLAN_APPLY_RADIO(ID,WlanID);
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]==NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;	
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WLAN[WlanID] == NULL)
											{
												ret2 = WLAN_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WLAN %d is NOT exist\n",WlanID);
											}	
										else
											{
												ret2 = WID_ADD_WLAN_APPLY_RADIO(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,WlanID);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d RADIO%d access into add wlan apply radio\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}	

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;	

}

#else
DBusMessage * wid_dbus_interface_radio_apply_wlan(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;
//	DBusMessageIter	 iter_array;
	unsigned int RadioID;
	//unsigned char wlan_count;
	unsigned char WlanID;	
	//int i=0;
	int ret = WID_DBUS_SUCCESS;
	/*
	if (NULL == msg) {
		printf("failed get msg.\n");
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
	}*/
	////////////////
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_BYTE,&WlanID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
//	printf("receive radioid %d wlanid %d\n",RadioID,WlanID);		
	if(AC_RADIO[RadioID] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[WlanID] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[WlanID]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		 ret = WID_WANT_TO_DELETE_WLAN;
	}
	else
	{
		if (ret == 0)
		{
			ret = WID_ADD_WLAN_APPLY_RADIO(RadioID,WlanID);
		}
		if (ret == 0)
		{
			if (((AC_RADIO[RadioID]->Radio_Type & IEEE80211_11A) || (AC_RADIO[RadioID]->Radio_Type &IEEE80211_11AN)) 
			&& (AC_RADIO[RadioID]->MixedGreenfield.Mixed_Greenfield == 1)
			&& (AC_WLAN[WlanID]->SecurityType == 3)  /* WPA_P */
			&& (AC_WLAN[WlanID]->EncryptionType == 3) /* TKIP */)
			{
				ret = WID_RADIO_SET_MODE(RadioID, 26);
				wid_syslog_debug_debug(WID_DEFAULT, "__ %s %d AC_RADIO[RadioID]->Radio_Type : %d  __", __func__, __LINE__, AC_RADIO[RadioID]->Radio_Type );
			}
		}
	}
	wid_syslog_debug_debug(WID_DEFAULT, "__ %s %d radio [ %d ] 's type: %d __", __func__, __LINE__, RadioID, AC_RADIO[RadioID]->Radio_Type);
	///////////////
	/*
	dbus_message_iter_init(msg, &iter);	
	dbus_message_iter_get_basic(&iter,&RadioID);
	if(AC_RADIO[RadioID] == NULL){
		ret = RADIO_ID_NOT_EXIST;
	}else{
		dbus_message_iter_next(&iter);
		dbus_message_iter_get_basic(&iter,&wlan_count);
		dbus_message_iter_recurse(&iter,&iter_array);
		for (i = 0; i < wlan_count; i++){
			unsigned char WlanID;		
			dbus_message_iter_get_basic(&iter_array,&WlanID);
			dbus_message_iter_next(&iter_array);
			ret = WID_ADD_WLAN_APPLY_RADIO(RadioID,WlanID);		
		}
	}
	*/
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
	

}
#endif
DBusMessage * wid_dbus_interface_radio_apply_wlan_base_essid(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;
//	DBusMessageIter	 iter_array;
	unsigned int RadioID;
	//unsigned char wlan_count;
	unsigned char WlanID;
	char *ESSID;
	
	//int i=0;
	int ret = WID_DBUS_SUCCESS;
	/*
	if (NULL == msg) {
		printf("failed get msg.\n");
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
	}*/
	////////////////
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_BYTE,&WlanID,
								DBUS_TYPE_STRING,&ESSID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	wid_syslog_debug_debug(WID_DEFAULT,"#########ESSID = %s\n",ESSID);
//	printf("receive radioid %d wlanid %d\n",RadioID,WlanID);		
	if(AC_RADIO[RadioID] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[WlanID] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[WlanID]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		 ret = WID_WANT_TO_DELETE_WLAN;
	}
	else
	{
		if (ret == 0)
		{
			ret = WID_ADD_WLAN_APPLY_RADIO_BASE_ESSID(RadioID,WlanID,ESSID);
			#if 0
			AsdWsm_WLANOp_essid(RadioID,WlanID,WID_MODIFY,0);
			#endif
		}
		if (ret == 0)
		{
			if (((AC_RADIO[RadioID]->Radio_Type & IEEE80211_11A) || (AC_RADIO[RadioID]->Radio_Type &IEEE80211_11AN)) 
			&& (AC_RADIO[RadioID]->MixedGreenfield.Mixed_Greenfield == 1)
			&& (AC_WLAN[WlanID]->SecurityType == 3)  /* WPA_P */
			&& (AC_WLAN[WlanID]->EncryptionType == 3) /* TKIP */)
			{
				ret = WID_RADIO_SET_MODE(RadioID, 26);
				wid_syslog_debug_debug(WID_DEFAULT, "__ %s %d AC_RADIO[RadioID]->Radio_Type : %d  __", __func__, __LINE__, AC_RADIO[RadioID]->Radio_Type );
			}
		}
	}
	wid_syslog_debug_debug(WID_DEFAULT, "__ %s %d radio [ %d ] 's type: %d __", __func__, __LINE__, RadioID, AC_RADIO[RadioID]->Radio_Type);
	///////////////
	/*
	dbus_message_iter_init(msg, &iter);	
	dbus_message_iter_get_basic(&iter,&RadioID);
	if(AC_RADIO[RadioID] == NULL){
		ret = RADIO_ID_NOT_EXIST;
	}else{
		dbus_message_iter_next(&iter);
		dbus_message_iter_get_basic(&iter,&wlan_count);
		dbus_message_iter_recurse(&iter,&iter_array);
		for (i = 0; i < wlan_count; i++){
			unsigned char WlanID;		
			dbus_message_iter_get_basic(&iter_array,&WlanID);
			dbus_message_iter_next(&iter_array);
			ret = WID_ADD_WLAN_APPLY_RADIO(RadioID,WlanID);		
		}
	}
	*/
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
	

}

#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_radio_apply_wlanid_base_vlanid(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;

	int i = 0;
	int num =0 ;
	int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned char WlanID = 0;
	unsigned int vlanid = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,	
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&WlanID,
								DBUS_TYPE_UINT32,&vlanid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_WLAN[WlanID] == NULL)
				{
					ret = WLAN_ID_NOT_EXIST;
				}
		
			int k1 = 0;
		
			if(AC_RADIO[ID] != NULL)
				{
					for(k1=0;k1<L_BSS_NUM;k1++)
					{
						if(AC_RADIO[ID]->BSS[k1] != NULL)
							{
								if(AC_RADIO[ID]->BSS[k1]->WlanID == WlanID)
									{
										if(AC_RADIO[ID]->BSS[k1]->State == 1)
											{
												ret = BSS_BE_ENABLE;
												break;
											}
									}
							}
					}
				}
		
			if(ret == WID_DBUS_SUCCESS)
				{
					ret = WID_ADD_WLAN_APPLY_RADIO_BASE_VLANID(ID,WlanID,vlanid);
				}
		}
	else if(type == 1)
		{
			int k1 = 0;
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]==NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;	
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WLAN[WlanID] == NULL)
											{
												ret2 = WLAN_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WLAN %d is NOT exist\n",WlanID);
											}	
										if(AC_WTP[tmp->WTPID]->WTP_Radio[i] != NULL)
											{
												for(k1=0;k1<L_BSS_NUM;k1++)
												{
													if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->BSS[k1] != NULL)
														{
															if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->BSS[k1]->WlanID == WlanID)
																{
																	if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->BSS[k1]->State == 1)
																		{
																			ret2 = BSS_BE_ENABLE;
																			wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d bss is enable\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
																			break;
																		}
																}
														}
												}
											}
										if(ret2 == WID_DBUS_SUCCESS)
											{
												ret2 = WID_ADD_WLAN_APPLY_RADIO_BASE_VLANID(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,WlanID,vlanid);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d access into apply wlan base vlan\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}	

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;

}

#else
DBusMessage * wid_dbus_interface_radio_apply_wlanid_base_vlanid(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
//	DBusMessageIter  iter_array;
	unsigned int RadioID;
	unsigned int vlanid;
	unsigned char WlanID;	
	//int i=0;
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_BYTE,&WlanID,
								DBUS_TYPE_UINT32,&vlanid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
//	printf("receive radioid %d wlanid %d vlanid %d\n",RadioID,WlanID,vlanid);		
	if(AC_RADIO[RadioID] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[WlanID] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[WlanID]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	
	int k1 = 0;
	
	if(AC_RADIO[RadioID] != NULL)
	{
		for(k1=0;k1<L_BSS_NUM;k1++)
		{
			if(AC_RADIO[RadioID]->BSS[k1] != NULL)
			{
				if(AC_RADIO[RadioID]->BSS[k1]->WlanID == WlanID
					&& (AC_WLAN[WlanID] != NULL && AC_WLAN[WlanID]->want_to_delete != 1))		/* Huangleilei add for ASXXZFI-1622 */
				{
					if(AC_RADIO[RadioID]->BSS[k1]->State == 1)
					{
						ret = BSS_BE_ENABLE;
						break;
					}
				}
			}
		}
	}
	
	
	if(ret == WID_DBUS_SUCCESS)
	{
		ret = WID_ADD_WLAN_APPLY_RADIO_BASE_VLANID(RadioID,WlanID,vlanid);
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
	

}
#endif

DBusMessage * wid_dbus_interface_radio_cpe_channel_apply_wlanid_base_vlanid(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
//	DBusMessageIter  iter_array;
	unsigned int RadioID;
	unsigned int vlanid;
	unsigned char WlanID;	
	//int i=0;
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_BYTE,&WlanID,
								DBUS_TYPE_UINT32,&vlanid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
//	printf("receive radioid %d wlanid %d vlanid %d\n",RadioID,WlanID,vlanid);		
	if(AC_RADIO[RadioID] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[WlanID] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[WlanID]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	
	
	if(ret == WID_DBUS_SUCCESS)
	{
		ret = WID_ADD_WLAN_CPE_CHANNEL_APPLY_RADIO_BASE_VLANID(RadioID,WlanID,vlanid);
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
	

}

DBusMessage * wid_dbus_interface_radio_cpe_channel_apply_wlanid_clean_vlanid(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
//	DBusMessageIter  iter_array;
	unsigned int RadioID = 0;
	unsigned char WlanID = 0;	
	unsigned int vlan_id = 0;
	//int i=0;
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_BYTE,&WlanID,
								DBUS_TYPE_UINT32,&vlan_id,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
//	printf("receive radioid %d wlanid %d\n",RadioID,WlanID);		
	if(AC_RADIO[RadioID] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[WlanID] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[WlanID]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	
	
	if(ret == WID_DBUS_SUCCESS)
	{
		ret = WID_ADD_WLAN_CPE_CHANNEL_APPLY_RADIO_CLEAN_VLANID(RadioID,WlanID,vlan_id);
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
	

}

#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_radio_apply_wlanid_clean_vlanid(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;

	int i = 0;
	int num =0 ;
	int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned char WlanID = 0;		
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&WlanID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_WLAN[WlanID] == NULL)
				{
					ret = WLAN_ID_NOT_EXIST;
				}
	
			int k1 = 0;
	
			if(AC_RADIO[ID] != NULL)
				{
					for(k1=0;k1<L_BSS_NUM;k1++)
					{
						if(AC_RADIO[ID]->BSS[k1] != NULL)
							{
								if(AC_RADIO[ID]->BSS[k1]->WlanID == WlanID)
									{
										if(AC_RADIO[ID]->BSS[k1]->State == 1)
											{
												ret = BSS_BE_ENABLE;
												break;
											}
									}
							}
					}
				}
			if(ret == WID_DBUS_SUCCESS)
				{
					ret = WID_ADD_WLAN_APPLY_RADIO_CLEAN_VLANID(ID,WlanID);
				}			
		}
	
	else if(type == 1)
		{
			int k1 = 0;
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]==NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;	
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WLAN[WlanID] == NULL)
											{
												ret2 = WLAN_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WLAN %d is NOT exist\n",WlanID);
											}	
										if(AC_WTP[tmp->WTPID]->WTP_Radio[i] != NULL)
											{
												for(k1=0;k1<L_BSS_NUM;k1++)
												{
													if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->BSS[k1] != NULL)
														{
															if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->BSS[k1]->WlanID == WlanID)
																{
																	if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->BSS[k1]->State == 1)
																		{
																			ret2 = BSS_BE_ENABLE;
																			break;
																		}
																}
														}
												}
											}
										if(ret2 == WID_DBUS_SUCCESS)
											{
												ret2 = WID_ADD_WLAN_APPLY_RADIO_CLEAN_VLANID(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,WlanID);
											}	

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;
}

#else
DBusMessage * wid_dbus_interface_radio_apply_wlanid_clean_vlanid(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
//	DBusMessageIter  iter_array;
	unsigned int RadioID = 0;
	unsigned char WlanID = 0;	
	//int i=0;
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_BYTE,&WlanID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
//	printf("receive radioid %d wlanid %d\n",RadioID,WlanID);		
	if(AC_RADIO[RadioID] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[WlanID] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[WlanID]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	
	int k1 = 0;
	
	if(AC_RADIO[RadioID] != NULL)
	{
		for(k1=0;k1<L_BSS_NUM;k1++)
		{
			if(AC_RADIO[RadioID]->BSS[k1] != NULL)
			{
				if(AC_RADIO[RadioID]->BSS[k1]->WlanID == WlanID
					&& ((AC_WLAN[WlanID] != NULL) && (AC_WLAN[WlanID]->want_to_delete != 1)))		/* Huangleilei add for ASXXZFI-1622 */
				{
					if(AC_RADIO[RadioID]->BSS[k1]->State == 1)
					{
						ret = BSS_BE_ENABLE;
						break;
					}
				}
			}
		}
	}
	
	
	if(ret == WID_DBUS_SUCCESS)
	{
		ret = WID_ADD_WLAN_APPLY_RADIO_CLEAN_VLANID(RadioID,WlanID);
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
	

}
#endif

//mahz add 2011.5.30
DBusMessage * wid_dbus_interface_radio_apply_wlanid_base_nas_port_id(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	unsigned int RadioID;
	unsigned char WlanID;	
	char* nas_port_id = NULL;
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_BYTE,&WlanID,
								DBUS_TYPE_STRING,&nas_port_id,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(AC_RADIO[RadioID] == NULL){
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[WlanID] == NULL){
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[WlanID]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	
	int k1 = 0;
	
	if(AC_RADIO[RadioID] != NULL)
	{
		for(k1=0;k1<L_BSS_NUM;k1++)
		{
			if(AC_RADIO[RadioID]->BSS[k1] != NULL)
			{
				if(AC_RADIO[RadioID]->BSS[k1]->WlanID == WlanID
					&& (AC_WLAN[WlanID] != NULL && (AC_WLAN[WlanID]->want_to_delete != 1)))		/* Huangleilei add for ASXXZFI-1622 */
				{
					if(AC_RADIO[RadioID]->BSS[k1]->State == 1)
					{
						ret = BSS_BE_ENABLE;
						break;
					}
				}
			}
		}
	}
	
	if(ret == WID_DBUS_SUCCESS){
		ret = WID_ADD_WLAN_APPLY_RADIO_BASE_NAS_PORT_ID(RadioID,WlanID,nas_port_id);
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &ret);
	return reply;
}

DBusMessage * wid_dbus_interface_radio_apply_wlanid_clean_nas_port_id(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	unsigned int RadioID = 0;
	unsigned char WlanID = 0;	
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_BYTE,&WlanID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(AC_RADIO[RadioID] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[WlanID] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[WlanID]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	
	int k1 = 0;
	
	if(AC_RADIO[RadioID] != NULL)
	{
		for(k1=0;k1<L_BSS_NUM;k1++)
		{
			if(AC_RADIO[RadioID]->BSS[k1] != NULL)
			{
				if(AC_RADIO[RadioID]->BSS[k1]->WlanID == WlanID
					&& (AC_WLAN[WlanID] != NULL && (AC_WLAN[WlanID]->want_to_delete != 1)))		/* Huangleilei add for ASXXZFI-1622 */
				{
					if(AC_RADIO[RadioID]->BSS[k1]->State == 1)
					{
						ret = BSS_BE_ENABLE;
						break;
					}
				}
			}
		}
	}
	
	
	if(ret == WID_DBUS_SUCCESS)
	{
		ret = WID_ADD_WLAN_APPLY_RADIO_CLEAN_NAS_PORT_ID(RadioID,WlanID);
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
	

}

DBusMessage * wid_dbus_interface_radio_apply_wlanid_base_hotspotid(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	unsigned int RadioID;
	unsigned int hotspotid;
	unsigned char WlanID;	
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_BYTE,&WlanID,
								DBUS_TYPE_UINT32,&hotspotid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_RADIO[RadioID] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[WlanID] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[WlanID]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	
	int k1 = 0;
	
	if(AC_RADIO[RadioID] != NULL)
	{
		for(k1=0;k1<L_BSS_NUM;k1++)
		{
			if(AC_RADIO[RadioID]->BSS[k1] != NULL)
			{
				if(AC_RADIO[RadioID]->BSS[k1]->WlanID == WlanID
					&& (AC_WLAN[WlanID] != NULL && (AC_WLAN[WlanID]->want_to_delete != 1)))		/* Huangleilei add for ASXXZFI-1622 */
				{
					if(AC_RADIO[RadioID]->BSS[k1]->State == 1)
					{
						ret = BSS_BE_ENABLE;
						break;
					}
				}
			}
		}
	}
	
	
	if(ret == WID_DBUS_SUCCESS)
	{
		ret = WID_ADD_WLAN_APPLY_RADIO_BASE_HOTSPOT_ID(RadioID,WlanID,hotspotid);
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
	

}

DBusMessage * wid_dbus_interface_radio_apply_wlanid_clean_hotspotid(DBusConnection *conn, DBusMessage *msg, void *user_data){
	wid_syslog_debug_debug(WID_DEFAULT,"in fuc %s\n",__func__);
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	unsigned int RadioID = 0;
	unsigned char WlanID = 0;	
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_BYTE,&WlanID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	wid_syslog_debug_debug(WID_DEFAULT,"radioid = %d\n",RadioID);
	wid_syslog_debug_debug(WID_DEFAULT,"WlanId = %d\n",WlanID);
	if(AC_RADIO[RadioID] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[WlanID] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[WlanID]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	
	int k1 = 0;
	
	if(AC_RADIO[RadioID] != NULL)
	{
		for(k1=0;k1<L_BSS_NUM;k1++)
		{
			if(AC_RADIO[RadioID]->BSS[k1] != NULL)
			{
				if(AC_RADIO[RadioID]->BSS[k1]->WlanID == WlanID
					&& (AC_WLAN[WlanID] != NULL && (AC_WLAN[WlanID]->want_to_delete != 1)))		/* Huangleilei add for ASXXZFI-1622 */
				{
					if(AC_RADIO[RadioID]->BSS[k1]->State == 1)
					{
						ret = BSS_BE_ENABLE;
						break;
					}
				}
			}
		}
	}
	
	
	if(ret == WID_DBUS_SUCCESS)
	{
		ret = WID_ADD_WLAN_APPLY_RADIO_CLEAN_HOTSPOT_ID(RadioID,WlanID);
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
	

}

DBusMessage * wid_dbus_interface_radio_receive_data_dead_time(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;

	unsigned int RadioID;

	unsigned int deadtime;	

	int ret = WID_DBUS_SUCCESS;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_UINT32,&deadtime,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
//	printf("receive radioid %d wlanid %d\n",RadioID,WlanID);		
	if(AC_RADIO[RadioID] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else
	{
		AC_RADIO[RadioID]->rx_data_deadtime = deadtime;

	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
	

}


DBusMessage * wid_dbus_interface_radio_receive_data_dead_time_show(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;

	unsigned int RadioID;

	unsigned int deadtime;	

	int ret = WID_DBUS_SUCCESS;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_RADIO[RadioID] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else
	{
		deadtime = AC_RADIO[RadioID]->rx_data_deadtime;

	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &deadtime);
	return reply;
	

}
DBusMessage *  wid_dbus_interface_check_radio_member(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;

	int i = 0;
	int num =0 ;
	int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	printf("@@@@@@@@@@@@@@@@@@@@@@@@@\n");	
	int ret = WID_DBUS_SUCCESS;
//	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
		printf("#############\n");
			if(AC_RADIO[ID] != NULL)
				{
					radio_head = (struct Radio_List *)WID_MALLOC(sizeof(struct Radio_List));
					radio_head->RadioId = ID;
					ret = WID_DBUS_SUCCESS;
				}
			else
				{
					ret =RADIO_ID_NOT_EXIST;
				}
		printf("ret = %d\n",ret);
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{

										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]==NULL)
											{
												
											}
										else
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												num++;
											}

											
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

		printf("$$$$$$$$$$$$$$$$$$$$$$$\n");
		if((type == 0)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
												DBUS_TYPE_UINT32,
											 	&(radio_head->RadioId));
				printf("radio_head->RadioId = %d\n",radio_head->RadioId);
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
				
			}
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("group wtp num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;
}

#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_radio_delete_wlan(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;
	
	int i = 0;
	int num =0 ;
	int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned char WlanID = 0;		
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&WlanID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
	{
		if(AC_RADIO[ID] == NULL)
		{
			ret = RADIO_ID_NOT_EXIST;
		}
		else if(AC_WLAN[WlanID] == NULL)
		{
			ret = WLAN_ID_NOT_EXIST;
		}
		else
		{
			ret = WID_DELETE_WLAN_APPLY_RADIO(ID,WlanID);

			if(ret == WID_DBUS_SUCCESS)
			{
				 WID_ADD_WLAN_CPE_CHANNEL_APPLY_RADIO_CLEAN_VLANID(ID,WlanID,0);   
			}
		}
	}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]==NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;	
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WLAN[WlanID] == NULL)
											{
												ret2 = WLAN_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WLAN %d is NOT exist\n",WlanID);
											}	
										else
											{
												ret2 = WID_DELETE_WLAN_APPLY_RADIO(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,WlanID);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d RADIO%d access into delete wlan apply radio\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;
}

#else
DBusMessage * wid_dbus_interface_radio_delete_wlan(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;

	unsigned int RadioID;

	unsigned char WlanID;	

	int ret = WID_DBUS_SUCCESS;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_BYTE,&WlanID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
//	printf("receive radioid %d wlanid %d\n",RadioID,WlanID);		
	if(AC_RADIO[RadioID] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[WlanID] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[WlanID]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else
	{
		ret = WID_DELETE_WLAN_APPLY_RADIO(RadioID,WlanID);
		if(ret == WID_DBUS_SUCCESS)
		{
			 WID_ADD_WLAN_CPE_CHANNEL_APPLY_RADIO_CLEAN_VLANID(RadioID,WlanID,0);   
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
	

}
#endif
DBusMessage * wid_dbus_interface_radio_delete_wlan_base_essid(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;

	unsigned int RadioID;

	unsigned char WlanID;	
	char *ESSID;

	int ret = WID_DBUS_SUCCESS;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_BYTE,&WlanID,
								DBUS_TYPE_STRING,&ESSID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
//	printf("receive radioid %d wlanid %d\n",RadioID,WlanID);		
	if(AC_RADIO[RadioID] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[WlanID] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[WlanID]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else
	{
		ret = WID_DELETE_WLAN_APPLY_RADIO_BASE_ESSID(RadioID,WlanID,ESSID);
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
	

}

#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_radio_enable_wlan(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;

	int i = 0;
	int num =0 ;
	int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned char WlanID = 0;			
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&WlanID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(type==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_WLAN[WlanID] == NULL)
				{
					ret = WLAN_ID_NOT_EXIST;
				}
			else
				{
					ret = WID_ENABLE_WLAN_APPLY_RADIO(ID,WlanID);
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]==NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;	
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WLAN[WlanID] == NULL)
											{
												ret2 = WLAN_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WLAN %d is NOT exist\n",WlanID);
											}	
										else
											{
												ret2 = WID_ENABLE_WLAN_APPLY_RADIO(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,WlanID);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d RADIO%d access into enable wlan apply radio\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;

}

#else
DBusMessage * wid_dbus_interface_radio_enable_wlan(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;

	unsigned int RadioID;

	unsigned char WlanID;	

	int ret = WID_DBUS_SUCCESS;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_BYTE,&WlanID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
//	printf("receive radioid %d wlanid %d\n",RadioID,WlanID);		
	if(AC_RADIO[RadioID] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[WlanID] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[WlanID]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else
	{
		ret = WID_ENABLE_WLAN_APPLY_RADIO(RadioID,WlanID);
	}
	

	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
	

}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_radio_disable_wlan(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;

	int i = 0;
	int num =0 ;
	int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned char WlanID = 0;			
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&WlanID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(type==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_WLAN[WlanID] == NULL)
				{
					ret = WLAN_ID_NOT_EXIST;
				}
			else
				{
					ret = WID_DISABLE_WLAN_APPLY_RADIO(ID,WlanID);
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]==NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;	
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WLAN[WlanID] == NULL)
											{
												ret2 = WLAN_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WLAN %d is NOT exist\n",WlanID);
											}	
										else
											{
												ret2 = WID_DISABLE_WLAN_APPLY_RADIO(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,WlanID);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d RADIO%d access into disable wlan apply radio\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}


										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;

}

#else
DBusMessage * wid_dbus_interface_radio_disable_wlan(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;

	unsigned int RadioID;

	unsigned char WlanID;	

	int ret = WID_DBUS_SUCCESS;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_BYTE,&WlanID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
//	printf("receive radioid %d wlanid %d\n",RadioID,WlanID);		
	if(AC_RADIO[RadioID] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[WlanID] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[WlanID]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else
	{
		ret = WID_DISABLE_WLAN_APPLY_RADIO(RadioID,WlanID);
	}
	

	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
	

}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_radio_recover_default_config(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;

	int i = 0;
	int num =0 ;
	int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned char reserved = 0;			
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&reserved,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(type==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}	

			else
				{
					ret = WID_RADIO_SET_CHAN(ID,0);
					ret = WID_RADIO_SET_MODE(ID,5);
					ret = WID_RADIO_SET_TXP(ID, 23,CW_FALSE);
					ret = WID_RADIO_SET_BEACON(ID,100);
					ret = WID_RADIO_SET_FRAGMENTATION(ID,2346);
					ret = WID_RADIO_SET_DTIM(ID,1);
					ret = WID_RADIO_SET_RTSTHRESHOLD(ID,2346);
					ret = WID_RADIO_SET_PREAMBLE(ID,1);
					ret = WID_RADIO_SET_SHORTRETRY(ID,7);
					ret = WID_RADIO_SET_LONGRETRY(ID,4);

					AC_RADIO[ID]->Radio_Chan = 0;
					AC_RADIO[ID]->Radio_TXP = 20;
					AC_RADIO[ID]->Radio_Type = 0x5;
					AC_RADIO[ID]->FragThreshold = 2346;
					AC_RADIO[ID]->BeaconPeriod = 100;
					AC_RADIO[ID]->IsShortPreamble = 1;
					AC_RADIO[ID]->DTIMPeriod = 1; 
					AC_RADIO[ID]->ShortRetry = 7; 
					AC_RADIO[ID]->LongRetry = 4; 
					AC_RADIO[ID]->rtsthreshold = 2346;//zhangshu modify 2010-10-28, Huang Leilei change it for AXSSZFI-1406, 2012-01-09
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]==NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;	
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else
											{
												ret2 = WID_RADIO_SET_CHAN(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,0);
												ret2 = WID_RADIO_SET_MODE(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,5);
												ret2 = WID_RADIO_SET_TXP(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID, 23,CW_FALSE);
												ret2 = WID_RADIO_SET_BEACON(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,100);
												ret2 = WID_RADIO_SET_FRAGMENTATION(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,2346);
												ret2 = WID_RADIO_SET_DTIM(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,1);
												ret2 = WID_RADIO_SET_RTSTHRESHOLD(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,2346);
												ret2 = WID_RADIO_SET_PREAMBLE(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,1);
												ret2 = WID_RADIO_SET_SHORTRETRY(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,7);
												ret2 = WID_RADIO_SET_LONGRETRY(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,4);
										
												AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_Chan = 0;
												AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_TXP = 20;
												AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_Type = 0x5;
												AC_WTP[tmp->WTPID]->WTP_Radio[i]->FragThreshold = 2346;
												AC_WTP[tmp->WTPID]->WTP_Radio[i]->BeaconPeriod = 100;
												AC_WTP[tmp->WTPID]->WTP_Radio[i]->IsShortPreamble = 1;
												AC_WTP[tmp->WTPID]->WTP_Radio[i]->DTIMPeriod = 1; 
												AC_WTP[tmp->WTPID]->WTP_Radio[i]->ShortRetry = 7; 
												AC_WTP[tmp->WTPID]->WTP_Radio[i]->LongRetry = 4; 
												AC_WTP[tmp->WTPID]->WTP_Radio[i]->rtsthreshold = 2347;//zhangshu modify 2010-10-28
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d recover default config\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;
}

#else
DBusMessage * wid_dbus_interface_radio_recover_default_config(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;

	unsigned int RadioID;

	unsigned char reserved;	

	int ret = WID_DBUS_SUCCESS;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_BYTE,&reserved,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(AC_RADIO[RadioID] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}

	else
	{
		ret = WID_RADIO_SET_CHAN(RadioID,0);
		ret = WID_RADIO_SET_MODE(RadioID,5);
		ret = WID_RADIO_SET_TXP(RadioID, 23,CW_FALSE);
		ret = WID_RADIO_SET_BEACON(RadioID,100);
		ret = WID_RADIO_SET_FRAGMENTATION(RadioID,2346);
		ret = WID_RADIO_SET_DTIM(RadioID,1);
		ret = WID_RADIO_SET_RTSTHRESHOLD(RadioID,2346);
		ret = WID_RADIO_SET_PREAMBLE(RadioID,1);
		ret = WID_RADIO_SET_SHORTRETRY(RadioID,7);
		ret = WID_RADIO_SET_LONGRETRY(RadioID,4);

		AC_RADIO[RadioID]->Radio_Chan = 0;
		AC_RADIO[RadioID]->Radio_TXP = 20;
		AC_RADIO[RadioID]->Radio_Type = 0x5;
		AC_RADIO[RadioID]->FragThreshold = 2346;
		AC_RADIO[RadioID]->BeaconPeriod = 100;
		AC_RADIO[RadioID]->IsShortPreamble = 1;
		AC_RADIO[RadioID]->DTIMPeriod = 1; 
		AC_RADIO[RadioID]->ShortRetry = 7; 
		AC_RADIO[RadioID]->LongRetry = 4; 
		AC_RADIO[RadioID]->rtsthreshold = 2346;//zhangshu modify 2010-10-28, Huang Leilei change it for AXSSZFI-1406, 2012-01-09
	}
	

	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
	

}
#endif


//added by weiay 20080714
/*DBusMessage * wid_dbus_interface_radio_set_rate(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	unsigned int RadioID;	
	unsigned short Radiorate;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_UINT16,&Radiorate,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_RADIO[RadioID] == NULL){
		ret = RADIO_ID_NOT_EXIST;
	}else{
		ret = WID_RADIO_SET_RATE(RadioID,Radiorate);
				
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &AC_RADIO[RadioID]->Radio_Type);
	return reply;	
}*/
////
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_radio_set_support_ratelist(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply = NULL;	
	DBusMessageIter	 iter;
	DBusError err;	
	
	int Radiorate[32];
	int i = 0;
	int flag = 1;
	int NUM = 0;
	int j = 0;
	int num =0 ;
	int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	//unsigned char reserved = 0;			
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;	
	struct Support_Rate_List *ptr = NULL;

	printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
	
	dbus_error_init(&err);
		
	dbus_message_iter_init(msg,&iter);
	dbus_message_iter_get_basic(&iter,&type);

	dbus_message_iter_next(&iter);
	dbus_message_iter_get_basic(&iter,&ID);
	
	dbus_message_iter_next(&iter);
	dbus_message_iter_get_basic(&iter,&NUM);

	printf("ID = %d\n",ID);
	printf("NUM = %d\n",NUM);
	
	memset(Radiorate,0,NUM);
	
	if(NUM > 0 )
	{		
		dbus_message_iter_next(&iter);	
		
		for (i = 0; i < NUM; i++) 
		{
			
			dbus_message_iter_get_basic(&iter,&Radiorate[i]);

			if(i != NUM-1)
				dbus_message_iter_next(&iter);	

			printf("Radiorate[%d] = %d\n",i,Radiorate[i]);
		
		}
		
	}

	if(type==0)
		{
			
			for (i=0;i<NUM;i++)
			{
				//printf("%d rate %d\n",i,Radiorate[i]);
				if((Radiorate[i] == 10)||(Radiorate[i] == 20)||(Radiorate[i] == 55)||
					(Radiorate[i] == 60)||(Radiorate[i] == 90)||(Radiorate[i] == 110)||
					(Radiorate[i] == 120)||(Radiorate[i] == 180)||(Radiorate[i] == 240)||
					(Radiorate[i] == 360)||(Radiorate[i] == 480)||(Radiorate[i] == 540))
				{

				}
				else
				{
					ret = WTP_NO_SURPORT_Rate;

					reply = dbus_message_new_method_return(msg);
	
					dbus_message_iter_init_append (reply, &iter);
				
					dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
													 &ret);
					dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
													 &AC_RADIO[ID]->Radio_Type);
					return reply;
				}
			}
		if(AC_RADIO[ID] == NULL)
			{
				ret = RADIO_ID_NOT_EXIST;
			}
		else if(AC_RADIO[ID]->Radio_Type==IEEE80211_11N)//hanjunweichange
			{
				ret = RADIO_MODE_IS_11N;
			}
		else
			{//next set the rate
				ret = WID_RADIO_SET_SUPPORT_RATE(ID,Radiorate,flag,NUM);
			}
	
		reply = dbus_message_new_method_return(msg);
	
		dbus_message_iter_init_append (reply, &iter);
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&AC_RADIO[ID]->Radio_Type);

		printf("ret = %d\n",ret);
		printf("AC_RADIO[ID]->Radio_Type= %d\n",AC_RADIO[ID]->Radio_Type);
		if (ret == 0)
			{
				NUM = length_of_rate_list(AC_RADIO[ID]->Radio_Rate);

				dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&NUM);
				
				ptr = AC_RADIO[ID]->Radio_Rate;
	
				for(i = 0; i < NUM; i++)
				{
					dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ptr->Rate);
					printf("%d rate %d\n",i,ptr->Rate);
					ptr = ptr->next;
					if(ptr == NULL)
						{
							return reply;
						}
				}
			}	
			return reply;
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										for (j=0;j<NUM;j++)
											{
												//printf("%d rate %d\n",i,Radiorate[i]);
												if((Radiorate[j] == 10)||(Radiorate[j] == 20)||(Radiorate[j] == 55)||
													(Radiorate[j] == 60)||(Radiorate[j] == 90)||(Radiorate[j] == 110)||
													(Radiorate[j] == 120)||(Radiorate[j] == 180)||(Radiorate[j] == 240)||
													(Radiorate[j] == 360)||(Radiorate[j] == 480)||(Radiorate[j] == 540))
												{
										
												}
												else
												{
													ret2 = WTP_NO_SURPORT_Rate;
													wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d no support rate\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);				
										
												}
											}
										if(AC_WTP[tmp->WTPID]->WTP_Radio[i] == NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is not exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);				
											}
										else if((AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_Type&IEEE80211_11N) > 0)
											{
												ret2 = RADIO_MODE_IS_11N;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d mode is 11N\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);				
											}
										else
											{//next set the rate
												ret2 = WID_RADIO_SET_SUPPORT_RATE(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,Radiorate,flag,NUM);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d access into set support rate\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);				
											}
					
										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;
		} else {
			return reply;
		}
}

#else
DBusMessage * wid_dbus_interface_radio_set_support_ratelist(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	int RadioID = 0;	
	int Radiorate[32];
	//int rate[32];
	int num = 0;
	int i = 0;
	int flag = 1;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;

	struct Support_Rate_List *ptr = NULL;
	
	
	dbus_error_init(&err);
		
	dbus_message_iter_init(msg,&iter);
	dbus_message_iter_get_basic(&iter,&RadioID);
	
	dbus_message_iter_next(&iter);
	dbus_message_iter_get_basic(&iter,&num);

	
	memset(Radiorate,0,num);
	
	if(num > 0 )
	{		
		dbus_message_iter_next(&iter);	
		
		for (i = 0; i < num; i++) 
		{
			
			dbus_message_iter_get_basic(&iter,&Radiorate[i]);
			
			dbus_message_iter_next(&iter);	
		
		}
		
	}
	for (i=0;i<num;i++)
	{
		//printf("%d rate %d\n",i,Radiorate[i]);
		if((Radiorate[i] == 10)||(Radiorate[i] == 20)||(Radiorate[i] == 55)||
			(Radiorate[i] == 60)||(Radiorate[i] == 90)||(Radiorate[i] == 110)||
			(Radiorate[i] == 120)||(Radiorate[i] == 180)||(Radiorate[i] == 240)||
			(Radiorate[i] == 360)||(Radiorate[i] == 480)||(Radiorate[i] == 540))
		{

		}
		else
		{
			ret = WTP_NO_SURPORT_Rate;

			reply = dbus_message_new_method_return(msg);
	
			dbus_message_iter_init_append (reply, &iter);
			
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &ret);
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &AC_RADIO[RadioID]->Radio_Type);
			return reply;
		}
	}
	if(AC_RADIO[RadioID] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_RADIO[RadioID]->Radio_Type==IEEE80211_11N)
	{
		ret = RADIO_MODE_IS_11N;
	}
	else
	{//next set the rate


		
	
		ret = WID_RADIO_SET_SUPPORT_RATE(RadioID,Radiorate,flag,num);
	}
	
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&AC_RADIO[RadioID]->Radio_Type);
	
	if (ret == 0)
	{
		num = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);

		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&num);
				
		ptr = AC_RADIO[RadioID]->Radio_Rate;

		
		
		for(i = 0; i < num; i++)
		{
			dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ptr->Rate);
			//printf("%d rate %d\n",i,ptr->Rate);
			ptr = ptr->next;
			if(ptr == NULL)
			{
				return reply;
			}
		}
	}	
	return reply;	
}
#endif


/*
** wid set 11n rate paras
** book add, 2010-10-20
*/
DBusMessage * wid_dbus_interface_radio_set_11n_rate_paras(DBusConnection *conn, DBusMessage *msg, void *user_data){
    DBusMessage * reply;    
    DBusMessageIter  iter;
    DBusError err;  
    
//    int i = 0;
    unsigned int ID = 0; 
//    int mcs = 0;
//    int cwmode = 0;
//    int guard_interval = 0;
    unsigned char channel = 0;
    int ret = WID_DBUS_SUCCESS;
    struct n_rate_info nRateInfo;
    
    dbus_error_init(&err);

    if (!(dbus_message_get_args ( msg, &err,
                                DBUS_TYPE_UINT32,&ID,
                                DBUS_TYPE_UINT32,&(nRateInfo.mcs),
                                DBUS_TYPE_UINT32,&(nRateInfo.cwmode),
                                DBUS_TYPE_UINT32,&(nRateInfo.guard_interval),
                                DBUS_TYPE_BYTE,&channel,
                                DBUS_TYPE_INVALID))){

        printf("Unable to get input args\n");
                
        if (dbus_error_is_set(&err)) {
            printf("%s raised: %s",err.name,err.message);
            dbus_error_free(&err);
        }
        return NULL;
    }

    /* set mcs, cwmode, guard interval */
    
    wid_syslog_debug_debug(WID_DEFAULT,"11 mcs = %d,cwmode = %d,gi = %d\n",nRateInfo.mcs,nRateInfo.cwmode,nRateInfo.guard_interval);
    if(nRateInfo.mcs < 0)
        nRateInfo.mcs+= 1000;
    if(nRateInfo.cwmode < 0)
        nRateInfo.cwmode += 1000;
    if(nRateInfo.guard_interval < 0)
        nRateInfo.guard_interval += 1000;

    ret = wid_radio_set_11n_rate_paras(ID, nRateInfo, channel);


    reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);

	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);

	return reply;
}


#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_radio_set_max_rate(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply = NULL;	
	DBusMessageIter	 iter;
	DBusError err;	
	
	int Radiorate[1] = {0};

	int i = 0;
	int num =0 ;
	int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;		
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	int flag = 3;
	int NUM = 1;	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;
	struct Support_Rate_List *ptr = NULL;	
	
	dbus_error_init(&err);

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&Radiorate[0],
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	printf("receive radioid %d rate %d\n",ID,Radiorate[0]);
	if(type==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if((AC_RADIO[ID]->Radio_Type&IEEE80211_11N) > 0)
				{
					ret = RADIO_MODE_IS_11N;
				}
			else
				{
					ret = WID_RADIO_SET_SUPPORT_RATE(ID,Radiorate,flag,NUM);
					
				}	
			reply = dbus_message_new_method_return(msg);
		
			dbus_message_iter_init_append (reply, &iter);
		
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &ret);	
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &AC_RADIO[ID]->Radio_Type);

			printf("ret = %d\n",ret);
			if (ret == 0)
				{
					NUM = length_of_rate_list(AC_RADIO[ID]->Radio_Rate);
					printf("NUM =  %d\n",NUM);
					dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&NUM);			
					ptr = AC_RADIO[ID]->Radio_Rate;
		
					for(i = 0; i < NUM; i++)
						{
							dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ptr->Rate);
							printf("ptr->Rate  =  %d\n",ptr->Rate);
							ptr = ptr->next;
							if(ptr == NULL)
								{
									return reply;
								}
						}
				}	
			return reply;	
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]==NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;	
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if((AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_Type&IEEE80211_11N) > 0)
											{
												ret2 = RADIO_MODE_IS_11N;
											}
										else
											{
												ret2 = WID_RADIO_SET_SUPPORT_RATE(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,Radiorate,flag,NUM);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d access into set support rate\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);				
											}


										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;
		} else {
			return reply;
		}
}

#else
DBusMessage * wid_dbus_interface_radio_set_max_rate(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	unsigned int ID;	
	int Radiorate[1] = {0};
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	int i = 0;
	struct Support_Rate_List *ptr = NULL;
	dbus_error_init(&err);
    int mcs = 0;
	int cwmode = 0;
	int guard_interval = 0;
	unsigned char channel = 0;
	unsigned int max_channel=0;    
	unsigned int min_channel = 0; 
	int wflag = 0;
	int flag = 3;
	int num = 1;
	struct n_rate_info nRateInfo;
	
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&Radiorate[0],
								DBUS_TYPE_UINT32,&wflag,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	wid_syslog_debug_debug(WID_DEFAULT,"receive radioid %d rate %d\n",ID,Radiorate[0]);
	if(AC_RADIO[ID] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if((AC_RADIO[ID]->Radio_Type&IEEE80211_11N) > 0)
	{
	    wid_syslog_debug_debug(WID_DEFAULT,"This is a 11n ap\n");
	    if(AC_RADIO[ID]->isBinddingWlan == 0)
		{
			ret = WTP_IS_NOT_BINDING_WLAN_ID;
		}
		else
		{
		    nRateInfo.rate = Radiorate[0];
            ret = wid_radio_get_11n_rate_paras(&nRateInfo, AC_RADIO[ID]->chainmask_num);
            wid_syslog_debug_debug(WID_DEFAULT,"ret = %d\n",ret);
            if(ret == 0)
            {
                if(nRateInfo.mcs != AC_RADIO[ID]->mcs)
                    mcs = nRateInfo.mcs - 1000;
                else
                    mcs = nRateInfo.mcs;
                if(nRateInfo.cwmode != AC_RADIO[ID]->cwmode)
                    cwmode = nRateInfo.cwmode - 1000;
                else
                    cwmode= nRateInfo.cwmode;
                if(nRateInfo.guard_interval != AC_RADIO[ID]->guardinterval)
                    guard_interval = nRateInfo.guard_interval - 1000;
                else
                    guard_interval = nRateInfo.guard_interval;

                if(nRateInfo.cwmode != AC_RADIO[ID]->cwmode)
    		    {
        		    wid_check_radio_max_min_channel(ID,&max_channel,&min_channel);  

            	    if((AC_RADIO[ID]->Radio_Chan > max_channel)&&(2 == nRateInfo.cwmode)&&(AC_RADIO[ID]->cwmode == 0))
                    {
                        channel = max_channel;
                        wid_syslog_debug_debug(WID_DEFAULT,"channel = %d\n",channel);
                    }
                }

                if(wflag == 1)
                {
                    ret = wid_radio_set_11n_rate_paras(ID, nRateInfo, channel);
                }
            }
        }
	}
	else
	{
		ret = WID_RADIO_SET_SUPPORT_RATE(ID,Radiorate,flag,num);
				
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &AC_RADIO[ID]->Radio_Type);
	if ((ret == 0) && ((AC_RADIO[ID]->Radio_Type&IEEE80211_11N) < 0))
	{
		num = length_of_rate_list(AC_RADIO[ID]->Radio_Rate);

		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&num);
				
		ptr = AC_RADIO[ID]->Radio_Rate;

		
		
		for(i = 0; i < num; i++)
		{
			dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ptr->Rate);
			ptr = ptr->next;
			if(ptr == NULL)
			{
				return reply;
			}
		}
	}
	else if((ret == 0) && (wflag == 0))
	{
	    if(nRateInfo.cwmode != AC_RADIO[ID]->cwmode)
	    {
		    wid_check_radio_max_min_channel(ID,&max_channel,&min_channel); 
    		
    	    if((AC_RADIO[ID]->Radio_Chan > max_channel)&&((1 == nRateInfo.cwmode)||(2 == nRateInfo.cwmode))&&(AC_RADIO[ID]->cwmode == 0))
            {
                channel = max_channel;
            }
        }
	    dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &mcs);	
	    dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &cwmode);
	    dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &guard_interval);
	    dbus_message_iter_append_basic (&iter, DBUS_TYPE_BYTE, &channel);
	}
	return reply;	
}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_radio_set_bss_l3_policy(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;

	int i = 0;
	int num =0 ;
	int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	//unsigned int bss_id = 0;     //fengwenchao comment 20110511
	unsigned char wlanid = 0;    //fengwenchao add  20110511
	int k1 =0 ;   //fengwenchao add 20110511
	unsigned int bsspolicy = 0;	
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
		                        DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&wlanid,     //fengwenchao modify 20110511
								DBUS_TYPE_UINT32,&bsspolicy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			unsigned int wtp_id = ID/L_RADIO_NUM;
			unsigned int l_radio_id = ID%L_RADIO_NUM;
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_WTP[wtp_id] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			/*fengwenchao add 20110511*/
			else if(AC_WLAN[wlanid] == NULL)
			{
				ret = WLAN_ID_NOT_EXIST;
			}
			/*fengwenchao add end*/		
			else if((AC_RADIO[ID]->BindingWlanCount) != 0)
				{
					/*fengwenchao add 20110511*/
					ret = Wlan_IF_NOT_BE_BINDED;
					for(k1 = 0 ; k1 < L_BSS_NUM;k1++)
					{
						if((AC_WTP[wtp_id]->WTP_Radio[l_radio_id] != NULL)&&(AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[k1] != NULL))
							{
								//ret = WID_RADIO_BSS_L3IF_POLICY(AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[bss_id]->WlanID,wtp_id,l_radio_id,bss_id,bsspolicy);
								ret = WID_RADIO_BSS_L3IF_POLICY_BR(AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[k1]->WlanID,wtp_id,l_radio_id,k1,bsspolicy);
								break;
							}
						continue;
					}
					/*fengwenchao add end*/
				}
			else
				{
					ret = WTP_IS_NOT_BINDING_WLAN_ID;
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);

										if(AC_WTP[tmp->WTPID] == NULL)
											{
												ret2 = WTP_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d is not exist\n",tmp->WTPID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i] == NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										/*fengwenchao add 20110511*/
										else if(AC_WLAN[wlanid] == NULL)
										{
											ret2 = WLAN_ID_NOT_EXIST;
										}
										/*fengwenchao add end*/	
										else if((AC_WTP[tmp->WTPID]->WTP_Radio[i]->BindingWlanCount) != 0)
											{
												/*fengwenchao modify begin , 20110511*/
												ret2 = Wlan_IF_NOT_BE_BINDED;
												for(k1 = 0 ; k1 < L_BSS_NUM;k1++)
												{
													if((AC_WTP[tmp->WTPID]->WTP_Radio[i] != NULL)&&(AC_WTP[tmp->WTPID]->WTP_Radio[i]->BSS[k1] != NULL))
														{
															//ret = WID_RADIO_BSS_L3IF_POLICY(AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[bss_id]->WlanID,wtp_id,l_radio_id,bss_id,bsspolicy);
															ret2 = WID_RADIO_BSS_L3IF_POLICY_BR(AC_WTP[tmp->WTPID]->WTP_Radio[i]->BSS[k1]->WlanID,tmp->WTPID,i,k1,bsspolicy);
															wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d access into bss l3 policy\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
															break;
														}
													continue;
												}
												/*fengwenchao modify end 20110511*/
											}
										else
											{
												ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d is not binding wlan\n",tmp->WTPID);
											}

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;	


}

#else
DBusMessage * wid_dbus_interface_radio_set_bss_l3_policy(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;

	//unsigned int bss_id = 0;     //fengwenchao comment 20110511
	unsigned char wlanid = 0;    //fengwenchao add  20110511
	int k1 =0 ;   //fengwenchao add 20110511
	unsigned int bsspolicy = 0;
	unsigned int radio_id = 0;

	dbus_error_init(&err);
	
	if (!(dbus_message_get_args ( msg, &err,
		                        DBUS_TYPE_UINT32,&radio_id,
								DBUS_TYPE_BYTE,&wlanid,     //fengwenchao modify 20110511
								DBUS_TYPE_UINT32,&bsspolicy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	unsigned int wtp_id = radio_id/L_RADIO_NUM;
	unsigned int l_radio_id = radio_id%L_RADIO_NUM;
	if(AC_RADIO[radio_id] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtp_id] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	/*fengwenchao add 20110511*/
	else if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	/*fengwenchao add end*/	
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else if((AC_RADIO[radio_id]->BindingWlanCount) != 0)
	{
		/*if((AC_WTP[wtp_id]->WTP_Radio[l_radio_id] != NULL)&&(AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[bss_id] != NULL))
		{
			//ret = WID_RADIO_BSS_L3IF_POLICY(AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[bss_id]->WlanID,wtp_id,l_radio_id,bss_id,bsspolicy);
			ret = WID_RADIO_BSS_L3IF_POLICY_BR(AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[bss_id]->WlanID,wtp_id,l_radio_id,bss_id,bsspolicy);
		}
		else
		{
			ret = BSS_NOT_EXIST;
		}*/    //fengwenchao comment 20110511
		/*fengwenchao add 20110511*/
		ret = Wlan_IF_NOT_BE_BINDED;
		for(k1 = 0 ; k1 < L_BSS_NUM;k1++)
		{
			if((AC_WTP[wtp_id]->WTP_Radio[l_radio_id] != NULL)&&(AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[k1] != NULL)&&(AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[k1]->WlanID == wlanid))
			{
				ret = WID_RADIO_BSS_L3IF_POLICY_BR(AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[k1]->WlanID,wtp_id,l_radio_id,k1,bsspolicy);
				break;
			}
			continue;
		}
		/*fengwenchao add end*/
	}
	else
	{
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}
	reply = dbus_message_new_method_return(msg);
				
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 
	return reply;	
}
#endif
/*
DBusMessage * wid_dbus_interface_radio_set_bss_l3_policy_br(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;

	unsigned int bss_id = 0;
	unsigned int bsspolicy = 0;
	unsigned int radio_id = 0;

	dbus_error_init(&err);
	
	if (!(dbus_message_get_args ( msg, &err,
		                        DBUS_TYPE_UINT32,&radio_id,
								DBUS_TYPE_UINT32,&bss_id,
								DBUS_TYPE_UINT32,&bsspolicy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	unsigned int wtp_id = radio_id/L_RADIO_NUM;
	unsigned int l_radio_id = radio_id%L_RADIO_NUM;
	if(AC_RADIO[radio_id] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtp_id] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	
	else if((AC_RADIO[radio_id]->BindingWlanCount) != 0)
	{
		if((AC_WTP[wtp_id]->WTP_Radio[l_radio_id] != NULL)&&(AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[bss_id] != NULL))
		{
			ret = WID_RADIO_BSS_L3IF_POLICY_BR(AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[bss_id]->WlanID,wtp_id,l_radio_id,bss_id,bsspolicy);
		}
		else
		{
			ret = BSS_NOT_EXIST;
		}
	}
	else
	{
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}
	reply = dbus_message_new_method_return(msg);
				
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 
	return reply;	
}*/
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_radio_set_bss_max_throughput(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;

	int i = 0;
	int num =0 ;
	int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	//unsigned int bss_id = 0;    //fengwenchao comment 20110512
 	unsigned char wlanid = 0 ;      //fengwenchao add 20110512
 	int k1 =0;     //fengwenchao add 20110512
	unsigned int throughput = 0;		
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
		                        DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&wlanid,        //fengwenchao modify 20110512
								DBUS_TYPE_UINT32,&throughput,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			unsigned int wtp_id = ID/L_RADIO_NUM;
			unsigned int l_radio_id = ID%L_RADIO_NUM;
			//unsigned int l_bss_id = bss_id-1;       //fengwenchao comment 20110512
			if(AC_WTP[wtp_id] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			/*fengwenchao modify begin  , 20110512*/
			else if(AC_WLAN[wlanid] == NULL)
				{
					ret = WLAN_ID_NOT_EXIST;
				}	
			/*else if(AC_RADIO[ID]->BSS[l_bss_id] == NULL)
				{
					ret = BSS_NOT_EXIST;
				}*/
			if(ret == WID_DBUS_SUCCESS)
				{
					ret = Wlan_IF_NOT_BE_BINDED;
					for(k1 = 0; k1 < L_BSS_NUM;k1++)
					{
						if((AC_RADIO[ID]->BSS[k1] != NULL)&&(AC_RADIO[ID]->BSS[k1]->WlanID ==wlanid))
							{
								ret = WID_DBUS_SUCCESS;
								break;			
							}
							continue;
					}	
					if(ret == WID_DBUS_SUCCESS)
						{
							ret = wid_radio_bss_set_max_throughput(wtp_id,l_radio_id,k1,throughput);
						}
				}
			/*else
			{
				ret = wid_radio_bss_set_max_throughput(wtp_id,l_radio_id,l_bss_id,throughput);
			}*/
			/*fengwenchao modify end*/

		}
	else if(type == 1)
		{
			//unsigned int l_bss_id = bss_id-1;     //fengwenchao comment 20110512
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);

										if(AC_WTP[tmp->WTPID] == NULL)
											{
												ret2 = WTP_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d is not exist\n",tmp->WTPID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i] == NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										/*fengwenchao modify begin  , 20110512*/
										else if(AC_WLAN[wlanid] == NULL)
											{
												ret2 = WLAN_ID_NOT_EXIST;
											}	
										/*else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->BSS[l_bss_id] == NULL)
											{
												ret2 = BSS_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"BSS not exist\n");
											}*/
										if(ret2 == WID_DBUS_SUCCESS)
											{
												ret2 = Wlan_IF_NOT_BE_BINDED;
												for(k1 = 0; k1 < L_BSS_NUM;k1++)
												{
													if((AC_WTP[tmp->WTPID]->WTP_Radio[i]->BSS[k1] != NULL)&&(AC_WTP[tmp->WTPID]->WTP_Radio[i]->BSS[k1]->WlanID == wlanid))
														{
															ret2 = WID_DBUS_SUCCESS;
															break;			
														}
														continue;
												}	
												if(ret2 == WID_DBUS_SUCCESS)
													{
														ret2 = wid_radio_bss_set_max_throughput(tmp->WTPID,i,k1,throughput);
														wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d access into set max throughput\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
													}
											}
										/*else
											{
												ret2 = wid_radio_bss_set_max_throughput(tmp->WTPID,i,l_bss_id,throughput);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d access into set amx throughput\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}*/
										/*fengwenchao modify end*/
										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;	
}

#else
DBusMessage * wid_dbus_interface_radio_set_bss_max_throughput(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;

 	//unsigned int bss_id = 0;    //fengwenchao comment 20110512
 	unsigned char wlanid = 0 ;      //fengwenchao add 20110512
 	int k1 =0;     //fengwenchao add 20110512
	unsigned int throughput = 0;
	unsigned int radio_id = 0;

	dbus_error_init(&err);
	
	if (!(dbus_message_get_args ( msg, &err,
		                        DBUS_TYPE_UINT32,&radio_id,
								DBUS_TYPE_BYTE,&wlanid,                //fengwenchao modify 20110512
								DBUS_TYPE_UINT32,&throughput,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	unsigned int wtp_id = radio_id/L_RADIO_NUM;
	unsigned int l_radio_id = radio_id%L_RADIO_NUM;
	//unsigned int l_bss_id = bss_id-1;     //fengwenchao comment 20110512
	if(AC_WTP[wtp_id] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radio_id] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	/*fengwenchao modify begin  , 20110512*/
	else if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}		
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	/*else if(AC_RADIO[radio_id]->BSS[l_bss_id] == NULL)
	{
		ret = BSS_NOT_EXIST;
	}*/
	if(ret == WID_DBUS_SUCCESS)
	{
		ret = Wlan_IF_NOT_BE_BINDED;
		for(k1 = 0; k1 < L_BSS_NUM;k1++)
		{
			if((AC_RADIO[radio_id]->BSS[k1] != NULL)&&(AC_RADIO[radio_id]->BSS[k1]->WlanID ==wlanid))
			{
				ret = WID_DBUS_SUCCESS;
				break;			
			}
			continue;
		}	
		if(ret == WID_DBUS_SUCCESS)
		{
			ret = wid_radio_bss_set_max_throughput(wtp_id,l_radio_id,k1,throughput);
		}
	}
	/*else
	{
		ret = wid_radio_bss_set_max_throughput(wtp_id,l_radio_id,l_bss_id,throughput);
	}*/
	/*fengwenchao modify end*/
	reply = dbus_message_new_method_return(msg);
				
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 
	return reply;	
}
#endif
DBusMessage * wid_dbus_interface_radio_show_bss_max_throughput(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply = NULL;
	DBusError err;
	DBusMessageIter  iter;
	DBusMessageIter  iter_array;
	DBusMessageIter  iter_struct;
	int ret = WID_DBUS_SUCCESS;
	int i = 0;
	int count = 0;
	unsigned int radio_id = 0;

	dbus_error_init(&err);
	
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radio_id,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	unsigned int wtp_id = radio_id/L_RADIO_NUM;
	unsigned int l_radio_id = radio_id%L_RADIO_NUM;
	ret = WID_CHECK_ID(WID_RADIO_CHECK,radio_id);

	if(ret != WID_DBUS_SUCCESS)
	{
		printf("radio id not correct. \n");
	}
	else if(AC_WTP[wtp_id] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radio_id] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else
	{
		for(i=0; i<L_BSS_NUM ;i++)
		{
			if(AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i] != NULL)
			{
				count++;
			}
		}


	}
	reply = dbus_message_new_method_return(msg);
				
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 
	if(ret == WID_DBUS_SUCCESS)
	{
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_BYTE,&AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->bandwidth);
	
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&count); 
		/*fengwenchao modify begin 20120502 for autelan-2917*/
		dbus_message_iter_open_container (&iter,
								DBUS_TYPE_ARRAY,
								DBUS_STRUCT_BEGIN_CHAR_AS_STRING
										DBUS_TYPE_UINT32_AS_STRING//BSSIndex
										DBUS_TYPE_BYTE_AS_STRING//WlanID
										DBUS_TYPE_BYTE_AS_STRING//band_width
										DBUS_TYPE_BYTE_AS_STRING//BSSID[0]
										DBUS_TYPE_BYTE_AS_STRING//BSSID[1]
										DBUS_TYPE_BYTE_AS_STRING//BSSID[2]
										DBUS_TYPE_BYTE_AS_STRING//BSSID[3]
										DBUS_TYPE_BYTE_AS_STRING//BSSID[4]
										DBUS_TYPE_BYTE_AS_STRING//BSSID[5]
										DBUS_TYPE_UINT32_AS_STRING//bss_max_allowed_sta_num
								DBUS_STRUCT_END_CHAR_AS_STRING,
								&iter_array);

		for(i=0; i<L_BSS_NUM ;i++)
		{
			if(AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i] != NULL)
			{
				dbus_message_iter_open_container(&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
				
				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_UINT32,&AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->BSSIndex);

				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->WlanID);
				
				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->band_width); 

				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&(AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->BSSID[0]));
		
				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&(AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->BSSID[1]));

				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&(AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->BSSID[2]));

				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&(AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->BSSID[3]));

				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&(AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->BSSID[4]));

				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&(AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->BSSID[5]));

				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_UINT32,&AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->bss_max_allowed_sta_num);
				
				wid_syslog_debug_debug(WID_DBUS,"bssindex %d bssid %02X:%02X:%02X:%02X:%02X:%02X troughput %d\n",AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->BSSIndex,
													AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->BSSID[0],
													AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->BSSID[1],
													AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->BSSID[2],
													AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->BSSID[3],
													AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->BSSID[4],
													AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->BSSID[5],
													AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->band_width);
				dbus_message_iter_close_container (&iter_array, &iter_struct);
			}
		}
		dbus_message_iter_close_container (&iter, &iter_array);
		/*fengwenchao modify end*/
	}
	return reply;	
}

DBusMessage * wid_dbus_interface_radio_show_bss_list(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter,iter_array;
	int ret = WID_DBUS_SUCCESS;
	int i = 0;
	int count = 0;
	unsigned int radio_id = 0;
	char *nas_id = NULL;
	nas_id = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME+1);
	if(NULL == nas_id){
		return NULL;
	}
	dbus_error_init(&err);
	
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radio_id,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		CW_FREE_OBJECT_WID(nas_id);
		return NULL;
	}
	unsigned int wtp_id = radio_id/L_RADIO_NUM;
	unsigned int l_radio_id = radio_id%L_RADIO_NUM;

	ret = WID_CHECK_ID(WID_RADIO_CHECK,radio_id);
	
	if(ret != WID_DBUS_SUCCESS)
	{
		printf("radio id not correct. \n");
	}
	else if(AC_WTP[wtp_id] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radio_id] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else
	{
		for(i=0; i<L_BSS_NUM ;i++)
		{
			if(AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i] != NULL)
			{
				count++;
			}
		}


	}

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	if(ret == WID_DBUS_SUCCESS)
	{	
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&count);

		dbus_message_iter_append_basic (&iter,DBUS_TYPE_BYTE,&AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->auto_channel);
			
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_BYTE,&AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->diversity);

		dbus_message_iter_append_basic (&iter,DBUS_TYPE_BYTE,&AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->txantenna);

		dbus_message_iter_open_container (&iter,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_UINT32_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_UINT32_AS_STRING
												DBUS_TYPE_UINT32_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_UINT32_AS_STRING
												DBUS_TYPE_UINT32_AS_STRING
												DBUS_TYPE_UINT32_AS_STRING
												DBUS_TYPE_UINT32_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_STRING_AS_STRING
												DBUS_TYPE_UINT32_AS_STRING
										DBUS_STRUCT_END_CHAR_AS_STRING,
										&iter_array);

		for(i = 0; i < L_BSS_NUM; i++)
		{		
			if(AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i] != NULL)
			{
				DBusMessageIter iter_struct;
					
				dbus_message_iter_open_container (&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);

				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_UINT32,&AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->BSSIndex);
					
				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->WlanID); 

				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&(AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->BSSID[0]));
		
				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&(AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->BSSID[1]));

				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&(AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->BSSID[2]));

				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&(AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->BSSID[3]));

				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&(AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->BSSID[4]));

				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&(AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->BSSID[5]));

				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_UINT32,&AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->vlanid);

				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_UINT32,&AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->wlan_vlanid);
				
				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->State);

				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->BSS_IF_POLICY);
				
				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->BSS_TUNNEL_POLICY);

				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->ath_l2_isolation);

				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->cwmmode);

				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->traffic_limit_able);

				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_UINT32,&AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->traffic_limit);

				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_UINT32,&AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->average_rate);

				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_UINT32,&AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->send_traffic_limit);

				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_UINT32,&AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->send_average_rate);

				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->ip_mac_binding);
				memset(nas_id,0,NAS_IDENTIFIER_NAME+1);
				if(AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->nas_id_len != 0)
				{
					memcpy(nas_id,AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->nas_id,NAS_IDENTIFIER_NAME); 
				}
				else
				{
					memcpy(nas_id," ",1); 	
				}
				
				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_STRING,&nas_id);
				dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_UINT32,&AC_WTP[wtp_id]->WTP_Radio[l_radio_id]->BSS[i]->hotspot_id);
				dbus_message_iter_close_container (&iter_array, &iter_struct);
			}
		}
					
		dbus_message_iter_close_container (&iter, &iter_array);
	}			
	WID_FREE(nas_id);
	nas_id = NULL;
	return reply;	

}

DBusMessage * wid_dbus_interface_radio_show_channel_change_info(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	unsigned short interval = 0;
	unsigned short count = 0;
	unsigned int radio_id = 0;

	dbus_error_init(&err);
	
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radio_id,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	unsigned int wtp_id = radio_id/L_RADIO_NUM;

	ret = WID_CHECK_ID(WID_RADIO_CHECK,radio_id);
	
	if(ret != WID_DBUS_SUCCESS)
	{
		printf("radio id not correct. \n");
	}
	else if(AC_WTP[wtp_id] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radio_id] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else
	{
		interval = gapscanset.reportinterval;

		count = AC_RADIO[radio_id]->channelchangetime;
	}
	reply = dbus_message_new_method_return(msg);
				
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 
	if(ret == WID_DBUS_SUCCESS)
	{
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT16,&count); 

		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT16,&interval); 
	}
	return reply;	
}

////
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_radio_set_mode(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply = NULL;	
	DBusMessageIter	 iter;
	DBusError err;	
	
	int i = 0;
	int num =0 ;

	int Ratenum =0;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned int Radiomode = 0;

	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;

	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;
	struct Support_Rate_List *ptr = NULL;


	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&Radiomode,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else
				{
					ret = WID_RADIO_SET_MODE(ID,Radiomode);				
				}
			reply = dbus_message_new_method_return(msg);	
			dbus_message_iter_init_append (reply, &iter);
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &ret);
			if (ret == 0)
				{
					Ratenum = length_of_rate_list(AC_RADIO[ID]->Radio_Rate);
					//printf("set mode send %d ratenum\n",num);
					printf("Ratenum = %d\n",Ratenum);
					dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&Ratenum);			
					ptr = AC_RADIO[ID]->Radio_Rate;		
					for(i = 0; i < Ratenum; i++)
					{
						dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ptr->Rate);
						ptr = ptr->next;
						if(ptr == NULL)
							{
								return reply;
							}
					}
				}	
			return reply;
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					//int RADIOID[radionum]={0};
					//radio_num = (struct Radio_List *)malloc(radionum*(sizeof(struct Radio_List)));
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);

										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else
											{
												ret2 = WID_RADIO_SET_MODE(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,Radiomode);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d access into set mode\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
												//RADIOID[i]=AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
											}

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
												printf("ret2 = %d\n",ret2);
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
			
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if(ret == WID_DBUS_SUCCESS)
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 		 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}

			}
		printf("****************\n");
		return reply;
		} else {
			return reply;
		}
}

#else
DBusMessage * wid_dbus_interface_radio_set_mode(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	unsigned int RadioID;	
	unsigned int Radiomode;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	struct Support_Rate_List *ptr = NULL;
	int i = 0;
	int num =0;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_UINT32,&Radiomode,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_RADIO[RadioID] == NULL){
		ret = RADIO_ID_NOT_EXIST;
	}else{
		ret = WID_RADIO_SET_MODE(RadioID,Radiomode);
				
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);

	if (ret == 0)
	{
		num = length_of_rate_list(AC_RADIO[RadioID]->Radio_Rate);

		//printf("set mode send %d ratenum\n",num);

		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&num);
				
		ptr = AC_RADIO[RadioID]->Radio_Rate;

		
		
		for(i = 0; i < num; i++)
		{
			dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ptr->Rate);
			ptr = ptr->next;
			if(ptr == NULL)
			{
				return reply;
			}
		}
	}	
	return reply;	
}
#endif
#if _GROUP_POLICY

//added end
DBusMessage * wid_dbus_interface_radio_set_beacon(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	DBusError err;

	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned short beaconinterval= 0;

	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,	
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT16,&beaconinterval,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else
				{
					ret = WID_RADIO_SET_BEACON(ID,beaconinterval);	
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);

										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else
											{
												ret2 = WID_RADIO_SET_BEACON(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,beaconinterval);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d access into set beacon\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;

	

}

#else
//added end
DBusMessage * wid_dbus_interface_radio_set_beacon(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	unsigned int RadioID;	
	unsigned short beaconinterval;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_UINT16,&beaconinterval,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_RADIO[RadioID] == NULL){
		ret = RADIO_ID_NOT_EXIST;
	}else{
		ret = WID_RADIO_SET_BEACON(RadioID,beaconinterval);
				
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	

}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_radio_set_fragmentation(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	DBusError err;	
	
	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned short fragmentation = 0;

	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT16,&fragmentation,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else
				{
					ret = WID_RADIO_SET_FRAGMENTATION(ID,fragmentation);
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);

										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else
											{
												ret2 = WID_RADIO_SET_FRAGMENTATION(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,fragmentation);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d access into set fragmentation\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;

}

#else
DBusMessage * wid_dbus_interface_radio_set_fragmentation(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	unsigned int RadioID;	
	unsigned short fragmentation;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_UINT16,&fragmentation,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_RADIO[RadioID] == NULL){
		ret = RADIO_ID_NOT_EXIST;
	}else{
		ret = WID_RADIO_SET_FRAGMENTATION(RadioID,fragmentation);
				
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	

}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_radio_set_dtim(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	DBusError err;	

	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned char dtim = 0;

	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&dtim,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else
				{
					ret = WID_RADIO_SET_DTIM(ID,dtim);				
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);

										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else
											{
												ret2 = WID_RADIO_SET_DTIM(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,dtim);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d access into set dtim\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;

}

#else
DBusMessage * wid_dbus_interface_radio_set_dtim(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	unsigned int RadioID;	
	unsigned char dtim;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_BYTE,&dtim,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_RADIO[RadioID] == NULL){
		ret = RADIO_ID_NOT_EXIST;
	}else{
		ret = WID_RADIO_SET_DTIM(RadioID,dtim);
				
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	

}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_radio_set_rtsthreshold(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	DBusError err;

	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned short rtsthre = 0;

	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT16,&rtsthre,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else
				{
					ret = WID_RADIO_SET_RTSTHRESHOLD(ID,rtsthre);			
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);

										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else
											{
												ret2 = WID_RADIO_SET_RTSTHRESHOLD(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,rtsthre);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d access into set rtsthre\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;
}

#else
DBusMessage * wid_dbus_interface_radio_set_rtsthreshold(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	unsigned int RadioID;	
	unsigned short rtsthre;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_UINT16,&rtsthre,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_RADIO[RadioID] == NULL){
		ret = RADIO_ID_NOT_EXIST;
	}else{
		ret = WID_RADIO_SET_RTSTHRESHOLD(RadioID,rtsthre);
				
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	

}
#endif
/* wcl add for RDIR-33 */
DBusMessage * wid_dbus_interface_radio_set_acktimeout_distance(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	unsigned int RadioID;	
	unsigned int distance;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_UINT32,&distance,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	//printf("able is %d\n",able);
	if(AC_RADIO[RadioID] == NULL){
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_RADIO[RadioID]->isBinddingWlan == 0)
	{
		ret = RADIO_NO_BINDING_WLAN;
	}
	else
	{
		AC_RADIO[RadioID]->ack.Type = RADIO;
		AC_RADIO[RadioID]->ack.Op = ACK_timeout;
		AC_RADIO[RadioID]->ack.L_RadioID = RadioID%L_RADIO_NUM;
		AC_RADIO[RadioID]->ack.state = 0;
		AC_RADIO[RadioID]->ack.distance = distance;
		ret = wid_radio_set_acktimeout_distance(RadioID);
				
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	

}
#if _GROUP_POLICY

DBusMessage * wid_dbus_interface_radio_set_guardinterval(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	DBusError err;

	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned short guardinterval = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT16,&guardinterval,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID]->isBinddingWlan == 0)
				{
					ret = RADIO_NO_BINDING_WLAN;
				}
			else
				{
					if(AC_RADIO[ID]->guardinterval == guardinterval)
						{
							ret = 0;
						}
					else
						{
							AC_RADIO[ID]->guardinterval = guardinterval;
							ret = wid_radio_set_guard_interval(ID);
							WID_RADIO_CHANGE_SUPPORT_RATE_BYGI_MCS_CWMODE(ID);	//fengwenchao add 20110408
						}		
				}		
		}

	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);

										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->isBinddingWlan == 0)
											{
												ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT binding wlan id\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else
											{
												if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->guardinterval == guardinterval)
													{
														ret2 = 0;
														wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d had this guardinterval yet\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
													}
												else
													{
														AC_WTP[tmp->WTPID]->WTP_Radio[i]->guardinterval = guardinterval;
														ret2 = wid_radio_set_guard_interval(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
														WID_RADIO_CHANGE_SUPPORT_RATE_BYGI_MCS_CWMODE(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);	//fengwenchao add 20110408
														wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d access into set guard interval\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
													}		
											}	

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;

}

#else
DBusMessage * wid_dbus_interface_radio_set_guardinterval(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	unsigned int RadioID;	
	unsigned short guardinterval;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_UINT16,&guardinterval,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_RADIO[RadioID] == NULL){
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_RADIO[RadioID]->isBinddingWlan == 0)
	{
		ret = RADIO_NO_BINDING_WLAN;
	}
	else{
		if(AC_RADIO[RadioID]->guardinterval == guardinterval)
		{
			ret = 0;
		}else{
			AC_RADIO[RadioID]->guardinterval = guardinterval;
			ret = wid_radio_set_guard_interval(RadioID);
			WID_RADIO_CHANGE_SUPPORT_RATE_BYGI_MCS_CWMODE(RadioID);	  //fengwenchao add 20110408
		}		
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	

}
#endif
#if _GROUP_POLICY
/* zhangshu modify for set amsdu, 2010-10-09 */
DBusMessage * wid_dbus_interface_radio_set_ampdu_able(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	DBusError err;
	
	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int TYPE = 0;
	
	unsigned char type = 0;
	unsigned char able = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&TYPE,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&able,
								DBUS_TYPE_BYTE,&type,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(TYPE==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID]->isBinddingWlan == 0)
				{
					ret = RADIO_NO_BINDING_WLAN;
				}
			else if((AC_RADIO[ID]->Radio_Type&IEEE80211_11N) != IEEE80211_11N)
				{
					ret = RADIO_MODE_IS_11N;
				}
			else
				{
	    			if(type == 1)
	    				{
	        				if(AC_RADIO[ID]->Ampdu.Able == able)
    							{
    								ret = WID_DBUS_SUCCESS;
    							}
    						if((able == 1) && (AC_RADIO[ID]->Amsdu.Able == 1))
    							{
    		    					ret = RADIO_11N_AMSDU_MUTEX;
    							}
    						else
    							{
        							AC_RADIO[ID]->Ampdu.Type = RADIO;
        							AC_RADIO[ID]->Ampdu.Op = Ampdu_op;
        							AC_RADIO[ID]->Ampdu.L_RadioID = ID%L_RADIO_NUM;
        							AC_RADIO[ID]->Ampdu.WlanID = AC_RADIO[ID]->Wlan_Id->wlanid;/*send one of binding wlanid*/
        							AC_RADIO[ID]->Ampdu.Able = able;
        							ret = wid_radio_set_ampdu_able(ID, type);
    							}
	    				}
					else
						{
		    				if(AC_RADIO[ID]->Amsdu.Able == able)
    							{
    								ret = WID_DBUS_SUCCESS;
    							}
    						if((able == 1) && (AC_RADIO[ID]->Ampdu.Able == 1))
    							{
    		    					ret = RADIO_11N_AMPDU_MUTEX;
    							}
    						else
    							{
        							AC_RADIO[ID]->Amsdu.Type = RADIO;
        							AC_RADIO[ID]->Amsdu.Op = Amsdu_op;
        							AC_RADIO[ID]->Amsdu.L_RadioID = ID%L_RADIO_NUM;
        							AC_RADIO[ID]->Amsdu.WlanID = AC_RADIO[ID]->Wlan_Id->wlanid;/*send one of binding wlanid*/
        							AC_RADIO[ID]->Amsdu.Able = able;
        							ret = wid_radio_set_ampdu_able(ID, type);
    							}
						}
				
				}
	
		}
	else if(TYPE == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);

										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->isBinddingWlan == 0)
											{
												ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT binding wlan id\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if((AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_Type&IEEE80211_11N) != IEEE80211_11N)
											{
												ret2 = RADIO_MODE_IS_11N;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d mode is 11N\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else
											{
												if(type == 1)
													{
		    											if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Ampdu.Able == able)
    														{
    															ret2 = WID_DBUS_SUCCESS;
																wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d had been %s yet\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,(able==1)?"enable":"disable");
    														}
														if((able == 1) && (AC_WTP[tmp->WTPID]->WTP_Radio[i]->Amsdu.Able == 1))
    														{
    		    												ret2 = RADIO_11N_AMSDU_MUTEX;
    														}
    													else
    														{
    		    												AC_WTP[tmp->WTPID]->WTP_Radio[i]->Ampdu.Type = RADIO;
        														AC_WTP[tmp->WTPID]->WTP_Radio[i]->Ampdu.Op = Ampdu_op;
        														AC_WTP[tmp->WTPID]->WTP_Radio[i]->Ampdu.L_RadioID = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_L_ID;
        														AC_WTP[tmp->WTPID]->WTP_Radio[i]->Ampdu.WlanID= AC_WTP[tmp->WTPID]->WTP_Radio[i]->Wlan_Id->wlanid;
																printf("AC_WTP[tmp->WTPID]->WTP_Radio[i]->Wlan_Id->wlanid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Wlan_Id->wlanid);
        														AC_WTP[tmp->WTPID]->WTP_Radio[i]->Ampdu.Able= able;
        										
        		    											ret2 = wid_radio_set_ampdu_able(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID, type);
																wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d set %s successful\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,(able==1)?"enable":"disable");
        															
    														}
													}
												else
													{
		    											if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Ampdu.Able == able)
    														{
    															ret2 = WID_DBUS_SUCCESS;
																wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d had been this %s yet\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,(able==1)?"enable":"disable");
    														}
														if((able == 1) && (AC_WTP[tmp->WTPID]->WTP_Radio[i]->Ampdu.Able == 1))
    														{
    		    												ret2 = RADIO_11N_AMPDU_MUTEX;
    														}
    													else
    														{
    		    												AC_WTP[tmp->WTPID]->WTP_Radio[i]->Amsdu.Type = RADIO;
        														AC_WTP[tmp->WTPID]->WTP_Radio[i]->Amsdu.Op = Amsdu_op;
        														AC_WTP[tmp->WTPID]->WTP_Radio[i]->Amsdu.L_RadioID = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_L_ID;
        														AC_WTP[tmp->WTPID]->WTP_Radio[i]->Amsdu.WlanID= AC_WTP[tmp->WTPID]->WTP_Radio[i]->Wlan_Id->wlanid;
																printf("AC_WTP[tmp->WTPID]->WTP_Radio[i]->Wlan_Id->wlanid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Wlan_Id->wlanid);
        														AC_WTP[tmp->WTPID]->WTP_Radio[i]->Ampdu.AmpduLimit= able;
        														
        		    											ret2 = wid_radio_set_ampdu_able(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID, type);
																wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d set %s successful\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,(able==1)?"enable":"disable");		
    														}
													}
											}	
										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((TYPE == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;
}

#else
/* zhangshu modify for set amsdu, 2010-10-09 */
DBusMessage * wid_dbus_interface_radio_set_ampdu_able(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	unsigned int RadioID;	
	unsigned char able;
	unsigned char type;
//	unsigned char wlan_id =0 ;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_BYTE,&able,
								DBUS_TYPE_BYTE,&type,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	//printf("able is %d\n",able);
	if(AC_RADIO[RadioID] == NULL){
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_RADIO[RadioID]->isBinddingWlan == 0)
	{
		ret = RADIO_NO_BINDING_WLAN;
	}
	else if((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11N) != IEEE80211_11N)
	{
		ret = RADIO_MODE_IS_11N;
	}
	else
	{
	    if(type == 1)
	    {
	        if(AC_RADIO[RadioID]->Ampdu.Able == able)
    		{
    			ret = WID_DBUS_SUCCESS;
    		}
    		if((able == 1) && (AC_RADIO[RadioID]->Amsdu.Able == 1))
    		{
    		    ret = RADIO_11N_AMSDU_MUTEX;
    		}
    		else
    		{
        		AC_RADIO[RadioID]->Ampdu.Type = RADIO;
        		AC_RADIO[RadioID]->Ampdu.Op = Ampdu_op;
        		AC_RADIO[RadioID]->Ampdu.L_RadioID = RadioID%L_RADIO_NUM;
        		AC_RADIO[RadioID]->Ampdu.WlanID = AC_RADIO[RadioID]->Wlan_Id->wlanid;/*send one of binding wlanid*/
        		AC_RADIO[RadioID]->Ampdu.Able = able;
        		ret = wid_radio_set_ampdu_able(RadioID, type);
    		}
	    }
		else
		{
		    if(AC_RADIO[RadioID]->Amsdu.Able == able)
    		{
    			ret = WID_DBUS_SUCCESS;
    		}
    		if((able == 1) && (AC_RADIO[RadioID]->Ampdu.Able == 1))
    		{
    		    ret = RADIO_11N_AMPDU_MUTEX;
    		}
    		else
    		{
        		AC_RADIO[RadioID]->Amsdu.Type = RADIO;
        		AC_RADIO[RadioID]->Amsdu.Op = Amsdu_op;
        		AC_RADIO[RadioID]->Amsdu.L_RadioID = RadioID%L_RADIO_NUM;
        		AC_RADIO[RadioID]->Amsdu.WlanID = AC_RADIO[RadioID]->Wlan_Id->wlanid;/*send one of binding wlanid*/
        		AC_RADIO[RadioID]->Amsdu.Able = able;
        		ret = wid_radio_set_ampdu_able(RadioID, type);
    		}
		}
				
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	wid_syslog_debug_debug(WID_DEFAULT,"set radio id is:%d, ampdu %s",RadioID,(able==1)?"enable":"disable");
	return reply;	

}
#endif
#if _GROUP_POLICY
/* zhangshu modify for 11n para, 2010-10-09 */
DBusMessage * wid_dbus_interface_radio_set_ampdu_limit(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	DBusError err;	
	
	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int TYPE = 0;
	unsigned int ampdulimit = 0;
	unsigned char type = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&TYPE,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&ampdulimit,
								DBUS_TYPE_BYTE,&type,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(TYPE==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID]->isBinddingWlan == 0)
				{
					ret = RADIO_NO_BINDING_WLAN;
				}
			else if((AC_RADIO[ID]->Radio_Type&IEEE80211_11N) != IEEE80211_11N)
				{
					ret = RADIO_MODE_IS_11N;
				}
			else
				{
					if(type == 1)
						{
		    				if(AC_RADIO[ID]->Ampdu.AmpduLimit == ampdulimit)
    							{
    								ret = WID_DBUS_SUCCESS;
    							}
    						else
    							{
    		    					AC_RADIO[ID]->Ampdu.Type = RADIO;
        							AC_RADIO[ID]->Ampdu.Op = Ampdu_op;
        							AC_RADIO[ID]->Ampdu.L_RadioID = ID%L_RADIO_NUM;
        							AC_RADIO[ID]->Ampdu.WlanID= AC_RADIO[ID]->Wlan_Id->wlanid;
        							AC_RADIO[ID]->Ampdu.AmpduLimit= ampdulimit;
        							if(AC_RADIO[ID]->Ampdu.Able == 1)
        								{
        		    						ret = wid_radio_set_ampdu_limit(ID, type);
        								}
    							}
						}
					else
						{
		    				if(AC_RADIO[ID]->Ampdu.AmpduLimit == ampdulimit)
    							{
    								ret = WID_DBUS_SUCCESS;
    							}
    						else
    							{
    		    					AC_RADIO[ID]->Amsdu.Type = RADIO;
        							AC_RADIO[ID]->Amsdu.Op = Amsdu_op;
        							AC_RADIO[ID]->Amsdu.L_RadioID = ID%L_RADIO_NUM;
        							AC_RADIO[ID]->Amsdu.WlanID= AC_RADIO[ID]->Wlan_Id->wlanid;
        							AC_RADIO[ID]->Amsdu.AmsduLimit= ampdulimit;
        							if(AC_RADIO[ID]->Amsdu.Able == 1)
        								{
        		    						ret = wid_radio_set_ampdu_limit(ID, type);
        								}
    							}
						}
				}		
		}
	else if(TYPE == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);

										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->isBinddingWlan == 0)
											{
												ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT binding wlan id\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if((AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_Type&IEEE80211_11N) != IEEE80211_11N)
											{
												ret2 = RADIO_MODE_IS_11N;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d mode is 11N\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else
											{
												if(type == 1)
													{
		    											if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Ampdu.AmpduLimit == ampdulimit)
    														{
    															ret2 = WID_DBUS_SUCCESS;
																wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d had been this ampdulimit %d yet\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,ampdulimit);
    														}
    													else
    														{
    		    												AC_WTP[tmp->WTPID]->WTP_Radio[i]->Ampdu.Type = RADIO;
        														AC_WTP[tmp->WTPID]->WTP_Radio[i]->Ampdu.Op = Ampdu_op;
        														AC_WTP[tmp->WTPID]->WTP_Radio[i]->Ampdu.L_RadioID = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_L_ID;
        														AC_WTP[tmp->WTPID]->WTP_Radio[i]->Ampdu.WlanID= AC_WTP[tmp->WTPID]->WTP_Radio[i]->Wlan_Id->wlanid;
																printf("AC_WTP[tmp->WTPID]->WTP_Radio[i]->Wlan_Id->wlanid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Wlan_Id->wlanid);
        														AC_WTP[tmp->WTPID]->WTP_Radio[i]->Ampdu.AmpduLimit= ampdulimit;
        														if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Ampdu.Able == 1)
        															{
        		    													ret2 = wid_radio_set_ampdu_limit(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID, type);
																		wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d set ampdulimit %d successful\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,ampdulimit);
        															}
    														}
													}
												else
													{
		    											if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Ampdu.AmpduLimit == ampdulimit)
    														{
    															ret2 = WID_DBUS_SUCCESS;
																wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d had been this ampdulimit %d yet\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,ampdulimit);
    														}
    													else
    														{
    		    												AC_WTP[tmp->WTPID]->WTP_Radio[i]->Amsdu.Type = RADIO;
        														AC_WTP[tmp->WTPID]->WTP_Radio[i]->Amsdu.Op = Amsdu_op;
        														AC_WTP[tmp->WTPID]->WTP_Radio[i]->Amsdu.L_RadioID = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_L_ID;
        														AC_WTP[tmp->WTPID]->WTP_Radio[i]->Amsdu.WlanID= AC_WTP[tmp->WTPID]->WTP_Radio[i]->Wlan_Id->wlanid;
																printf("AC_WTP[tmp->WTPID]->WTP_Radio[i]->Wlan_Id->wlanid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Wlan_Id->wlanid);
        														AC_WTP[tmp->WTPID]->WTP_Radio[i]->Ampdu.AmpduLimit= ampdulimit;
        														if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Amsdu.Able == 1)
        															{
        		    													ret2 = wid_radio_set_ampdu_limit(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID, type);
																		wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d set ampdulimit %d successful\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,ampdulimit);
        															}
    														}
													}
											}	
										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((TYPE == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;
}

#else
/* zhangshu modify for 11n para, 2010-10-09 */
DBusMessage * wid_dbus_interface_radio_set_ampdu_limit(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	unsigned int RadioID;	
	unsigned int ampdulimit;
//	unsigned char wlan_id = 0;
	unsigned char type = 0;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_UINT32,&ampdulimit,
								DBUS_TYPE_BYTE,&type,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_RADIO[RadioID] == NULL){
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_RADIO[RadioID]->isBinddingWlan == 0)
	{
		ret = RADIO_NO_BINDING_WLAN;
	}
	else if((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11N) != IEEE80211_11N)
	{
		ret = RADIO_MODE_IS_11N;
	}
	else{
		if(type == 1)
		{
		    if(AC_RADIO[RadioID]->Ampdu.AmpduLimit == ampdulimit)
    		{
    			ret = WID_DBUS_SUCCESS;
    		}
    		else
    		{
    		    AC_RADIO[RadioID]->Ampdu.Type = RADIO;
        		AC_RADIO[RadioID]->Ampdu.Op = Ampdu_op;
        		AC_RADIO[RadioID]->Ampdu.L_RadioID = RadioID%L_RADIO_NUM;
        		AC_RADIO[RadioID]->Ampdu.WlanID= AC_RADIO[RadioID]->Wlan_Id->wlanid;
        		AC_RADIO[RadioID]->Ampdu.AmpduLimit = ampdulimit;
        		if(AC_RADIO[RadioID]->Ampdu.Able == 1)
        		{
        		    ret = wid_radio_set_ampdu_limit(RadioID, type);
        		}
    		}
		}
		else
		{
		    if(AC_RADIO[RadioID]->Amsdu.AmsduLimit == ampdulimit)
    		{
    			ret = WID_DBUS_SUCCESS;
    		}
    		else
    		{
    		    AC_RADIO[RadioID]->Amsdu.Type = RADIO;
        		AC_RADIO[RadioID]->Amsdu.Op = Amsdu_op;
        		AC_RADIO[RadioID]->Amsdu.L_RadioID = RadioID%L_RADIO_NUM;
        		AC_RADIO[RadioID]->Amsdu.WlanID= AC_RADIO[RadioID]->Wlan_Id->wlanid;
        		AC_RADIO[RadioID]->Amsdu.AmsduLimit = ampdulimit;
        		if(AC_RADIO[RadioID]->Amsdu.Able == 1)
        		{
        		    ret = wid_radio_set_ampdu_limit(RadioID, type);
        		}
    		}
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	wid_syslog_debug_debug(WID_DEFAULT,"set radio id is:%d, AmpduLimit is %d",RadioID,ampdulimit);
	return reply;	

}
#endif
#if _GROUP_POLICY
/* zhangshu modify for 11n para, 2010-10-09 */
DBusMessage * wid_dbus_interface_radio_set_ampdu_subframe(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	DBusError err;
	
	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int TYPE = 0;
	unsigned char subframe = 0;
	unsigned char type = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&TYPE,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&subframe,
								DBUS_TYPE_BYTE,&type,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(TYPE==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID]->isBinddingWlan == 0)
				{
					ret = RADIO_NO_BINDING_WLAN;
				}
			else if((AC_RADIO[ID]->Radio_Type&IEEE80211_11N) != IEEE80211_11N)
				{
					ret = RADIO_MODE_IS_11N;
				}
			else
				{
					if(type == 1)
						{
		    				if(AC_RADIO[ID]->Ampdu.subframe == subframe)
    							{
    								ret = WID_DBUS_SUCCESS;
    							}
    						else
    							{
    		    					AC_RADIO[ID]->Ampdu.Type = RADIO;
        							AC_RADIO[ID]->Ampdu.Op = Ampdu_op;
        							AC_RADIO[ID]->Ampdu.L_RadioID = ID%L_RADIO_NUM;
        							AC_RADIO[ID]->Ampdu.WlanID= AC_RADIO[ID]->Wlan_Id->wlanid;
        							AC_RADIO[ID]->Ampdu.subframe= subframe;
        							if(AC_RADIO[ID]->Ampdu.Able == 1)
        								{
        		    						ret = wid_radio_set_ampdu_subframe(ID, type);
        								}
    							}
						}
					else
						{
		    				if(AC_RADIO[ID]->Amsdu.subframe == subframe)
    							{
    								ret = WID_DBUS_SUCCESS;
    							}
    						else
    							{
    		    					AC_RADIO[ID]->Amsdu.Type = RADIO;
        							AC_RADIO[ID]->Amsdu.Op = Amsdu_op;
        							AC_RADIO[ID]->Amsdu.L_RadioID = ID%L_RADIO_NUM;
        							AC_RADIO[ID]->Amsdu.WlanID= AC_RADIO[ID]->Wlan_Id->wlanid;
        							AC_RADIO[ID]->Amsdu.subframe= subframe;
        							if(AC_RADIO[ID]->Amsdu.Able == 1)
        								{
        		    						ret = wid_radio_set_ampdu_subframe(ID, type);
        								}
    							}
						}
				}		
		}
	else if(TYPE == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);

										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->isBinddingWlan == 0)
											{
												ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT binding wlan id\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if((AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_Type&IEEE80211_11N) != IEEE80211_11N)
											{
												ret2 = RADIO_MODE_IS_11N;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d mode is 11N\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else
											{
												if(type == 1)
													{
		    											if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Ampdu.subframe == subframe)
    														{
    															ret2 = WID_DBUS_SUCCESS;
																wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d had been this subframe %d yet\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,subframe);
    														}
    													else
    														{
    		    												AC_WTP[tmp->WTPID]->WTP_Radio[i]->Ampdu.Type = RADIO;
        														AC_WTP[tmp->WTPID]->WTP_Radio[i]->Ampdu.Op = Ampdu_op;
        														AC_WTP[tmp->WTPID]->WTP_Radio[i]->Ampdu.L_RadioID = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_L_ID;
        														AC_WTP[tmp->WTPID]->WTP_Radio[i]->Ampdu.WlanID= AC_WTP[tmp->WTPID]->WTP_Radio[i]->Wlan_Id->wlanid;
																printf("AC_WTP[tmp->WTPID]->WTP_Radio[i]->Wlan_Id->wlanid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Wlan_Id->wlanid);
        														AC_WTP[tmp->WTPID]->WTP_Radio[i]->Ampdu.subframe= subframe;
        														if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Ampdu.Able == 1)
        															{
        		    													ret2 = wid_radio_set_ampdu_subframe(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID, type);
																		wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d set subframe %d successful\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,subframe);
        															}
    														}
													}
												else
													{
		    											if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Amsdu.subframe == subframe)
    														{
    															ret2 = WID_DBUS_SUCCESS;
																wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d had been this subframe %d yet\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,subframe);
    														}
    													else
    														{
    		    												AC_WTP[tmp->WTPID]->WTP_Radio[i]->Amsdu.Type = RADIO;
        														AC_WTP[tmp->WTPID]->WTP_Radio[i]->Amsdu.Op = Amsdu_op;
        														AC_WTP[tmp->WTPID]->WTP_Radio[i]->Amsdu.L_RadioID = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_L_ID;
        														AC_WTP[tmp->WTPID]->WTP_Radio[i]->Amsdu.WlanID= AC_WTP[tmp->WTPID]->WTP_Radio[i]->Wlan_Id->wlanid;
																printf("AC_WTP[tmp->WTPID]->WTP_Radio[i]->Wlan_Id->wlanid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Wlan_Id->wlanid);
        														AC_WTP[tmp->WTPID]->WTP_Radio[i]->Amsdu.subframe= subframe;
        														if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Amsdu.Able == 1)
        															{
        		    													ret2 = wid_radio_set_ampdu_subframe(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID, type);
																		wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d set subframe %d successful\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,subframe);
        															}
    														}
													}
											}	
										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((TYPE == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;
}

#else
/* zhangshu modify for 11n para, 2010-10-09 */
DBusMessage * wid_dbus_interface_radio_set_ampdu_subframe(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	unsigned int RadioID;	
	unsigned char subframe = 0;
//	unsigned char wlan_id = 0;
	unsigned char type = 0;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_BYTE,&subframe,
								DBUS_TYPE_BYTE,&type,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_RADIO[RadioID] == NULL){
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_RADIO[RadioID]->isBinddingWlan == 0)
	{
		ret = RADIO_NO_BINDING_WLAN;
	}
	else if((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11N) != IEEE80211_11N)
	{
		ret = RADIO_MODE_IS_11N;
	}
	else{
		if(type == 1)
		{
		    if(AC_RADIO[RadioID]->Ampdu.subframe == subframe)
    		{
    			ret = WID_DBUS_SUCCESS;
    		}
    		else
    		{
    		    AC_RADIO[RadioID]->Ampdu.Type = RADIO;
        		AC_RADIO[RadioID]->Ampdu.Op = Ampdu_op;
        		AC_RADIO[RadioID]->Ampdu.L_RadioID = RadioID%L_RADIO_NUM;
        		AC_RADIO[RadioID]->Ampdu.WlanID= AC_RADIO[RadioID]->Wlan_Id->wlanid;
        		AC_RADIO[RadioID]->Ampdu.subframe= subframe;
        		if(AC_RADIO[RadioID]->Ampdu.Able == 1)
        		{
        		    ret = wid_radio_set_ampdu_subframe(RadioID, type);
        		}
    		}
		}
		else
		{
		    if(AC_RADIO[RadioID]->Amsdu.subframe == subframe)
    		{
    			ret = WID_DBUS_SUCCESS;
    		}
    		else
    		{
    		    AC_RADIO[RadioID]->Amsdu.Type = RADIO;
        		AC_RADIO[RadioID]->Amsdu.Op = Amsdu_op;
        		AC_RADIO[RadioID]->Amsdu.L_RadioID = RadioID%L_RADIO_NUM;
        		AC_RADIO[RadioID]->Amsdu.WlanID= AC_RADIO[RadioID]->Wlan_Id->wlanid;
        		AC_RADIO[RadioID]->Amsdu.subframe= subframe;
        		if(AC_RADIO[RadioID]->Amsdu.Able == 1)
        		{
        		    ret = wid_radio_set_ampdu_subframe(RadioID, type);
        		}
    		}
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	wid_syslog_debug_debug(WID_DEFAULT,"set radio id is:%d, subframe is %d",RadioID,subframe);
	return reply;	

}
#endif
#if _GROUP_POLICY

/*wuwl add 20100311*/
DBusMessage * wid_dbus_interface_radio_set_mixed_puren_switch(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	DBusError err;
	
	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	unsigned char mixed_puren_switch = 0;
	unsigned char wlan_id = 0;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&mixed_puren_switch,
								DBUS_TYPE_BYTE,&wlan_id,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	//printf("switch is %d\n",mixed_puren_switch);
	/*if(AC_RADIO[RadioID]->isBinddingWlan != 0){
		struct wlanid *wlanid_tmp = NULL;
		wlanid_tmp = AC_RADIO[RadioID]->Wlan_Id;
		if(wlanid_tmp){
			while((wlanid_tmp != NULL)&&(wlan_id != wlanid_tmp->wlanid)){
				wlanid_tmp = wlanid_tmp->next;
			}
			if(wlan_id != wlanid_tmp->wlanid){
				ret = RADIO_NO_BINDING_WLAN;
			}else{
			}
		}
	}
	if(ret == RADIO_NO_BINDING_WLAN){

	}
	else */
	if(type==0)
		{	
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_WLAN[wlan_id] == NULL)
				{
					ret = WLAN_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID]->isBinddingWlan == 0)
				{
					ret = RADIO_NO_BINDING_WLAN;
				}
			else if((AC_RADIO[ID]->Radio_Type&IEEE80211_11N) != IEEE80211_11N)
				{
					ret = RADIO_MODE_IS_11N;
				}
			else
				{
					struct wlanid *wlan_ID = AC_RADIO[ID]->Wlan_Id;
					while(wlan_ID != NULL)
						{	
							if(wlan_ID->wlanid == wlan_id)
								{
									ret = WID_DBUS_SUCCESS;
									break;
								}
							wlan_ID = wlan_ID->next;
						}
					if(wlan_ID == NULL)
						{
							ret = RADIO_NO_BINDING_WLAN;
						}
				
				}
			if(ret == WID_DBUS_SUCCESS)
				{
					if(AC_RADIO[ID]->MixedGreenfield.Mixed_Greenfield == mixed_puren_switch)
						{
							ret = WID_DBUS_SUCCESS;
						}
					AC_RADIO[ID]->MixedGreenfield.Type = WLAN;/*VAP*/
					AC_RADIO[ID]->MixedGreenfield.Op = Puren_mixed_op;
					AC_RADIO[ID]->MixedGreenfield.L_RadioID = ID;
					AC_RADIO[ID]->MixedGreenfield.WlanID = wlan_id;
					AC_RADIO[ID]->MixedGreenfield.Mixed_Greenfield = mixed_puren_switch;
					ret = wid_radio_set_mixed_puren_switch(ID);				
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);

										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WLAN[wlan_id] == NULL)
											{
												ret2 = WLAN_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WLANID is not exist\n");
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->isBinddingWlan == 0)
											{
												ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT binding wlan id\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if((AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_Type&IEEE80211_11N) != IEEE80211_11N)
											{
												ret2 = RADIO_MODE_IS_11N;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d mode is not 11N\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else
											{	
     	 							  			struct wlanid *wlan_ID = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Wlan_Id;
												while(wlan_ID != NULL)
													{	
														if(wlan_ID->wlanid == wlan_id)
															{
																ret2 = WID_DBUS_SUCCESS;
																break;
															}
														wlan_ID = wlan_ID->next;
													}
												if(wlan_ID == NULL)
													{
														ret2 = RADIO_NO_BINDING_WLAN;
													}
											}
										if(ret2 == WID_DBUS_SUCCESS)
											{
												if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->MixedGreenfield.Mixed_Greenfield == mixed_puren_switch)
													{
														ret2 = WID_DBUS_SUCCESS;
													}
												AC_WTP[tmp->WTPID]->WTP_Radio[i]->MixedGreenfield.Type = WLAN;/*VAP*/
												AC_WTP[tmp->WTPID]->WTP_Radio[i]->MixedGreenfield.Op = Puren_mixed_op;
												AC_WTP[tmp->WTPID]->WTP_Radio[i]->MixedGreenfield.L_RadioID = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												AC_WTP[tmp->WTPID]->WTP_Radio[i]->MixedGreenfield.WlanID = wlan_id;
												AC_WTP[tmp->WTPID]->WTP_Radio[i]->MixedGreenfield.Mixed_Greenfield = mixed_puren_switch;
												ret2 = wid_radio_set_mixed_puren_switch(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID); 
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d set mixed puren switch successful\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);

											}
										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
										}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		
		}
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;
}

#else
/*wuwl add 20100311*/
DBusMessage * wid_dbus_interface_radio_set_mixed_puren_switch(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	unsigned int RadioID;	
	unsigned char mixed_puren_switch = 0;
	unsigned char wlan_id = 0;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	//printf("in fuction set mixed puren\n");
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_BYTE,&wlan_id,
								DBUS_TYPE_BYTE,&mixed_puren_switch,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	//printf("switch is %d\n",mixed_puren_switch);
	/*if(AC_RADIO[RadioID]->isBinddingWlan != 0){
		struct wlanid *wlanid_tmp = NULL;
		wlanid_tmp = AC_RADIO[RadioID]->Wlan_Id;
		if(wlanid_tmp){
			while((wlanid_tmp != NULL)&&(wlan_id != wlanid_tmp->wlanid)){
				wlanid_tmp = wlanid_tmp->next;
			}
			if(wlan_id != wlanid_tmp->wlanid){
				ret = RADIO_NO_BINDING_WLAN;
			}else{
			}
		}
	}
	if(ret == RADIO_NO_BINDING_WLAN){

	}
	else */if(AC_RADIO[RadioID] == NULL){
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[wlan_id] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlan_id]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else if(AC_RADIO[RadioID]->isBinddingWlan == 0)
	{
		ret = RADIO_NO_BINDING_WLAN;
	}
	else if((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11N) != IEEE80211_11N)
	{
		ret = RADIO_MODE_IS_11N;
	}
	else if(((AC_RADIO[RadioID]->Radio_Type == 10)||(AC_RADIO[RadioID]->Radio_Type == 12))&&(mixed_puren_switch ==0)) //fengwenchao add 20120716 for autela-3057
	{
		ret = WID_DBUS_ERROR;
	}
	else{
		struct wlanid *wlan_ID = AC_RADIO[RadioID]->Wlan_Id;
		while(wlan_ID != NULL)
		{	
			if(wlan_ID->wlanid == wlan_id)
			{
				ret = WID_DBUS_SUCCESS;
				break;
			}
			wlan_ID = wlan_ID->next;
		}
		if(wlan_ID == NULL)
		{
			ret = RADIO_NO_BINDING_WLAN;
		}
		
	}
	if(ret == WID_DBUS_SUCCESS){
		if(AC_RADIO[RadioID]->MixedGreenfield.Mixed_Greenfield == mixed_puren_switch)
		{
			ret = WID_DBUS_SUCCESS;
		}
		AC_RADIO[RadioID]->MixedGreenfield.Type = WLAN;/*VAP*/
		AC_RADIO[RadioID]->MixedGreenfield.Op = Puren_mixed_op;
		AC_RADIO[RadioID]->MixedGreenfield.L_RadioID = RadioID;
		AC_RADIO[RadioID]->MixedGreenfield.WlanID = wlan_id;
		AC_RADIO[RadioID]->MixedGreenfield.Mixed_Greenfield = mixed_puren_switch;
		ret = wid_radio_set_mixed_puren_switch(RadioID);
				
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	

}
#endif
#if _GROUP_POLICY

/*wuwl add 20100313*/
DBusMessage * wid_dbus_interface_radio_set_channel_offset(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	DBusError err;
	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	char policy = 0;	// huxf
	unsigned int type = 0;
	unsigned int max_channel = 0;  //fengwenchao add 20110421   
	unsigned int min_channel = 0;  //fengwenchao add 20110421
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			wid_check_radio_max_min_channel(ID,&max_channel,&min_channel);  //fengwenchao add 20110421
			
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID]->isBinddingWlan == 0)
				{
					ret = WTP_IS_NOT_BINDING_WLAN_ID;
				}
			else if((AC_RADIO[ID]->Radio_Type&IEEE80211_11N) != IEEE80211_11N)
				{
					ret = RADIO_MODE_IS_11N;
				}
   			/*zhaoruijia,20100817,4020/40 .start*/
			else if(((AC_RADIO[ID]->Radio_Type&IEEE80211_11N) == IEEE80211_11N)&&
		       		(AC_RADIO[ID]->cwmode==0))
				{

        			ret = RADIO_HT_IS_NOT_40;
    			}
			 /*zhaoruijia,20100817,40end*/
		   /*fengwenchao copy from (zhaoruijia,20101230),if the current channel is larger than the max_channel or less than the min_channel ,we dont allow for set channel offset,start*/
			else if(policy == 1)
		    {				
				if(AC_RADIO[ID]->Radio_Chan > max_channel){
					ret = CHANNEL_CWMODE_HT40;
				}	
			}
			else if(policy == -1)
			{
				if(AC_RADIO[ID]->Radio_Chan < min_channel){
					ret = CHANNEL_CWMODE_HT40;
				}	
			}
		  /*fengwenchao copy from (zhaoruijia,20101230),if the current channel is larger than the max_channel or less than the min_channel ,we dont allow for set channel offset,end*/			 
			else{}
			if(ret == WID_DBUS_SUCCESS)
				{
					if(AC_RADIO[ID]->channel_offset == policy)
						{
							ret = WID_DBUS_SUCCESS;
						}
					else
						{
							AC_RADIO[ID]->channel_offset = policy;
							ret = wid_radio_set_channel_Extoffset(ID);
						}
				}
	
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
										
										wid_check_radio_max_min_channel(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,&max_channel,&min_channel);  //fengwenchao add 20110421

										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->isBinddingWlan == 0)
											{
												ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT binding wlan id\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if((AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_Type&IEEE80211_11N) != IEEE80211_11N)
											{
												ret2 = RADIO_MODE_IS_11N;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d mode is  not 11N\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(((AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_Type&IEEE80211_11N) == IEEE80211_11N)&&
		       									(AC_WTP[tmp->WTPID]->WTP_Radio[i]->cwmode==0))
											{
     	 							  			ret2 = RADIO_HT_IS_NOT_40;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d ht is not 40\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
    										}
										/*fengwenchao copy from (zhaoruijia,20101230),if the current channel is larger than the max_channel or less than the min_channel ,we dont allow for set channel offset,start*/
										else if(policy == 1)
									    {				
											if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_Chan > max_channel){
												ret2 = CHANNEL_CWMODE_HT40;
											}	
										}
										else if(policy == -1)
										{
											if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_Chan < min_channel){
												ret2 = CHANNEL_CWMODE_HT40;
											}	
										}
		                               /*fengwenchao copy from (zhaoruijia,20101230),if the current channel is larger than the max_channel or less than the min_channel ,we dont allow for set channel offset,end*/	
										if(ret2 == WID_DBUS_SUCCESS)
											{
												if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->channel_offset== policy)
													{
														ret2 = WID_DBUS_SUCCESS;
														wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d channel_offset had this policy yet\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
													}
												else
													{
														AC_WTP[tmp->WTPID]->WTP_Radio[i]->channel_offset = policy;
														ret2 = wid_radio_set_channel_Extoffset(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
														wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d set channel_offset successful\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
													}
											}
										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;
}

#else
/*wuwl add 20100313*/
DBusMessage * wid_dbus_interface_radio_set_channel_offset(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	unsigned int RadioID = 0;	
	unsigned int max_channel=0;
	unsigned int min_channel = 0;
	char policy = 0;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	//printf("in fuction set mixed puren\n");
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_BYTE,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	wid_check_radio_max_min_channel(RadioID,&max_channel,&min_channel);  //fengwenchao add 20110421

	if(AC_RADIO[RadioID] == NULL){
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_RADIO[RadioID]->isBinddingWlan == 0)
	{
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}
	else if((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11N) != IEEE80211_11N)
	{
		ret = RADIO_MODE_IS_11N;
	}
   /*zhaoruijia,20100817,4020/40 .start*/
	else if(((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11N) == IEEE80211_11N)&&
		       (AC_RADIO[RadioID]->cwmode==0))
	{

        ret = RADIO_HT_IS_NOT_40;
    }
	 /*zhaoruijia,20100817,40end*/
   /*zhaoruijia,20101230,if the current channel is larger than the max_channel or less than the min_channel ,we dont allow for set channel offset,start*/
	else if(policy == 1)
    {				
		if(AC_RADIO[RadioID]->Radio_Chan > max_channel){
			ret = CHANNEL_CWMODE_HT40;
		}	
	}
	else if(policy == -1)
	{
		if(AC_RADIO[RadioID]->Radio_Chan < min_channel){
			ret = CHANNEL_CWMODE_HT40;
		}	
	}
  /*zhaoruijia,20101230,if the current channel is larger than the max_channel or less than the min_channel ,we dont allow for set channel offset,end*/
    if(ret == WID_DBUS_SUCCESS){
		if(AC_RADIO[RadioID]->channel_offset == policy)
		{
			ret = WID_DBUS_SUCCESS;
		}else{
		    
			AC_RADIO[RadioID]->channel_offset = policy;
			ret = wid_radio_set_channel_Extoffset(RadioID);
		}	
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	if(ret == CHANNEL_CWMODE_HT40){

		dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &max_channel);
		dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &min_channel);
		dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_BYTE,
									 &AC_RADIO[RadioID]->Radio_Chan);

	}
	return reply;	

}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_radio_set_mcs(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	DBusError err;	

	int i = 0;
	int j = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int mcs_count = 0;
	int mcslist[32] = {0};
	unsigned int type = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret1 = 0;
	int ret2 = WID_DBUS_SUCCESS;
	int ret3 = 0;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;
//cs = (update_mcs_list *)WID_MALLOC(sizeof(mcs));
	//qiuchen change it
	dbus_error_init(&err);
	/* (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&mcs,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}*/
	dbus_message_iter_init(msg,&iter);

	dbus_message_iter_get_basic(&iter,&type);
	
	dbus_message_iter_next(&iter);
	dbus_message_iter_get_basic(&iter,&ID);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&mcs_count);
	//wid_syslog_debug_debug(WID_DEFAULT,"type is %d, count is %d.\n",type,mcs_count);//qiuchen add for test
	
	if(mcs_count){
		for(i=0;i<mcs_count;i++){
			
			dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&mcslist[i]);
			 
		}
	}
	
	
	if(type==0)
		{
		 
			for(i=0;i<mcs_count;i++){//qiuchen add
			if(AC_RADIO[ID] == NULL)
				{
					ret1 = RADIO_ID_NOT_EXIST;
					ret = ret || ret1;
				}
			/*fengwenchao add 20110408*/
			else if(AC_RADIO[ID]->chainmask_num == 1)
			{
				if(mcslist[i] > 7)
					ret1 = MCS_CROSS_THE_BORDER;
					ret = ret || ret1;
					 
					
			}
			else if(AC_RADIO[ID]->chainmask_num == 2)
			{
				if((mcslist[i] < 8)||(mcslist[i] > 15))
					ret1 = MCS_CROSS_THE_BORDER;
					ret = ret || ret1;
					 
			}
			else if(AC_RADIO[ID]->chainmask_num == 3)
			{
				if((mcslist[i] < 16)||(mcslist[i] > 23))  
					ret1 = MCS_CROSS_THE_BORDER;
					ret = ret || ret1;
				 
			}
			}
			/*fengwenchao add end*/
			if(ret == 0)      //fengwenchao modify 20110411
				{
					memset(AC_RADIO[ID]->mcs_list,0,32);//qiuchen add
					AC_RADIO[ID]->mcs_count = mcs_count;//qiuchen add
					for(i=0;i<mcs_count;i++){//qiuchen add
					AC_RADIO[ID]->mcs_list[i] = mcslist[i];//qiuchen add
				 
					}			
				
					ret = wid_radio_set_mcs(ID);
					WID_RADIO_CHANGE_SUPPORT_RATE_BYGI_MCS_CWMODE_1(ID,mcs_count);//fqiuchen change it
				}		
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
							//	struct tag_mcsid *temp = mcs->mcsidlist;
										for(j=0;j<mcs_count;j++){
											if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
												{
													ret3 = RADIO_ID_NOT_EXIST;
													ret2 = ret2 || ret3;
													wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
												}
										/*fengwenchao add 20110408*/
											else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->chainmask_num == 1)
											{
												if(mcslist[i] > 7){
													ret3 = MCS_CROSS_THE_BORDER;
													ret2 = ret2 || ret3;
													 
													wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d : chainmask_num = 1,but mcs > 7\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
												}
											}
											else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->chainmask_num == 2)
											{
												if((mcslist[i] < 8)||(mcslist[i] > 15)){
													ret3 = MCS_CROSS_THE_BORDER;
													ret2 = ret2 || ret3;
													 
													wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d : chainmask_num = 2,but mcs < 8 or mcs >15\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
												}
											}
											else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->chainmask_num == 3)
											{
												if((mcslist[i] < 16)||(mcslist[i] > 23)) {
													ret3 = MCS_CROSS_THE_BORDER; 
													ret2 = ret2 || ret3;
												 
													wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d : chainmask_num = 3,but mcs < 16 or mcs >23\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
												}
											}
										}
										/*fengwenchao add end*/
										if(ret2 == 0)      //fengwenchao modify 20110411
											{
												/*if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->mcs == mcs)
													{
														ret2 = 0;
														wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d had this mcs yet\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
													}
												else
													{*/	memset(AC_WTP[tmp->WTPID]->WTP_Radio[i]->mcs_list,0,32);//qiuchen add
													 	AC_WTP[tmp->WTPID]->WTP_Radio[i]->mcs_count = mcs_count;
														for(j=0;j<mcs_count;j++){
														AC_WTP[tmp->WTPID]->WTP_Radio[i]->mcs_list[j] = mcslist[j];//qiuchen change it.
														 
														}
														ret2 = wid_radio_set_mcs(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);	
														WID_RADIO_CHANGE_SUPPORT_RATE_BYGI_MCS_CWMODE_1(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,mcs_count);//qiuchen change it
														wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d access into set mcs\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
													//}
	
											}

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;	

}

#else
DBusMessage * wid_dbus_interface_radio_set_mcs(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply = NULL;	
	DBusMessageIter	 iter;
	unsigned int RadioID = 0;	
	int i =0;
	unsigned int mcs_count = 0;
	int mcslist[32] = {0};
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);

	/*fengwenchao copy from ht2.0 for requiremnets-407*/
	dbus_message_iter_init(msg,&iter);
	dbus_message_iter_get_basic(&iter,&RadioID);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&mcs_count);

	if(mcs_count > 0 )
	{		
		dbus_message_iter_next(&iter);	
		
		for (i = 0; i < mcs_count; i++) 
		{			
			dbus_message_iter_get_basic(&iter,&mcslist[i]);
			
			dbus_message_iter_next(&iter);			
		}
		
	}	
	/*fengwenchao copy end*/
	
	if(AC_RADIO[RadioID] == NULL){
		ret = RADIO_ID_NOT_EXIST;
	}else{
		/*fengwenchao add 20120314 for requirements-407*/
		memset(AC_RADIO[RadioID]->mcs_list,0,32);
		AC_RADIO[RadioID]->mcs_count = mcs_count;
		for (i = 0; i < mcs_count; i++) 
		{
			AC_RADIO[RadioID]->mcs_list[i] = mcslist[i];
		}
		/*fengwenchao add end*/

		ret = wid_radio_set_mcs_list(RadioID);
				
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	

}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_radio_set_cmmode(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	DBusError err;
	
	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned short cwmode = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	unsigned int max_channel=0;    //fengwenchao add 20110323
	unsigned int min_channel = 0;  //fengwenchao add 20110323	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT16,&cwmode,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	//fengwenchao add 20110322
		/*switch(gCOUNTRYCODE)
		   {
			 case COUNTRY_CHINA_CN : 
					{
						max_channel = 9;
						min_channel = 5;
					}

				     break;
			 case COUNTRY_EUROPE_EU : 
					{
						max_channel = 9;
						min_channel = 5;
				    }	
					    break;
			  case COUNTRY_USA_US : 
					{
						max_channel = 7;
						min_channel = 5;
					}
					break;
			  case COUNTRY_JAPAN_JP : 
								
					{
						max_channel = 10;
						min_channel = 5;
					}										
						break;
			   case COUNTRY_FRANCE_FR : 
					{
						max_channel = 7;
						min_channel = 5;
					}	
					   break;
			   case COUNTRY_SPAIN_ES : 
					{
						max_channel = 7;
						min_channel = 5;
					}	
						break;
                default : 
				break;
		     }*/
	//fengwenchao add end
	if(type==0)
		{
			wid_check_radio_max_min_channel(ID,&max_channel,&min_channel);  //fengwenchao add 20110421
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID]->isBinddingWlan == 0)
				{
					ret = WTP_IS_NOT_BINDING_WLAN_ID;
				}
		  /*zhaoruijia,20100825, 40 20/40 20.start*/
			else if(((AC_RADIO[ID]->channel_offset==1) || (AC_RADIO[ID]->channel_offset==-1))&&
		  		     	(0 == cwmode))
		  		{
        			ret = RADIO_CHANNEL_OFFSET_NEED_BE_RESET;
				}
		 /*zhaoruijia,20100825, 40 20/40 20.end*/
			 /*fengwenchao add 20110322,ht20ht20/40,ht40 start*/
			 else if((AC_RADIO[ID]->Radio_Chan > max_channel)&&((1 == cwmode)||(2 == cwmode))&&(AC_RADIO[ID]->cwmode == 0)){
			 
				   ret = CHANNEL_CROSS_THE_BORDER;	   /**/
			 }
			 
			 /*fengwenchao add 20110322,ht20ht20/40,ht40 end*/
			else
				{
					/*fengwenchao add 20110421,20 20/4040NONE*/
			 	    if((AC_RADIO[ID]->cwmode == 0)&&((1 == cwmode)||(2 == cwmode)))
					{      
					      AC_RADIO[ID]->channel_offset = 1;
				    }
		 			/*fengwenchao add end*/
						
					if(AC_RADIO[ID]->cwmode == cwmode)
						{
							ret = 0;
						}
					else
						{
							AC_RADIO[ID]->cwmode = cwmode;
							ret = wid_radio_set_cmmode(ID);
							WID_RADIO_CHANGE_SUPPORT_RATE_BYGI_MCS_CWMODE(ID);	//fengwenchao add 20110408
						}		
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);

										wid_check_radio_max_min_channel(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,&max_channel,&min_channel);  //fengwenchao add 20110421
										
										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										 else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->isBinddingWlan == 0)
											{
												   ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
												   wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT binding wlan\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										 /*zhaoruijia,20100825, 40 20/40 20.start*/
										   else if(((AC_WTP[tmp->WTPID]->WTP_Radio[i]->channel_offset==1) || (AC_WTP[tmp->WTPID]->WTP_Radio[i]->channel_offset==-1))&&
													   (0 == cwmode))
											   {
												   ret2 = RADIO_CHANNEL_OFFSET_NEED_BE_RESET;
												   wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d channel offset need be reset\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											   }
										/*zhaoruijia,20100825, 40 20/40 20.end*/
											/*fengwenchao add 20110322,ht20ht20/40,ht40 start*/
											 else if((AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_Chan > max_channel)&&((1 == cwmode)||(2 == cwmode))&&(AC_WTP[tmp->WTPID]->WTP_Radio[i]->cwmode == 0)){
											 
												   ret2 = CHANNEL_CROSS_THE_BORDER;	   /**/
												   wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d channel cross the border max channel\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											 }									 
			 								/*fengwenchao add 20110322,ht20ht20/40,ht40 end*/	 
										   else
											   {
													/*fengwenchao add 20110421,20 20/4040NONE*/
											 	    if((AC_WTP[tmp->WTPID]->WTP_Radio[i]->cwmode == 0)&&((1 == cwmode)||(2 == cwmode)))
													{      
													      AC_WTP[tmp->WTPID]->WTP_Radio[i]->channel_offset = 1;
												    }
										 			/*fengwenchao add end*/
																							   
												   if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->cwmode == cwmode)
													   {
														   ret2 = 0;
														   wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d had this CWmode yet\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
													   }
												   else
													   {
														   AC_WTP[tmp->WTPID]->WTP_Radio[i]->cwmode = cwmode;
														   ret2 = wid_radio_set_cmmode(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
														   WID_RADIO_CHANGE_SUPPORT_RATE_BYGI_MCS_CWMODE(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);	//fengwenchao add 20110408
														   wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d access into set cwmode\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
													   }	   
											   }

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
		//fengwenchao add 20110323
		if((type == 0)&&(ret == CHANNEL_CROSS_THE_BORDER))
			{					
				dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &max_channel);
				dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &min_channel);
				dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_BYTE,
											 &AC_RADIO[ID]->Radio_Chan);	
			}
		//fengwenchao add end		
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;	


}

#else
DBusMessage * wid_dbus_interface_radio_set_cmmode(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	unsigned int RadioID;	
	unsigned short cwmode;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	unsigned int max_channel = 0;   //fengwenchao add 20110323
	unsigned int min_channel = 0;   //fengwenchao add 20110323
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_UINT16,&cwmode,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	wid_check_radio_max_min_channel(RadioID,&max_channel,&min_channel);  //fengwenchao add 20110421

	if(AC_RADIO[RadioID] == NULL){
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_RADIO[RadioID]->isBinddingWlan == 0)
	{
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}
	else if((AC_RADIO[RadioID]->Radio_Type&IEEE80211_11N) != IEEE80211_11N)
	{
		ret = RADIO_MODE_IS_11N;
	}
	 /*fengwenchao add 20110322,ht20ht20/40,ht40 start*/
	 else if((AC_RADIO[RadioID]->Radio_Chan > max_channel)&&((1 == cwmode)||(2 == cwmode))&&(AC_RADIO[RadioID]->cwmode == 0)){
	 
		   ret = CHANNEL_CROSS_THE_BORDER;	   /**/
	 }
	 
	 /*fengwenchao add 20110322,ht20ht20/40,ht40 end*/	
	else{
		/*zhaoruijia,20100825, 40 20/40 20.start*/
  /*zhaoruijia,20101220, 40 20/40 200.start*/

	    if(((AC_RADIO[RadioID]->channel_offset==1) || (AC_RADIO[RadioID]->channel_offset==-1))&&
		       (0 == cwmode)){
      
		      AC_RADIO[RadioID]->channel_offset = 0;
	    }
 /*zhaoruijia,20101220, 40 20/40 200.end*/
 /*zhaoruijia,20100825, 40 20/40 20.end*/
 /*fengwenchao add 20110421,20 20/4040NONE*/
 	    if((AC_RADIO[RadioID]->cwmode == 0)&&((1 == cwmode)||(2 == cwmode)))
		{      
		      AC_RADIO[RadioID]->channel_offset = 1;
	    }
 /*fengwenchao add end*/
		if(AC_RADIO[RadioID]->cwmode == cwmode)
		{
			ret = 0;
		}else{
			AC_RADIO[RadioID]->cwmode = cwmode;
			WID_RADIO_CHANGE_SUPPORT_RATE_BYGI_MCS_CWMODE(RadioID);	//fengwenchao add 20110408
			ret = wid_radio_set_cmmode(RadioID);
		}		
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	//fengwenchao add 20110323
	if(ret == CHANNEL_CROSS_THE_BORDER){

		dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &max_channel);
		dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &min_channel);
		dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_BYTE,
									 &AC_RADIO[RadioID]->Radio_Chan);
	}	
	//fengwenchao add end
	return reply;	

}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_radio_set_wds_distance(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	DBusError err;	
	
	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned int distance = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	char command[80] = {0};
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,			
								DBUS_TYPE_UINT32,&type,					
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&distance,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(type==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID]->REFlag == 0)
				{
					ret = RADIO_NOT_SUPPORT_COMMAND;
				}
			else
				{
					if(AC_RADIO[ID]->distance != distance)
						{
							AC_RADIO[ID]->distance = distance;
							//memset(command, 0, 80);
							sprintf(command,"set wbeDistance %d",distance);
							printf("%s\n",command);
							wid_radio_set_extension_command(ID/L_RADIO_NUM,command);
						}
				}
	
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);

										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->REFlag == 0)
											{
												ret2 = RADIO_NOT_SUPPORT_COMMAND;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT support command\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else{
												if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->distance != distance)
													{
														AC_WTP[tmp->WTPID]->WTP_Radio[i]->distance = distance;
														//memset(command, 0, 80);
														sprintf(command,"set wbeDistance %d",distance);
														printf("%s\n",command);
														wid_radio_set_extension_command(tmp->WTPID,command);
														wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d set wds distance successful\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
													}

											}
										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;	


}

#else
DBusMessage * wid_dbus_interface_radio_set_wds_distance(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	unsigned int RadioID;	
	unsigned int distance;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	char command[80];
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_UINT32,&distance,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_RADIO[RadioID] == NULL){
		ret = RADIO_ID_NOT_EXIST;
	}else if(AC_RADIO[RadioID]->REFlag == 0){
		ret = RADIO_NOT_SUPPORT_COMMAND;
	}else{
		if(AC_RADIO[RadioID]->distance != distance){
			AC_RADIO[RadioID]->distance = distance;
			memset(command, 0, 80);
			sprintf(command,"set wbeDistance %d",distance);
			printf("%s\n",command);
			wid_radio_set_extension_command(RadioID/L_RADIO_NUM,command);
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	

}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_radio_set_wds_remote_brmac(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	DBusError err;

	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned int is_add = 0;
	unsigned char mac[MAC_LEN];
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	int ret_bridge = WID_DBUS_SUCCESS;
	char command[80] = {0};
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&is_add,
								DBUS_TYPE_BYTE,&mac[0],
								DBUS_TYPE_BYTE,&mac[1],
								DBUS_TYPE_BYTE,&mac[2],
								DBUS_TYPE_BYTE,&mac[3],
								DBUS_TYPE_BYTE,&mac[4],
								DBUS_TYPE_BYTE,&mac[5],
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	//printf("radioid %d\n",RadioID);
	if(type==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID]->REFlag == 0)
				{
					ret = RADIO_NOT_SUPPORT_COMMAND;
				}
			else
				{
					ret = wid_wds_remote_bridge_mac_op(ID, is_add, mac);
					printf("radioid %d\n",ID);
					if(ret == 0)
						{
							//memset(command, 0, 80);
							sprintf(command,"%s remoteWbr %02x:%02x:%02x:%02x:%02x:%02x",is_add?"add":"del",mac[0],mac[1],mac[2],mac[3],mac[4],mac[5]);
							printf("%s\n",command);
							wid_radio_set_extension_command(ID/L_RADIO_NUM,command);
						}
				}		
		}

	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);

										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->REFlag == 0)
											{
												ret2 = RADIO_NOT_SUPPORT_COMMAND;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT support command\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else{
											ret_bridge = wid_wds_remote_bridge_mac_op(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,is_add,mac);
											//printf("radioid %d\n",ID);
											if(ret_bridge == 0)
												{
													//memset(command, 0, 80);
													sprintf(command,"%s remoteWbr %02x:%02x:%02x:%02x:%02x:%02x",is_add?"add":"del",mac[0],mac[1],mac[2],mac[3],mac[4],mac[5]);
													printf("%s\n",command);
													wid_radio_set_extension_command(tmp->WTPID,command);
													wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d set remote brmac successful\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
												}

											}
										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;	


}

#else
DBusMessage * wid_dbus_interface_radio_set_wds_remote_brmac(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	unsigned int RadioID;	
	unsigned int is_add;
	unsigned char mac[MAC_LEN];
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	char command[80];
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_UINT32,&is_add,
								DBUS_TYPE_BYTE,&mac[0],
								DBUS_TYPE_BYTE,&mac[1],
								DBUS_TYPE_BYTE,&mac[2],
								DBUS_TYPE_BYTE,&mac[3],
								DBUS_TYPE_BYTE,&mac[4],
								DBUS_TYPE_BYTE,&mac[5],
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	printf("radioid %d\n",RadioID);
	if(AC_RADIO[RadioID] == NULL){
		ret = RADIO_ID_NOT_EXIST;
	}else if(AC_RADIO[RadioID]->REFlag == 0){
		ret = RADIO_NOT_SUPPORT_COMMAND;
	}else{
		ret = wid_wds_remote_bridge_mac_op(RadioID, is_add, mac);
		printf("radioid %d\n",RadioID);
		if(ret == 0){
			memset(command, 0, 80);
			sprintf(command,"%s remoteWbr %02x:%02x:%02x:%02x:%02x:%02x",is_add?"add":"del",mac[0],mac[1],mac[2],mac[3],mac[4],mac[5]);
			printf("%s\n",command);
			wid_radio_set_extension_command(RadioID/L_RADIO_NUM,command);
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	

}
#endif
#if _GROUP_POLICY

DBusMessage * wid_dbus_interface_radio_set_wds_wep_key(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	DBusError err;

	int len = 0;
	int i = 0;
	int num =0 ;
    int radionum = 0;
	char *key;
	unsigned int ID = 0;
	unsigned int type = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	char command[80];
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_STRING,&key,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(type==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID]->REFlag == 0)
				{
					ret = RADIO_NOT_SUPPORT_COMMAND;
				}
			else{
					printf("AC_RADIO[ID]->cipherType %d\n",AC_RADIO[ID]->cipherType);
					if(AC_RADIO[ID]->cipherType == 1)
						{
							memset(AC_RADIO[ID]->wepkey, 0, 32);
							memcpy(AC_RADIO[ID]->wepkey, key,strlen(key));
							memset(command, 0, 80);
							len = strlen(key);
							if((len == 5)||(len == 10))
								{
									len = 40;
								}
							else if((len == 13)||(len == 26))
								{
									len = 104;
								}
							sprintf(command,"set key 1 %d %s",len,key); 		
							printf("%s\n",command);
							wid_radio_set_extension_command(ID/L_RADIO_NUM,command);
						}
					else
						ret = RADIO_ENCRYPTION_NO_MATCH;
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);

										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->REFlag== 0)
											{
												ret2 = RADIO_NOT_SUPPORT_COMMAND;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT support command\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else{
												printf("AC_WTP[tmp->WTPID]->WTP_Radio[i]->cipherType %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->cipherType);
												if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->cipherType == 1)
													{
														memset(AC_WTP[tmp->WTPID]->WTP_Radio[i]->wepkey, 0, 32);
														memcpy(AC_WTP[tmp->WTPID]->WTP_Radio[i]->wepkey, key,strlen(key));
														memset(command, 0, 80);
														len = strlen(key);
														if((len == 5)||(len == 10))
															{
																len = 40;
															}
														else if((len == 13)||(len == 26))
															{
																len = 104;
															}
														sprintf(command,"set key 1 %d %s",len,key); 		
														printf("%s\n",command);
														ret2 = wid_radio_set_extension_command(tmp->WTPID,command);
														wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d set wds wep key successful\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
													}
												else
													ret2 = RADIO_ENCRYPTION_NO_MATCH;
											}

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;


}

#else
DBusMessage * wid_dbus_interface_radio_set_wds_wep_key(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	unsigned int RadioID;	
	unsigned char *key;
	int len = 0;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	char command[80];
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_STRING,&key,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_RADIO[RadioID] == NULL){
		ret = RADIO_ID_NOT_EXIST;
	}else if(AC_RADIO[RadioID]->REFlag == 0){
		ret = RADIO_NOT_SUPPORT_COMMAND;
	}else{
		printf("AC_RADIO[RadioID]->cipherType %d\n",AC_RADIO[RadioID]->cipherType);
		if(AC_RADIO[RadioID]->cipherType == 1){
			memset(AC_RADIO[RadioID]->wepkey, 0, 32);
			memcpy(AC_RADIO[RadioID]->wepkey, key,strlen((char*)key));
			memset(command, 0, 80);
			len = strlen((char*)key);
			if((len == 5)||(len == 10)){
				len = 40;
			}
			else if((len == 13)||(len == 26)){
				len = 104;
			}
			sprintf(command,"set key 1 %d %s",len,key);			
			printf("%s\n",command);
			wid_radio_set_extension_command(RadioID/L_RADIO_NUM,command);
		}else
			ret = RADIO_ENCRYPTION_NO_MATCH;
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	

}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_radio_set_wds_encryption_type(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	DBusError err;	
	
	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned int TYPE = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	char command[80] = {0};
	char buf[10] = {0};
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;	
	
	//memset(buf,0,10);
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&TYPE,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(TYPE==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID]->REFlag == 0)
				{
					ret = RADIO_NOT_SUPPORT_COMMAND;
				}
			else
				{
					if(AC_RADIO[ID]->cipherType != type)
						{
							AC_RADIO[ID]->cipherType = type;
							if(type == 0)
								{
									memcpy(buf,"disable", 7);
								}
							else if(type == 1)
								{
									memcpy(buf,"wep", 3);
								}
							else if(type == 2)
								{
									memcpy(buf,"aes", 3);
								}
							//memset(command, 0, 80);
							sprintf(command,"set cipher %s",buf);
							printf("%s\n",command);
							wid_radio_set_extension_command(ID/L_RADIO_NUM,command);
						}
				}
		}
	else if(TYPE == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);

										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->REFlag== 0)
											{
												ret2 = RADIO_NOT_SUPPORT_COMMAND;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT support command\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else{
												if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->cipherType != type)
													{
														AC_WTP[tmp->WTPID]->WTP_Radio[i]->cipherType = type;
														if(type == 0)
															{
																memcpy(buf,"disable", 7);
															}
														else if(type == 1)
															{
																memcpy(buf,"wep", 3);
															}
														else if(type == 2)
															{
																memcpy(buf,"aes", 3);
															}
														//memset(command, 0, 80);
														sprintf(command,"set cipher %s",buf);
														printf("%s\n",command);
														wid_radio_set_extension_command(tmp->WTPID,command);
														wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d set wds encryption type successful\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
													}

											}

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((TYPE == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;	



}

#else
DBusMessage * wid_dbus_interface_radio_set_wds_encryption_type(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	unsigned int RadioID;	
	unsigned int type;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	
	char command[80];
	char buf[10];
	memset(buf,0,10);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_RADIO[RadioID] == NULL){
		ret = RADIO_ID_NOT_EXIST;
	}else if(AC_RADIO[RadioID]->REFlag == 0){
		ret = RADIO_NOT_SUPPORT_COMMAND;
	}else{
		if(AC_RADIO[RadioID]->cipherType != type){
			AC_RADIO[RadioID]->cipherType = type;
			if(type == 0){
				memcpy(buf,"disable", 7);
			}
			else if(type == 1){
				memcpy(buf,"wep", 3);
			}
			else if(type == 2){
				memcpy(buf,"aes", 3);
			}
			memset(command, 0, 80);
			sprintf(command,"set cipher %s",buf);
			printf("%s\n",command);
			wid_radio_set_extension_command(RadioID/L_RADIO_NUM,command);
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	

}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_radio_set_wds_aes_key(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	DBusError err;

	int i = 0;
	int num =0 ;
    int radionum = 0;
	char *key;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned char mac[MAC_LEN];
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	int ret_set_key = WID_DBUS_SUCCESS;
	char command[80];
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_STRING,&key,
								DBUS_TYPE_BYTE,&mac[0],
								DBUS_TYPE_BYTE,&mac[1],
								DBUS_TYPE_BYTE,&mac[2],
								DBUS_TYPE_BYTE,&mac[3],
								DBUS_TYPE_BYTE,&mac[4],
								DBUS_TYPE_BYTE,&mac[5],
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(type==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID]->REFlag == 0)
				{
					ret = RADIO_NOT_SUPPORT_COMMAND;
				}
			else{
					ret = wid_wds_remote_bridge_mac_set_aes_key(ID, mac, key);
					if(ret == 0)
						{
							memset(command, 0, 80);
							sprintf(command,"set bridgekey %02x:%02x:%02x:%02x:%02x:%02x %s",mac[0],mac[1],mac[2],mac[3],mac[4],mac[5], key);
							printf("%s\n",command);
							wid_radio_set_extension_command(ID/L_RADIO_NUM,command);
						}
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);

										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->REFlag== 0)
											{
												ret2 = RADIO_NOT_SUPPORT_COMMAND;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT support command\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else{
												ret_set_key = wid_wds_remote_bridge_mac_set_aes_key(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID, mac, key);
												if(ret_set_key == 0)
													{
														memset(command, 0, 80);
														sprintf(command,"set bridgekey %02x:%02x:%02x:%02x:%02x:%02x %s",mac[0],mac[1],mac[2],mac[3],mac[4],mac[5], key);
														printf("%s\n",command);
														wid_radio_set_extension_command(tmp->WTPID,command);
														wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d set wds aes key successful\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
														ret2 = 0;
													}
											}

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;
	
}

#else
DBusMessage * wid_dbus_interface_radio_set_wds_aes_key(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	unsigned int RadioID;	
	char *key;
	unsigned char mac[MAC_LEN];
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	char command[80];
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_STRING,&key,
								DBUS_TYPE_BYTE,&mac[0],
								DBUS_TYPE_BYTE,&mac[1],
								DBUS_TYPE_BYTE,&mac[2],
								DBUS_TYPE_BYTE,&mac[3],
								DBUS_TYPE_BYTE,&mac[4],
								DBUS_TYPE_BYTE,&mac[5],
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_RADIO[RadioID] == NULL){
		ret = RADIO_ID_NOT_EXIST;
	}else if(AC_RADIO[RadioID]->REFlag == 0){
		ret = RADIO_NOT_SUPPORT_COMMAND;
	}else{
		ret = wid_wds_remote_bridge_mac_set_aes_key(RadioID, mac, key);
		if(ret == 0){
			memset(command, 0, 80);
			sprintf(command,"set bridgekey %02x:%02x:%02x:%02x:%02x:%02x %s",mac[0],mac[1],mac[2],mac[3],mac[4],mac[5], key);
			printf("%s\n",command);
			wid_radio_set_extension_command(RadioID/L_RADIO_NUM,command);
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	

}

#endif

#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_radio_set_status(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	DBusError err;	

	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned char status = 0;

	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;

	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,	
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&status,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else
				{
					ret = WID_RADIO_SET_STATUS(ID,status);				
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);

										if(AC_WTP[tmp->WTPID]->WTP_Radio[i] == NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d RADIO%d is not exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else
											{
												ret2 = WID_RADIO_SET_STATUS(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,status);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d RADIO%d access into set status\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
												
											}

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}		
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
	return reply;	

	

}

#else
DBusMessage * wid_dbus_interface_radio_set_status(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	unsigned int RadioID;	
	unsigned char status;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_BYTE,&status,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_RADIO[RadioID] == NULL){
		ret = RADIO_ID_NOT_EXIST;
	}else{
		ret = WID_RADIO_SET_STATUS(RadioID,status);
				
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	

}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_radio_set_wds_status(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter  iter;
	DBusError err;	
	
	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned char status = 0;
	unsigned char WLANID = 0;

	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;

	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&WLANID,
								DBUS_TYPE_BYTE,&status,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else
				{
					ret = WID_RADIO_SET_WDS_STATUS(ID,WLANID,status);		
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);

										if(AC_WTP[tmp->WTPID]->WTP_Radio[i] == NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d RADIO%d is not exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else
											{
												ret2 = WID_RADIO_SET_WDS_STATUS(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,WLANID,status);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d RADIO%d access into set wds status\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
												
											}

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}		
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
	return reply;	

}

#else
DBusMessage * wid_dbus_interface_radio_set_wds_status(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter  iter;
	unsigned int RadioID;	
	unsigned char status;
	unsigned char WLANID;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&WLANID,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_BYTE,&status,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_RADIO[RadioID] == NULL){
		ret = RADIO_ID_NOT_EXIST;
	}else{
		ret = WID_RADIO_SET_WDS_STATUS(RadioID,WLANID,status);
				
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	

}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_radio_set_preamble(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	DBusError err;	

	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned char preamble = 0;

	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;

	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;


	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&preamble,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else
				{
					ret = WID_RADIO_SET_PREAMBLE(ID,preamble);				
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);

										if(AC_WTP[tmp->WTPID]->WTP_Radio[i] == NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d RADIO%d is not exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else
											{
												ret2 = WID_RADIO_SET_PREAMBLE(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,preamble);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d RADIO%d access into set preamble\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
												
											}

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}		
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
	return reply;	
}

#else
DBusMessage * wid_dbus_interface_radio_set_preamble(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	unsigned int RadioID;	
	unsigned char preamble;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_BYTE,&preamble,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_RADIO[RadioID] == NULL){
		ret = RADIO_ID_NOT_EXIST;
	}else{
		ret = WID_RADIO_SET_PREAMBLE(RadioID,preamble);
				
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	

}
#endif
#if _GROUP_POLICY

DBusMessage * wid_dbus_interface_radio_set_shortretry(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	DBusError err;

	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned char shortretry = 0;

	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;

	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&shortretry,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else
				{
					ret = WID_RADIO_SET_SHORTRETRY(ID,shortretry);
					
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);

										if(AC_WTP[tmp->WTPID]->WTP_Radio[i] == NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d RADIO%d is not exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else
											{
												ret2 = WID_RADIO_SET_SHORTRETRY(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,shortretry);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d RADIO%d access into set shortretry\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
												
											}

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
	return reply;	
}

#else
DBusMessage * wid_dbus_interface_radio_set_shortretry(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	unsigned int RadioID;	
	unsigned char shortretry;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_BYTE,&shortretry,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_RADIO[RadioID] == NULL){
		ret = RADIO_ID_NOT_EXIST;
	}else{
		ret = WID_RADIO_SET_SHORTRETRY(RadioID,shortretry);
				
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	

}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_radio_set_longretry(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	DBusError err;
	
	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned char longretry = 0;

	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;

	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&longretry,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else
				{
					ret = WID_RADIO_SET_LONGRETRY(ID,longretry);
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);

										if(AC_WTP[tmp->WTPID]->WTP_Radio[i] == NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d RADIO%d is not exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else
											{
												ret2 =  WID_RADIO_SET_LONGRETRY(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,longretry);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d RADIO%d access into set longretry\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
												
											}

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
	return reply;	

	


}

#else
DBusMessage * wid_dbus_interface_radio_set_longretry(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	unsigned int RadioID;	
	unsigned char longretry;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_BYTE,&longretry,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_RADIO[RadioID] == NULL){
		ret = RADIO_ID_NOT_EXIST;
	}else{
		ret = WID_RADIO_SET_LONGRETRY(RadioID,longretry);
				
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	

}
#endif
#if _GROUP_POLICY
DBusMessage *wid_dbus_radio_wlan_wds_mac_op(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 	
	DBusMessageIter  iter;
	DBusError err;

	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned char wlanid=0;
	unsigned char list_type=0;	//1--black list, 2--white list
	unsigned char *mac = NULL;
	mac = (unsigned char*)WID_MALLOC(6);
	memset(mac, 0, 6);

	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;

	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,	
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_BYTE,&list_type,
								DBUS_TYPE_BYTE,&mac[0],
								DBUS_TYPE_BYTE,&mac[1],
								DBUS_TYPE_BYTE,&mac[2],
								DBUS_TYPE_BYTE,&mac[3],
								DBUS_TYPE_BYTE,&mac[4],
								DBUS_TYPE_BYTE,&mac[5],
								DBUS_TYPE_INVALID))){
	
				
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(type==0)
		{
			if(AC_WLAN[wlanid] == NULL)
					ret = WLAN_ID_NOT_EXIST;
			else
				{
					ret = WID_WDS_BSSID_OP(ID,wlanid,mac,list_type);
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);

										if(AC_WLAN[wlanid] == NULL)
											{
												ret2 = WLAN_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"wlan id is not exist\n");
											}
											
										else
											{
												ret2 = WID_WDS_BSSID_OP(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,wlanid,mac,list_type);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d RADIO%d access into wds bssid op\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}

	WID_FREE(mac);
	mac = NULL;
	return reply;	
}

#else
DBusMessage *wid_dbus_radio_wlan_wds_mac_op(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 	
	DBusMessageIter  iter;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;

	unsigned int RadioID;
	unsigned char wlanid=0;
	unsigned char list_type=0;	//1--black list, 2--white list
	unsigned char *mac;
	mac = (unsigned char*)WID_MALLOC(6);
	memset(mac, 0, 6);


	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_BYTE,&list_type,
								DBUS_TYPE_BYTE,&mac[0],
								DBUS_TYPE_BYTE,&mac[1],
								DBUS_TYPE_BYTE,&mac[2],
								DBUS_TYPE_BYTE,&mac[3],
								DBUS_TYPE_BYTE,&mac[4],
								DBUS_TYPE_BYTE,&mac[5],
								DBUS_TYPE_INVALID))){
	
				
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(AC_WLAN[wlanid] == NULL)
		ret = WLAN_ID_NOT_EXIST;
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else {
		ret = WID_WDS_BSSID_OP(RadioID,wlanid,mac,list_type);
	}

	reply = dbus_message_new_method_return(msg);
			
	dbus_message_iter_init_append (reply, &iter);	

	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 

	WID_FREE(mac);
	mac = NULL;
	return reply;	
}
#endif
DBusMessage * wid_dbus_interface_show_wds_bssid_list(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	unsigned char WlanID;
	unsigned int RadioID;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	unsigned int BSSIndex;
	int i;	
	unsigned int num = 0;
	unsigned char *bssid;
	bssid = (unsigned char*)WID_MALLOC(MAC_LEN);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&WlanID,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		CW_FREE_OBJECT_WID(bssid);
		return NULL;
	}
	BSSIndex = RadioID*L_BSS_NUM;
	for(i=0;i<L_BSS_NUM;i++){
		if((AC_BSS[BSSIndex] != NULL)&&(AC_BSS[BSSIndex]->WlanID == WlanID) && (AC_WLAN[WlanID] != NULL && AC_WLAN[WlanID]->want_to_delete != 1))		/* Huangleilei add for ASXXZFI-1622 */
			break;
		BSSIndex += i;
		continue;
	}
	if(i == L_BSS_NUM){
		ret = WLAN_ID_NOT_EXIST;
		if (AC_WLAN[WlanID] != NULL && AC_WLAN[WlanID]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
		{
			ret = WID_WANT_TO_DELETE_WLAN;
		}
		reply = dbus_message_new_method_return(msg);
			
		dbus_message_iter_init_append (reply, &iter);
		
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &ret);
	}else{
		struct wds_bssid *wds = AC_BSS[BSSIndex]->wds_bss_list;
		while(wds != NULL){
			num++;
			wds = wds->next;
		}
		printf("wds bssid num %d\n",num);
		reply = dbus_message_new_method_return(msg);
			
		dbus_message_iter_init_append (reply, &iter);
			
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &ret);
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &num);
			
		dbus_message_iter_open_container (&iter,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
										DBUS_STRUCT_END_CHAR_AS_STRING,
										&iter_array);
		wds = AC_BSS[BSSIndex]->wds_bss_list;	
		for(i = 0; i < num; i++){	
			memset(bssid, 0, MAC_LEN);
			memcpy(bssid, wds->BSSID,MAC_LEN);
			DBusMessageIter iter_struct;
			dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
		
			dbus_message_iter_append_basic (&iter_struct,
											 DBUS_TYPE_BYTE,
											 &(bssid[0]));
			dbus_message_iter_append_basic (&iter_struct,
											 DBUS_TYPE_BYTE,
											 &(bssid[1]));
			dbus_message_iter_append_basic (&iter_struct,
											 DBUS_TYPE_BYTE,
											 &(bssid[2]));
			dbus_message_iter_append_basic (&iter_struct,
											 DBUS_TYPE_BYTE,
											 &(bssid[3]));
			dbus_message_iter_append_basic (&iter_struct,
											 DBUS_TYPE_BYTE,
											 &(bssid[4]));
			dbus_message_iter_append_basic (&iter_struct,
											 DBUS_TYPE_BYTE,
											 &(bssid[5]));			
			
			wds = wds->next;
			dbus_message_iter_close_container (&iter_array, &iter_struct);
		}
		dbus_message_iter_close_container (&iter, &iter_array);
				
	}
	WID_FREE(bssid);
	return reply;	
}



//qos area
DBusMessage *wid_dbus_interface_qos_add_del_qos(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage * reply;
	DBusMessageIter	 iter;
	int isAdd;
	char* QosName;
	int QosID;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	int i;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&isAdd,								
								DBUS_TYPE_UINT32,&QosID,
								DBUS_TYPE_STRING,&QosName,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(isAdd)
	{
		if(WID_QOS[QosID] == NULL)
		{
			ret = WID_ADD_QOS_PROFILE(QosName,QosID);
		}
		else
		{
			ret = WID_QOS_BE_USED;
		}
	}
	else
	{
		if(WID_QOS[QosID] == NULL)
		{
			ret = WID_QOS_NOT_EXIST;
		}
		else
		{
			/*for(i = 0; i < G_RADIO_NUM; i++)
			{
				if((AC_RADIO[i]!=NULL)&&(AC_RADIO[i]->AdStat == 0)&&(AC_RADIO[i]->QOSID == QosID))
				{
					ret = WID_QOS_RADIO_SHOULD_BE_DISABLE;
					break;
				}
				else
				{
					continue;
				}
			}
			if(ret == 0)
			{
				for(i = 0; i < G_RADIO_NUM; i++)
				{
					printf("AC_RADIO[%d]->AdStat = %d  \n",i,AC_RADIO[i]->AdStat);
					printf("AC_RADIO[%d]->QOSID = %d \n",i,AC_RADIO[i]->QOSID);
					printf("QosID = %d \n",QosID);
					if((AC_RADIO[i]!=NULL)&&(AC_RADIO[i]->AdStat == 1)&&(AC_RADIO[i]->QOSID == QosID))
					{

						
						AC_RADIO[i]->QOSID = -1;
						
						continue;
						ret = WID_QOS_BE_USED_BY_RADIO;
					}
					else
					{
						continue;
					}
				}				
				ret = WID_DELETE_QOS_PROFILE(QosID);  
			}*/
			/*fengwenchao modify begin 20110427*/
			for(i = 0; i < G_RADIO_NUM; i++)
			{
				if((AC_RADIO[i]!=NULL)&&(AC_RADIO[i]->AdStat == 0)&&(AC_RADIO[i]->QOSID == QosID))
				{
					ret = WID_QOS_RADIO_SHOULD_BE_DISABLE;
					break;
				}
				else if((AC_RADIO[i]!=NULL)&&(AC_RADIO[i]->AdStat == 1)&&(AC_RADIO[i]->QOSID == QosID))
				{
					ret = WID_QOS_BE_USED_BY_RADIO;
					break;
				}
				else
				{
					continue;
				}
			}
			if(ret == 0)
			{
				ret = WID_DELETE_QOS_PROFILE(QosID);  
			}
			/*fengwenchao modify end*/
		}

	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;


}
/*fengwenchao add 20110427*/
DBusMessage *wid_dbus_interface_delete_radio_with_qos_profile(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply = NULL;
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);

	int QosID = 0;
	int i =0;
	int ret = WID_DBUS_SUCCESS;
	
	if (!(dbus_message_get_args ( msg, &err,						
								DBUS_TYPE_UINT32,&QosID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(WID_QOS[QosID] == NULL)
	{
		ret = WID_QOS_NOT_EXIST;
	}
	else
	{
		for(i = 0; i < G_RADIO_NUM; i++)
		{
			if((AC_RADIO[i]!=NULL)&&(AC_RADIO[i]->AdStat == 1)&&(AC_RADIO[i]->QOSID == QosID))
			{
				ret = WID_ADD_RADIO_APPLY_QOS(i,QosID,0);
				AC_RADIO[i]->QOSID = 0;	
			}
		}	
	}

	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
}

/*fengwenchao add end*/
DBusMessage * wid_dbus_interface_qos_show_qos(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage * reply;
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;
	
	int QOSID;
	
	int i,j;

	int ret=WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&QOSID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(WID_QOS[QOSID] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	if(ret == 0){
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &(WID_QOS[QOSID]->QosID));
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_STRING,
										 &(WID_QOS[QOSID]->name));
		
		
		dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_UINT16_AS_STRING
											DBUS_TYPE_UINT16_AS_STRING											
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_UINT16_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_UINT16_AS_STRING
											DBUS_TYPE_UINT16_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_UINT16_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);
		

		for (i = 0; i < NUM_QOS_PROFILES; i++) {	
		
			DBusMessageIter iter_struct;
			
			dbus_message_iter_open_container (&iter_array,
										DBUS_TYPE_STRUCT,
										NULL,
										&iter_struct);
		
		
			dbus_message_iter_append_basic(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WID_QOS[QOSID]->radio_qos[i]->QueueDepth));
			
			dbus_message_iter_append_basic(&iter_struct,
					  DBUS_TYPE_UINT16,
					  &(WID_QOS[QOSID]->radio_qos[i]->CWMin));
			
			dbus_message_iter_append_basic(&iter_struct,
					  DBUS_TYPE_UINT16,
					  &(WID_QOS[QOSID]->radio_qos[i]->CWMax));
		
			dbus_message_iter_append_basic(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WID_QOS[QOSID]->radio_qos[i]->AIFS));
			
			dbus_message_iter_append_basic(&iter_struct,
					  DBUS_TYPE_UINT16,
					  &(WID_QOS[QOSID]->radio_qos[i]->TXOPlimit));
			/*
			dbus_message_iter_append_basic(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WID_QOS[QOSID]->radio_qos[i]->Dot1PTag));

			dbus_message_iter_append_basic(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WID_QOS[QOSID]->radio_qos[i]->DSCPTag));
			*/
			dbus_message_iter_append_basic(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WID_QOS[QOSID]->radio_qos[i]->ACK));

			dbus_message_iter_append_basic(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WID_QOS[QOSID]->radio_qos[i]->mapstate));

			dbus_message_iter_append_basic(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WID_QOS[QOSID]->radio_qos[i]->wmm_map_dot1p));

			dbus_message_iter_append_basic(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WID_QOS[QOSID]->radio_qos[i]->dot1p_map_wmm_num));

			for(j = 0; j < 8; j++)
			{
				dbus_message_iter_append_basic (&iter_struct,
					 DBUS_TYPE_BYTE,
					 &(WID_QOS[QOSID]->radio_qos[i]->dot1p_map_wmm[j]));	
			}
					
		
					
			//client qos
			dbus_message_iter_append_basic(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WID_QOS[QOSID]->client_qos[i]->QueueDepth));

			dbus_message_iter_append_basic(&iter_struct,
					  DBUS_TYPE_UINT16,
					  &(WID_QOS[QOSID]->client_qos[i]->CWMin));
			
			dbus_message_iter_append_basic(&iter_struct,
					  DBUS_TYPE_UINT16,
					  &(WID_QOS[QOSID]->client_qos[i]->CWMax));
			
			dbus_message_iter_append_basic(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WID_QOS[QOSID]->client_qos[i]->AIFS));

			dbus_message_iter_append_basic(&iter_struct,
					  DBUS_TYPE_UINT16,
					  &(WID_QOS[QOSID]->client_qos[i]->TXOPlimit));
			/*
			dbus_message_iter_append_basic(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WID_QOS[QOSID]->client_qos[i]->Dot1PTag));
			
			dbus_message_iter_append_basic(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(WID_QOS[QOSID]->client_qos[i]->DSCPTag));
			*/
			
			
			dbus_message_iter_close_container (&iter_array, &iter_struct);

			

		}					
		dbus_message_iter_close_container (&iter, &iter_array);
	}			
	return reply;	
}
DBusMessage * wid_dbus_interface_show_radio_apply_qos(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage * reply;
	DBusMessageIter	 iter;
//	DBusMessageIter	 iter_array;
	DBusError err;
	
	int WTPID,L_RADIOID/*,qos_type*/;
	
//	int i,j;
	int RadioID;
	int qosID = 0;

	int ret=WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&WTPID,
								DBUS_TYPE_UINT32,&L_RADIOID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	RadioID = WTPID*4+L_RADIOID;
	if((AC_RADIO[RadioID] != NULL)&&(AC_RADIO[RadioID]->QOSID != 0)){
		qosID = AC_RADIO[RadioID]->QOSID;
printf("qosID is %d,\n",qosID);
	}
	
	if(AC_WTP[WTPID] == NULL){
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[RadioID] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if((AC_RADIO[RadioID]->QOSstate == 0)||(AC_RADIO[RadioID]->QOSID == 0))
	{
		ret = RADIO_NO_BINDING_WQOS;
	}
	else if(WID_QOS[qosID] == NULL)
	{
		ret = WID_QOS_NOT_EXIST;
	}
	else
	{
	}
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	if(ret == 0){
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &(AC_RADIO[RadioID]->QOSID));		
	}			
	return reply;	
}
DBusMessage * wid_dbus_interface_show_qos_list(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	unsigned int num=0;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	int i=0;
	AC_QOS *qos[QOS_NUM];

	while(i<QOS_NUM){
		if(WID_QOS[i] != NULL)
		{
			qos[num] = WID_QOS[i];
			num++;
		}
		i++;
	}
	if(num == 0)
		ret = WTP_ID_NOT_EXIST;
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
		// Total slot count
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
		
	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for(i = 0; i < num; i++){			
		DBusMessageIter iter_struct;
			
		dbus_message_iter_open_container (&iter_array,
										DBUS_TYPE_STRUCT,
										NULL,
										&iter_struct);
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_UINT32,
					  &(qos[i]->QosID));
			
		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_STRING,
					  &(qos[i]->name));

		dbus_message_iter_append_basic
					(&iter_struct,
					  DBUS_TYPE_BYTE,
					  &(qos[i]->radio_qos[0]->mapstate));

		dbus_message_iter_close_container (&iter_array, &iter_struct);


	}
				
	dbus_message_iter_close_container (&iter, &iter_array);
				
	
	return reply;	
}

DBusMessage * wid_dbus_interface_qos(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	int qosID;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&qosID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(WID_QOS[qosID] == NULL)
		ret = WID_QOS_NOT_EXIST;
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_append_args(reply,
							 DBUS_TYPE_UINT32,&ret,
							 DBUS_TYPE_INVALID);
	return reply;
	
}
DBusMessage * wid_dbus_interface_qos_set_qos_info(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	DBusError err;

	int ID = 0;	
	int qos_stream_id = 0;
	unsigned short cwmin = 0;
	unsigned short cwmax = 0;
	unsigned char aifs = 0;
	unsigned char ack = 0;
	unsigned short txoplimit = 0;
	
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&qos_stream_id,
								DBUS_TYPE_UINT16,&cwmin,
								DBUS_TYPE_UINT16,&cwmax,
								DBUS_TYPE_BYTE,&aifs,
								DBUS_TYPE_BYTE,&ack,
								DBUS_TYPE_UINT16,&txoplimit,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(WID_QOS[ID] == NULL)
	{
		ret = WID_QOS_NOT_EXIST;
	}
	else
	{
		ret = WID_QOS_SET_QOS_INFO(ID,qos_stream_id,cwmin,cwmax,aifs,ack,txoplimit);
				
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	
	return reply;	
}
DBusMessage * wid_dbus_interface_qos_set_qos_info_client(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;	
	DBusMessageIter	 iter;
	DBusError err;

	int ID = 0;	
	int qos_stream_id = 0;
	unsigned short cwmin = 0;
	unsigned short cwmax = 0;
	unsigned char aifs = 0;
	unsigned short txoplimit = 0;
	
	
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&qos_stream_id,
								DBUS_TYPE_UINT16,&cwmin,
								DBUS_TYPE_UINT16,&cwmax,
								DBUS_TYPE_BYTE,&aifs,
								DBUS_TYPE_UINT16,&txoplimit,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(WID_QOS[ID] == NULL)
	{
		ret = WID_QOS_NOT_EXIST;
	}
	else
	{
		ret = WID_QOS_SET_QOS_INFO_CLIENT(ID,qos_stream_id,cwmin,cwmax,aifs,txoplimit);
				
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	
	return reply;	
}
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_radio_apply_qos(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;

	int qosstate = 1;
	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned int qosID = 0;

	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;

	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&qosID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(WID_QOS[qosID] == NULL)
				{
					ret = WID_QOS_NOT_EXIST;
				}
			else if(AC_RADIO[ID]->QOSID == qosID)
				{
					ret = WID_DBUS_SUCCESS;
				}
			else
				{
					ret = WID_ADD_RADIO_APPLY_QOS(ID,qosID,qosstate);
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);

										if(AC_WTP[tmp->WTPID]->WTP_Radio[i] == NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d RADIO%d is not exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(WID_QOS[qosID] == NULL)
											{
												ret2 = WID_QOS_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WID QOS is not exist\n");
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->QOSID == qosID)
											{
												ret2 = WID_DBUS_SUCCESS;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d RADIO%d had apply this qos yet\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else
											{
												ret2 = WID_ADD_RADIO_APPLY_QOS(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,qosID,qosstate);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d RADIO%d access into add radio apply qos\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}		
										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}

	return reply;	
}
#else
DBusMessage * wid_dbus_interface_radio_apply_qos(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;

	unsigned int RadioID;
	int qosID = 0;	
	int qosstate = 1;
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_UINT32,&qosID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
			
	if(AC_RADIO[RadioID] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(WID_QOS[qosID] == NULL)
	{
		ret = WID_QOS_NOT_EXIST;
	}
	else if(AC_RADIO[RadioID]->QOSID == qosID)
	{
		ret = WID_DBUS_SUCCESS;
	}
	else
	{
		ret = WID_ADD_RADIO_APPLY_QOS(RadioID,qosID,qosstate);
	}
	
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
	

}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_radio_delete_qos(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;
	
	int qosstate = 0;
	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned int qosID = 0;

	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;

	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;	
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&qosID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			/*else if(WID_QOS[qosID] == NULL)      //fengwenchao comment 20110511
				{
					ret = WID_QOS_NOT_EXIST;
				}*/
			else if((AC_RADIO[ID]->QOSID == 0) ||(AC_RADIO[ID]->QOSID != qosID))       //fengwenchao add 20110511
				{
					ret = WID_QOS_NOT_EXIST;
				}
			else
				{
					if((AC_RADIO[ID]!=NULL)&&(AC_RADIO[ID]->AdStat == 0)&&(AC_RADIO[ID]->QOSID == qosID))
						{
							ret = WID_QOS_RADIO_SHOULD_BE_DISABLE;
					
						}
					else
						{
							ret = WID_ADD_RADIO_APPLY_QOS(ID,qosID,qosstate);
							if(AC_RADIO[ID]->QOSstate == 0)       //fengwenchao add 20110511
							{							
								AC_RADIO[ID]->QOSID = 0;
							}
						}		
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);

										if(AC_WTP[tmp->WTPID]->WTP_Radio[i] == NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d RADIO%d is not exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										/*else if(WID_QOS[qosID] == NULL)     //fengwenchao comment 20110511
											{
												ret2 = WID_QOS_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WID QOS is not exist\n");
											}*/
										else if((AC_WTP[tmp->WTPID]->WTP_Radio[i]->QOSID == 0) ||(AC_WTP[tmp->WTPID]->WTP_Radio[i]->QOSID != qosID))       //fengwenchao add  20110511
											{
												ret = WID_QOS_NOT_EXIST;
											}
										else
											{
												if((AC_WTP[tmp->WTPID]->WTP_Radio[i]!=NULL)&&(AC_WTP[tmp->WTPID]->WTP_Radio[i]->AdStat == 0)&&(AC_WTP[tmp->WTPID]->WTP_Radio[i]->QOSID == qosID))
													{
														ret2 = WID_QOS_RADIO_SHOULD_BE_DISABLE;
														wid_syslog_debug_debug(WID_DEFAULT,"WID QOS RADIO%d should be disable\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
												
													}
												else
													{
														ret2 = WID_ADD_RADIO_APPLY_QOS(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,qosID,qosstate);
														if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->QOSstate == 0)       //fengwenchao add 20110511
														{
															
															AC_WTP[tmp->WTPID]->WTP_Radio[i]->QOSID = 0;
															
														}
														wid_syslog_debug_debug(WID_DEFAULT,"WTP%d RADIO%d access into add radio delete QOS\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
													}		
											}		
										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}

	return reply;	
}

#else
DBusMessage * wid_dbus_interface_radio_delete_qos(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;

	unsigned int RadioID;
	int qosID = 0;	
	int qosstate = 0;
	
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&RadioID,
								DBUS_TYPE_UINT32,&qosID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
			
	if(AC_RADIO[RadioID] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	/*else if(WID_QOS[qosID] == NULL)    //fengwenchao comment 20110511
	{
		ret = WID_QOS_NOT_EXIST;
	}*/
	else if((AC_RADIO[RadioID]->QOSID == 0) ||(AC_RADIO[RadioID]->QOSID != qosID))       //fengwenchao add 20110511
	{
		ret = WID_QOS_NOT_EXIST;
	}
	else
	{
		if((AC_RADIO[RadioID]!=NULL)&&(AC_RADIO[RadioID]->AdStat == 0)&&(AC_RADIO[RadioID]->QOSID == qosID))
		{
			ret = WID_QOS_RADIO_SHOULD_BE_DISABLE;
				
		}
		else
		{
			ret = WID_ADD_RADIO_APPLY_QOS(RadioID,qosID,qosstate);
			
			if(AC_RADIO[RadioID]->QOSstate == 0)
			{
				
				AC_RADIO[RadioID]->QOSID = 0;
				
			}
		}
			
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
	

}
#endif
DBusMessage * wid_dbus_interface_qos_set_qos_map(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter	 iter;
	int able;
	int QosID;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	int i;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&QosID,								
								DBUS_TYPE_UINT32,&able,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	
	if(WID_QOS[QosID] == NULL)
	{
		ret = WID_QOS_NOT_EXIST;
	}
	else
	{
		for(i = 0; i < G_RADIO_NUM; i++)
		{
			if((AC_RADIO[i]!=NULL)&&(AC_RADIO[i]->AdStat == 0)&&(AC_RADIO[i]->QOSID == QosID))
			{
				ret = WID_QOS_RADIO_SHOULD_BE_DISABLE;
				break;
			}
			else
			{
				continue;
			}
		}
		if(ret == 0)
		{
			ret = WID_QOS_SET_QOS_WMM_MAP(QosID,able);
		}
		

	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	
}
DBusMessage * wid_dbus_interface_qos_set_qos_wmm_map_dot1p(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter	 iter;
	int wmm_order;
	int ID;
	unsigned char dot1p;
	
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	int i;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&ID,								
								DBUS_TYPE_UINT32,&wmm_order,
								DBUS_TYPE_BYTE,&dot1p,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	
	if(WID_QOS[ID] == NULL)
	{
		ret = WID_QOS_NOT_EXIST;
	}
	else
	{
		for(i = 0; i < G_RADIO_NUM; i++)
		{
			if((AC_RADIO[i]!=NULL)&&(AC_RADIO[i]->AdStat == 0)&&(AC_RADIO[i]->QOSID == ID))
			{
				ret = WID_QOS_RADIO_SHOULD_BE_DISABLE;
				break;
			}
			else
			{
				continue;
			}
		}
		if(ret == 0)
		{
			if(WID_QOS[ID]->radio_qos[wmm_order]->mapstate == 0)
			{
				ret = WID_QOS_WMM_MAP_DISABLE;
				
			}
			else
			{
				ret = WID_QOS_SET_QOS_WMM_MAP_DOT1P(ID,wmm_order,dot1p);
			}
		}

	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	
}
DBusMessage * wid_dbus_interface_qos_set_qos_dot1p_map_wmm(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter	 iter;
	int wmm_order;
	int ID;
	unsigned char dot1p[16];
	unsigned char num = 0;
	
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	int i;
	dbus_error_init(&err);

	dbus_message_iter_init(msg,&iter);
	
	dbus_message_iter_get_basic(&iter,&ID);

	dbus_message_iter_next(&iter);	

	dbus_message_iter_get_basic(&iter,&num);
	//printf("num %d\n",num);
	dbus_message_iter_next(&iter);
	
	dbus_message_iter_get_basic(&iter,&wmm_order);
	
	memset(dot1p,0,num);
	
	if(num > 0 )
	{		
		dbus_message_iter_next(&iter);	
		
		for (i = 0; i < num; i++) 
		{
			
			dbus_message_iter_get_basic(&iter,&dot1p[i]);
			
			dbus_message_iter_next(&iter);	
			//printf("%d num %d\n",i,dot1p[i]);
		}
		
	}
	if(WID_QOS[ID] == NULL)
	{
		ret = WID_QOS_NOT_EXIST;
	}
	else if(num != 0)
	{
		if(WID_QOS[ID]->radio_qos[wmm_order]->mapstate == 0)
		{
			ret = WID_QOS_WMM_MAP_DISABLE;
			
		}
		else
		{
			ret = WID_QOS_SET_QOS_DOT1P_MAP_WMM(ID,wmm_order,num,dot1p);
		}
	}
	
		
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
		
	return reply;		
}
//set wireless qos info for mib
DBusMessage * wid_dbus_interface_qos_show_qos_extension_info(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage * reply;
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;
	
	int QOSID;
	int i;
	int ret=WID_DBUS_SUCCESS;
	char *manage_name = (char *)WID_MALLOC(sizeof(char)*WID_QOS_ARITHMETIC_NAME_LEN);
	if(NULL == manage_name){
		return NULL;
	}
	char *grab_name = (char *)WID_MALLOC(sizeof(char)*WID_QOS_ARITHMETIC_NAME_LEN);
	if(NULL == grab_name){
		CW_FREE_OBJECT_WID(manage_name);
		return NULL;
	}
	char *shove_name = (char *)WID_MALLOC(sizeof(char)*WID_QOS_ARITHMETIC_NAME_LEN);
	if(NULL == shove_name){
		CW_FREE_OBJECT_WID(manage_name);
		CW_FREE_OBJECT_WID(grab_name);
		return NULL;
	}
	memset(manage_name,0,WID_QOS_ARITHMETIC_NAME_LEN);
	memset(grab_name,0,WID_QOS_ARITHMETIC_NAME_LEN);
	memset(shove_name,0,WID_QOS_ARITHMETIC_NAME_LEN);

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&QOSID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		CW_FREE_OBJECT_WID(manage_name);
		CW_FREE_OBJECT_WID(grab_name);
		CW_FREE_OBJECT_WID(shove_name);
		return NULL;
	}
	if(WID_QOS[QOSID] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	if(ret == 0){

		memcpy(manage_name,WID_QOS[QOSID]->qos_manage_arithmetic,WID_QOS_ARITHMETIC_NAME_LEN);
		memcpy(grab_name,WID_QOS[QOSID]->qos_res_grab_arithmetic,WID_QOS_ARITHMETIC_NAME_LEN);
		memcpy(shove_name,WID_QOS[QOSID]->qos_res_shove_arithmetic,WID_QOS_ARITHMETIC_NAME_LEN);

		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &(WID_QOS[QOSID]->QosID));
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(WID_QOS[QOSID]->qos_total_bandwidth));

		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(WID_QOS[QOSID]->qos_res_scale));

		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(WID_QOS[QOSID]->qos_share_bandwidth));

		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(WID_QOS[QOSID]->qos_res_share_scale));

		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_STRING,
										&manage_name);

		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_STRING,
										&grab_name);

		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_STRING,
										 &shove_name);

		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(WID_QOS[QOSID]->qos_use_res_grab));

		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(WID_QOS[QOSID]->qos_use_res_shove));
		
		dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING											
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);
		

		for (i = 0; i < NUM_QOS_PROFILES; i++) {	
		
			DBusMessageIter iter_struct;
			dbus_message_iter_open_container (&iter_array,
										DBUS_TYPE_STRUCT,
										NULL,
										&iter_struct);
		
			dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_BYTE,
									  &(WID_QOS[QOSID]->radio_qos[i]->qos_average_rate));
			
			dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_BYTE,
									  &(WID_QOS[QOSID]->radio_qos[i]->qos_max_degree));

			dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_BYTE,
									  &(WID_QOS[QOSID]->radio_qos[i]->qos_policy_pri));

			dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_BYTE,
									  &(WID_QOS[QOSID]->radio_qos[i]->qos_res_shove_pri));

			dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_BYTE,
									  &(WID_QOS[QOSID]->radio_qos[i]->qos_res_grab_pri));

			dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_BYTE,
									  &(WID_QOS[QOSID]->radio_qos[i]->qos_max_parallel));

			dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_BYTE,
									  &(WID_QOS[QOSID]->radio_qos[i]->qos_bandwidth));

			dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_BYTE,
									  &(WID_QOS[QOSID]->radio_qos[i]->qos_bandwidth_scale));

			dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_BYTE,
									  &(WID_QOS[QOSID]->radio_qos[i]->qos_use_wred));

			dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_BYTE,
									  &(WID_QOS[QOSID]->radio_qos[i]->qos_use_traffic_shaping));

			dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_BYTE,
									  &(WID_QOS[QOSID]->radio_qos[i]->qos_use_flow_eq_queue));

			dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_BYTE,
									  &(WID_QOS[QOSID]->radio_qos[i]->qos_flow_average_rate));

			dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_BYTE,
									  &(WID_QOS[QOSID]->radio_qos[i]->qos_flow_max_degree));

			dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_BYTE,
									  &(WID_QOS[QOSID]->radio_qos[i]->qos_flow_max_queuedepth));
			
			dbus_message_iter_close_container (&iter_array, &iter_struct);

			

		}					
		dbus_message_iter_close_container (&iter, &iter_array);
	}	
	CW_FREE_OBJECT_WID(manage_name);
	CW_FREE_OBJECT_WID(grab_name);
	CW_FREE_OBJECT_WID(shove_name);
	return reply;	
}

DBusMessage * wid_dbus_interface_set_qos_total_bandwidth(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter	 iter;
	unsigned char bandwidth;
	unsigned int QosID;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&QosID,								
								DBUS_TYPE_BYTE,&bandwidth,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	
	if(WID_QOS[QosID] == NULL)
	{
		ret = WID_QOS_NOT_EXIST;
	}
	else
	{
		WID_QOS[QosID]->qos_total_bandwidth = bandwidth;
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}
DBusMessage * wid_dbus_interface_set_qos_flow_parameter_value(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter	 iter;
	unsigned char qos_stream_id = 0;
	unsigned int QosID = 0;
	unsigned int type = 0;
	unsigned int value = 0;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&QosID,								
								DBUS_TYPE_BYTE,&qos_stream_id,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&value,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	
	if(WID_QOS[QosID] == NULL)
	{
		ret = WID_QOS_NOT_EXIST;
	}
	else
	{
		ret = wid_set_qos_flow_parameter_value(QosID,qos_stream_id,type,value);
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}
DBusMessage * wid_dbus_interface_set_qos_flow_parameter_value_v2(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter	 iter;
	unsigned char qos_stream_id = 0;
	unsigned int QosID = 0;
	unsigned int type = 0;
	unsigned int value = 0;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&QosID,								
								DBUS_TYPE_BYTE,&qos_stream_id,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&value,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	
	if(WID_QOS[QosID] == NULL)
	{
		ret = WID_QOS_NOT_EXIST;
	}
	else
	{
		ret = wid_set_qos_flow_parameter_value(QosID,qos_stream_id,type,value);
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}
DBusMessage * wid_dbus_interface_set_qos_flow_able_value(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter	 iter;
	unsigned char qos_stream_id = 0;
	unsigned int QosID = 0;
	unsigned int type = 0;
	unsigned int flag = 0;
	unsigned int ret = WID_DBUS_SUCCESS;
	unsigned int use_type = 0;
	DBusError err;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&QosID,								
								DBUS_TYPE_BYTE,&qos_stream_id,
								DBUS_TYPE_UINT32,&use_type,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	
	if(WID_QOS[QosID] == NULL)
	{
		ret = WID_QOS_NOT_EXIST;
	}
	else
	{	
		if(use_type == 1)
			flag = 1;/*qos_use_traffic_shaping*/
		else if(use_type == 2)/*qos_use_wred*/
			flag = 3;
		ret = wid_set_qos_flow_able_value(QosID,qos_stream_id,type,flag);
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}
DBusMessage * wid_dbus_interface_set_qos_flow_able_value_v2(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter	 iter;
	unsigned char qos_stream_id = 0;
	unsigned int QosID = 0;
	unsigned int type = 0;
	unsigned int flag = 0;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&QosID,								
								DBUS_TYPE_BYTE,&qos_stream_id,
								DBUS_TYPE_UINT32,&type,
								//DBUS_TYPE_UINT32,&value,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	
	if(WID_QOS[QosID] == NULL)
	{
		ret = WID_QOS_NOT_EXIST;
	}
	else
	{	
		flag = 2;/*qos_use_flow_eq_queue*/
		ret = wid_set_qos_flow_able_value(QosID,qos_stream_id,type,flag);
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}
DBusMessage * wid_dbus_interface_set_qos_parameter_value(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter	 iter;
	unsigned int QosID = 0;
	unsigned int type = 0;
	unsigned int value = 0;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&QosID,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&value,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	
	if(WID_QOS[QosID] == NULL)
	{
		ret = WID_QOS_NOT_EXIST;
	}
	else
	{
		ret = wid_set_qos_parameter_value(QosID,type,value);
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}
DBusMessage * wid_dbus_interface_set_qos_policy_used(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter	 iter;
	unsigned char policy = 0;
	unsigned int QosID = 0;
	unsigned char used = 0;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&QosID,
								DBUS_TYPE_BYTE,&policy,
								DBUS_TYPE_BYTE,&used,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	
	if(WID_QOS[QosID] == NULL)
	{
		ret = WID_QOS_NOT_EXIST;
	}
	else
	{
		switch(policy)
		{
			case 1 ://grab

					WID_QOS[QosID]->qos_use_res_grab = used;
					break;

			case 2 ://shove

					WID_QOS[QosID]->qos_use_res_shove = used;
					break;
					
			default : break;
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}
DBusMessage * wid_dbus_interface_set_qos_policy_name(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter	 iter;
	unsigned char policy = 0;
	unsigned int QosID = 0;
	char *name;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&QosID,
								DBUS_TYPE_BYTE,&policy,
								DBUS_TYPE_STRING,&name,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	
	if(WID_QOS[QosID] == NULL)
	{
		ret = WID_QOS_NOT_EXIST;
	}
	else
	{
		switch(policy)
		{
			case 1 ://grab
					memset(WID_QOS[QosID]->qos_res_grab_arithmetic,0,WID_QOS_ARITHMETIC_NAME_LEN);
					memcpy(WID_QOS[QosID]->qos_res_grab_arithmetic,name,strlen(name));
					break;

			case 2 ://shove
					memset(WID_QOS[QosID]->qos_res_shove_arithmetic,0,WID_QOS_ARITHMETIC_NAME_LEN);
					memcpy(WID_QOS[QosID]->qos_res_shove_arithmetic,name,strlen(name));
					break;
					
			default : break;
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}
DBusMessage * 	wid_dbus_interface_set_qos_manage_arithmetic_name(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter	 iter;
	unsigned int QosID = 0;
	char *name;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&QosID,
								DBUS_TYPE_STRING,&name,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	
	if(WID_QOS[QosID] == NULL)
	{
		ret = WID_QOS_NOT_EXIST;
	}
	else
	{
		
		memset(WID_QOS[QosID]->qos_manage_arithmetic,0,WID_QOS_ARITHMETIC_NAME_LEN);
		memcpy(WID_QOS[QosID]->qos_manage_arithmetic,name,strlen(name));
		
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_radio_set_max_throughout(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;	
	
	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned char bandwidth = 0;

	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;

	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&bandwidth,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(type==0)
		{
			if(AC_RADIO[ID] != NULL)
				{
					ret =  wid_mul_radio_set_throughout(ID, bandwidth);
				}
			else
				{
					ret = RADIO_ID_NOT_EXIST;
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);

										if(AC_WTP[tmp->WTPID]->WTP_Radio[i]!= NULL)
											{
												ret2 =  wid_mul_radio_set_throughout(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,bandwidth);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d RADIO%d access into set throughout\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d RADIO%d is not exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}

	return reply;	
}

#else
DBusMessage * wid_dbus_interface_radio_set_max_throughout(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	unsigned char bandwidth;
	unsigned int radioid;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,
								DBUS_TYPE_BYTE,&bandwidth,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	//process the parameter
	if(AC_RADIO[radioid] != NULL)
	{
		ret =  wid_mul_radio_set_throughout(radioid, bandwidth);
	}
	else
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	return reply;
	
}
#endif
#if _GROUP_POLICY

DBusMessage * wid_dbus_interface_set_ap_max_throughout(DBusConnection *conn, DBusMessage *msg, void *user_data){


	DBusError err;
	DBusMessageIter  iter;
	DBusMessage* reply =NULL;

	int i =0;
	unsigned int ID = 0;
	unsigned int num = 0;
	unsigned int type = 0;
	unsigned char bandwidth = 0;
	
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Wtp_List * wtp_head =NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;

	dbus_error_init(&err);
	
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&bandwidth,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(type == 0){
	//process the parameter
		if(ID == 0){
			gBANDWIDTH = bandwidth;
			for(i=0;i<WTP_NUM;i++){
				if(AC_WTP[i] !=NULL){
					ret =  wid_radio_set_throughout(i, bandwidth);					
				}
			}
		} /*wcl modify for globle variable*/
		else if(AC_WTP[ID] != NULL)
		{
			ret =  wid_radio_set_throughout(ID, bandwidth);
		}
		else
		{
			ret = WTP_ID_NOT_EXIST;
		}
	}

	else if (type == 1){
		printf("******** type == 1 *****\n");
		if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
			tmp = WTP_GROUP[ID]->WTP_M;
			wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
			
			while(tmp){
				ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
				
				if(ret_check == WID_DBUS_SUCCESS){
					
					ret2 =  wid_radio_set_throughout(tmp->WTPID, bandwidth);
					
					if(ret2 != WID_DBUS_SUCCESS){
						wtp_head[num].WtpId = tmp->WTPID;
						wtp_head[num].FailReason = ret2;
						num++;
					}
					tmp = tmp->next;
				}
			}
			ret = WID_DBUS_SUCCESS;
		}
		
		else{
			ret = GROUP_ID_NOT_EXIST;
		}
	}

	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);

	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if(type == 1){
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
		
		for(i = 0; i < num; i++){
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &(wtp_head[i].WtpId ));
			
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_BYTE,
											 &(wtp_head[i].FailReason));
		}	
	}
	
	if(wtp_head!=NULL){
		WID_FREE(wtp_head);
		wtp_head = NULL;	
	}
	
	return reply;
	
}
#else
DBusMessage * wid_dbus_interface_set_ap_max_throughout(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	unsigned char bandwidth;
	unsigned int wtpid;
	int i = 0; /*wcl add for globle variable*/
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_BYTE,&bandwidth,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	//process the parameter
	if(wtpid == 0){
		gBANDWIDTH = bandwidth;
		for(i=0;i<WTP_NUM;i++){
			if(AC_WTP[i] !=NULL){
				ret =  wid_radio_set_throughout(i, bandwidth);					
			}
		}
	} /*wcl modify for globle variable*/
	else if(AC_WTP[wtpid] != NULL)
	{
		ret =  wid_radio_set_throughout(wtpid, bandwidth);
	}
	else
	{
		ret = WTP_ID_NOT_EXIST;
	}
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	return reply;
	
}
#endif

#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_ap_extension_command(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusError err;
	DBusMessage* reply;
	DBusMessageIter	 iter;
	unsigned char* command;
	int i =0;
	unsigned int ID = 0;
	unsigned int num = 0;
	unsigned int type = 0;
	
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Wtp_List * wtp_head =NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_STRING,&command,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			if(AC_WTP[ID] != NULL)
			{
				CWThreadMutexLock(&(gSTARoamingMutex)); 		
				ret = wid_radio_set_extension_command(ID, (char *)command);
				CWThreadMutexUnlock(&(gSTARoamingMutex)); 
			}
			else
			{
				ret = WTP_ID_NOT_EXIST;
			}
		}
	else if (type == 1){
		printf("******** type == 1 *****\n");
		if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
			tmp = WTP_GROUP[ID]->WTP_M;
			wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
			
			while(tmp){
				ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
				
				if(ret_check == WID_DBUS_SUCCESS){
					
					if(AC_WTP[tmp->WTPID] != NULL)
					{
						CWThreadMutexLock(&(gSTARoamingMutex)); 		
						ret2 = wid_radio_set_extension_command(tmp->WTPID, (char *)command);
						CWThreadMutexUnlock(&(gSTARoamingMutex)); 
						wid_syslog_debug_debug(WID_DEFAULT,"WTP%d set extension command successful\n",tmp->WTPID);
					}
					else
					{
						ret2 = WTP_ID_NOT_EXIST;
						wid_syslog_debug_debug(WID_DEFAULT,"WTP%d id is not exist\n",tmp->WTPID);
					}
					
					if(ret2 != WID_DBUS_SUCCESS){
						wtp_head[num].WtpId = tmp->WTPID;
						wtp_head[num].FailReason = ret2;
						num++;
					}
					tmp = tmp->next;
				}
			}
			ret = WID_DBUS_SUCCESS;
		}
		
		else{
			ret = GROUP_ID_NOT_EXIST;
		}
	}

	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);

	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
		
		for(i = 0; i < num; i++){
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &(wtp_head[i].WtpId ));
			
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_BYTE,
											 &(wtp_head[i].FailReason));
		}	

		if(wtp_head!=NULL){
		WID_FREE(wtp_head);
		wtp_head = NULL;	
		}
	}
	

	
	return reply;


	
}

#else

DBusMessage * wid_dbus_interface_set_ap_longitude_latitude_command(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter  iter;
	unsigned char *longitude, *latitude;
	unsigned int wtpid;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32, &wtpid,
								DBUS_TYPE_STRING, &longitude,
								DBUS_TYPE_STRING, &latitude,
								DBUS_TYPE_INVALID))){
								
		wid_syslog_err("Unable to get input args\n");
		
		if (dbus_error_is_set(&err)) {
			wid_syslog_err("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	wid_syslog_debug_debug(WID_DEFAULT, "set longitude and latitude for wtp %d\n", wtpid);
	
	if(wtpid == 0 || AC_WTP[wtpid] != NULL)
	{
		wid_set_ap_longitude_latitude(wtpid, longitude, latitude); 
	} else {
		ret = WTP_ID_NOT_EXIST;
	}
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	return reply;
	
}


DBusMessage * wid_dbus_interface_set_ap_extension_command(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	char* command;
	unsigned int wtpid;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_STRING,&command,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	//process the parameter
	if(AC_WTP[wtpid] != NULL)
	{
		CWThreadMutexLock(&(gSTARoamingMutex)); 		
		ret = wid_radio_set_extension_command(wtpid, command);
		CWThreadMutexUnlock(&(gSTARoamingMutex)); 
	}
	else
	{
		ret = WTP_ID_NOT_EXIST;
	}
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	return reply;
	
}

#endif

DBusMessage * wid_dbus_interface_set_ap_option60_parameter(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	char* parameter;
	unsigned int wtpid;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_STRING,&parameter,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	//process the parameter
	if(AC_WTP[wtpid] != NULL)
	{
		CWThreadMutexLock(&(gSTARoamingMutex)); 		
		ret = wid_radio_set_option60_parameter(wtpid, parameter);
		CWThreadMutexUnlock(&(gSTARoamingMutex)); 
	}
	else
	{
		ret = WTP_ID_NOT_EXIST;
	}
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	return reply;
	
}


#if _GROUP_POLICY
DBusMessage * wid_dbus_tcpdump_command(DBusConnection *conn, DBusMessage *msg, void *user_data){

	
	DBusMessage* reply = NULL;
	DBusMessageIter	 iter;
	char* command = NULL;
	//char* tmpcommand = NULL;
	char *buffer1command = 0;
	char *buffercommand = 0;
	DBusError err;
	char buffer[256]={0};
	char buffer1[256]={0};
	char buffer2[256]={0};
	int sockfd;
	int sysState=0;
	int sysErrorCode = 0;
	int i =0;
	unsigned int ID = 0;
	unsigned int num = 0;
	unsigned int type = 0;
	
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	printf("dfdfdfdfdfdfdf\n");
	struct Wtp_List * wtp_head =NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	struct ifreq	ifr;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_STRING,&command,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}
	//len = strlen(command)+1;
	//memset(tmpcommand,0,len);
	//memcpy(tmpcommand,command,len-1);
	printf("command = %s\n",command);
	
if(type==0)
  {
	strncpy(ifr.ifr_name,AC_WTP[ID]->BindingIFName, sizeof(ifr.ifr_name));
	if(ioctl(sockfd, SIOCGIFADDR, &ifr) == -1){
		wid_syslog_debug_debug(WID_DEFAULT,"wtp quit reason is SIOCGIFADDR error");
		close(sockfd);
		return WID_DBUS_SUCCESS;}
	sprintf(buffer," -w /tmp/wtp%d.pcap && cd /tmp && tftp -pl wtp%d.pcap %s&",ID,ID,inet_ntoa(((struct sockaddr_in*)(&ifr.ifr_addr))->sin_addr));
	sprintf(buffer1,"tcpdump ");
	buffercommand = (char *)WID_MALLOC(256);
	//command=strcat(buffer1,strcat(command,buffer));
	buffer1command=strcat(buffer1,strcat(buffercommand,buffer));
	if(strlen(buffer1command) > 256){
			printf("access type0\n");
			ret = WID_ILLEGAL_INPUT;
			reply = dbus_message_new_method_return(msg);
			dbus_message_iter_init_append(reply, &iter);
			dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			return reply;}
			
	else{	
		    sprintf(buffer2, "cd /mnt/wtp/&&touch wtp%d.pcap&&chmod 666 wtp%d.pcap",ID,ID);
		    sysState = system(buffer2);
    		sysErrorCode = WEXITSTATUS(sysState);
			if(0==sysErrorCode)
			{
				if(AC_WTP[ID] != NULL)
					{
						CWThreadMutexLock(&(gSTARoamingMutex)); 		
						ret = wid_radio_set_extension_command(ID, buffer1command);
						CWThreadMutexUnlock(&(gSTARoamingMutex)); 	
					}
				else
					{
						ret = WTP_ID_NOT_EXIST;
					}
	
			}
   			else
			{
				wid_syslog_debug_debug(WID_DBUS,"System cmd error,error code %d\n",sysErrorCode);
			}
			if(sysState != 0 )
    		{
        		wid_syslog_debug_debug(WID_DBUS,"System sysState error,error code %d\n",sysState);
			}
		}
	if(buffercommand)
		 {
			WID_FREE(buffercommand);
			buffercommand = NULL;

		 }
  }

else if (type == 1)
	{
	
		printf("******** type == 1 *****\n");
		if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
			{
				tmp = WTP_GROUP[ID]->WTP_M;
				wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
				printf("access type1\n");
				printf("strlen:%d\n",(strlen(command)+1));

		while(tmp)
			{

			    buffercommand = (char *)WID_MALLOC(256);
				//buffercommand = command;
				//buffercommand = (char *)WID_MALLOC(strlen(command)+1);
				//if(buffercommand == NULL){
				//	printf("buffercommand:%p\n",buffercommand);
				//}
				memset(buffercommand,0,strlen(command)+1);
				memcpy(buffercommand,command,strlen(command));
				printf("command =%s \n",command);
				printf("buffercommand = %s \n",buffercommand);
				ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
				printf("tmp->WTPID = %d\n",tmp->WTPID);

				printf("retcheck = %d\n",ret_check);
			
				if(ret_check == WID_DBUS_SUCCESS)
					{
						
						strncpy(ifr.ifr_name,AC_WTP[tmp->WTPID]->BindingIFName, sizeof(ifr.ifr_name));
						if(ioctl(sockfd, SIOCGIFADDR, &ifr) == -1)
							{
								wid_syslog_debug_debug(WID_DEFAULT,"wtp quit reason is SIOCGIFADDR error");
								close(sockfd);
								return WID_DBUS_SUCCESS;
							}
						sprintf(buffer," -w /tmp/wtp%d.pcap && cd /tmp && tftp -pl wtp%d.pcap %s&",tmp->WTPID,tmp->WTPID,inet_ntoa(((struct sockaddr_in*)(&ifr.ifr_addr))->sin_addr));
						sprintf(buffer1,"tcpdump ");
						printf("buffer = %s\n",buffer);
						printf("buffer1 = %s\n",buffer1);
						buffer1command=strcat(buffer1,strcat(buffercommand,buffer));
						printf("buffer1command = %s\n",buffer1command);
						printf("buffercommand = %s\n",buffercommand);
						if(strlen(buffer1command) > 256)
							{
								ret = WID_ILLEGAL_INPUT;
			
								reply = dbus_message_new_method_return(msg);
								dbus_message_iter_init_append(reply, &iter);
								dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
								return reply;
							}
						else
							{	
								//memset(buffer2,0,256);
		    					sprintf(buffer2, "cd /mnt/wtp/&&touch wtp%d.pcap&&chmod 666 wtp%d.pcap",tmp->WTPID,tmp->WTPID);
								printf("buffer2 = %s\n",buffer2);
		    					sysState = system(buffer2);
								printf("after system\n");
				
    							sysErrorCode = WEXITSTATUS(sysState);
								printf("after WEXITSTATUS,sysErrorCode=%d\n",sysErrorCode);
								if(0==sysErrorCode)
									{
										if(AC_WTP[tmp->WTPID] != NULL)
										{
											CWThreadMutexLock(&(gSTARoamingMutex)); 		
											ret2 = wid_radio_set_extension_command(tmp->WTPID, buffer1command);
											CWThreadMutexUnlock(&(gSTARoamingMutex)); 
											wid_syslog_debug_debug(WID_DBUS,"WTP%d tcpdump command successful\n",tmp->WTPID);
										}
										else
										{
											ret2 = WTP_ID_NOT_EXIST;
											wid_syslog_debug_debug(WID_DBUS,"WTP%d SI NOT EXIST\n",tmp->WTPID);
										}
									}
   								else
									{
										wid_syslog_debug_debug(WID_DBUS,"System cmd error,error code %d\n",sysErrorCode);
									}
								if(sysState != 0 )
    								{
        								wid_syslog_debug_debug(WID_DBUS,"System sysState error,error code %d\n",sysState);
									}
								}
				
							if(ret2 != WID_DBUS_SUCCESS)
								{
									wtp_head[num].WtpId = tmp->WTPID;
									wtp_head[num].FailReason = ret2;
									num++;
								}

							

							memset(buffer,0,sizeof(buffer));
							memset(buffer1,0,sizeof(buffer1));
							memset(buffer2,0,sizeof(buffer2));
							buffer1command = NULL;
							//mset(buffercommand,0,strlen(command)+1);
						}
				if(buffercommand)
		 		{
						WID_FREE(buffercommand);
		 				buffercommand = NULL;

				}
				tmp = tmp->next;

				/*if(buffercommand)
		 			{
						WID_FREE(buffercommand);
		 				buffercommand = NULL;

			 		}*/
			}
		ret = WID_DBUS_SUCCESS;

		}
	
	else{
		ret = GROUP_ID_NOT_EXIST;
	}
}

reply = dbus_message_new_method_return(msg);

dbus_message_iter_init_append(reply, &iter);

dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

if((type == 1)&&(ret == WID_DBUS_SUCCESS))
	{
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &num);
	
	for(i = 0; i < num; i++)
		{
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &(wtp_head[i].WtpId ));
		
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_BYTE,
											 &(wtp_head[i].FailReason));
		}	

	     if(wtp_head!=NULL)
	 	{
			WID_FREE(wtp_head);
			wtp_head = NULL;	
		}
	}




	return reply;

}

#else
DBusMessage * wid_dbus_tcpdump_command(DBusConnection *conn, DBusMessage *msg, void *user_data){

	
	DBusMessage* reply = NULL;
	DBusMessageIter	 iter;
	char* command = NULL;
	unsigned int wtpid = 0;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	char buffer[256]={0};
	char buffer1[256]={0};
	char buffer2[256]={0};
	int sockfd;
	int sysState=0;
	int sysErrorCode = 0;
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	struct ifreq	ifr;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_STRING,&command,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}
	
	strncpy(ifr.ifr_name,AC_WTP[wtpid]->BindingIFName, sizeof(ifr.ifr_name));
	if(ioctl(sockfd, SIOCGIFADDR, &ifr) == -1){
		wid_syslog_debug_debug(WID_DEFAULT,"wtp quit reason is SIOCGIFADDR error");
		close(sockfd);
		return WID_DBUS_SUCCESS;}
	sprintf(buffer," -w /tmp/wtp%d.pcap && cd /tmp && tftp -pl wtp%d.pcap %s&",wtpid,wtpid,inet_ntoa(((struct sockaddr_in*)(&ifr.ifr_addr))->sin_addr));
	sprintf(buffer1,"tcpdump ");
		
	command=strcat(buffer1,strcat(command,buffer));
	if(strlen(command) > 256){

			ret = WID_ILLEGAL_INPUT;
			
			reply = dbus_message_new_method_return(msg);
			dbus_message_iter_init_append(reply, &iter);
			dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			return reply;}
			

		

	else{	

		    sprintf(buffer2, "cd /mnt/wtp/&&touch wtp%d.pcap&&chmod 666 wtp%d.pcap",wtpid,wtpid);
		    sysState = system(buffer2);
    		sysErrorCode = WEXITSTATUS(sysState);
			if(0==sysErrorCode)
			{



				if(AC_WTP[wtpid] != NULL)
			
					{

			
						CWThreadMutexLock(&(gSTARoamingMutex)); 		
						ret = wid_radio_set_extension_command(wtpid, command);
						CWThreadMutexUnlock(&(gSTARoamingMutex)); 
						
					}
				else
					{
						ret = WTP_ID_NOT_EXIST;
					}
	
			}

   			else
			{
		
				wid_syslog_debug_debug(WID_DBUS,"System cmd error,error code %d\n",sysErrorCode);
		
			}
		

			if(sysState != 0 )
    		{
		
        		wid_syslog_debug_debug(WID_DBUS,"System sysState error,error code %d\n",sysState);
		
			}
		}
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	close(sockfd);
	return reply;
}


#endif



DBusMessage * wid_dbus_interface_set_ap_ip_gateway(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	unsigned int ip,gateway;
	unsigned int wtpid;
	unsigned int mask;
	unsigned int fstdns;//12.17
	unsigned int snddns = 0;//12.17
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&ip,
								DBUS_TYPE_UINT32,&mask,
								DBUS_TYPE_UINT32,&gateway,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	fstdns = gateway;//12.17
	snddns = gateway;//12.17
	printf("ip %d gateway %d mask %d\n",ip,gateway,mask);
	//process the parameter
	if(AC_WTP[wtpid] != NULL)
	{
		/*ret = wid_radio_set_ip_gateway(wtpid,ip,gateway,mask);//12.17*/
		ret = wid_radio_set_ip_gateway_dns(wtpid,ip,gateway,mask,fstdns,snddns);//12.17
	}
	else
	{
		ret = WTP_ID_NOT_EXIST;
	}
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	return reply;
	
}
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_ap_ip_gateway_dns(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	unsigned int ip =0;
	unsigned int gateway = 0;
	unsigned int mask;
	unsigned int fstdns;
	unsigned int snddns = 0;
	int i =0;
	unsigned int ID = 0;
	unsigned int num = 0;
	unsigned int type = 0;
	
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Wtp_List * wtp_head =NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&ip,
								DBUS_TYPE_UINT32,&mask,
								DBUS_TYPE_UINT32,&gateway,
								DBUS_TYPE_UINT32,&fstdns,
								DBUS_TYPE_UINT32,&snddns,								
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			if(AC_WTP[ID] != NULL)
				{
					ret = wid_radio_set_ip_gateway_dns(ID,ip,gateway,mask,fstdns,snddns);
					
				}
			else
				{
					ret = WTP_ID_NOT_EXIST;
				}
	
		}
	
	else if (type == 1){
		printf("******** type == 1 *****\n");
		if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
			tmp = WTP_GROUP[ID]->WTP_M;
			wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
			
			while(tmp){
				ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
				
				if(ret_check == WID_DBUS_SUCCESS)
					{
						if(AC_WTP[tmp->WTPID] != NULL)
						{
							ret = wid_radio_set_ip_gateway_dns(tmp->WTPID,ip,gateway,mask,fstdns,snddns);
							wid_syslog_debug_debug(WID_DEFAULT,"WTP%d set ip mask gateway dns OK\n",tmp->WTPID);
						}
						else
						{
							ret = WTP_ID_NOT_EXIST;
						}
					
					if(ret2 != WID_DBUS_SUCCESS){
						wtp_head[num].WtpId = tmp->WTPID;
						wtp_head[num].FailReason = ret2;
						num++;
					}
					tmp = tmp->next;
				}
			}
			ret = WID_DBUS_SUCCESS;
		}
		
		else{
			ret = GROUP_ID_NOT_EXIST;
		}
	}

	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);

	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
		
		for(i = 0; i < num; i++){
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &(wtp_head[i].WtpId ));
			
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_BYTE,
											 &(wtp_head[i].FailReason));
		}

		if(wtp_head!=NULL){
		WID_FREE(wtp_head);
		wtp_head = NULL;	
		}
	}
	

	
	return reply;

	
}

#else
DBusMessage * wid_dbus_interface_set_ap_ip_gateway_dns(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	unsigned int ip,gateway;
	unsigned int wtpid;
	unsigned int mask;
	unsigned int fstdns,snddns;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&ip,
								DBUS_TYPE_UINT32,&mask,
								DBUS_TYPE_UINT32,&gateway,
								DBUS_TYPE_UINT32,&fstdns,
								DBUS_TYPE_UINT32,&snddns,								
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(AC_WTP[wtpid] != NULL)
	{
		ret = wid_radio_set_ip_gateway_dns(wtpid,ip,gateway,mask,fstdns,snddns);
	}
	else
	{
		ret = WTP_ID_NOT_EXIST;
	}
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	return reply;
	
}
#endif

#if _GROUP_POLICY

DBusMessage * wid_dbus_interface_update_ap_config(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusError err;
	DBusMessage* reply;
	DBusMessageIter	 iter;
	char *ip = NULL;
	int i =0;
	unsigned int ID = 0;
	unsigned int num = 0;
	unsigned int type = 0;
	
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Wtp_List * wtp_head =NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_STRING,&ip,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

if(type==0)
{
	if(AC_WTP[ID] != NULL)
	{
		ret = wid_update_ap_config(ID,ip);
	}
	else
	{
		ret = WTP_ID_NOT_EXIST;
	}
}

else if (type == 1){
	printf("******** type == 1 *****\n");
	if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
		tmp = WTP_GROUP[ID]->WTP_M;
		wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
		
		while(tmp){
			ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
			
			if(ret_check == WID_DBUS_SUCCESS)
				{
					if(AC_WTP[tmp->WTPID] == NULL)
					{
						ret2 = WTP_ID_NOT_EXIST;
						wid_syslog_debug_debug(WID_DEFAULT,"<error>WTP%d is not exist\n",tmp->WTPID);
					}
					else 
					{
						ret2 = wid_update_ap_config(tmp->WTPID,ip);
						wid_syslog_debug_debug(WID_DEFAULT,"WTP%d update ap config successful\n",tmp->WTPID);
					}

				if(ret2 != WID_DBUS_SUCCESS){
					wtp_head[num].WtpId = tmp->WTPID;
					wtp_head[num].FailReason = ret2;
					num++;
				}
				tmp = tmp->next;
			}
		}
		ret = WID_DBUS_SUCCESS;
	}
	
	else{
		ret = GROUP_ID_NOT_EXIST;
	}
}
printf("num =  %d\n",num);
reply = dbus_message_new_method_return(msg);

dbus_message_iter_init_append(reply, &iter);

dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &num);
	
	for(i = 0; i < num; i++){
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &(wtp_head[i].WtpId ));
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(wtp_head[i].FailReason));
	}

	if(wtp_head!=NULL){
	WID_FREE(wtp_head);
	wtp_head = NULL;	
   }	
}



return reply;

	

}


#else
DBusMessage * wid_dbus_interface_update_ap_config(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	char *ip;
	unsigned int wtpid;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_STRING,&ip,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	//printf("ip %s\n",ip);
	//process the parameter
	if(AC_WTP[wtpid] != NULL)
	{
		ret = wid_update_ap_config(wtpid,ip);
	}
	else
	{
		ret = WTP_ID_NOT_EXIST;
	}
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	return reply;
	
}
#endif
DBusMessage * wid_dbus_interface_show_wtp_runtime(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	unsigned int wtpid;
	DBusError err;
	time_t add_time;
	time_t q_time;
	time_t *now_time = NULL;
	unsigned int checktimes = 0;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	CWThreadMutexLock(&(gWTPs[wtpid].WTPThreadMutex));//fengwenchao add 20121123 for AXSSZFI-1050	
	ret = WID_CHECK_ID(WID_WTP_CHECK,wtpid);
	CWThreadMutexUnlock(&(gWTPs[wtpid].WTPThreadMutex));	
	
	if(ret != WID_DBUS_SUCCESS)
	{
		printf("WTP_ID_LARGE_THAN_MAX \n");
	}
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtpid]->add_time == NULL)
	{
		add_time = 0;
		if((AC_WTP[wtpid]!=NULL)&&(AC_WTP[wtpid]->WTPStat != 5))
		{
			if(now_time == NULL)
			{
				now_time = (time_t *)WID_MALLOC(sizeof(time_t));
				time(now_time);
			}
			else
			{
				time(now_time);
			}
		}
	}
	else if(0 == *AC_WTP[wtpid]->add_time)
	{
		add_time = *AC_WTP[wtpid]->add_time;
		if(now_time == NULL)
		{
			now_time = (time_t*)WID_MALLOC(sizeof(time_t));
			time(now_time);
		}
		else
			time(now_time);
	}
	else
	{
		add_time = *AC_WTP[wtpid]->add_time;
	}
	if(AC_WTP[wtpid]->quit_time == NULL)
	{
		q_time = 0;
	}
	else
	{
		q_time = *AC_WTP[wtpid]->quit_time;
	}
	if((AC_WTP[wtpid]->quit_time)&&(*AC_WTP[wtpid]->quit_time>0)&&(AC_WTP[wtpid]->add_time)&&(*AC_WTP[wtpid]->add_time>0))
	{
		if(*AC_WTP[wtpid]->add_time>*AC_WTP[wtpid]->quit_time)//  -(the first quit time - the second run time) = the time from quit to run
		{
			if(((*AC_WTP[wtpid]->add_time- *AC_WTP[wtpid]->quit_time)%gCheckRequestTimer) == 0)
			{
				checktimes = (*AC_WTP[wtpid]->add_time- *AC_WTP[wtpid]->quit_time)/gCheckRequestTimer - 1;//(checktimes +1 )*EchoTimer == the time from quit to run
			}
			else
			{
				checktimes = (*AC_WTP[wtpid]->add_time- *AC_WTP[wtpid]->quit_time)/gCheckRequestTimer;
			}
		}
		else
		{
			checktimes = 0;
		}
	}
	else if((AC_WTP[wtpid]->quit_time)&&(*AC_WTP[wtpid]->quit_time > 0)&&(now_time)&&(*now_time >0))
	{
		if(*now_time > *AC_WTP[wtpid]->quit_time)
		{
			if((*now_time - *AC_WTP[wtpid]->quit_time)%gCheckRequestTimer == 0)
			{
				checktimes = (*now_time - *AC_WTP[wtpid]->quit_time)/gCheckRequestTimer - 1;//(checktimes +1 )*EchoTimer == the time from quit to run
			}
			else
			{
				checktimes = (*now_time - *AC_WTP[wtpid]->quit_time)/gCheckRequestTimer;//(checktimes +1 )*EchoTimer == the time from quit to run
			}
		}
	}
	else
	{
		checktimes = 0;
	}
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	if(ret == WID_DBUS_SUCCESS)
	{
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &add_time);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &AC_WTP[wtpid]->ElectrifyRegisterCircle);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &AC_WTP[wtpid]->imagedata_time);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &AC_WTP[wtpid]->config_update_time);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &q_time);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &checktimes);
	}
	CW_FREE_OBJECT_WID(now_time);
	return reply;
	
}

#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_wtp_location(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	char *location = NULL;
	int i =0;
	unsigned int ID = 0;
	unsigned int num = 0;
	unsigned int type = 0;
	
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Wtp_List * wtp_head =NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_STRING,&location,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
		 	if(AC_WTP[ID] == NULL)
			{
				ret = WTP_ID_NOT_EXIST;
			}
			else if(AC_WTP[ID]->location == NULL)
			{
				AC_WTP[ID]->location = (char *)WID_MALLOC(strlen(location)+1);
				memset(AC_WTP[ID]->location, 0, strlen(location)+1);
				memcpy(AC_WTP[ID]->location,location,strlen(location));
			}
			else
			{
				CW_FREE_OBJECT_WID(AC_WTP[ID]->location);
				AC_WTP[ID]->location = (char *)WID_MALLOC(strlen(location)+1);
				memset(AC_WTP[ID]->location, 0, strlen(location)+1);
				memcpy(AC_WTP[ID]->location,location,strlen(location));
	
			}
		}

	else if (type == 1){
		printf("******** type == 1 *****\n");
		if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
			tmp = WTP_GROUP[ID]->WTP_M;
			wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
			
			while(tmp){
				ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
				
				if(ret_check == WID_DBUS_SUCCESS)
					{
						if(AC_WTP[tmp->WTPID] == NULL)
						{
							ret2 = WTP_ID_NOT_EXIST;
							wid_syslog_debug_debug(WID_DEFAULT,"<error>WTP%d is not exist\n",tmp->WTPID);
						}
						else if(AC_WTP[tmp->WTPID]->location== NULL)
						{
							AC_WTP[tmp->WTPID]->location = (char *)WID_MALLOC(strlen(location)+1);
							memset(AC_WTP[tmp->WTPID]->location, 0, strlen(location)+1);
							memcpy(AC_WTP[tmp->WTPID]->location,location,strlen(location));

							wid_syslog_debug_debug(WID_DEFAULT,"WTP%d set wtp location successful\n",tmp->WTPID);
			
							
						}
						else
						{
							CW_FREE_OBJECT_WID(AC_WTP[ID]->location);
							AC_WTP[tmp->WTPID]->location = (char *)WID_MALLOC(strlen(location)+1);
							memset(AC_WTP[tmp->WTPID]->location, 0, strlen(location)+1);
							memcpy(AC_WTP[tmp->WTPID]->location,location,strlen(location));
						
							wid_syslog_debug_debug(WID_DEFAULT,"WTP%d set wtp location successful\n",tmp->WTPID);
	
							
						}
					
					if(ret2 != WID_DBUS_SUCCESS){
						wtp_head[num].WtpId = tmp->WTPID;
						wtp_head[num].FailReason = ret2;
						num++;
					}
					tmp = tmp->next;
				}
			}
			ret = WID_DBUS_SUCCESS;
		}
		
		else{
			ret = GROUP_ID_NOT_EXIST;
		}
	}
	printf("num =  %d\n",num);
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);

	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
		
		for(i = 0; i < num; i++){
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &(wtp_head[i].WtpId ));
			
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_BYTE,
											 &(wtp_head[i].FailReason));
		}

		if(wtp_head!=NULL){
		WID_FREE(wtp_head);
		wtp_head = NULL;	
		}
	}
	

	
	return reply;
	
}

#else
DBusMessage * wid_dbus_interface_set_wtp_location(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	unsigned int wtpid;
	DBusError err;
	char *location;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_STRING,&location,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtpid]->location == NULL)
	{
		AC_WTP[wtpid]->location = (char *)WID_MALLOC(strlen(location)+1);
		memset(AC_WTP[wtpid]->location, 0, strlen(location)+1);
		memcpy(AC_WTP[wtpid]->location,location,strlen(location));
	}
	else
	{
		CW_FREE_OBJECT_WID(AC_WTP[wtpid]->location);
		AC_WTP[wtpid]->location = (char *)WID_MALLOC(strlen(location)+1);
		memset(AC_WTP[wtpid]->location, 0, strlen(location)+1);
		memcpy(AC_WTP[wtpid]->location,location,strlen(location));
	
	}
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}
#endif
DBusMessage * wid_dbus_interface_show_wtp_location(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	unsigned int wtpid;
	DBusError err;
	
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	reply = dbus_message_new_method_return(msg);
	
	ret = WID_CHECK_ID(WID_WTP_CHECK,wtpid);
	
	if(ret != WID_DBUS_SUCCESS)
	{
		printf("WTP id not correct \n");
	}
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtpid]->location == NULL)
	{
		ret = WID_WTP_LOCATION_NOT_SET;
		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	}
	else
	{
		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &AC_WTP[wtpid]->location);
		wid_syslog_debug_debug(WID_DBUS,"set wtp %d location %s\n",wtpid,AC_WTP[wtpid]->location);
	}
	
	
	return reply;
	
}
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_wtpname(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	int i =0;
	unsigned int ID = 0;
	unsigned int num = 0;
	unsigned int type = 0;
	char *name = NULL;
	
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Wtp_List * wtp_head =NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_STRING,&name,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			if(AC_WTP[ID] == NULL)
			{
				ret = WTP_ID_NOT_EXIST;
			}
			else if(AC_WTP[ID]->WTPNAME == NULL)
			{
				AC_WTP[ID]->WTPNAME = (char *)WID_MALLOC(strlen(name)+1);
				memset(AC_WTP[ID]->WTPNAME, 0, strlen(name)+1);
				memcpy(AC_WTP[ID]->WTPNAME,name,strlen(name));
				if(1!=AsdWsm_WTPOp(ID,WID_MODIFY))
					{

		 				ret=WID_DBUS_ERROR;

	   				}
			}
			else
			{
				CW_FREE_OBJECT_WID(AC_WTP[ID]->WTPNAME);
				AC_WTP[ID]->WTPNAME = (char *)WID_MALLOC(strlen(name)+1);
				memset(AC_WTP[ID]->WTPNAME, 0, strlen(name)+1);
				memcpy(AC_WTP[ID]->WTPNAME,name,strlen(name));
				if(1!=AsdWsm_WTPOp(ID,WID_MODIFY))
					{
						ret	=WID_DBUS_ERROR;
					}
	
			}
		}

	else if (type == 1){
		printf("******** type == 1 *****\n");
		if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
			tmp = WTP_GROUP[ID]->WTP_M;
			wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
			
			while(tmp){
				ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
				
				if(ret_check == WID_DBUS_SUCCESS)
					{
						if(AC_WTP[tmp->WTPID] == NULL)
						{
							ret2 = WTP_ID_NOT_EXIST;
							wid_syslog_debug_debug(WID_DEFAULT,"<error>WTP%d is not exist\n",tmp->WTPID);
						}
						else if(AC_WTP[tmp->WTPID]->WTPNAME== NULL)
						{
							AC_WTP[tmp->WTPID]->WTPNAME = (char *)WID_MALLOC(strlen(name)+1);
							memset(AC_WTP[tmp->WTPID]->WTPNAME, 0, strlen(name)+1);
							memcpy(AC_WTP[tmp->WTPID]->WTPNAME,name,strlen(name));
							wid_syslog_debug_debug(WID_DEFAULT,"WTP%d set wtpname successful\n",tmp->WTPID);
							if(1!=AsdWsm_WTPOp(tmp->WTPID,WID_MODIFY))
								{
	
					 				ret2=WID_DBUS_ERROR;
									wid_syslog_debug_debug(WID_DEFAULT,"<error>WTP%d dbus error\n",tmp->WTPID);

	   							}
							
						}
						else
						{
							CW_FREE_OBJECT_WID(AC_WTP[tmp->WTPID]->WTPNAME);
							AC_WTP[tmp->WTPID]->WTPNAME = (char *)WID_MALLOC(strlen(name)+1);
							memset(AC_WTP[tmp->WTPID]->WTPNAME, 0, strlen(name)+1);
							memcpy(AC_WTP[tmp->WTPID]->WTPNAME,name,strlen(name));
						
							wid_syslog_debug_debug(WID_DEFAULT,"WTP%d set wtpname successful\n",tmp->WTPID);
							if(1!=AsdWsm_WTPOp(tmp->WTPID,WID_MODIFY))
								{
									ret2=WID_DBUS_ERROR;
									wid_syslog_debug_debug(WID_DEFAULT,"<error>WTP%d dbus error\n",tmp->WTPID);
								}
							
						}
					
					if(ret2 != WID_DBUS_SUCCESS){
						wtp_head[num].WtpId = tmp->WTPID;
						wtp_head[num].FailReason = ret2;
						num++;
					}
					tmp = tmp->next;
				}
			}
			ret = WID_DBUS_SUCCESS;
		}
		
		else{
			ret = GROUP_ID_NOT_EXIST;
		}
	}
	printf("num =  %d\n",num);
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);

	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
		
		for(i = 0; i < num; i++){
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &(wtp_head[i].WtpId ));
			
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_BYTE,
											 &(wtp_head[i].FailReason));
		}

		if(wtp_head!=NULL){
		WID_FREE(wtp_head);
		wtp_head = NULL;	
		}
	}
	

	
	return reply;

}

#else
DBusMessage * wid_dbus_interface_set_wtpname(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	unsigned int wtpid;
	DBusError err;
	char *name;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_STRING,&name,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtpid]->WTPNAME == NULL)
	{
		AC_WTP[wtpid]->WTPNAME = (char *)WID_MALLOC(strlen(name)+1);
		memset(AC_WTP[wtpid]->WTPNAME, 0, strlen(name)+1);
		memcpy(AC_WTP[wtpid]->WTPNAME,name,strlen(name));
		if(1!=AsdWsm_WTPOp(wtpid,WID_MODIFY)){

		 ret=WID_DBUS_ERROR;

	   }
	}
	else
	{
		CW_FREE_OBJECT_WID(AC_WTP[wtpid]->WTPNAME);
		AC_WTP[wtpid]->WTPNAME = (char *)WID_MALLOC(strlen(name)+1);
		memset(AC_WTP[wtpid]->WTPNAME, 0, strlen(name)+1);
		memcpy(AC_WTP[wtpid]->WTPNAME,name,strlen(name));
		if(1!=AsdWsm_WTPOp(wtpid,WID_MODIFY)){

		 ret=WID_DBUS_ERROR;

	   }
	
	}
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}
#endif
#if _GROUP_POLICY

DBusMessage * wid_dbus_interface_set_wtpsn(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusError err;
	DBusMessageIter  iter;
	DBusMessage* reply =NULL;

	int i =0;
	unsigned int ID = 0;
	unsigned int num = 0;
	unsigned int type = 0;
	char *name = NULL;
	
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Wtp_List * wtp_head =NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_STRING,&name,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(type==0)
	{
		if(AC_WTP[ID] == NULL)
		{
			ret = WTP_ID_NOT_EXIST;
		}
		else if(AC_WTP[ID]->WTPStat == 5){
			ret = WID_DBUS_ERROR;

		}
		else
		{
			memset(AC_WTP[ID]->WTPSN, 0, NAS_IDENTIFIER_NAME);
			memcpy(AC_WTP[ID]->WTPSN,name,strlen(name));
	
		}
	}

	else if (type == 1){
		printf("******** type == 1 *****\n");
		if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
			tmp = WTP_GROUP[ID]->WTP_M;
			wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
			
			while(tmp){
				ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
				
				if(ret_check == WID_DBUS_SUCCESS)
					{
						if(AC_WTP[tmp->WTPID] == NULL)
						{
							ret2 = WTP_ID_NOT_EXIST;
							wid_syslog_debug_debug(WID_DEFAULT,"<error>WTP%d is not exist\n",tmp->WTPID);
						}
						else if(AC_WTP[tmp->WTPID]->WTPStat == 5)
						{
							ret2 = WID_DBUS_ERROR;
							wid_syslog_debug_debug(WID_DEFAULT,"<error>WTP%d is running\n",tmp->WTPID);
						}
						else
						{
							memset(AC_WTP[tmp->WTPID]->WTPSN, 0, NAS_IDENTIFIER_NAME);
							memcpy(AC_WTP[tmp->WTPID]->WTPSN,name,strlen(name));
							ret2 = WID_DBUS_SUCCESS;
							wid_syslog_debug_debug(WID_DEFAULT,"WTP%d set sn successful\n",tmp->WTPID);
						}
					
					if(ret2 != WID_DBUS_SUCCESS){
						wtp_head[num].WtpId = tmp->WTPID;
						wtp_head[num].FailReason = ret2;
						num++;
					}
					tmp = tmp->next;
				}
			}
			ret = WID_DBUS_SUCCESS;
		}
		
		else{
			ret = GROUP_ID_NOT_EXIST;
		}
	}
	printf("num =  %d\n",num);
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);

	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
		
		for(i = 0; i < num; i++){
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &(wtp_head[i].WtpId ));
			
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_BYTE,
											 &(wtp_head[i].FailReason));
		}

		if(wtp_head!=NULL){
		WID_FREE(wtp_head);
		wtp_head = NULL;	
		}
	}
	

	
	return reply;

	
}

#else
DBusMessage * wid_dbus_interface_set_wtpsn(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	unsigned int wtpid;
	DBusError err;
	char *name;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_STRING,&name,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtpid]->WTPStat == 5){
		ret = WID_DBUS_ERROR;

	}
	else
	{
		memset(AC_WTP[wtpid]->WTPSN, 0, NAS_IDENTIFIER_NAME);
		memcpy(AC_WTP[wtpid]->WTPSN,name,strlen(name));
	
	}
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}

#endif

#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_wtp_netid(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	char *netid;
	int i =0;
	unsigned int ID = 0;
	unsigned int num = 0;
	unsigned int type = 0;	
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Wtp_List * wtp_head =NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_STRING,&netid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			if(AC_WTP[ID] == NULL)
			{
				ret = WTP_ID_NOT_EXIST;
			}
			else if(AC_WTP[ID]->netid == NULL)
			{
				AC_WTP[ID]->netid = (char *)WID_MALLOC(strlen(netid)+1);
				memset(AC_WTP[ID]->netid, 0, strlen(netid)+1);
				memcpy(AC_WTP[ID]->netid,netid,strlen(netid));
				AsdWsm_WTPOp(ID,WID_MODIFY);  
			}
			else
			{
				CW_FREE_OBJECT_WID(AC_WTP[ID]->netid);
				AC_WTP[ID]->netid = (char *)WID_MALLOC(strlen(netid)+1);
				memset(AC_WTP[ID]->netid, 0, strlen(netid)+1);
				memcpy(AC_WTP[ID]->netid,netid,strlen(netid));
				AsdWsm_WTPOp(ID,WID_MODIFY);  
	
			}
		}

	else if (type == 1){
		printf("******** type == 1 *****\n");
		if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
			tmp = WTP_GROUP[ID]->WTP_M;
			wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
			
			while(tmp){
				ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
				
				if(ret_check == WID_DBUS_SUCCESS)
					{
					if(AC_WTP[tmp->WTPID] == NULL)
					{
						ret2= WTP_ID_NOT_EXIST;
						wid_syslog_debug_debug(WID_DEFAULT,"<error>WTP%d is not exist\n",tmp->WTPID);
					}
					else if(AC_WTP[tmp->WTPID]->netid == NULL)
					{
						AC_WTP[tmp->WTPID]->netid = (char *)WID_MALLOC(strlen(netid)+1);
						memset(AC_WTP[tmp->WTPID]->netid, 0, strlen(netid)+1);
						memcpy(AC_WTP[tmp->WTPID]->netid,netid,strlen(netid));
						wid_syslog_debug_debug(WID_DEFAULT,"WTP%d set wtp netid successful\n",tmp->WTPID);
						AsdWsm_WTPOp(tmp->WTPID,WID_MODIFY);  
					}
					else
					{
						CW_FREE_OBJECT_WID(AC_WTP[tmp->WTPID]->netid);
						AC_WTP[tmp->WTPID]->netid = (char *)WID_MALLOC(strlen(netid)+1);
						memset(AC_WTP[tmp->WTPID]->netid, 0, strlen(netid)+1);
						memcpy(AC_WTP[tmp->WTPID]->netid,netid,strlen(netid));
						wid_syslog_debug_debug(WID_DEFAULT,"WTP%d set wtp netid successful\n",tmp->WTPID);
						AsdWsm_WTPOp(tmp->WTPID,WID_MODIFY);  
					
					}

					
					if(ret2 != WID_DBUS_SUCCESS){
						wtp_head[num].WtpId = tmp->WTPID;
						wtp_head[num].FailReason = ret2;
						num++;
					}
					tmp = tmp->next;
				}
			}
			ret = WID_DBUS_SUCCESS;
		}
		
		else{
			ret = GROUP_ID_NOT_EXIST;
		}
	}
	printf("num =  %d\n",num);
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);

	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
		
		for(i = 0; i < num; i++){
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &(wtp_head[i].WtpId ));
			
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_BYTE,
											 &(wtp_head[i].FailReason));
		}	
		if(wtp_head!=NULL){
		WID_FREE(wtp_head);
		wtp_head = NULL;	
		}
	
	}
	

	return reply;

}

#else
DBusMessage * wid_dbus_interface_set_wtp_netid(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	unsigned int wtpid;
	DBusError err;
	char *netid;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_STRING,&netid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtpid]->netid == NULL)
	{
		AC_WTP[wtpid]->netid = (char *)WID_MALLOC(strlen(netid)+1);
		memset(AC_WTP[wtpid]->netid, 0, strlen(netid)+1);
		memcpy(AC_WTP[wtpid]->netid,netid,strlen(netid));
		AsdWsm_WTPOp(wtpid,WID_MODIFY);  //zhangshu add for sending wtp_netid to asd, 2010-10-19
	}
	else
	{
		CW_FREE_OBJECT_WID(AC_WTP[wtpid]->netid);
		AC_WTP[wtpid]->netid = (char *)WID_MALLOC(strlen(netid)+1);
		memset(AC_WTP[wtpid]->netid, 0, strlen(netid)+1);
		memcpy(AC_WTP[wtpid]->netid,netid,strlen(netid));
		AsdWsm_WTPOp(wtpid,WID_MODIFY);  //zhangshu add for sending wtp_netid to asd, 2010-10-19
	
	}
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}
#endif
DBusMessage * wid_dbus_interface_show_wtp_netid(DBusConnection *conn, DBusMessage *msg, void *user_data){

    wid_syslog_debug_debug(WID_DEFAULT,"jjjjjjjjjjjjjjjj\n come into wid_dbus_show_wtp_netid\n");
	DBusMessage* reply;
	DBusMessageIter	 iter;
	unsigned int wtpid;
	DBusError err;
	
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		wid_syslog_debug_debug(WID_DEFAULT,"error\n");
		return NULL;
	}
	wid_syslog_debug_debug(WID_DEFAULT,"wtp id = %d\n",wtpid);
	reply = dbus_message_new_method_return(msg);
	
	if(wtpid > WTP_NUM)
	{
		ret = WTP_ID_NOT_EXIST;
		wid_syslog_debug_debug(WID_DEFAULT,"wtp id not exist1111111\n");
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	}
	else
	{
		if(AC_WTP[wtpid] == NULL)
		{
		    wid_syslog_debug_debug(WID_DEFAULT,"wtp id not exist2222222\n");
			ret = WTP_ID_NOT_EXIST;
			dbus_message_iter_init_append(reply, &iter);
			
			dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
		}
		else if(AC_WTP[wtpid]->netid == NULL)
		{
		    wid_syslog_debug_debug(WID_DEFAULT,"net id is NULL\n");
			ret = WID_WTP_LOCATION_NOT_SET;
			dbus_message_iter_init_append(reply, &iter);
			
			dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

		}
		else
		{
			dbus_message_iter_init_append(reply, &iter);
			
			dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

			dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &AC_WTP[wtpid]->netid);
			wid_syslog_debug_debug(WID_DEFAULT,"set wtp %d netid %s\n",wtpid,AC_WTP[wtpid]->netid);
		}
	}
	
	
	return reply;
	
}
DBusMessage * wid_dbus_interface_set_wid_monitor_time(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int time;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&time,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	WID_SAMPLE_INFORMATION.monitor_time = time;
	
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}

DBusMessage * wid_dbus_interface_set_wid_sample_time(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int time;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&time,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	WID_SAMPLE_INFORMATION.sample_time = time;
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}
DBusMessage * wid_dbus_interface_set_wid_monitor_enable(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int able;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&able,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	WID_SAMPLE_INFORMATION.monitor_switch = able;
	
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}
DBusMessage * wid_dbus_interface_set_wid_ipfwd(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int able;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&able,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if (able) {
		if (getuid()) 
			system("sudo insmod /lib/modules/2.6.16.26-Cavium-Octeon/misc/cavium-ip-offload.ko");
		else
			system("insmod /lib/modules/2.6.16.26-Cavium-Octeon/misc/cavium-ip-offload.ko");
	} else{
		if (getuid())
			system("sudo rmmod cavium_ip_offload");
		else
			system("rmmod cavium_ip_offload");
	}
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}

//luoxun add
DBusMessage * wid_dbus_interface_show_wid_ipfwd(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int state;
	int ret = WID_DBUS_SUCCESS;
	
	FILE* fp = NULL;
	fp = fopen("/sys/module/cavium_ip_offload/parameters/cw_ipfwd_debug", "r");
	if(NULL == fp) {
		state = 0;  //ipfwd disable
	}
	else {
		fclose(fp);
		state = 1;  //ipfwd enable
	}

	dbus_error_init(&err);
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &state);
	
	return reply;
	
}


DBusMessage * wid_dbus_interface_set_wid_sample_enable(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int able;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&able,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	WID_SAMPLE_INFORMATION.sample_switch = able;
	set_wid_sample_enable();
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}


DBusMessage * wid_dbus_interface_show_wid_sample_infomation(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	

	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &WID_SAMPLE_INFORMATION.monitor_switch);

	dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &WID_SAMPLE_INFORMATION.monitor_time);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &WID_SAMPLE_INFORMATION.sample_switch);

	dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &WID_SAMPLE_INFORMATION.sample_time);

	return reply;
	
}

DBusMessage * wid_dbus_interface_show_rrm_config(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter  iter;
	DBusError err;
	
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	

	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &gapscanset.opstate);

	dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &gapscanset.flag);

	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT16, &gapscanset.reportinterval);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &channel_state);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &gapscanset.countermeasures_mode);
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &gapscanset.countermeasures_switch);	

	return reply;
	
}
DBusMessage * wid_dbus_interface_show_radio_qos(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply; 
		DBusMessageIter  iter;
		DBusMessageIter  iter_array;
		unsigned int num=0;
		DBusError err;
		int ret = WID_DBUS_SUCCESS;
		dbus_error_init(&err);
		int i=0,j=0;
		WID_WTP_RADIO **RADIO;
		RADIO = WID_MALLOC(G_RADIO_NUM*sizeof(WID_WTP_RADIO *));
		while(i<WTP_NUM){		
			if(AC_WTP[i] != NULL)
			{	int n=0,m=0;
				n = AC_WTP[i]->RadioCount;
				m = AC_WTP[i]->WFR_Index;
				for(j=0;j<n;j++){
					RADIO[num] = AC_RADIO[m];
					m++;
					num++;
				}
			}
			i++;
		}
		if(num == 0)
		{
			ret = RADIO_ID_NOT_EXIST;
		}
		reply = dbus_message_new_method_return(msg);
			
		dbus_message_iter_init_append (reply, &iter);
			
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &ret);
			
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &num);
			
		dbus_message_iter_open_container (&iter,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_UINT32_AS_STRING
												DBUS_TYPE_UINT32_AS_STRING
										DBUS_STRUCT_END_CHAR_AS_STRING,
										&iter_array);
		for(i = 0; i < num; i++){			
			DBusMessageIter iter_struct;
				
			dbus_message_iter_open_container (&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);

			dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_UINT32,&(RADIO[i]->Radio_G_ID));

			dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_UINT32,&(RADIO[i]->QOSID));
	
			dbus_message_iter_close_container (&iter_array, &iter_struct);
	
	
		}
					
		dbus_message_iter_close_container (&iter, &iter_array);
					
		WID_FREE(RADIO);
		return reply;	
		

}
DBusMessage * wid_dbus_interface_set_receiver_signal_level(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	unsigned int level = 0;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&level,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	receiver_signal_level = level;
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}
DBusMessage * wid_dbus_interface_show_receiver_signal_level(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	unsigned int level = receiver_signal_level;
	DBusError err;
	
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &level);

	return reply;
	
}
DBusMessage * wid_dbus_interface_show_wtp_txpower_control_infomation(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	int state = txpower_state;
	unsigned char scope = control_scope;
	unsigned char th1 = coverage_threshold;
	unsigned char th2 = tx_power_threshold;
	unsigned char constant = power_constant;
	unsigned char max = tx_power_max;

	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &state);

	dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &scope);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &th1);

	dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &th2);

	dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &constant);

	dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &max);
	
	return reply;
	
}
/*

DBusMessage * wid_dbus_interface_show_wtp_extension_infomation(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	int i = 0;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	if(AC_WTP[wtpid]->wifi_extension_reportswitch == 0)
	{
		ret = SWITCH_IS_DISABLE;
	}
	//ret = wid_send_to_ap_extension_infomation(wtpid);
		
	reply = dbus_message_new_method_return(msg);

	if(ret != WID_DBUS_SUCCESS)
	{
		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	}
	else
	{
		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.cpu));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.tx_mgmt));
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.rx_mgmt));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.tx_packets));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.tx_errors));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.tx_retry));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.eth_count));

		for(i=0;i<AP_ETH_IF_NUM;i++)
		{
			dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.eth_updown_time[i]));
		}

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.ath_count));

		for(i=0;i<AP_ATH_IF_NUM;i++)
		{
			dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.ath_updown_time[i]));
		}
	}
	return reply;
	
}

DBusMessage * wid_dbus_interface_show_wtp_extension_infomation_v2(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	int i = 0;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	if(AC_WTP[wtpid]->wifi_extension_reportswitch == 0)
	{
		ret = SWITCH_IS_DISABLE;
	}
	//ret = wid_send_to_ap_extension_infomation(wtpid);
		
	reply = dbus_message_new_method_return(msg);

	if(ret != WID_DBUS_SUCCESS)
	{
		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	}
	else
	{
		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.cpu));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.tx_mgmt));
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.rx_mgmt));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.tx_packets));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.tx_errors));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.tx_retry));
		//
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_reportswitch));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT16, &(AC_WTP[wtpid]->wifi_extension_reportinterval));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.ipmode));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT16, &(AC_WTP[wtpid]->wifi_extension_info.memoryall));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.memoryuse));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT16, &(AC_WTP[wtpid]->wifi_extension_info.flashall));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.flashempty));
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.wifi_snr));
		//
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.eth_count));

		for(i=0;i<AP_ETH_IF_NUM;i++)
		{
			dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.eth_updown_time[i]));
		}

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.ath_count));

		for(i=0;i<AP_ATH_IF_NUM;i++)
		{
			dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.ath_updown_time[i]));
		}
	}
	return reply;
	
}*/
DBusMessage * wid_dbus_interface_show_wtp_extension_infomation_v3(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply = NULL;
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusMessageIter	 iter_struct;
	DBusError err;
	unsigned int wtpid = 0;
	int i = 0;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtpid]->wifi_extension_reportswitch == 0)
	{
		ret = SWITCH_IS_DISABLE;
	}
	//ret = wid_send_to_ap_extension_infomation(wtpid);
		
	reply = dbus_message_new_method_return(msg);

	if(ret != WID_DBUS_SUCCESS)
	{
		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	}
	else
	{
		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.cpu));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.tx_mgmt));
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.rx_mgmt));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.tx_packets));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.tx_errors));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.tx_retry));
		//
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_reportswitch));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT16, &(AC_WTP[wtpid]->wifi_extension_reportinterval));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.ipmode));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT16, &(AC_WTP[wtpid]->wifi_extension_info.memoryall));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.memoryuse));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT16, &(AC_WTP[wtpid]->wifi_extension_info.flashall));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.flashempty));
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.wifi_snr));
		//
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.eth_count));
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->collect_time));

		for(i=0;i<AP_ETH_IF_NUM;i++)
		{
			dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.eth_updown_time[i]));
		}

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.ath_count));

		/*fengwenchao modify begin 20120502 for autelan-2917*/
		dbus_message_iter_open_container (&iter,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING	//radioid
												DBUS_TYPE_BYTE_AS_STRING	//wlanid
												DBUS_TYPE_BYTE_AS_STRING	//ath_updown_times
										DBUS_STRUCT_END_CHAR_AS_STRING,
										&iter_array);

		for(i=0;i<AC_WTP[wtpid]->wifi_extension_info.ath_count;i++)
		{
			dbus_message_iter_open_container (&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
																																	
			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.ath_if_info[i].radioid));

			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.ath_if_info[i].wlanid));

			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.ath_if_info[i].ath_updown_times));
			
			dbus_message_iter_close_container (&iter_array, &iter_struct);
		}

		dbus_message_iter_close_container (&iter, &iter_array);
		/*fengwenchao modify end*/
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.temperature));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.wifi_count));

		for(i=0;i<AP_WIFI_IF_NUM;i++)
		{
			dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.wifi_state[i]));
		}
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.rx_broadcast));
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.rx_unicast));
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.tx_broadcast));
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.tx_unicast));
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.rx_multicast));
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.tx_multicast));
	}
	return reply;
	
}
DBusMessage * wid_dbus_interface_show_wtp_extension_infomation_v4(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply = NULL;
	DBusMessageIter	 iter;
	DBusMessageIter   iter_array;
	DBusMessageIter   iter_struct;
	DBusError err;
	unsigned int wtpid = 0;
	int i = 0;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtpid]->wifi_extension_reportswitch == 0)
	{
		ret = SWITCH_IS_DISABLE;
	}
		
	reply = dbus_message_new_method_return(msg);

	if(ret != WID_DBUS_SUCCESS)
	{
		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	}
	else
	{
		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.cpu));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.tx_mgmt));
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.rx_mgmt));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.tx_packets));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.tx_errors));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.tx_retry));
		//
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_reportswitch));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT16, &(AC_WTP[wtpid]->wifi_extension_reportinterval));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.ipmode));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT16, &(AC_WTP[wtpid]->wifi_extension_info.memoryall));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.memoryuse));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT16, &(AC_WTP[wtpid]->wifi_extension_info.flashall));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.flashempty));
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.wifi_snr));
		//
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.eth_count));

		for(i=0;i<AP_ETH_IF_NUM;i++)
		{
			dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.eth_updown_time[i]));
		}

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.ath_count));
		/*fengwenchao modify begin 20120502 for autelan-2917*/
		dbus_message_iter_open_container (&iter,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING	//radioid
												DBUS_TYPE_BYTE_AS_STRING	//wlanid
												DBUS_TYPE_BYTE_AS_STRING	//ath_updown_times
										DBUS_STRUCT_END_CHAR_AS_STRING,
										&iter_array);
		for(i=0;i<AC_WTP[wtpid]->wifi_extension_info.ath_count;i++)
		{
			dbus_message_iter_open_container (&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
			
			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.ath_if_info[i].radioid));

			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.ath_if_info[i].wlanid));

			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.ath_if_info[i].ath_updown_times));

			dbus_message_iter_close_container (&iter_array, &iter_struct);
		}
		dbus_message_iter_close_container (&iter, &iter_array);
		/*fengwenchao modify end*/
	
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.temperature));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.wifi_count));

		for(i=0;i<AP_WIFI_IF_NUM;i++)
		{
			dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->wifi_extension_info.wifi_state[i]));
		}

		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.tx_unicast));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.tx_broadcast));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.tx_multicast));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.tx_drop));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.rx_unicast));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.rx_broadcast));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.rx_multicast));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.rx_drop));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.wpi_replay_error));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.wpi_decryptable_error));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.wpi_mic_error));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.disassoc_unnormal));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.rx_assoc_norate));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.rx_assoc_capmismatch));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.assoc_invaild));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wifi_extension_info.reassoc_deny));

	}
	return reply;
	
}

/*fengwenchao add 20111130 for GM-3*/
DBusMessage * wid_dbus_interface_set_ap_heart_statistics_switch(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	unsigned char policy = 0;
	int ret = WID_DBUS_SUCCESS;
//	unsigned int i = 0;
//	unsigned int length = 0;
	struct heart_time_value_head * p = NULL;
	struct heart_time_value_head * tmp = NULL;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_BYTE,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	printf("policy =  %d \n",policy);
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtpid]->heart_time.heart_statistics_switch == policy)
	{
		//printf("111111111111111111\n");
		ret = WID_DBUS_SUCCESS;
	}
	else
	{
		AC_WTP[wtpid]->heart_time.heart_statistics_switch = policy;
		
		if(policy == 0)
		{	
			CWThreadMutexLock(&(gWTPs[wtpid].WTPThreadMutex));
			AC_WTP[wtpid]->heart_time.heart_time_avarge = 0;
			if(AC_WTP[wtpid]->heart_time.heart_time_value_head != NULL)
			{
				p = AC_WTP[wtpid]->heart_time.heart_time_value_head;
		
				while(p!=NULL)
				{
					tmp = p;	
					p = p->next;			
					tmp->next =NULL;
					WID_FREE(tmp);
					tmp = NULL;

						//printf("222222222222222\n");
				}						
				AC_WTP[wtpid]->heart_time.heart_time_value_length = 0;
			}
			AC_WTP[wtpid]->heart_time.heart_time_value_head = NULL;
			CWThreadMutexUnlock(&(gWTPs[wtpid].WTPThreadMutex));
		}
		
	}

		
	reply = dbus_message_new_method_return(msg);

	dbus_message_iter_init_append(reply, &iter);

	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	return reply;

}

DBusMessage *wid_dbus_interface_set_ap_heart_statistics_collect_time(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	unsigned int collect_time = 0;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&collect_time,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	//printf("%s \n",__func__);
	//printf("collect_time =  %d  \n",collect_time);
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtpid]->heart_time.heart_statistics_switch == 1)
	{
		//printf("dddddddddddddddd \n");
		ret = WID_DBUS_ERROR;
	}
	else
	{
		//printf("fffffffffffffffff \n");
		AC_WTP[wtpid]->heart_time.heart_statistics_collect = collect_time;
	}

		
	reply = dbus_message_new_method_return(msg);

	dbus_message_iter_init_append(reply, &iter);

	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	return reply;

}
/*fengwenchao add end*/

DBusMessage * wid_dbus_interface_set_ap_username_password(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply = NULL;
	DBusMessageIter  iter;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	int wtpid = 0;
	char *name = NULL;
	char *passwd = NULL;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_STRING,&name,
								DBUS_TYPE_STRING,&passwd,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	wid_syslog_debug_debug(WID_DEFAULT,"the wtp id is %d\n",wtpid);
	wid_syslog_debug_debug(WID_DEFAULT,"the name is %s\n",name);
	wid_syslog_debug_debug(WID_DEFAULT,"the passwd is %s\n",passwd);

	wid_set_ap_username_password(wtpid,name,passwd);
	reply = dbus_message_new_method_return(msg);


	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	return reply;
}

#if _GROUP_POLICY

DBusMessage * wid_dbus_interface_set_wtp_extension_infomation_enable(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	int policy = 0;
	int i = 0;
	int num =0 ;
	unsigned int ID = 0;
	unsigned int type = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
		
	struct Wtp_List  *wtp_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			if(AC_WTP[ID] == NULL)
			{
				ret = WTP_ID_NOT_EXIST;
			}
			else if(AC_WTP[ID]->wifi_extension_reportswitch == policy)
			{
				ret = WID_DBUS_SUCCESS;
			}
			else
			{
				AC_WTP[ID]->wifi_extension_reportswitch = policy;

				ret = wid_send_to_ap_extension_infomation(ID);
			}
		}

	else if(type==1)
			{
				printf("******** type == 1 *****\n");
				if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
					tmp = WTP_GROUP[ID]->WTP_M;
					wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
					
					while(tmp){
						ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
						printf("ret_check = %d\n",ret_check);
						if(ret_check == WID_DBUS_SUCCESS){

									if(AC_WTP[tmp->WTPID] == NULL)
									{
										ret2 = WTP_ID_NOT_EXIST;
										wid_syslog_debug_debug(WID_DEFAULT,"WTP%d NOT EXIST\n",tmp->WTPID);
									}
									else if(AC_WTP[tmp->WTPID]->wifi_extension_reportswitch == policy)
									{
										ret2 = WID_DBUS_SUCCESS;
										wid_syslog_debug_debug(WID_DEFAULT,"WTP%d had this policy yet\n",tmp->WTPID);
									}
									else
									{
										AC_WTP[tmp->WTPID]->wifi_extension_reportswitch = policy;
										wid_syslog_debug_debug(WID_DEFAULT,"WTP%d set policy successful\n",tmp->WTPID);
							
										ret2 = wid_send_to_ap_extension_infomation(tmp->WTPID);
										
									}
								}
	
							if(ret2 != WID_DBUS_SUCCESS){
	
								wtp_head[num].WtpId = tmp->WTPID;
								wtp_head[num].FailReason = ret2;
								num++;
								
								}
							
							tmp = tmp->next;
						}
		
					}
						ret = WID_DBUS_SUCCESS;
				}
					
				else{
					ret = GROUP_ID_NOT_EXIST;
					}
			
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
		printf("num= %d\n",num);
			if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
													 &num);
				for(i = 0; i < num; i++){
					dbus_message_iter_append_basic (&iter,
														 DBUS_TYPE_UINT32,
														 &(wtp_head[i].WtpId));
					dbus_message_iter_append_basic (&iter,
														 DBUS_TYPE_BYTE,
														 &(wtp_head[i].FailReason));
				}	
				
				if(wtp_head!=NULL){
					WID_FREE(wtp_head);
					wtp_head = NULL;	
				}
			}
			
			return reply;

	
}

#else
DBusMessage * wid_dbus_interface_set_wtp_extension_infomation_enable(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	int policy = 0;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtpid]->wifi_extension_reportswitch == policy)
	{
		ret = WID_DBUS_SUCCESS;
	}
	else
	{
		AC_WTP[wtpid]->wifi_extension_reportswitch = policy;

		ret = wid_send_to_ap_extension_infomation(wtpid);
	}
	
		
	reply = dbus_message_new_method_return(msg);

	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	return reply;
	
}
#endif
#if _GROUP_POLICY

/* zhangshu add for Terminal Disturb Info Report swtich, 2010-10-08 */
DBusMessage * wid_dbus_interface_set_wtp_terminal_disturb_info_switch(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	int policy = 0;
	int i = 0;
	int num =0 ;
	unsigned int ID = 0;
	unsigned int type = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
		
	struct Wtp_List  *wtp_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) 
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			if(ID == 0){
				gTER_DIS_INFOREPORTSWITCH = policy;
				for(i=0;i<WTP_NUM;i++)
{
					if(AC_WTP[i] != NULL){						
						if(AC_WTP[i]->ter_dis_info.reportswitch == policy)
						{
							ret = WID_DBUS_SUCCESS;
						}
						else
						{
							AC_WTP[i]->ter_dis_info.reportswitch = policy;
				
							ret = wid_send_to_ap_Terminal_Disturb_info(i);
						}
					}
				}
			}/*wcl modify for globle variable*/
			else if((ID>0)&&(ID<=(WTP_NUM-1)))
			{
				if(AC_WTP[ID] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
				else if(AC_WTP[ID]->ter_dis_info.reportswitch == policy)
				{
					ret = WID_DBUS_SUCCESS;
				}
				else
				{
					AC_WTP[ID]->ter_dis_info.reportswitch = policy;
		
					ret = wid_send_to_ap_Terminal_Disturb_info(ID);
				}

			}
		}

	else if(type==1)
			{
				printf("******** type == 1 *****\n");
				if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
					tmp = WTP_GROUP[ID]->WTP_M;
					wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
					
					while(tmp){
						ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
						printf("ret_check = %d\n",ret_check);
						if(ret_check == WID_DBUS_SUCCESS){
							if((tmp->WTPID>0)&&(tmp->WTPID<=(WTP_NUM-1)))
								{
									if(AC_WTP[tmp->WTPID] == NULL)
									{
										ret2 = WTP_ID_NOT_EXIST;
										wid_syslog_debug_debug(WID_DEFAULT,"WTP%d NOT EXIST\n",tmp->WTPID);
									}
									else if(AC_WTP[tmp->WTPID]->ter_dis_info.reportswitch == policy)
									{
										ret2 = WID_DBUS_SUCCESS;
										wid_syslog_debug_debug(WID_DEFAULT,"WTP%d had this num yet\n",tmp->WTPID);
									}
									else
									{
										AC_WTP[tmp->WTPID]->ter_dis_info.reportswitch = policy;
										wid_syslog_debug_debug(WID_DEFAULT,"WTP%d set num successful\n",tmp->WTPID);
							
										ret2 = wid_send_to_ap_Terminal_Disturb_info(tmp->WTPID);
										
										
									}
								}
	
							if(ret2 != WID_DBUS_SUCCESS){
	
								wtp_head[num].WtpId = tmp->WTPID;
								wtp_head[num].FailReason = ret2;
								num++;
								
								}
							
							tmp = tmp->next;
						}
		
					}
						ret = WID_DBUS_SUCCESS;
				}
					
				else{
					ret = GROUP_ID_NOT_EXIST;
					}
			}
		reply = dbus_message_new_method_return(msg);
		
			dbus_message_iter_init_append(reply, &iter);
			
			dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			printf("num= %d\n",num);
			if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
													 &num);
				for(i = 0; i < num; i++){
					dbus_message_iter_append_basic (&iter,
														 DBUS_TYPE_UINT32,
														 &(wtp_head[i].WtpId));
					dbus_message_iter_append_basic (&iter,
														 DBUS_TYPE_BYTE,
														 &(wtp_head[i].FailReason));
				}	
				
				if(wtp_head!=NULL){
					WID_FREE(wtp_head);
					wtp_head = NULL;	
				}
			}
			
			return reply;


}

#else
/* zhangshu add for Terminal Disturb Info Report swtich, 2010-10-08 */
DBusMessage * wid_dbus_interface_set_wtp_terminal_disturb_info_switch(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	int policy = 0;
	unsigned int i = 0;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) 
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid == 0){
		gTER_DIS_INFOREPORTSWITCH = policy;
		for(i=0;i<WTP_NUM;i++)
{
			if(AC_WTP[i] != NULL){						
				if(AC_WTP[i]->ter_dis_info.reportswitch == policy)
				{
					ret = WID_DBUS_SUCCESS;
				}
				else
				{
					AC_WTP[i]->ter_dis_info.reportswitch = policy;
		
					ret = wid_send_to_ap_Terminal_Disturb_info(i);
				}
			}
		}
	}/*wcl modify for globle variable*/
	else if((wtpid>0)&&(wtpid<=(WTP_NUM-1)))
	{
		if(AC_WTP[wtpid] == NULL)
		{
			ret = WTP_ID_NOT_EXIST;
		}
		else if(AC_WTP[wtpid]->ter_dis_info.reportswitch == policy)
		{
			ret = WID_DBUS_SUCCESS;
		}
		else
		{
			AC_WTP[wtpid]->ter_dis_info.reportswitch = policy;
		
			ret = wid_send_to_ap_Terminal_Disturb_info(wtpid);
		}

	}
	/*else if(wtpid == 0)
	{
		for(i=0;i<WTP_NUM;i++)
		{
			if((AC_WTP[i] != NULL)&&(AC_WTP[i]->ter_dis_info.reportswitch == policy))
			{
				ret = WID_DBUS_SUCCESS;
			}
			else if(AC_WTP[i] != NULL)
			{
				AC_WTP[i]->ter_dis_info.reportswitch = policy;
			
				ret = wid_send_to_ap_Terminal_Disturb_info(i);
			}
		}
	}*//*wcl modify for globle variable*/
	
	reply = dbus_message_new_method_return(msg);

	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	return reply;
	
}
#endif
//weichao add 
DBusMessage * wid_dbus_interface_set_sta_deauth_message_report_enable(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	int policy = 0;
	int ret = WID_DBUS_SUCCESS;
	int i = 0 ; 
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid == 0){
		if(sta_deauth_message_reportswitch != policy)
			sta_deauth_message_reportswitch = policy;
		for(i = 1 ; i<WTP_NUM; i++  ){
			if((AC_WTP[i]!=NULL)&&(AC_WTP[i]->sta_deauth_message_reportswitch != policy))
			{
				AC_WTP[i]->sta_deauth_message_reportswitch = policy;
				ret = wid_send_to_ap_sta_deauth_report(i);
			}	
		}	
		ret = WID_DBUS_SUCCESS;
	}
	else{
		if(AC_WTP[wtpid] == NULL)
		{
			ret = WTP_ID_NOT_EXIST;
		}
		else if(AC_WTP[wtpid]->sta_deauth_message_reportswitch== policy)
		{
			ret = WID_DBUS_SUCCESS;
		}
		else
		{
			AC_WTP[wtpid]->sta_deauth_message_reportswitch = policy;

			ret = wid_send_to_ap_sta_deauth_report(wtpid);
		}
	}
		
	reply = dbus_message_new_method_return(msg);

	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	return reply;
	
}
//weichao add 
DBusMessage * wid_dbus_interface_set_sta_all_flow_information_report_enable(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	int policy = 0;
	int ret = WID_DBUS_SUCCESS;
	int i = 0 ; 
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid == 0){
		if(sta_flow_information_reportswitch != policy)
			sta_flow_information_reportswitch = policy;
		for(i = 1 ; i<WTP_NUM; i++  ){
			if((AC_WTP[i]!=NULL)&&(AC_WTP[i]->sta_flow_information_reportswitch != policy))
			{
				AC_WTP[i]->sta_flow_information_reportswitch = policy;
				ret = wid_send_to_ap_sta_flow_information_report(i);
			}	
		}	
		ret = WID_DBUS_SUCCESS;
	}
	else{
		if(AC_WTP[wtpid] == NULL)
		{
			ret = WTP_ID_NOT_EXIST;
		}
		else if(AC_WTP[wtpid]->sta_flow_information_reportswitch== policy)
		{
			ret = WID_DBUS_SUCCESS;
		}
		else
		{
			AC_WTP[wtpid]->sta_flow_information_reportswitch = policy;

			ret = wid_send_to_ap_sta_flow_information_report(wtpid);
		}
	}
		
	reply = dbus_message_new_method_return(msg);

	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	return reply;
	
}
#if _GROUP_POLICY
/* zhangshu add for Terminal Disturb Info Report pkt, 2010-10-08 */
DBusMessage * wid_dbus_interface_set_wtp_terminal_disturb_info_pkt(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	int i = 0;
	int num =0 ;
	unsigned int ID = 0;
	unsigned int pkt = 0;
	unsigned int type = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
		
	struct Wtp_List  *wtp_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&pkt,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) 
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
if(type==0)
{	
	if(ID == 0){
		gTER_DIS_INFOREPORTPKT = pkt;
		for(i=0;i<WTP_NUM;i++){
			if(AC_WTP[i] != NULL){
				if(AC_WTP[i]->ter_dis_info.reportpkt == pkt)
				{
					ret = WID_DBUS_SUCCESS;
				}
				else
				{
					AC_WTP[i]->ter_dis_info.reportpkt = pkt;

				    if(AC_WTP[i]->ter_dis_info.reportswitch == 1)
				    {
					    ret = wid_send_to_ap_Terminal_Disturb_info(i);
					}
				}
			}	
		}
	}	/*wcl add for globle variable*/
	else if((ID>0)&&(ID<=(WTP_NUM-1)))
	{
		if(AC_WTP[ID] == NULL)
		{
			ret = WTP_ID_NOT_EXIST;
		}
		else if(AC_WTP[ID]->ter_dis_info.reportpkt == pkt)
		{
			ret = WID_DBUS_SUCCESS;
		}
		else
		{
			AC_WTP[ID]->ter_dis_info.reportpkt = pkt;

		    if(AC_WTP[ID]->ter_dis_info.reportswitch == 1)
		    {
			    ret = wid_send_to_ap_Terminal_Disturb_info(ID);
			}
		}
	}
	
}
else if(type==1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
				tmp = WTP_GROUP[ID]->WTP_M;
				wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
				
				while(tmp){
					ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
					printf("ret_check = %d\n",ret_check);
					if(ret_check == WID_DBUS_SUCCESS){
						if((tmp->WTPID>0)&&(tmp->WTPID<=(WTP_NUM-1)))
							{
								if(AC_WTP[tmp->WTPID] == NULL)
								{
									ret2 = WTP_ID_NOT_EXIST;
									wid_syslog_debug_debug(WID_DEFAULT,"WTP%d NOT EXIST\n",tmp->WTPID);
								}
								else if(AC_WTP[tmp->WTPID]->ter_dis_info.reportpkt == pkt)
								{
									ret2 = WID_DBUS_SUCCESS;
									wid_syslog_debug_debug(WID_DEFAULT,"WTP%d had this num yet\n",tmp->WTPID);
								}
								else
								{
									AC_WTP[tmp->WTPID]->ter_dis_info.reportpkt = pkt; //huxf
									wid_syslog_debug_debug(WID_DEFAULT,"WTP%d set num successful\n",tmp->WTPID);
						
									if(AC_WTP[tmp->WTPID]->ter_dis_info.reportswitch == 1)
									{
										  ret2 = wid_send_to_ap_Terminal_Disturb_info(tmp->WTPID);
										wid_syslog_debug_debug(WID_DEFAULT,"WTP%d has send info because of reportswitch on\n",tmp->WTPID);
									}
								}
							}

						if(ret2 != WID_DBUS_SUCCESS){

							wtp_head[num].WtpId = tmp->WTPID;
							wtp_head[num].FailReason = ret2;
							num++;
							
							}
						
						tmp = tmp->next;
					}
	
				}
					ret = WID_DBUS_SUCCESS;
			}
				
			else{
				ret = GROUP_ID_NOT_EXIST;
				}
		}
	reply = dbus_message_new_method_return(msg);
	
		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
		printf("num= %d\n",num);
		if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_UINT32,
												 &num);
			for(i = 0; i < num; i++){
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
													 &(wtp_head[i].WtpId));
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_BYTE,
													 &(wtp_head[i].FailReason));
			}	
			
			if(wtp_head!=NULL){
				WID_FREE(wtp_head);
				wtp_head = NULL;	
			}
		}
		
		return reply;


}

#else
/* zhangshu add for Terminal Disturb Info Report pkt, 2010-10-08 */
DBusMessage * wid_dbus_interface_set_wtp_terminal_disturb_info_pkt(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	unsigned int pkt = 0;
	unsigned int i = 0;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&pkt,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) 
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid == 0){
		gTER_DIS_INFOREPORTPKT = pkt;
		for(i=0;i<WTP_NUM;i++){
			if(AC_WTP[i] != NULL){
				if(AC_WTP[i]->ter_dis_info.reportpkt == pkt)
				{
					ret = WID_DBUS_SUCCESS;
				}
				else
				{
					AC_WTP[i]->ter_dis_info.reportpkt = pkt;

				    if(AC_WTP[i]->ter_dis_info.reportswitch == 1)
				    {
					    ret = wid_send_to_ap_Terminal_Disturb_info(i);
					}
				}
			}	
		}
	}	/*wcl add for globle variable*/
	else if((wtpid>0)&&(wtpid<=(WTP_NUM-1)))
	{
		if(AC_WTP[wtpid] == NULL)
		{
			ret = WTP_ID_NOT_EXIST;
		}
		else if(AC_WTP[wtpid]->ter_dis_info.reportpkt == pkt)
		{
			ret = WID_DBUS_SUCCESS;
		}
		else
		{
			AC_WTP[wtpid]->ter_dis_info.reportpkt = pkt;

		    if(AC_WTP[wtpid]->ter_dis_info.reportswitch == 1)
		    {
			    ret = wid_send_to_ap_Terminal_Disturb_info(wtpid);
			}
		}
	}
	/*else if(wtpid == 0)
	{
		for(i=0;i<WTP_NUM;i++)
		{
			if((AC_WTP[i] != NULL)&&(AC_WTP[i]->ter_dis_info.reportpkt == pkt))
			{
				ret = WID_DBUS_SUCCESS;
			}
			else if(AC_WTP[i] != NULL)
			{
				AC_WTP[i]->ter_dis_info.reportpkt = pkt;
			
				if(AC_WTP[wtpid]->ter_dis_info.reportswitch == 1)
		        {
			        ret = wid_send_to_ap_Terminal_Disturb_info(wtpid);
			    }
			}
		}
	}*//*wcl modify for globle variable*/
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
}
#endif
#if _GROUP_POLICY

/* zhangshu add for Terminal Disturb Info Report sta_trap_num, 2010-10-08 */
DBusMessage * wid_dbus_interface_set_wtp_terminal_disturb_info_sta_num(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;

	int i = 0;
	int num =0 ;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned int sta_trap_num = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
		
	struct Wtp_List  *wtp_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&sta_trap_num,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) 
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
if(type==0)
{
	if(ID == 0)
	{
		gTER_DIS_INFOSTA_TRAP_COUNT = sta_trap_num;
		for(i=0;i<WTP_NUM;i++){
			if(AC_WTP[i] != NULL){
				if(AC_WTP[i]->ter_dis_info.sta_trap_count== sta_trap_num)
				{
					ret = WID_DBUS_SUCCESS;
					
				}
				else
				{
					AC_WTP[i]->ter_dis_info.sta_trap_count = sta_trap_num;
					

				    if(AC_WTP[i]->ter_dis_info.reportswitch == 1)
				    {
					    ret = wid_send_to_ap_Terminal_Disturb_info(i);
					}
				}
			}
		}
	}/*wcl modify for globle variable*/
	else if((ID>0)&&(ID<=(WTP_NUM-1)))
	{
		if(AC_WTP[ID] == NULL)
		{
			ret = WTP_ID_NOT_EXIST;
			
		}
		else if(AC_WTP[ID]->ter_dis_info.sta_trap_count== sta_trap_num)
		{
			ret = WID_DBUS_SUCCESS;
			
		}
		else
		{
			AC_WTP[ID]->ter_dis_info.sta_trap_count = sta_trap_num;
			

		    if(AC_WTP[ID]->ter_dis_info.reportswitch == 1)
		    {
			    ret = wid_send_to_ap_Terminal_Disturb_info(ID);
			}
		}
	}
}

else if(type==1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
				tmp = WTP_GROUP[ID]->WTP_M;
				wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
				
				while(tmp){
					ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
					printf("ret_check = %d\n",ret_check);
					if(ret_check == WID_DBUS_SUCCESS){
						if((tmp->WTPID>0)&&(tmp->WTPID<=(WTP_NUM-1)))
							{
								if(AC_WTP[tmp->WTPID] == NULL)
								{
									ret2 = WTP_ID_NOT_EXIST;
									wid_syslog_debug_debug(WID_DEFAULT,"WTP%d NOT EXIST\n",tmp->WTPID);
								}
								else if(AC_WTP[tmp->WTPID]->ter_dis_info.sta_trap_count== sta_trap_num)
								{
									ret2 = WID_DBUS_SUCCESS;
									wid_syslog_debug_debug(WID_DEFAULT,"WTP%d had this num yet\n",tmp->WTPID);
								}
								else
								{
									AC_WTP[tmp->WTPID]->ter_dis_info.sta_trap_count = sta_trap_num;
									wid_syslog_debug_debug(WID_DEFAULT,"WTP%d set num successful\n",tmp->WTPID);
						
									if(AC_WTP[tmp->WTPID]->ter_dis_info.reportswitch == 1)
									{
										ret2 = wid_send_to_ap_Terminal_Disturb_info(tmp->WTPID);
										wid_syslog_debug_debug(WID_DEFAULT,"WTP%d has send info because of reportswitch on\n",tmp->WTPID);
									}
								}
							}

						if(ret2 != WID_DBUS_SUCCESS){

							wtp_head[num].WtpId = tmp->WTPID;
							wtp_head[num].FailReason = ret2;
							num++;
							
							}
						
						tmp = tmp->next;
					}
	
				}
					ret = WID_DBUS_SUCCESS;
			}
				
			else{
				ret = GROUP_ID_NOT_EXIST;
				}
		}
	reply = dbus_message_new_method_return(msg);
	
		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
		printf("num= %d\n",num);
		if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_UINT32,
												 &num);
			for(i = 0; i < num; i++){
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
													 &(wtp_head[i].WtpId));
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_BYTE,
													 &(wtp_head[i].FailReason));
			}	
			
			if(wtp_head!=NULL){
				WID_FREE(wtp_head);
				wtp_head = NULL;	
			}
		}
		
		return reply;
	

	

}

#else
/* zhangshu add for Terminal Disturb Info Report sta_trap_num, 2010-10-08 */
DBusMessage * wid_dbus_interface_set_wtp_terminal_disturb_info_sta_num(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	unsigned int sta_trap_num = 0;
	unsigned int i = 0;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&sta_trap_num,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) 
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid == 0)
	{
		gTER_DIS_INFOSTA_TRAP_COUNT = sta_trap_num;
		for(i=0;i<WTP_NUM;i++){
			if(AC_WTP[i] != NULL){
				if(AC_WTP[i]->ter_dis_info.sta_trap_count== sta_trap_num)
				{
					ret = WID_DBUS_SUCCESS;
					
				}
				else
				{
					AC_WTP[i]->ter_dis_info.sta_trap_count = sta_trap_num;
					

				    if(AC_WTP[i]->ter_dis_info.reportswitch == 1)
				    {
					    ret = wid_send_to_ap_Terminal_Disturb_info(i);
					}
				}
			}
		}
	}/*wcl modify for globle variable*/
	else if((wtpid>0)&&(wtpid<=(WTP_NUM-1)))
	{
		if(AC_WTP[wtpid] == NULL)
		{
			ret = WTP_ID_NOT_EXIST;
		}
		else if(AC_WTP[wtpid]->ter_dis_info.sta_trap_count== sta_trap_num)
		{
			ret = WID_DBUS_SUCCESS;
		}
		else
		{
			AC_WTP[wtpid]->ter_dis_info.sta_trap_count = sta_trap_num;

		    if(AC_WTP[wtpid]->ter_dis_info.reportswitch == 1)
		    {
			    ret = wid_send_to_ap_Terminal_Disturb_info(wtpid);
			}
		}
	}
	/*else if(wtpid == 0)
	{
		for(i=0;i<WTP_NUM;i++)
		{
			if((AC_WTP[i] != NULL)&&(AC_WTP[i]->ter_dis_info.sta_trap_count == sta_trap_num))
			{
				ret = WID_DBUS_SUCCESS;
			}
			else if(AC_WTP[i] != NULL)
			{
				AC_WTP[i]->ter_dis_info.sta_trap_count = sta_trap_num;
			
				if(AC_WTP[wtpid]->ter_dis_info.reportswitch == 1)
		        {
			        ret = wid_send_to_ap_Terminal_Disturb_info(wtpid);
			    }
			}
		}
	}
	*//*wcl modify for globle variable*/
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
}
#endif

DBusMessage * wid_dbus_interface_set_wtp_no_response_to_sta_proble_request(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	unsigned int policy = 0;
	unsigned int i = 0,j = 0,k=0;
	unsigned int radioid = 0;
	unsigned char l_radioid = 0;
	unsigned char wlanid = 0;
	unsigned char flag = 0;
	unsigned int bssindex = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret_tmp =0;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) 
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	wtpid = radioid/L_RADIO_NUM;
	l_radioid = radioid % L_RADIO_NUM;

	if((wlanid < 1)||(wlanid >= WLAN_NUM)||(AC_WLAN[wlanid] == NULL)){
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else{
		if((wtpid>0)&&(wtpid<=(WTP_NUM-1)))
		{
			if((AC_WTP[wtpid] == NULL)||(AC_RADIO[radioid] == NULL))
			{
				wid_syslog_warning("%s,%d,AC_WTP[%d]=%p,AC_RADIO[radioid]=%p.\n",__func__,__LINE__,wtpid,radioid,AC_WTP[wtpid],AC_RADIO[radioid]);
				ret = WTP_ID_NOT_EXIST;
			}
			for(k = 0; k < L_BSS_NUM; k++){
				if((AC_RADIO[radioid] != NULL)&&(AC_RADIO[radioid]->BSS[k] != NULL)&&(AC_BSS[radioid*L_BSS_NUM+k] != NULL)&&(AC_RADIO[radioid]->BSS[k]->WlanID == wlanid)){
					flag = 1;
					bssindex = radioid*L_BSS_NUM+k;
					break;
				}
			}
			if(1 == flag){
				if((AC_BSS[bssindex])&&(AC_BSS[bssindex]->noResToStaProReqSW == policy))
				{
					ret_tmp = WID_DBUS_SUCCESS;
				}
				else if(AC_BSS[bssindex])
				{
					AC_BSS[bssindex]->noResToStaProReqSW = policy;
					ret_tmp = setWtpNoRespToStaProReq(wtpid,l_radioid,wlanid,policy);
					wid_syslog_debug_debug(WID_DBUS,"%s,%d,radio %d not bind wlan:%d,bssindex=%d.\n",__func__,__LINE__,radioid,wlanid,bssindex);
				}else{
					wid_syslog_warning("%s,%d,AC_BSS[%d]=%p.\n",__func__,__LINE__,bssindex,AC_BSS[bssindex]);
					ret_tmp = BSS_NOT_EXIST;
				}
			}else{
				wid_syslog_warning("%s,%d,radio %d not bind wlan:%d.\n",__func__,__LINE__,radioid,wlanid);
				ret = RADIO_NO_BINDING_WLAN;
			}
		}
		else if(wtpid == 0)
		{
			for(i=0;i<WTP_NUM;i++)
			{
				for(j=0;(AC_WTP[i])&&(j<AC_WTP[i]->RadioCount)&&(j<L_RADIO_NUM);j++){
					radioid = i*L_RADIO_NUM + j;
					l_radioid = j;
					for(k = 0; k < L_BSS_NUM; k++){
						if((AC_RADIO[radioid] != NULL)&&(AC_RADIO[radioid]->BSS[k] != NULL)&&(AC_BSS[radioid*L_BSS_NUM+k] != NULL)){
							wlanid = AC_RADIO[radioid]->BSS[k]->WlanID;
							bssindex = radioid*L_BSS_NUM+k;
							if((AC_BSS[bssindex])&&(AC_BSS[bssindex]->noResToStaProReqSW == policy))
							{
								ret_tmp = WID_DBUS_SUCCESS;
							}
							else if(AC_BSS[bssindex])
							{
								AC_BSS[bssindex]->noResToStaProReqSW = policy;/*default is zero--disable*/
								ret_tmp = setWtpNoRespToStaProReq(i,l_radioid,wlanid,policy);
								wid_syslog_debug_debug(WID_DBUS,"%s,%d,radio %d not bind wlan:%d,bssindex=%d.\n",__func__,__LINE__,radioid,wlanid,bssindex);
							}else{
								wid_syslog_warning("%s,%d,AC_WTP[%d]=%p,AC_RADIO[%d]=%p,AC_BSSP[%d]=%p.\n",__func__,__LINE__,i,AC_WTP[i],radioid,AC_RADIO[radioid],bssindex,AC_BSS[bssindex]);
							}
							ret_tmp = WID_DBUS_SUCCESS;/*set ret successfull*/
						}
					}
		
				}
			}
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
}

DBusMessage * wid_dbus_interface_set_wtp_uni_muti_bro_cast_isolation_sw_and_rate_set(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	unsigned char policy = 0;
	unsigned int unicast = 0;
	unsigned int rate = 0;
	unsigned int i = 0,j = 0,k = 0;
	unsigned int pcy = 0;
	unsigned int radioid = 0,bssindex =0;
	unsigned char l_radioid = 0,flag = 0;
	unsigned char wlanid = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret_tmp = 0;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,
								DBUS_TYPE_UINT32,&unicast,
								DBUS_TYPE_BYTE,&policy,
								DBUS_TYPE_UINT32,&rate,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) 
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	wtpid = radioid/L_RADIO_NUM;
	l_radioid = radioid % L_RADIO_NUM;
	if((wlanid < 1)||(wlanid >= WLAN_NUM)||(AC_WLAN[wlanid] == NULL)){
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else{
		if((wtpid>0)&&(wtpid<=(WTP_NUM-1)))
		{
			if(AC_WTP[wtpid] == NULL)
			{
				ret = WTP_ID_NOT_EXIST;
			}
			else if(AC_WTP[wtpid] != NULL)
			{
				for(k = 0; k < L_BSS_NUM; k++){
					if((AC_RADIO[radioid] != NULL)&&(AC_RADIO[radioid]->BSS[k] != NULL)&&(AC_BSS[radioid*L_BSS_NUM+k] != NULL)&&(AC_RADIO[radioid]->BSS[k]->WlanID == wlanid)){
						flag = 1;
						bssindex = radioid*L_BSS_NUM+k;
						break;
					}
				}
				if(1 == flag){
					if(unicast == 1)
					{
						if(AC_BSS[bssindex]->unicast_sw != policy){
							AC_BSS[bssindex]->unicast_sw = policy;
							if((1 == AC_BSS[bssindex]->muti_bro_cast_sw)&&(1 == AC_BSS[bssindex]->unicast_sw)){
								pcy = 3;
							}else if(1 == AC_BSS[bssindex]->muti_bro_cast_sw){
								pcy = 2;
							}else if(1 == AC_BSS[bssindex]->unicast_sw){
								pcy = 1;
							}else{
								pcy = 0;
							}
							if(AC_BSS[bssindex]->wifi_sw == 1){
								pcy = pcy|0X4;
							}else{
								pcy = pcy&~0X4;
							}
							ret_tmp = setWtpUniMutiBroCastIsolation(wtpid,l_radioid,wlanid,pcy);
						}else{
							ret_tmp = WID_DBUS_SUCCESS;
						}
					}else if(unicast == 0){
						if(AC_BSS[bssindex]->muti_bro_cast_sw != policy){
							AC_BSS[bssindex]->muti_bro_cast_sw = policy;
							if((1 == AC_BSS[bssindex]->muti_bro_cast_sw)&&(1 == AC_BSS[bssindex]->unicast_sw)){
								pcy = 3;
							}else if(1 == AC_BSS[bssindex]->muti_bro_cast_sw){
								pcy = 2;
							}else if(1 == AC_BSS[bssindex]->unicast_sw){
								pcy = 1;
							}else{
								pcy = 0;
							}
							if(AC_BSS[bssindex]->wifi_sw == 1){
								pcy = pcy|0X4;
							}else{
								pcy = pcy&~0X4;
							}
							ret_tmp = setWtpUniMutiBroCastIsolation(wtpid,l_radioid,wlanid,pcy);
						}else{
							ret_tmp = WID_DBUS_SUCCESS;
						}
					}else if(unicast == 2){
							AC_BSS[bssindex]->unicast_sw = policy;
							AC_BSS[bssindex]->muti_bro_cast_sw = policy;
							
							if((1 == AC_BSS[bssindex]->muti_bro_cast_sw)&&(1 == AC_BSS[bssindex]->unicast_sw)){
								pcy = 3;
							}else if(1 == AC_BSS[bssindex]->muti_bro_cast_sw){
								pcy = 2;
							}else if(1 == AC_BSS[bssindex]->unicast_sw){
								pcy = 1;
							}else{
								pcy = 0;
							}
							if(AC_BSS[bssindex]->wifi_sw == 1){
								pcy = pcy|0X4;
							}else{
								pcy = pcy&~0X4;
							}
							ret_tmp = setWtpUniMutiBroCastIsolation(wtpid,l_radioid,wlanid,pcy);
					}else{
						if(AC_BSS[bssindex]->wifi_sw != policy){
							AC_BSS[bssindex]->wifi_sw = policy;
							if((1 == AC_BSS[bssindex]->muti_bro_cast_sw)&&(1 == AC_BSS[bssindex]->unicast_sw)){
								pcy = 3;
							}else if(1 == AC_BSS[bssindex]->muti_bro_cast_sw){
								pcy = 2;
							}else if(1 == AC_BSS[bssindex]->unicast_sw){
								pcy = 1;
							}else{
								pcy = 0;
							}
							if(AC_BSS[bssindex]->wifi_sw == 1){
								pcy = pcy|0X4;
							}else{
								pcy = pcy&~0X4;
							}
							ret_tmp = setWtpUniMutiBroCastIsolation(wtpid,l_radioid,wlanid,pcy);
						}
					}
				}else{
					wid_syslog_warning("%s,%d,radio %d not bind wlan:%d.\n",__func__,__LINE__,radioid,wlanid);
					ret = RADIO_NO_BINDING_WLAN;
				}
			}
		}
		else if(wtpid == 0)
		{
			for(i=0;i<WTP_NUM;i++)
			{
				if(AC_WTP[i] != NULL)
				{
					for(j=0;(j<AC_WTP[i]->RadioCount)&&(j<L_RADIO_NUM);j++){
						radioid = i*L_RADIO_NUM+j;
						l_radioid = j;
						for(k = 0; k < L_BSS_NUM; k++){
							if((AC_RADIO[radioid] != NULL)&&(AC_RADIO[radioid]->BSS[k] != NULL)&&(AC_BSS[radioid*L_BSS_NUM+k] != NULL)){
								bssindex = radioid*L_BSS_NUM+k;
								wlanid = AC_RADIO[radioid]->BSS[k]->WlanID;
								if(unicast == 1)
								{
									if(AC_BSS[bssindex]->unicast_sw != policy){
										AC_BSS[bssindex]->unicast_sw = policy;
										if((1 == AC_BSS[bssindex]->muti_bro_cast_sw)&&(1 == AC_BSS[bssindex]->unicast_sw)){
											pcy = 3;
										}else if(1 == AC_BSS[bssindex]->muti_bro_cast_sw){
											pcy = 2;
										}else if(1 == AC_BSS[bssindex]->unicast_sw){
											pcy = 1;
										}else{
											pcy = 0;
										}
										if(AC_BSS[bssindex]->wifi_sw == 1){
											pcy = pcy|0X4;
										}else{
											pcy = pcy&~0X4;
										}
										ret_tmp = setWtpUniMutiBroCastIsolation(i,l_radioid,wlanid,pcy);
									}else{
										ret_tmp = WID_DBUS_SUCCESS;
									}
								}else if(unicast == 0){
									if(AC_BSS[bssindex]->muti_bro_cast_sw != policy){
										AC_BSS[bssindex]->muti_bro_cast_sw = policy;
										if((1 == AC_BSS[bssindex]->muti_bro_cast_sw)&&(1 == AC_BSS[bssindex]->unicast_sw)){
											pcy = 3;
										}else if(1 == AC_BSS[bssindex]->muti_bro_cast_sw){
											pcy = 2;
										}else if(1 == AC_BSS[bssindex]->unicast_sw){
											pcy = 1;
										}else{
											pcy = 0;
										}
										if(AC_BSS[bssindex]->wifi_sw == 1){
											pcy = pcy|0X4;
										}else{
											pcy = pcy&~0X4;
										}
										ret_tmp = setWtpUniMutiBroCastIsolation(i,l_radioid,wlanid,pcy);
									}else{
										ret_tmp = WID_DBUS_SUCCESS;
									}
								}else if(unicast == 2){
									AC_BSS[bssindex]->unicast_sw = policy;
									AC_BSS[bssindex]->muti_bro_cast_sw = policy;
									
									if((1 == AC_BSS[bssindex]->muti_bro_cast_sw)&&(1 == AC_BSS[bssindex]->unicast_sw)){
										pcy = 3;
									}else if(1 == AC_BSS[bssindex]->muti_bro_cast_sw){
										pcy = 2;
									}else if(1 == AC_BSS[bssindex]->unicast_sw){
										pcy = 1;
									}else{
										pcy = 0;
									}
									if(AC_BSS[bssindex]->wifi_sw == 1){
										pcy = pcy|0X4;
									}else{
										pcy = pcy&~0X4;
									}
									ret_tmp = setWtpUniMutiBroCastIsolation(i,l_radioid,wlanid,pcy);
								}else{
									if(AC_BSS[bssindex]->wifi_sw != policy){
										AC_BSS[bssindex]->wifi_sw = policy;
										if((1 == AC_BSS[bssindex]->muti_bro_cast_sw)&&(1 == AC_BSS[bssindex]->unicast_sw)){
											pcy = 3;
										}else if(1 == AC_BSS[bssindex]->muti_bro_cast_sw){
											pcy = 2;
										}else if(1 == AC_BSS[bssindex]->unicast_sw){
											pcy = 1;
										}else{
											pcy = 0;
										}
										if(AC_BSS[bssindex]->wifi_sw == 1){
											pcy = pcy|0X4;
										}else{
											pcy = pcy&~0X4;
										}
										ret_tmp = setWtpUniMutiBroCastIsolation(i,l_radioid,wlanid,pcy);
									}
								}
							}
						}
					}
				}
			}
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
}

DBusMessage * wid_dbus_interface_set_wtp_muti_bro_cast_rate_set(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	unsigned char policy = 0;
	unsigned int unicast = 0;
	unsigned int rate = 0;
	unsigned int i = 0,j = 0,k = 0;
	//unsigned int pcy = 0;
	unsigned int radioid = 0,bssindex =0;
	unsigned char l_radioid = 0,flag = 0;
	unsigned char wlanid = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret_tmp = 0;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,
								DBUS_TYPE_UINT32,&unicast,
								DBUS_TYPE_BYTE,&policy,
								DBUS_TYPE_UINT32,&rate,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) 
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	wtpid = radioid/L_RADIO_NUM;
	l_radioid = radioid % L_RADIO_NUM;
	if((wlanid < 1)||(wlanid >= WLAN_NUM)||(AC_WLAN[wlanid] == NULL)){
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else{
		if((wtpid>0)&&(wtpid<=(WTP_NUM-1)))
		{
			if(AC_WTP[wtpid] == NULL)
			{
				ret = WTP_ID_NOT_EXIST;
			}
			else if(AC_WTP[wtpid] != NULL)
			{
				for(k = 0; k < L_BSS_NUM; k++){
					if((AC_RADIO[radioid] != NULL)&&(AC_RADIO[radioid]->BSS[k] != NULL)&&(AC_BSS[radioid*L_BSS_NUM+k] != NULL)&&(AC_RADIO[radioid]->BSS[k]->WlanID == wlanid)){
						flag = 1;
						bssindex = radioid*L_BSS_NUM+k;
						break;
					}
				}
				if(1 == flag){  /*fengwenchao change "ret_tmp" to ret for autelan-3094 20121129*/
					ret = uni_muti_bro_cast_rate_check(wtpid,l_radioid,rate);
					wid_syslog_debug_debug(WID_DBUS,"%s,%d,radio %d wlan:%d,bssindex=%d,check rate:%d,ret=%d.\n",__func__,__LINE__,radioid,wlanid,bssindex,rate,ret);
					if(0 == ret){
						if(AC_BSS[bssindex]->muti_rate != rate){
							AC_BSS[bssindex]->muti_rate = rate;
							wid_syslog_warning("%s,%d,set bssindex=%d,rate=%d.\n",__func__,__LINE__,bssindex,rate);
							ret = setWtpUniMutiBroCastRate(wtpid,l_radioid,wlanid,rate);
						}else{
							ret = WID_DBUS_SUCCESS;
						}
					}else{
						wid_syslog_warning("%s,%d,rate check fail.\n",__func__,__LINE__);
					}
				}else{
					wid_syslog_warning("%s,%d,radio %d not bind wlan:%d.\n",__func__,__LINE__,radioid,wlanid);
					ret = RADIO_NO_BINDING_WLAN;
				}
				/*fengwenchao change end*/
			}
		}
		else if(wtpid == 0)
		{
			for(i=0;i<WTP_NUM;i++)
			{
				if(AC_WTP[i] != NULL)
				{
					for(j=0;(j<AC_WTP[i]->RadioCount)&&(j<L_RADIO_NUM);j++){
						radioid = i*L_RADIO_NUM+j;
						l_radioid = j;
						for(k = 0; k < L_BSS_NUM; k++){
							if((AC_RADIO[radioid] != NULL)&&(AC_RADIO[radioid]->BSS[k] != NULL)&&(AC_BSS[radioid*L_BSS_NUM+k] != NULL)){
								bssindex = radioid*L_BSS_NUM+k;
								wlanid = AC_RADIO[radioid]->BSS[k]->WlanID;
								ret_tmp = uni_muti_bro_cast_rate_check(i,l_radioid,rate);
								wid_syslog_debug_debug(WID_DBUS,"%s,%d,radio %d wlan:%d,bssindex=%d,check rate.\n",__func__,__LINE__,radioid,wlanid,bssindex);
								if(ret_tmp == 0){
									if(AC_BSS[bssindex]->muti_rate != rate){
										AC_BSS[bssindex]->muti_rate = rate;
										ret_tmp = setWtpUniMutiBroCastRate(i,l_radioid,wlanid,rate);
									}else{
										ret_tmp = WID_DBUS_SUCCESS;
									}
								}
								else{
									wid_syslog_warning("%s,%d,radio %d check rate fail,ret:%d,radiotype=%d,rate=%d.\n",__func__,__LINE__,radioid,ret,AC_RADIO[radioid]->Radio_Type,rate);
									ret_tmp = WID_DBUS_SUCCESS;/*set ret successfull*/
								}
							}
						}
					}
				}
			}
		}
	}

	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
}


DBusMessage * wid_dbus_interface_set_wlan_no_response_to_sta_proble_request(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int policy = 0;
	unsigned int i = 0,j = 0,k=0;
	unsigned char wlanid = 0;
	//unsigned char flag = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret_tmp = 0;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) 
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wlanid > 0){
		if((wlanid < 1)||(wlanid >= WLAN_NUM)||(AC_WLAN[wlanid] == NULL)){
			ret = WLAN_ID_NOT_EXIST;
		}/*else if(AC_WLAN[wlanid]->Status == 0){
			return WLAN_BE_ENABLE;
		}*/	else
		if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
		{
			ret = WID_WANT_TO_DELETE_WLAN;
		}else{
			AC_WLAN[wlanid]->wlan_noResToStaProReqSW = policy;
			ret = WID_DBUS_SUCCESS;
			wid_syslog_debug_debug(WID_DBUS,"%s,%d,wlan:%d policy=%d.\n",__func__,__LINE__,wlanid,policy);
			for(i=0; i<WTP_NUM; i++)
			{
				if((AC_WTP[i]!=NULL)/*&&(AC_WTP[i]->isused == 1)*/)
				{
					for(j=0; j<AC_WTP[i]->RadioCount; j++)//zhanglei change L_RADIO_NUM to AC_WTP[i]->RadioCount
					{
						if(AC_WLAN[wlanid]->S_WTP_BSS_List[i][j] != 0)
						{
							int bssindex = AC_WLAN[wlanid]->S_WTP_BSS_List[i][j];
							int wtpid = (bssindex/L_BSS_NUM)/L_RADIO_NUM;
							int radioid = j;
							if(wtpid != i){
								wid_syslog_warning("%s,%d,wtpid != i,wtpid=%d,i=%d.\n",__func__,__LINE__,wtpid,i);
								continue;
							}
							if((AC_BSS[bssindex])&&(AC_BSS[bssindex]->noResToStaProReqSW == policy))
							{
								ret_tmp = WID_DBUS_SUCCESS;
							}
							else if(AC_BSS[bssindex])
							{
								AC_BSS[bssindex]->noResToStaProReqSW = policy;
								ret_tmp = setWtpNoRespToStaProReq(wtpid,j,wlanid,policy);
								wid_syslog_debug_debug(WID_DBUS,"%s,%d,radio %d not bind wlan:%d,bssindex=%d.\n",__func__,__LINE__,radioid,wlanid,bssindex);
							}else{
								wid_syslog_warning("%s,%d,AC_BSS[%d]=%p.\n",__func__,__LINE__,bssindex,AC_BSS[bssindex]);
								ret_tmp = BSS_NOT_EXIST;
							}
							wid_syslog_debug_debug(WID_DBUS,"%s,%d,ret=%d,bssindex=%d,wlan=%d.\n",__func__,__LINE__,ret_tmp,bssindex,wlanid);
						}
					}
				}

			}
		}
	}else if(wlanid == 0){/*wo must check AC_WLAN[wlanid]->Status,so not support wlanid ==0,now*/
		for(k=0;k<WLAN_NUM;k++){
			if(AC_WLAN[k] && (AC_WLAN[k]->want_to_delete != 1)){		/* Huangleilei add for ASXXZFI-1622 */
				AC_WLAN[k]->wlan_noResToStaProReqSW = policy;
				ret_tmp = WID_DBUS_SUCCESS;
				wid_syslog_debug_debug(WID_DBUS,"%s,%d,wlan:%d policy=%d.\n",__func__,__LINE__,k,policy);
				for(i=0; i<WTP_NUM; i++)
				{
					if((AC_WTP[i]!=NULL)/*&&(AC_WTP[i]->isused == 1)*/)
					{
						for(j=0; j<AC_WTP[i]->RadioCount; j++)//zhanglei change L_RADIO_NUM to AC_WTP[i]->RadioCount
						{
							if(AC_WLAN[k]->S_WTP_BSS_List[i][j] != 0)
							{
								int bssindex = AC_WLAN[k]->S_WTP_BSS_List[i][j];
								int wtpid = (bssindex/L_BSS_NUM)/L_RADIO_NUM;
								int radioid = j;
								if(wtpid != i){
									wid_syslog_warning("%s,%d,wtpid != i,wtpid=%d,i=%d.\n",__func__,__LINE__,wtpid,i);
									continue;
								}
								if((AC_BSS[bssindex])&&(AC_BSS[bssindex]->noResToStaProReqSW == policy))
								{
									ret_tmp = WID_DBUS_SUCCESS;
								}
								else if(AC_BSS[bssindex])
								{
									AC_BSS[bssindex]->noResToStaProReqSW = policy;
									ret_tmp = setWtpNoRespToStaProReq(wtpid,j,k,policy);
									wid_syslog_debug_debug(WID_DBUS,"%s,%d,radio %d not bind wlan:%d,bssindex=%d.\n",__func__,__LINE__,radioid,k,bssindex);
								}else{
									wid_syslog_warning("%s,%d,AC_BSS[%d]=%p.\n",__func__,__LINE__,bssindex,AC_BSS[bssindex]);
									ret_tmp = BSS_NOT_EXIST;
								}
								wid_syslog_debug_debug(WID_DBUS,"%s,%d,ret=%d,bssindex=%d,wlan=%d.\n",__func__,__LINE__,ret_tmp,bssindex,k);
							}
						}
					}

				}
			}
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
}

DBusMessage * wid_dbus_interface_set_wlan_uni_muti_bro_cast_isolation_sw_and_rate_set(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned char policy = 0;
	unsigned int unicast = 0;
	unsigned int rate = 0;
	unsigned int i = 0,j = 0,k = 0;
	unsigned int pcy = 0;
	unsigned char wlanid = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret_tmp = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&unicast,
								DBUS_TYPE_BYTE,&policy,
								DBUS_TYPE_UINT32,&rate,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) 
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wlanid > 0){
		if((wlanid < 1)||(wlanid >= WLAN_NUM)||(AC_WLAN[wlanid] == NULL)){
			ret = WLAN_ID_NOT_EXIST;
		}/*else if(AC_WLAN[wlanid]->Status == 0){
			return WLAN_BE_ENABLE;
		}*/
		else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
		{
			ret = WID_WANT_TO_DELETE_WLAN;
		}
		else{
			if(unicast == 1)
			{
				if(AC_WLAN[wlanid]->wlan_unicast_sw != policy){
					AC_WLAN[wlanid]->wlan_unicast_sw = policy;
				}else{
					ret = WID_DBUS_SUCCESS;
				}
			}else if(unicast == 0){
				if(AC_WLAN[wlanid]->wlan_muti_bro_cast_sw != policy){
					AC_WLAN[wlanid]->wlan_muti_bro_cast_sw = policy;
				}else{
					ret = WID_DBUS_SUCCESS;
				}
			}else if(unicast == 2){
					AC_WLAN[wlanid]->wlan_unicast_sw = policy;
					AC_WLAN[wlanid]->wlan_muti_bro_cast_sw = policy;
					
			}else{
				if(AC_WLAN[wlanid]->wlan_wifi_sw != policy){
					AC_WLAN[wlanid]->wlan_wifi_sw = policy;
				}
			}
			if(0 == ret)
			for(i=0; i<WTP_NUM; i++)
			{
				if((AC_WTP[i]!=NULL)/*&&(AC_WTP[i]->isused == 1)*/)
				{
					for(j=0; (j<AC_WTP[i]->RadioCount)&&(j<L_RADIO_NUM); j++)
					{
						if(AC_WLAN[wlanid]->S_WTP_BSS_List[i][j] != 0)
						{
							int bssindex = AC_WLAN[wlanid]->S_WTP_BSS_List[i][j];
							int wtpid = (bssindex/L_BSS_NUM)/L_RADIO_NUM;
							if(wtpid != i){
								wid_syslog_warning("%s,%d,wtpid != i,wtpid=%d,i=%d.\n",__func__,__LINE__,wtpid,i);
								continue;
							}
							//int radioid = j;
							if(0 == ret){
								if(unicast == 1)
								{
									if(AC_BSS[bssindex]->unicast_sw != policy){
										AC_BSS[bssindex]->unicast_sw = policy;
										if((1 == AC_BSS[bssindex]->muti_bro_cast_sw)&&(1 == AC_BSS[bssindex]->unicast_sw)){
											pcy = 3;
										}else if(1 == AC_BSS[bssindex]->muti_bro_cast_sw){
											pcy = 2;
										}else if(1 == AC_BSS[bssindex]->unicast_sw){
											pcy = 1;
										}else{
											pcy = 0;
										}
										if(AC_BSS[bssindex]->wifi_sw == 1){
											pcy = pcy|0X4;
										}else{
											pcy = pcy&~0X4;
										}
										ret_tmp = setWtpUniMutiBroCastIsolation(wtpid,j,wlanid,pcy);
									}else{
										ret_tmp = WID_DBUS_SUCCESS;
									}
								}else if(unicast == 0){
									if(AC_BSS[bssindex]->muti_bro_cast_sw != policy){
										AC_BSS[bssindex]->muti_bro_cast_sw = policy;
										if((1 == AC_BSS[bssindex]->muti_bro_cast_sw)&&(1 == AC_BSS[bssindex]->unicast_sw)){
											pcy = 3;
										}else if(1 == AC_BSS[bssindex]->muti_bro_cast_sw){
											pcy = 2;
										}else if(1 == AC_BSS[bssindex]->unicast_sw){
											pcy = 1;
										}else{
											pcy = 0;
										}
										if(AC_BSS[bssindex]->wifi_sw == 1){
											pcy = pcy|0X4;
										}else{
											pcy = pcy&~0X4;
										}
										ret_tmp = setWtpUniMutiBroCastIsolation(wtpid,j,wlanid,pcy);
									}else{
										ret_tmp = WID_DBUS_SUCCESS;
									}
								}else if(unicast == 2){
										AC_BSS[bssindex]->unicast_sw = policy;
										AC_BSS[bssindex]->muti_bro_cast_sw = policy;
										
										if((1 == AC_BSS[bssindex]->muti_bro_cast_sw)&&(1 == AC_BSS[bssindex]->unicast_sw)){
											pcy = 3;
										}else if(1 == AC_BSS[bssindex]->muti_bro_cast_sw){
											pcy = 2;
										}else if(1 == AC_BSS[bssindex]->unicast_sw){
											pcy = 1;
										}else{
											pcy = 0;
										}
										if(AC_BSS[bssindex]->wifi_sw == 1){
											pcy = pcy|0X4;
										}else{
											pcy = pcy&~0X4;
										}
										ret_tmp = setWtpUniMutiBroCastIsolation(wtpid,j,wlanid,pcy);
								}else{
									if(AC_BSS[bssindex]->wifi_sw != policy){
										AC_BSS[bssindex]->wifi_sw = policy;
										if((1 == AC_BSS[bssindex]->muti_bro_cast_sw)&&(1 == AC_BSS[bssindex]->unicast_sw)){
											pcy = 3;
										}else if(1 == AC_BSS[bssindex]->muti_bro_cast_sw){
											pcy = 2;
										}else if(1 == AC_BSS[bssindex]->unicast_sw){
											pcy = 1;
										}else{
											pcy = 0;
										}
										if(AC_BSS[bssindex]->wifi_sw == 1){
											pcy = pcy|0X4;
										}else{
											pcy = pcy&~0X4;
										}
										ret_tmp = setWtpUniMutiBroCastIsolation(wtpid,j,wlanid,pcy);
										wid_syslog_debug_debug(WID_DBUS,"%s,%d,ret=%d,bssindex=%d,wlan=%d,pcy=%d.\n",__func__,__LINE__,ret,bssindex,wlanid,pcy);
									}
								}
							}
							wid_syslog_debug_debug(WID_DBUS,"%s,%d,ret=%d,bssindex=%d,wlan=%d.\n",__func__,__LINE__,ret,bssindex,wlanid);
						}
					}
				}
		
			}
		}
	}else if(0 == wlanid){
		/*fengwenchao add 20120323*/
		if(unicast == 1)
		{
			gWLAN_UNI_MUTI_BRO_CAST.unicast_policy = policy;
		}else if(unicast == 0)
		{
			gWLAN_UNI_MUTI_BRO_CAST.multicast_broadcast_policy = policy;
		}else if(unicast == 2)
		{
			gWLAN_UNI_MUTI_BRO_CAST.multicast_broadcast_policy = policy;
			gWLAN_UNI_MUTI_BRO_CAST.unicast_policy = policy;				
		}else
		{
			gWLAN_UNI_MUTI_BRO_CAST.wifi_policy = policy;
		}
		/*fengwenchao add end*/
		for(k=0;k<WLAN_NUM;k++){
			if(AC_WLAN[k] == NULL){
				continue;
			}
			else if (AC_WLAN[k]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
			{
				ret = WID_WANT_TO_DELETE_WLAN;
				continue;
			}
			if(unicast == 1)
			{
				if(AC_WLAN[k]->wlan_unicast_sw != policy){
					AC_WLAN[k]->wlan_unicast_sw = policy;
				}else{
					ret = WID_DBUS_SUCCESS;
				}
			}else if(unicast == 0){
				if(AC_WLAN[k]->wlan_muti_bro_cast_sw != policy){
					AC_WLAN[k]->wlan_muti_bro_cast_sw = policy;
				}else{
					ret = WID_DBUS_SUCCESS;
				}
			}else if(unicast == 2){
					AC_WLAN[k]->wlan_unicast_sw = policy;
					AC_WLAN[k]->wlan_muti_bro_cast_sw = policy;
					
			}else{
				if(AC_WLAN[k]->wlan_wifi_sw != policy){
					AC_WLAN[k]->wlan_wifi_sw = policy;
				}
			}
			if(ret == 0)
			for(i=0; i<WTP_NUM; i++)
			{
				if((AC_WTP[i]!=NULL)/*&&(AC_WTP[i]->isused == 1)*/)
				{
					for(j=0; (j<AC_WTP[i]->RadioCount)&&(j<L_RADIO_NUM); j++)
					{
						if((AC_WLAN[k])&&(AC_WLAN[k]->S_WTP_BSS_List[i][j] != 0) && (AC_WLAN[k]->want_to_delete != 1))		/* Huangleilei add for ASXXZFI-1622 */
						{
							int bssindex = AC_WLAN[k]->S_WTP_BSS_List[i][j];
							int wtpid = (bssindex/L_BSS_NUM)/L_RADIO_NUM;
							//int radioid = j;
							if(wtpid != i){
								wid_syslog_warning("%s,%d,wtpid != i,wtpid=%d,i=%d.\n",__func__,__LINE__,wtpid,i);
								continue;
							}
							if(0 == ret){
								if(unicast == 1)
								{
									if(AC_BSS[bssindex]->unicast_sw != policy){
										AC_BSS[bssindex]->unicast_sw = policy;
										if((1 == AC_BSS[bssindex]->muti_bro_cast_sw)&&(1 == AC_BSS[bssindex]->unicast_sw)){
											pcy = 3;
										}else if(1 == AC_BSS[bssindex]->muti_bro_cast_sw){
											pcy = 2;
										}else if(1 == AC_BSS[bssindex]->unicast_sw){
											pcy = 1;
										}else{
											pcy = 0;
										}
										if(AC_BSS[bssindex]->wifi_sw == 1){
											pcy = pcy|0X4;
										}else{
											pcy = pcy&~0X4;
										}
										ret_tmp = setWtpUniMutiBroCastIsolation(wtpid,j,k,pcy);
									}else{
										ret_tmp = WID_DBUS_SUCCESS;
									}
								}else if(unicast == 0){
									if(AC_BSS[bssindex]->muti_bro_cast_sw != policy){
										AC_BSS[bssindex]->muti_bro_cast_sw = policy;
										if((1 == AC_BSS[bssindex]->muti_bro_cast_sw)&&(1 == AC_BSS[bssindex]->unicast_sw)){
											pcy = 3;
										}else if(1 == AC_BSS[bssindex]->muti_bro_cast_sw){
											pcy = 2;
										}else if(1 == AC_BSS[bssindex]->unicast_sw){
											pcy = 1;
										}else{
											pcy = 0;
										}
										if(AC_BSS[bssindex]->wifi_sw == 1){
											pcy = pcy|0X4;
										}else{
											pcy = pcy&~0X4;
										}
										ret_tmp = setWtpUniMutiBroCastIsolation(wtpid,j,k,pcy);
									}else{
										ret_tmp = WID_DBUS_SUCCESS;
									}
								}else if(unicast == 2){
										AC_BSS[bssindex]->unicast_sw = policy;
										AC_BSS[bssindex]->muti_bro_cast_sw = policy;
										
										if((1 == AC_BSS[bssindex]->muti_bro_cast_sw)&&(1 == AC_BSS[bssindex]->unicast_sw)){
											pcy = 3;
										}else if(1 == AC_BSS[bssindex]->muti_bro_cast_sw){
											pcy = 2;
										}else if(1 == AC_BSS[bssindex]->unicast_sw){
											pcy = 1;
										}else{
											pcy = 0;
										}
										if(AC_BSS[bssindex]->wifi_sw == 1){
											pcy = pcy|0X4;
										}else{
											pcy = pcy&~0X4;
										}
										ret_tmp = setWtpUniMutiBroCastIsolation(wtpid,j,k,pcy);
								}else{
									if(AC_BSS[bssindex]->wifi_sw != policy){
										AC_BSS[bssindex]->wifi_sw = policy;
										if(AC_BSS[bssindex]->wifi_sw == 1){
											pcy = pcy|0X4;
										}else{
											pcy = pcy&~0X4;
										}
										ret_tmp = setWtpUniMutiBroCastIsolation(wtpid,j,k,pcy);
									}
								}
							}
							wid_syslog_debug_debug(WID_DBUS,"%s,%d,ret=%d,bssindex=%d,wlan=%d.\n",__func__,__LINE__,ret,bssindex,k);
						}
					}
				}
		
			}
		}
	}

	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
}

DBusMessage * wid_dbus_interface_set_wlan_muti_bro_cast_rate_set(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned char policy = 0;
	unsigned int unicast = 0;
	unsigned int rate = 0;
	unsigned int i = 0,j = 0,k = 0;
	//unsigned int pcy = 0;
	unsigned char wlanid = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret_tmp = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&unicast,
								DBUS_TYPE_BYTE,&policy,
								DBUS_TYPE_UINT32,&rate,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) 
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wlanid > 0){
		if((wlanid < 1)||(wlanid >= WLAN_NUM)||(AC_WLAN[wlanid] == NULL)){
			ret = WLAN_ID_NOT_EXIST;
		}/*else if(AC_WLAN[wlanid]->Status == 0){
			return WLAN_BE_ENABLE;
		}*/
		else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
		{
			ret = WID_WANT_TO_DELETE_WLAN;
		}
		else{
			if(AC_WLAN[wlanid]->wlan_muti_rate != rate){
				AC_WLAN[wlanid]->wlan_muti_rate = rate;
				wid_syslog_debug_debug(WID_DBUS,"%s,%d,set wlan=%d,rate=%d.\n",__func__,__LINE__,wlanid,rate);
				for(i=0; i<WTP_NUM; i++)
				{
					if((AC_WTP[i]!=NULL)/*&&(AC_WTP[i]->isused == 1)*/)
					{
						for(j=0; (j<AC_WTP[i]->RadioCount)&&(j<L_RADIO_NUM); j++)
						{
							if(AC_WLAN[wlanid]->S_WTP_BSS_List[i][j] != 0)
							{
								int bssindex = AC_WLAN[wlanid]->S_WTP_BSS_List[i][j];
								int wtpid = (bssindex/L_BSS_NUM)/L_RADIO_NUM;
								if(wtpid != i){
									wid_syslog_warning("%s,%d,wtpid != i,wtpid=%d,i=%d.\n",__func__,__LINE__,wtpid,i);
									continue;
								}
								int radioid = j;
		
								ret_tmp = uni_muti_bro_cast_rate_check(wtpid,j,rate);
								wid_syslog_debug_debug(WID_DBUS,"%s,%d,radio %d wlan:%d,bssindex=%d,check rate:%d,ret=%d.\n",__func__,__LINE__,radioid,wlanid,bssindex,rate,ret);
								if(0 == ret_tmp){
									if(AC_BSS[bssindex]){
										if(AC_BSS[bssindex]->muti_rate != rate){
											AC_BSS[bssindex]->muti_rate = rate;
											wid_syslog_warning("%s,%d,set bssindex=%d,rate=%d.\n",__func__,__LINE__,bssindex,rate);
											ret_tmp = setWtpUniMutiBroCastRate(wtpid,j,wlanid,rate);
										}else{
											ret_tmp = WID_DBUS_SUCCESS;
										}
									}else{
										wid_syslog_warning("%s,%d,AC_BSS[%d]=NULL.\n",__func__,__LINE__,bssindex,AC_BSS[bssindex]);
									}
								}else{
									wid_syslog_warning("%s,%d,rate check fail.\n",__func__,__LINE__);
								}
								wid_syslog_debug_debug(WID_DBUS,"%s,%d,ret=%d,bssindex=%d,wlan=%d.\n",__func__,__LINE__,ret,bssindex,wlanid);
							}
						}
					}
			
				}
			}else{
				ret = WID_DBUS_SUCCESS;
			}
		}
	}else if(wlanid == 0){
		gWLAN_UNI_MUTI_BRO_CAST.rate = rate;//fengwenchao add 20120323
		for(k=0;k<WLAN_NUM;k++){
			if(AC_WLAN[k] && (AC_WLAN[k]->want_to_delete != 1)){		/* Huangleilei add for ASXXZFI-1622 */
				AC_WLAN[k]->wlan_muti_rate = rate;
				for(i=0; i<WTP_NUM; i++)
				{
					if((AC_WTP[i]!=NULL)/*&&(AC_WTP[i]->isused == 1)*/)
					{
						for(j=0; (j<AC_WTP[i]->RadioCount)&&(j<L_RADIO_NUM); j++)
						{
							if(AC_WLAN[k]->S_WTP_BSS_List[i][j] != 0)
							{
								int bssindex = AC_WLAN[k]->S_WTP_BSS_List[i][j];
								int wtpid = (bssindex/L_BSS_NUM)/L_RADIO_NUM;
								int radioid = j;
								if(wtpid != i){
									wid_syslog_warning("%s,%d,wtpid != i,wtpid=%d,i=%d.\n",__func__,__LINE__,wtpid,i);
									continue;
								}
								ret_tmp = uni_muti_bro_cast_rate_check(wtpid,j,rate);
								wid_syslog_debug_debug(WID_DBUS,"%s,%d,radio %d wlan:%d,bssindex=%d,check rate:%d,ret=%d.\n",__func__,__LINE__,radioid,k,bssindex,rate,ret);
								if(0 == ret_tmp){
									if(AC_BSS[bssindex]){
										if(AC_BSS[bssindex]->muti_rate != rate){
											AC_BSS[bssindex]->muti_rate = rate;
											wid_syslog_warning("%s,%d,set bssindex=%d,rate=%d.\n",__func__,__LINE__,bssindex,rate);
											ret_tmp = setWtpUniMutiBroCastRate(wtpid,j,k,rate);
										}else{
											ret_tmp = WID_DBUS_SUCCESS;
										}
									}else{
										wid_syslog_warning("%s,%d,AC_BSS[%d]=NULL.\n",__func__,__LINE__,bssindex,AC_BSS[bssindex]);
									}
								}else{
									wid_syslog_warning("%s,%d,rate check fail.\n",__func__,__LINE__);
								}
								wid_syslog_debug_debug(WID_DBUS,"%s,%d,ret=%d,bssindex=%d,wlan=%d.\n",__func__,__LINE__,ret,bssindex,k);
							}
						}
					}
			
				}

			}
		}
	}


	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
}
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_wtp_extension_infomation_interval(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	int i = 0;
	int num =0 ;

	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned int interval = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
		
	struct Wtp_List  *wtp_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&interval,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			if(ID == 0){
				gWIFIEXTENSIONREPORTINTERVAL = interval;
				for(i=0;i<WTP_NUM;i++){				
					if(AC_WTP[i] != NULL){
						if(AC_WTP[i]->wifi_extension_reportinterval == interval ){
							ret = WID_DBUS_SUCCESS;
						}else {
							AC_WTP[i]->wifi_extension_reportinterval = interval ;
							ret = wid_send_to_ap_extension_infomation(i);
							}
					}
				}
			}	/*wcl add for globle variable*/
			
			else if(AC_WTP[ID] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else if(AC_WTP[ID]->wifi_extension_reportinterval == interval)
				{
					ret = WID_DBUS_SUCCESS;
				}
			else if(gWTPs[ID].currentState != CW_ENTER_RUN)
				{
					ret = WTP_NOT_IN_RUN_STATE;
				}	
			else
				{
					AC_WTP[ID]->wifi_extension_reportinterval = interval;

					ret = wid_send_to_ap_extension_infomation(ID);
				}
		}

	
	else if(type==1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
				tmp = WTP_GROUP[ID]->WTP_M;
				wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
				
				while(tmp){
					ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
					printf("ret_check = %d\n",ret_check);
					if(ret_check == WID_DBUS_SUCCESS){
						 if(AC_WTP[tmp->WTPID]->wifi_extension_reportinterval==(unsigned short)interval)
							{
								ret2 = WID_DBUS_SUCCESS;
								wid_syslog_debug_debug(WID_DEFAULT,"WTP%d had this interval yet\n",tmp->WTPID);

							}
						 else if(AC_WTP[tmp->WTPID]->WTPStat != 5)
						 	{
						 		ret2= WTP_NOT_IN_RUN_STATE;
								wid_syslog_debug_debug(WID_DEFAULT,"WTP%d NOT RUN\n",tmp->WTPID);
						 	}
						 else 
							{	AC_WTP[tmp->WTPID]->wifi_extension_reportinterval = (unsigned short)interval;
								ret2 = wid_send_to_ap_extension_infomation(tmp->WTPID);

							}
						if(ret2 != WID_DBUS_SUCCESS){

							wtp_head[num].WtpId = tmp->WTPID;
							wtp_head[num].FailReason = ret2;
							num++;
							
							}
						
						tmp = tmp->next;
					}
	
				}
					ret = WID_DBUS_SUCCESS;
			}
				
			else{
				ret = GROUP_ID_NOT_EXIST;
				}
		}
	reply = dbus_message_new_method_return(msg);
	
		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
		printf("num= %d\n",num);
		if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_UINT32,
												 &num);
			for(i = 0; i < num; i++){
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
													 &(wtp_head[i].WtpId));
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_BYTE,
													 &(wtp_head[i].FailReason));
			}	
			
			if(wtp_head!=NULL){
				WID_FREE(wtp_head);
				wtp_head = NULL;	
			}
		}
		
		return reply;
	
}



DBusMessage * wid_dbus_interface_set_wtp_wbs_cpe_switch(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter  iter;
	DBusError err;
	unsigned int policy = 0;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){
		wid_syslog_err("get input args for wtp unathorized mac switch failed\n");	
		if (dbus_error_is_set(&err)) {
			wid_syslog_err("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	g_wbs_cpe_switch = policy;
	
	wid_syslog_debug_debug(WID_DEFAULT, "set wbs-cpe switch %s successfully\n", policy ? "enable" : "disable");
	
	reply = dbus_message_new_method_return(msg);

	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}

DBusMessage * wid_dbus_interface_set_wtp_unauthorized_mac_switch(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	unsigned int policy = 0;
	int i=0; 
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){
		wid_syslog_err("get input args for wtp unathorized mac switch failed\n");	
		if (dbus_error_is_set(&err)) {
			wid_syslog_err("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid == 0){
		wid_syslog_debug_debug(WID_DEFAULT, "set unauthorized mac switch %s for all wtp\n", policy ? "enable" : "disable");
		g_unauthorized_mac_switch = (unsigned char)policy;
		
		for(i=0;i<WTP_NUM;i++){				
			if(AC_WTP[i] != NULL){
				if(AC_WTP[i]->unauthorized_mac_reportswitch == (unsigned char)policy) {
					continue;
				} else {
					AC_WTP[i]->unauthorized_mac_reportswitch = (unsigned char)policy;
					ret = wid_send_to_ap_unauthorized_mac_reportinterval(i);
				}
			}
		}
	}
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtpid]->unauthorized_mac_reportswitch == (unsigned char)policy)
	{
		wid_syslog_debug_debug(WID_DEFAULT, "wtp %d unauthorized mac reportswitch is already %s\n", wtpid, policy ? "enable" : "disable");
		ret = WID_DBUS_SUCCESS;
	}
	else
	{
		wid_syslog_debug_debug(WID_DEFAULT, "set unauthorized mac switch %s for wtp %d\n", policy ? "enable" : "disable", wtpid);
		AC_WTP[wtpid]->unauthorized_mac_reportswitch = (unsigned char)policy;
		ret = wid_send_to_ap_unauthorized_mac_reportinterval(wtpid);
	}
	
		
	reply = dbus_message_new_method_return(msg);

	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}

DBusMessage * wid_dbus_interface_set_ap_longitude_latitude_command(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter  iter;
	unsigned char *longitude, *latitude;
	unsigned int wtpid;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32, &wtpid,
								DBUS_TYPE_STRING, &longitude,
								DBUS_TYPE_STRING, &latitude,
								DBUS_TYPE_INVALID))){
								
		wid_syslog_err("Unable to get input args\n");
		
		if (dbus_error_is_set(&err)) {
			wid_syslog_err("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	wid_syslog_debug_debug(WID_DEFAULT, "set longitude and latitude for wtp %d\n", wtpid);
	
	if(wtpid == 0 || AC_WTP[wtpid] != NULL)
	{
		wid_set_ap_longitude_latitude(wtpid, longitude, latitude); 
	} else {
		ret = WTP_ID_NOT_EXIST;
	}
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	return reply;
	
}

DBusMessage * wid_dbus_interface_set_wtp_unauthorized_mac_interval(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	unsigned int interval = 0;
	int i=0; /*wcl add for globle variable*/
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&interval,
								DBUS_TYPE_INVALID))){

		wid_syslog_err("Unable to get input args for set wtp unauthorized mac interval\n");
				
		if (dbus_error_is_set(&err)) {
			wid_syslog_err("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid == 0){
		wid_syslog_debug_debug(WID_DEFAULT, "set unauthorized mac interval %u for all wtp\n", interval);
		g_unauthorized_mac_interval = (unsigned short)interval;
		for(i=0;i<WTP_NUM;i++){				
			if(AC_WTP[i] != NULL){
				if(AC_WTP[i]->unauthorized_mac_reportinterval == (unsigned short)interval){
					ret = WID_DBUS_SUCCESS;
				}else {
					AC_WTP[i]->unauthorized_mac_reportinterval = (unsigned short)interval;
					ret = wid_send_to_ap_unauthorized_mac_reportinterval(i);
				}
			}
		}
	}
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtpid]->unauthorized_mac_reportinterval == (unsigned short)interval)
	{
		wid_syslog_debug_debug(WID_DEFAULT, "wtp %d unauthorized mac report interval is already %u\n",wtpid, interval);
		ret = WID_DBUS_SUCCESS;
	}
	else
	{
		wid_syslog_debug_debug(WID_DEFAULT, "set unauthorized mac interval %u for wtp %d\n", interval, wtpid);
		AC_WTP[wtpid]->unauthorized_mac_reportinterval = (unsigned short)interval;
		ret = wid_send_to_ap_unauthorized_mac_reportinterval(wtpid);
	}
	
		
	reply = dbus_message_new_method_return(msg);

	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}


DBusMessage * wid_dbus_interface_set_wtp_configure_error_switch(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	unsigned int policy = 0;
	int i=0; 
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		wid_syslog_err("Unable to get input args for set wtp configure error switch\n");
		if (dbus_error_is_set(&err)) {
			wid_syslog_err("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(wtpid == 0){
		wid_syslog_debug_debug(WID_DEFAULT, "set configure error switch %s for all wtp\n", policy ? "enable" : "disable");
		g_configure_error_switch = (unsigned char)policy;
		
		for(i=0;i<WTP_NUM;i++){				
			if(AC_WTP[i] != NULL){
				if(AC_WTP[i]->wtp_configure_error_reportswitch == (unsigned char)policy){
					continue;
				}else {
					AC_WTP[i]->wtp_configure_error_reportswitch = (unsigned char)policy;
					ret = wid_send_to_ap_configure_error_reportinterval(i);
				}
			}
		}
	}
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtpid]->wtp_configure_error_reportswitch == (unsigned char)policy)
	{
		wid_syslog_debug_debug(WID_DEFAULT, "wtp %d unauthorized mac report switch is already %s\n", wtpid, policy ? "enabl" : "disable");
		ret = WID_DBUS_SUCCESS;
	}
	else
	{
		wid_syslog_debug_debug(WID_DEFAULT, "set unauthorized mac switch %s for wtp %d\n", policy ? "enable" : "disable", wtpid);
		AC_WTP[wtpid]->wtp_configure_error_reportswitch = (unsigned char)policy;
		ret = wid_send_to_ap_configure_error_reportinterval(wtpid);
	}
	
	reply = dbus_message_new_method_return(msg);

	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}


DBusMessage * wid_dbus_interface_set_wtp_configure_error_interval(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	unsigned int interval = 0;
	int i=0; /*wcl add for globle variable*/
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&interval,
								DBUS_TYPE_INVALID))){

		wid_syslog_err("Unable to get input args\n");

		if (dbus_error_is_set(&err)) {
			wid_syslog_err("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid == 0){
		wid_syslog_debug_debug(WID_DEFAULT, "set configure error interval %u for all wtp\n", interval);
		g_unauthorized_mac_interval = (unsigned short)interval;
		
		for(i=0;i<WTP_NUM;i++){				
			if(AC_WTP[i] != NULL){
				if(AC_WTP[i]->wtp_configure_error_reportinterval == (unsigned short)interval){
					ret = WID_DBUS_SUCCESS;
				}else {
					AC_WTP[i]->wtp_configure_error_reportinterval = (unsigned short)interval;
					ret = wid_send_to_ap_configure_error_reportinterval(i);
				}
			}
		}
	}	/*wcl add for globle variable*/
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtpid]->wtp_configure_error_reportinterval == (unsigned short)interval)
	{
		wid_syslog_debug_debug(WID_DEFAULT, "wtp %d configure error report interval is already %u\n",wtpid, interval);
		ret = WID_DBUS_SUCCESS;
	}
	else
	{
		wid_syslog_debug_debug(WID_DEFAULT, "set configure error interval %u for wtp %d\n", interval, wtpid);
		AC_WTP[wtpid]->wtp_configure_error_reportinterval = (unsigned short)interval;
		ret = wid_send_to_ap_unauthorized_mac_reportinterval(wtpid);
	}
	
		
	reply = dbus_message_new_method_return(msg);

	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}



DBusMessage * wid_dbus_interface_set_wtp_online_sta_full_switch(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	unsigned int policy = 0;
	int i=0; 
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		wid_syslog_err("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			wid_syslog_err("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid == 0){
		wid_syslog_debug_debug(WID_DEFAULT, "set wtp online sta full switch %s for all wtp\n", policy ? "enable" : "disable");
		g_online_sta_full_switch = (unsigned char)policy;
		
		for(i=0;i<WTP_NUM;i++){				
			if(AC_WTP[i] != NULL){
				if(AC_WTP[i]->sta_online_full_reportswitch == (unsigned char)policy){
					continue;
				}else {
					AC_WTP[i]->sta_online_full_reportswitch = (unsigned char)policy;
					ret = wid_send_to_ap_sta_online_full_reportinterval(i);
				}
			}
		}
	}
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtpid]->sta_online_full_reportswitch == (unsigned char)policy)
	{
		wid_syslog_debug_debug(WID_DEFAULT, "wtp %d online sta full switch is already %s\n", wtpid, policy ? "enable" : "disable");
		ret = WID_DBUS_SUCCESS;
	}
	else
	{
		wid_syslog_debug_debug(WID_DEFAULT, "set online sta full switch %s for wtp %d\n", policy ? "enable" : "disable", wtpid);
		AC_WTP[wtpid]->sta_online_full_reportswitch = (unsigned char)policy;
		ret = wid_send_to_ap_sta_online_full_reportinterval(wtpid);
	}
	
		
	reply = dbus_message_new_method_return(msg);

	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}


DBusMessage * wid_dbus_interface_set_wtp_online_sta_full_interval(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	unsigned int interval = 0;
	int i=0; /*wcl add for globle variable*/
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&interval,
								DBUS_TYPE_INVALID))){

		wid_syslog_err("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			wid_syslog_err("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid == 0){
		wid_syslog_debug_debug(WID_DEFAULT, "set online sta full interval %u for all wtp\n", interval);
		g_online_sta_full_interval = (unsigned short)interval;
		
		for(i=0;i<WTP_NUM;i++){				
			if(AC_WTP[i] != NULL){
				if(AC_WTP[i]->sta_online_full_reportinterval == (unsigned short)interval){
					ret = WID_DBUS_SUCCESS;
				}else {
					AC_WTP[i]->sta_online_full_reportinterval = (unsigned short)interval;
					ret = wid_send_to_ap_sta_online_full_reportinterval(i);
				}
			}
		}
	}	/*wcl add for globle variable*/
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtpid]->sta_online_full_reportinterval == (unsigned short)interval)
	{
		wid_syslog_debug_debug(WID_DEFAULT, "wtp %d online sta full report interval already is %u\n",wtpid, interval);
		ret = WID_DBUS_SUCCESS;
	}
	else
	{
		wid_syslog_debug_debug(WID_DEFAULT, "set online sta full interval %u for wtp %d\n", interval, wtpid);
		AC_WTP[wtpid]->sta_online_full_reportinterval = (unsigned short)interval;
		ret = wid_send_to_ap_sta_online_full_reportinterval(wtpid);
	}
	
		
	reply = dbus_message_new_method_return(msg);

	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}


DBusMessage * wid_dbus_interface_set_wtp_sta_flow_rx_tx_trap_switch(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	unsigned int policy = 0;

	unsigned int is_rx_tx = 0;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&is_rx_tx,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		wid_syslog_err("Unable to get input args for sta flow rx/tx trap switch\n");
				
		if (dbus_error_is_set(&err)) {
			wid_syslog_err("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	} else {
		if (is_rx_tx) {
			wid_syslog_debug_debug(WID_DEFAULT, "set sta flow overflow trap switch %s for all wtp %s\n", 
				policy ? "enable" : "disable", is_rx_tx ? "rx" : "tx");
			g_sta_flow_rx_overflow_trap_switch = (unsigned char)policy;
		} else {
			wid_syslog_debug_debug(WID_DEFAULT, "set unauthorized mac switch %s for all wtp %s\n", 
				policy ? "enable" : "disable", is_rx_tx ? "rx" : "tx");
			g_sta_flow_tx_overflow_trap_switch = (unsigned char)policy;
			
		}
		
	}

	reply = dbus_message_new_method_return(msg);

	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	wid_syslog_debug_debug(WID_DEFAULT, "ssssssssssssssss\n");
	return reply;
	
}


DBusMessage * wid_dbus_interface_set_wtp_sta_flow_rx_tx_overflow_switch(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	unsigned int policy = 0;
	int i=0; 
	unsigned int is_rx_tx = 0;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&is_rx_tx,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		wid_syslog_err("Unable to get input args for sta flow rx/tx overflow switch\n");
				
		if (dbus_error_is_set(&err)) {
			wid_syslog_err("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(wtpid == 0){
		if (is_rx_tx) {
			wid_syslog_debug_debug(WID_DEFAULT, "set sta flow overflow switch %s for all wtp %s\n", 
				policy ? "enable" : "disable", is_rx_tx ? "rx" : "tx");
			g_sta_flow_rx_overflow_switch = (unsigned char)policy;
		
			for(i=0;i<WTP_NUM;i++){				
				if(AC_WTP[i] != NULL){
					if(AC_WTP[i]->sta_flow_overflow_rx_reportswitch == (unsigned char)policy){
						continue;
					}else {
						AC_WTP[i]->sta_flow_overflow_rx_reportswitch = (unsigned char)policy;
						if (AC_WTP[i]->sta_flow_overflow_rx_threshold == 0) {
							AC_WTP[i]->sta_flow_overflow_rx_threshold = STA_FLOW_OVERFLOW_RX_THRESHOLD;
						}
						ret = wid_send_to_ap_sta_flow_rx_tx_overflow_reportinterval(i, is_rx_tx);
					}
				}
			}
		} else {
			wid_syslog_debug_debug(WID_DEFAULT, "set sta flow overflow switch %s for all wtp %s\n", 
				policy ? "enable" : "disable", is_rx_tx ? "rx" : "tx");
			g_sta_flow_tx_overflow_switch = (unsigned char)policy;
		
			for(i=0;i<WTP_NUM;i++){				
				if(AC_WTP[i] != NULL){
					if(AC_WTP[i]->sta_flow_overflow_tx_reportswitch == (unsigned char)policy){
						continue;
					}else {
						AC_WTP[i]->sta_flow_overflow_tx_reportswitch = (unsigned char)policy;
						if (AC_WTP[i]->sta_flow_overflow_tx_threshold == 0) {
							AC_WTP[i]->sta_flow_overflow_tx_threshold = STA_FLOW_OVERFLOW_TX_THRESHOLD;
						}
						ret = wid_send_to_ap_sta_flow_rx_tx_overflow_reportinterval(i, is_rx_tx);
					}
				}
			}
		}
		
	}
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else
	{
		if (is_rx_tx) {
			if (AC_WTP[wtpid]->sta_flow_overflow_rx_reportswitch == (unsigned char)policy) {
				wid_syslog_debug_debug(WID_DEFAULT, "wtp %d sta flow rx reportswitch already %s\n", wtpid, policy ? "enable" : "disable");
				ret = WID_DBUS_SUCCESS;
			} else {
				wid_syslog_debug_debug(WID_DEFAULT, "set sta flow rx switch %s for wtp %d\n", policy ? "enable" : "disable", wtpid);
				AC_WTP[wtpid]->sta_flow_overflow_rx_reportswitch = (unsigned char)policy;

				if (AC_WTP[wtpid]->sta_flow_overflow_rx_threshold == 0) {
					AC_WTP[wtpid]->sta_flow_overflow_rx_threshold = STA_FLOW_OVERFLOW_RX_THRESHOLD;
				}
				ret = wid_send_to_ap_sta_flow_rx_tx_overflow_reportinterval(wtpid, is_rx_tx);
			}
		} else {
			if (AC_WTP[wtpid]->sta_flow_overflow_tx_reportswitch == (unsigned char)policy) {
				wid_syslog_debug_debug(WID_DEFAULT, "wtp %d sta flow tx reportswitch already %s\n", wtpid, policy ? "enable" : "disable");
				ret = WID_DBUS_SUCCESS;
			} else {
				wid_syslog_debug_debug(WID_DEFAULT, "set sta flow tx switch %s for wtp %d\n", policy ? "enable" : "disable", wtpid);
				AC_WTP[wtpid]->sta_flow_overflow_tx_reportswitch = (unsigned char)policy;
				if (AC_WTP[wtpid]->sta_flow_overflow_tx_threshold == 0) {
					AC_WTP[wtpid]->sta_flow_overflow_tx_threshold = STA_FLOW_OVERFLOW_TX_THRESHOLD;
				}
				ret = wid_send_to_ap_sta_flow_rx_tx_overflow_reportinterval(wtpid, is_rx_tx);
			}
		}
	}

	reply = dbus_message_new_method_return(msg);

	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	wid_syslog_debug_debug(WID_DEFAULT, "ssssssssssssssss\n");
	return reply;
	
}


DBusMessage * wid_dbus_interface_set_wtp_sta_flow_rx_tx_overflow_threshold(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter  iter;
	DBusError err;
	unsigned int wtpid = 0;
	unsigned int threshold = 0;
	unsigned int is_rx_tx = 0;
	int i=0; /*wcl add for globle variable*/
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&is_rx_tx,
								DBUS_TYPE_UINT32,&threshold,
								DBUS_TYPE_INVALID))){

		wid_syslog_err("Unable to get input args for set wtp sta flow rx/tx overflow interval\n");
				
		if (dbus_error_is_set(&err)) {
			wid_syslog_err("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid == 0){
		if (is_rx_tx) {
			wid_syslog_debug_debug(WID_DEFAULT, "set sta flow rx overflow threshold %u for all wtp\n", threshold);
			g_sta_flow_rx_overflow_threshold = threshold;
			for(i=0;i<WTP_NUM;i++){ 			
				if(AC_WTP[i] != NULL){
					if(AC_WTP[i]->sta_flow_overflow_rx_threshold == threshold){
						wid_syslog_debug_debug(WID_DEFAULT, "wtp %d sta flow rx overflow threshold already is %u\n",wtpid, threshold);
						ret = WID_DBUS_SUCCESS;
					}else {
						wid_syslog_debug_debug(WID_DEFAULT, "set sta flow rx overflow threshold %u for wtp %d\n", threshold, wtpid);
						AC_WTP[i]->sta_flow_overflow_rx_threshold = threshold;
						ret = wid_send_to_ap_sta_flow_rx_tx_overflow_reportinterval(i, is_rx_tx);
					}
				}
			}
		} else {
			wid_syslog_debug_debug(WID_DEFAULT, "set sta flow tx overflow threshold %u for all wtp\n", threshold);
			g_sta_flow_tx_overflow_threshold = threshold;
			for(i=0;i<WTP_NUM;i++){ 			
				if(AC_WTP[i] != NULL){
					if(AC_WTP[i]->sta_flow_overflow_tx_threshold == threshold){
						wid_syslog_debug_debug(WID_DEFAULT, "wtp %d sta flow tx overflow report threshold already is %u\n",wtpid, threshold);
						ret = WID_DBUS_SUCCESS;
					}else {
						wid_syslog_debug_debug(WID_DEFAULT, "set sta flow tx overflow threshold %u for wtp %d\n", threshold, wtpid);
						AC_WTP[i]->sta_flow_overflow_tx_threshold = threshold;
						ret = wid_send_to_ap_sta_flow_rx_tx_overflow_reportinterval(i, is_rx_tx);
					}
				}
			}
		}
	}	/*wcl add for globle variable*/
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else
	{
		if (is_rx_tx) {
			if (AC_WTP[wtpid]->sta_flow_overflow_rx_threshold == threshold) {
				ret = WID_DBUS_SUCCESS; 
			} else {
				AC_WTP[wtpid]->sta_flow_overflow_rx_threshold = threshold;
				ret = wid_send_to_ap_sta_flow_rx_tx_overflow_reportinterval(wtpid, is_rx_tx);
			}
		} else {
			if (AC_WTP[wtpid]->sta_flow_overflow_tx_threshold == threshold) {
				ret = WID_DBUS_SUCCESS;
			} else {
				AC_WTP[wtpid]->sta_flow_overflow_tx_threshold = threshold;
				ret = wid_send_to_ap_sta_flow_rx_tx_overflow_reportinterval(wtpid, is_rx_tx);
			}
		}
		
	}
	
	reply = dbus_message_new_method_return(msg);

	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}

DBusMessage * wid_dbus_interface_set_wtp_sta_flow_rx_tx_overflow_interval(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	unsigned int interval = 0;
	unsigned int is_rx_tx = 0;
	int i=0; /*wcl add for globle variable*/
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&is_rx_tx,
								DBUS_TYPE_UINT32,&interval,
								DBUS_TYPE_INVALID))){

		wid_syslog_err("Unable to get input args for set wtp sta flow rx/tx overflow interval\n");
				
		if (dbus_error_is_set(&err)) {
			wid_syslog_err("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid == 0){
		if (is_rx_tx) {
			wid_syslog_debug_debug(WID_DEFAULT, "set sta flow rx overflow interval %u for all wtp\n", interval);
			g_sta_flow_rx_overflow_interval = (unsigned short)interval;
			for(i=0;i<WTP_NUM;i++){				
				if(AC_WTP[i] != NULL){
					if(AC_WTP[i]->sta_flow_overflow_rx_reportinterval == (unsigned short)interval){
						wid_syslog_debug_debug(WID_DEFAULT, "wtp %d sta flow rx overflow report interval already is %u\n",wtpid, interval);
						ret = WID_DBUS_SUCCESS;
					}else {
						wid_syslog_debug_debug(WID_DEFAULT, "set sta flow rx overflow interval %u for wtp %d\n", interval, wtpid);
						AC_WTP[i]->sta_flow_overflow_rx_reportinterval = (unsigned short)interval;
						ret = wid_send_to_ap_sta_flow_rx_tx_overflow_reportinterval(i, is_rx_tx);
					}
				}
			}
		} else {
			wid_syslog_debug_debug(WID_DEFAULT, "set sta flow tx overflow interval %u for all wtp\n", interval);
			g_sta_flow_tx_overflow_interval = (unsigned short)interval;
			for(i=0;i<WTP_NUM;i++){				
				if(AC_WTP[i] != NULL){
					if(AC_WTP[i]->sta_flow_overflow_tx_reportinterval == (unsigned short)interval){
						wid_syslog_debug_debug(WID_DEFAULT, "wtp %d sta flow tx overflow report interval already is %u\n",wtpid, interval);
						ret = WID_DBUS_SUCCESS;
					}else {
						wid_syslog_debug_debug(WID_DEFAULT, "set sta flow tx overflow interval %u for wtp %d\n", interval, wtpid);
						AC_WTP[i]->sta_flow_overflow_tx_reportinterval = (unsigned short)interval;
						ret = wid_send_to_ap_sta_flow_rx_tx_overflow_reportinterval(i, is_rx_tx);
					}
				}
			}
		}
	}	/*wcl add for globle variable*/
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else
	{
		if (is_rx_tx) {
			if (AC_WTP[wtpid]->sta_flow_overflow_rx_reportinterval == (unsigned short)interval) {
				ret = WID_DBUS_SUCCESS;	
			} else {
				AC_WTP[wtpid]->sta_flow_overflow_rx_reportinterval = (unsigned short)interval;
				ret = wid_send_to_ap_sta_flow_rx_tx_overflow_reportinterval(wtpid, is_rx_tx);
			}
		} else {
			if (AC_WTP[wtpid]->sta_flow_overflow_tx_reportinterval == (unsigned short)interval) {
				ret = WID_DBUS_SUCCESS;
			} else {
				AC_WTP[wtpid]->sta_flow_overflow_tx_reportinterval = (unsigned short)interval;
				ret = wid_send_to_ap_sta_flow_rx_tx_overflow_reportinterval(wtpid, is_rx_tx);
			}
		}
		
	}
	
	reply = dbus_message_new_method_return(msg);

	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}

#if 0
DBusMessage * wid_dbus_interface_set_wtp_sta_flow_tx_overflow_switch(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	unsigned int policy = 0;
	int i=0; 
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid == 0){
		g_sta_flow_tx_overflow_switch = (unsigned char)policy;
		
		for(i=0;i<WTP_NUM;i++){				
			if(AC_WTP[i] != NULL){
				if(AC_WTP[i]->sta_flow_overflow_tx_reportswitch == (unsigned char)policy){
					continue;
				}else {
					AC_WTP[i]->sta_flow_overflow_tx_reportswitch = (unsigned char)policy;
					ret = wid_send_to_ap_sta_flow_tx_overflow_reportinterval(i);
				}
			}
		}
	}
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtpid]->sta_flow_overflow_tx_reportswitch == (unsigned char)policy)
	{
		ret = WID_DBUS_SUCCESS;
	}
	else
	{
		AC_WTP[wtpid]->sta_flow_overflow_tx_reportswitch = (unsigned char)policy;

		ret = wid_send_to_ap_sta_flow_tx_overflow_reportinterval(wtpid);
	}
	
		
	reply = dbus_message_new_method_return(msg);

	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}


DBusMessage * wid_dbus_interface_set_wtp_sta_flow_tx_overflow_interval(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	unsigned int interval = 0;
	int i=0; /*wcl add for globle variable*/
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&interval,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid == 0){
		
		g_sta_flow_tx_overflow_interval = (unsigned short)interval;
		
		for(i=0;i<WTP_NUM;i++){				
			if(AC_WTP[i] != NULL){
				if(AC_WTP[i]->sta_flow_overflow_tx_reportinterval == (unsigned short)interval){
					ret = WID_DBUS_SUCCESS;
				}else {
					AC_WTP[i]->sta_flow_overflow_tx_reportinterval = (unsigned short)interval;
					ret = wid_send_to_ap_sta_flow_tx_overflow_reportinterval(i);
				}
			}
		}
	}	/*wcl add for globle variable*/
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtpid]->sta_flow_overflow_tx_reportinterval == (unsigned short)interval)
	{
		ret = WID_DBUS_SUCCESS;
	}
	else
	{
		AC_WTP[wtpid]->sta_flow_overflow_tx_reportinterval = (unsigned short)interval;
		ret = wid_send_to_ap_sta_flow_tx_overflow_reportinterval(wtpid);
	}
	
		
	reply = dbus_message_new_method_return(msg);

	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}
#endif

#else

/* ---zhangshu add for Terminal Disturb Info Report END---,2010-10-08 */


DBusMessage * wid_dbus_interface_set_wtp_extension_infomation_interval(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	unsigned int interval = 0;
	int i=0; /*wcl add for globle variable*/
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&interval,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid == 0){
		
		gWIFIEXTENSIONREPORTINTERVAL = (unsigned short)interval;
		
		for(i=0;i<WTP_NUM;i++){				
			if(AC_WTP[i] != NULL){
				if(AC_WTP[i]->wifi_extension_reportinterval == (unsigned short)interval){
					
					ret = WID_DBUS_SUCCESS;
				}else {
				
					AC_WTP[i]->wifi_extension_reportinterval = (unsigned short)interval;
					
					ret = wid_send_to_ap_extension_infomation(i);
					
					}
			}
		}
	}	/*wcl add for globle variable*/
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtpid]->wifi_extension_reportinterval == (unsigned short)interval)
	{
		ret = WID_DBUS_SUCCESS;
	}
	else
	{
		AC_WTP[wtpid]->wifi_extension_reportinterval = (unsigned short)interval;

		ret = wid_send_to_ap_extension_infomation(wtpid);
	}
	
		
	reply = dbus_message_new_method_return(msg);

	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}
#endif
DBusMessage * wid_dbus_interface_set_wtp_sample_infomation_interval(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int interval = 0;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&interval,
								DBUS_TYPE_INVALID))){
								
		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(sample_infor_interval == interval){
		ret = VALUE_IS_NONEED_TO_CHANGE;
	}
	
	else {
		sample_infor_interval = interval;
		ret = WID_DBUS_SUCCESS;
	}
		
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
}

DBusMessage * wid_dbus_interface_set_wtp_moment_infomation_interval(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int interval = 0;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&interval,
								DBUS_TYPE_INVALID))){
								
		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(moment_report_interval == interval){
		ret = VALUE_IS_NONEED_TO_CHANGE;
	}
	
	else {
		moment_report_interval = (unsigned short)interval;
		ret = WID_DBUS_SUCCESS;
	}
		
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
}

DBusMessage * wid_dbus_interface_set_wtp_routine_infomation_interval(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int interval = 0;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&interval,
								DBUS_TYPE_INVALID))){
								
		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(routine_report_interval == interval){
		ret = VALUE_IS_NONEED_TO_CHANGE;
	}
	
	else {
		routine_report_interval = (unsigned short)interval;
		ret = WID_DBUS_SUCCESS;
	}
		
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
}


DBusMessage * wid_dbus_interface_set_wtp_moment_infomation_enable(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	int policy = 0;
	unsigned int i = 0;
	WID_WTP **WTP = NULL;
	unsigned int num = 0;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	memset(WTP,0,WTP_NUM*(sizeof(WID_WTP *)));
	
	num = Wid_Find_Wtp(WTP);
	
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){
		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		CW_FREE_OBJECT_WID(WTP);
		return NULL;
	}
	
	if((wtpid > 0)&&(wtpid <= (WTP_NUM-1))){
		if(AC_WTP[wtpid] == NULL){
			ret = WTP_ID_NOT_EXIST;
		}
		else if((AC_WTP[wtpid]->wifi_extension_reportswitch == policy)
			&&(AC_WTP[wtpid]->wifi_extension_reportinterval == moment_report_interval)
			&&(AC_WTP[wtpid]->moment_infor_report_switch == policy)){
			ret = VALUE_IS_NONEED_TO_CHANGE;
		}
		else{
			if(policy == 1){
				AC_WTP[wtpid]->wifi_extension_reportinterval = moment_report_interval;
				AC_WTP[wtpid]->wifi_extension_reportswitch = policy ;
				AC_WTP[wtpid]->moment_infor_report_switch = policy ;
				ret = wid_send_to_ap_extension_infomation(wtpid);
			}
			else if(policy == 0){
				AC_WTP[wtpid]->wifi_extension_reportinterval = routine_report_interval;
				AC_WTP[wtpid]->wifi_extension_reportswitch = policy ;
				AC_WTP[wtpid]->moment_infor_report_switch = policy ;
				ret = wid_send_to_ap_extension_infomation(wtpid);
			}
		}
	}

	else if(wtpid == 0){
		if(num == 0)
			ret = WTP_ID_NOT_EXIST;
		else{
			if(policy == 1){
				for(i=0;i<num;i++){
					WTP[i]->wifi_extension_reportinterval = moment_report_interval;
					WTP[i]->wifi_extension_reportswitch = policy ;
					WTP[i]->moment_infor_report_switch= policy ;
					ret = wid_send_to_ap_extension_infomation(WTP[i]->WTPID);//remember
				}
				moment_report_switch = policy ;
			}		
			else if (policy == 0){
				for(i=0;i<num;i++){
					WTP[i]->wifi_extension_reportinterval = routine_report_interval;
					WTP[i]->moment_infor_report_switch= policy ;
					ret = wid_send_to_ap_extension_infomation(WTP[i]->WTPID);
				}
				moment_report_switch = policy ;
			}
		}
	}
	
	reply = dbus_message_new_method_return(msg);

	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if(WTP!=NULL){
		WID_FREE(WTP);
		WTP = NULL;
	}
	
	return reply;
}

DBusMessage * wid_dbus_interface_show_wtp_moment_infomation(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
	
	int ret = WID_DBUS_SUCCESS;
	unsigned int moment_value = 0;
	unsigned int routine_value = 0;
	int collect_time = cpu_mem_collect_time;
	
	moment_value = (unsigned int) moment_report_interval;
	routine_value = (unsigned int) routine_report_interval;
	collect_time = (int)cpu_mem_collect_time ; 

	reply = dbus_message_new_method_return(msg);

	dbus_message_iter_init_append(reply, &iter);

	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &moment_value);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &routine_value);

	dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &moment_report_switch);

	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &collect_time);

	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &sample_infor_interval);

	dbus_error_init(&err);
	
	return reply;
}
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_wtp_sta_infomation_enable(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	int i = 0;
	int num =0 ;
	int policy = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
		
	struct Wtp_List  *wtp_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			if(ID == 0){
				gSTAREPORTSWITCH = policy;
				for(i=0;i<WTP_NUM;i++){
					if(AC_WTP[i] != NULL){
							if(AC_WTP[i]->ap_sta_report_switch != policy){
								ret = wid_set_ap_sta_infomation_report(i);
							}
						
					}
				}
			} /*wcl add for globle variable*/
			else if(AC_WTP[ID] == NULL)
			{
				ret = WTP_ID_NOT_EXIST;
			}
			else if(gWTPs[ID].currentState != CW_ENTER_RUN)
			{
				ret = WTP_NOT_IN_RUN_STATE;
			}

			else if(AC_WTP[ID]->ap_sta_report_switch == policy)
			{
				ret = WID_DBUS_SUCCESS;
			}
			else
			{
				AC_WTP[ID]->ap_sta_report_switch = policy;

				ret = wid_set_ap_sta_infomation_report(ID);
			}
		}

	else if(type==1)
			{
				printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
				//printf("1111111111111111\n");
				tmp = WTP_GROUP[ID]->WTP_M;
				wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
				
				while(tmp){
					ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
					//printf("ret_check = %d\n",ret_check);
					if(ret_check == WID_DBUS_SUCCESS){

						 if(AC_WTP[tmp->WTPID]->WTPStat != 5)
						 	{
						 		ret2 = WTP_NOT_IN_RUN_STATE;
								wid_syslog_debug_debug(WID_DEFAULT,"WTP%d NOT RUN\n",tmp->WTPID);
						 	}
						 else if(AC_WTP[tmp->WTPID]->ap_sta_report_switch==policy)
							{
								ret2 = WID_DBUS_SUCCESS;
								wid_syslog_debug_debug(WID_DEFAULT,"WTP%d had this policy yet\n",tmp->WTPID);
								//printf("%%%%ret2= %d\n",ret2);
							}

						 else 
							{	AC_WTP[tmp->WTPID]->ap_sta_report_switch = policy;
								ret2 = wid_set_ap_sta_infomation_report(tmp->WTPID);
								//printf("!!!!!ret2= %d\n",ret2);
							}
						if(ret2 != WID_DBUS_SUCCESS){
							//printf("#####ret2= %d\n",ret2);
							wtp_head[num].WtpId = tmp->WTPID;
							wtp_head[num].FailReason = ret2;
							num++;
							
							}
						
						tmp = tmp->next;
					}
	
				}
					ret = WID_DBUS_SUCCESS;
			}
				
			else{
				ret = GROUP_ID_NOT_EXIST;
				}
		}

		reply = dbus_message_new_method_return(msg);
	
		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
		printf("num= %d\n",num);
		if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_UINT32,
												 &num);
			for(i = 0; i < num; i++){
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
													 &(wtp_head[i].WtpId));
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_BYTE,
													 &(wtp_head[i].FailReason));
			}	
			
			if(wtp_head!=NULL){
				WID_FREE(wtp_head);
				wtp_head = NULL;	
			}
		}
		
		return reply;
	
}

#else
DBusMessage * wid_dbus_interface_set_wtp_sta_infomation_enable(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	int policy = 0;
	int i = 0; /*wcl add for globle variable*/
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid == 0){
		gSTAREPORTSWITCH = policy;
		for(i=0;i<WTP_NUM;i++){
			if(AC_WTP[i] != NULL){
					if(AC_WTP[i]->ap_sta_report_switch != policy){				
						AC_WTP[i]->ap_sta_report_switch = policy;
						ret = wid_set_ap_sta_infomation_report(i);
					}
				
			}
		}
	} /*wcl add for globle variable*/
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	/*else if(gWTPs[wtpid].currentState != CW_ENTER_RUN)
	{
		ret = WTP_NOT_IN_RUN_STATE;
	}*/
	else if(AC_WTP[wtpid]->ap_sta_report_switch == policy)
	{
		ret = WID_DBUS_SUCCESS;
	}
	else
	{
		AC_WTP[wtpid]->ap_sta_report_switch = policy;

		ret = wid_set_ap_sta_infomation_report(wtpid);
	}
	
		
	reply = dbus_message_new_method_return(msg);

	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	return reply;
	
}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_wtp_sta_infomation_interval(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	int i = 0;
	int num =0 ;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned int interval = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Wtp_List  *wtp_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&interval,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(type==0)
		{	
			if(ID == 0){
				gSTAREPORTINTERVAL = (u_int16_t)interval;
				for(i=0;i<WTP_NUM;i++){
					if(AC_WTP[i] != NULL){
						AC_WTP[i]->ap_sta_report_interval = (u_int16_t)interval; //huxf
						ret = wid_set_ap_sta_infomation_report(i);
					}
				}
			} /*wcl add for globle variable*/
			else if(AC_WTP[ID] == NULL)
			{
				ret = WTP_ID_NOT_EXIST;
			}
			else if(AC_WTP[ID]->ap_sta_report_interval == (u_int16_t)interval)
			{
				ret = WID_DBUS_SUCCESS;
			}
			else
			{
				AC_WTP[ID]->ap_sta_report_interval = (u_int16_t)interval;

				ret = wid_set_ap_sta_infomation_report(ID);
			}
		}

	else if(type==1)
		{
			printf("******** type == 1 *****\n");
		if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
			tmp = WTP_GROUP[ID]->WTP_M;
			wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
			
			while(tmp){
				ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
				
				if(ret_check == WID_DBUS_SUCCESS){
					 if(AC_WTP[tmp->WTPID]->ap_sta_report_interval==(u_int16_t)interval)
						{
							ret2 = WID_DBUS_SUCCESS;
							wid_syslog_debug_debug(WID_DEFAULT,"WTP%d had this interval yet\n",tmp->WTPID);
						}
					 else 
					 	{	AC_WTP[tmp->WTPID]->ap_sta_report_interval = (u_int16_t)interval;
							ret2 = wid_set_ap_sta_infomation_report(tmp->WTPID);
					 	}
					if(ret2 != WID_DBUS_SUCCESS){
						wtp_head[num].WtpId = tmp->WTPID;
						wtp_head[num].FailReason = ret2;
						num++;
					}
					
					tmp = tmp->next;
				}

			}
				ret = WID_DBUS_SUCCESS;
		}
			
		else{
			ret = GROUP_ID_NOT_EXIST;
			}
	}
		
	reply = dbus_message_new_method_return(msg);

	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &num);
		printf("num= %d\n",num);
		for(i = 0; i < num; i++){
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_UINT32,
												 &(wtp_head[i].WtpId));
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_BYTE,
												 &(wtp_head[i].FailReason));
		}	
		
		if(wtp_head!=NULL){
			WID_FREE(wtp_head);
			wtp_head = NULL;	
		}
	}
	
	return reply;
}

#else
DBusMessage * wid_dbus_interface_set_wtp_sta_infomation_interval(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	unsigned int interval = 0;
	int i = 0; /*wcl add for globle variable*/
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&interval,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid == 0){
		gSTAREPORTINTERVAL = (u_int16_t)interval;
		for(i=0;i<WTP_NUM;i++){
			if(AC_WTP[i] != NULL){
				AC_WTP[i]->ap_sta_report_interval = (u_int16_t)interval;
				ret = wid_set_ap_sta_infomation_report(i);
			}
		}
	} /*wcl add for globle variable*/
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtpid]->ap_sta_report_interval == (u_int16_t)interval)
	{
		ret = WID_DBUS_SUCCESS;
	}
	else
	{
		AC_WTP[wtpid]->ap_sta_report_interval = (u_int16_t)interval;

		ret = wid_set_ap_sta_infomation_report(wtpid);
	}
	
		
	reply = dbus_message_new_method_return(msg);

	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}
#endif
#if _GROUP_POLICY

DBusMessage * wid_dbus_interface_set_wtp_sta_wapi_info_enable(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	int i = 0;
	int num =0 ;
	int policy = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Wtp_List  *wtp_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			if(ID == 0){
				gAP_STA_WAPI_REPORT_SWITCH = policy;
				for(i=0;i<WTP_NUM;i++){
					if(AC_WTP[i] != NULL){
						if(AC_WTP[i]->ap_sta_wapi_report_switch == policy)
						{
							ret = WID_DBUS_SUCCESS;
						}else{
							AC_WTP[i]->ap_sta_wapi_report_switch = policy;
							ret = wid_set_ap_sta_wapi_info_report(i);
						}
					}
				}
			}/*wcl modify for globle variable*/
			else if(AC_WTP[ID] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			/*else if(gWTPs[wtpid].currentState != CW_ENTER_RUN)
				{
					ret = WTP_NOT_IN_RUN_STATE;
				}*/
			else if(AC_WTP[ID]->ap_sta_wapi_report_switch == policy)
				{
					ret = WID_DBUS_SUCCESS;
				}
			else
				{
					AC_WTP[ID]->ap_sta_wapi_report_switch = policy;

					ret = wid_set_ap_sta_wapi_info_report(ID);
				}
		}

	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
					
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
							if(ret_check == WID_DBUS_SUCCESS)
								{
									/*if(AC_WTP[tmp->WTPID]->WTPStat != 5)
										{
											ret2 = WTP_NOT_IN_RUN_STATE;	
											wid_syslog_debug_debug(WID_DEFAULT,"WTP%d NOT RUN\n",tmp->WTPID);
										}*/
									if(AC_WTP[tmp->WTPID]->ap_sta_wapi_report_switch == policy)
										{
											ret2 = WID_DBUS_SUCCESS;
											wid_syslog_debug_debug(WID_DEFAULT,"WTP%d had this interval yet\n",tmp->WTPID);
										}
									else
										{
										AC_WTP[tmp->WTPID]->ap_sta_wapi_report_switch = policy;
										
										ret2 = wid_set_ap_sta_wapi_info_report(tmp->WTPID);

										}
									if(ret2 != WID_DBUS_SUCCESS)
										{
											wtp_head[num].WtpId = tmp->WTPID;
											wtp_head[num].FailReason = ret2;
											num++;
										}
									tmp = tmp->next;
								}
							ret = WID_DBUS_SUCCESS;
						}
				}
					
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
													 &num);
				for(i = 0; i < num; i++){
					dbus_message_iter_append_basic (&iter,
														 DBUS_TYPE_UINT32,
														 &(wtp_head[i].WtpId));
					dbus_message_iter_append_basic (&iter,
														 DBUS_TYPE_BYTE,
														 &(wtp_head[i].FailReason));
				}	
				
				if(wtp_head!=NULL){
					WID_FREE(wtp_head);
					wtp_head = NULL;	
				}
			}
		
			return reply;
	
}

#else
DBusMessage * wid_dbus_interface_set_wtp_sta_wapi_info_enable(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	int policy = 0;
	int i = 0;/*wcl add for globle variable*/
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid == 0){
		gAP_STA_WAPI_REPORT_SWITCH = policy;
		for(i=0;i<WTP_NUM;i++){
			if(AC_WTP[i] != NULL){
				if(AC_WTP[i]->ap_sta_wapi_report_switch == policy)
				{
					ret = WID_DBUS_SUCCESS;
				}else{
					AC_WTP[i]->ap_sta_wapi_report_switch = policy;
					ret = wid_set_ap_sta_wapi_info_report(i);
				}
			}
		}
	}/*wcl modify for globle variable*/
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	/*else if(gWTPs[wtpid].currentState != CW_ENTER_RUN)
	{
		ret = WTP_NOT_IN_RUN_STATE;
	}*/
	else if(AC_WTP[wtpid]->ap_sta_wapi_report_switch == policy)
	{
		ret = WID_DBUS_SUCCESS;
	}
	else
	{
		AC_WTP[wtpid]->ap_sta_wapi_report_switch = policy;

		ret = wid_set_ap_sta_wapi_info_report(wtpid);
	}
	
		
	reply = dbus_message_new_method_return(msg);

	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	return reply;
	
}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_wtp_sta_wapi_info_interval(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	int i = 0;
	int num =0 ;

	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned char interval = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Wtp_List  *wtp_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&interval,
								DBUS_TYPE_INVALID))){


		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			if(ID == 0){
				gAP_STA_WAPI_REPORT_INTERVAL = interval;
				for(i=0;i<WTP_NUM;i++){
					if(AC_WTP[i] != NULL){
						if(gWTPs[i].currentState == CW_ENTER_RUN){
							if(AC_WTP[i]->ap_sta_wapi_report_interval == interval){
								ret = WID_DBUS_SUCCESS;
							}else{
								AC_WTP[i]->ap_sta_wapi_report_interval = interval;
								if(AC_WTP[i]->ap_sta_wapi_report_switch == 1)
								ret = wid_set_ap_sta_wapi_info_report(i);
							}
						}
					}
				}
			}/*wcl modify for globle variable*/
			else if(AC_WTP[ID] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else if(AC_WTP[ID]->ap_sta_wapi_report_interval == interval)
				{
					ret = WID_DBUS_SUCCESS;
				}
			else
				{
					AC_WTP[ID]->ap_sta_wapi_report_interval = interval;
					if(AC_WTP[ID]->ap_sta_wapi_report_switch == 1)
					ret = wid_set_ap_sta_wapi_info_report(ID);
				}
		}

	
		
	else if(type == 1){
				printf("******** type == 1 *****\n");
				if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
					tmp = WTP_GROUP[ID]->WTP_M;
					wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
					
					while(tmp){
						ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
						
						if(ret_check == WID_DBUS_SUCCESS){
							if(AC_WTP[tmp->WTPID]->WTPStat != 5)
								{
									ret2 = WTP_NOT_IN_RUN_STATE;	
									wid_syslog_debug_debug(WID_DEFAULT,"WTP%d NOT RUN\n",tmp->WTPID);
								}
							else if(AC_WTP[tmp->WTPID]->ap_sta_wapi_report_interval == interval)
								{
									ret2 = WID_DBUS_SUCCESS;
									wid_syslog_debug_debug(WID_DEFAULT,"WTP%d had this interval yet\n",tmp->WTPID);
								}
							else
								{
									AC_WTP[tmp->WTPID]->ap_sta_wapi_report_interval = interval;
									if(AC_WTP[tmp->WTPID]->ap_sta_wapi_report_switch == 1)
									ret2 = wid_set_ap_sta_wapi_info_report(tmp->WTPID);
								}
							if(ret2 != WID_DBUS_SUCCESS){
								wtp_head[num].WtpId = tmp->WTPID;
								wtp_head[num].FailReason = ret2;
								num++;
							}
							tmp = tmp->next;
						}
						ret = WID_DBUS_SUCCESS;
					}
				}
					
				else{
					ret = GROUP_ID_NOT_EXIST;
				}
			}
		
			reply = dbus_message_new_method_return(msg);
		
			dbus_message_iter_init_append(reply, &iter);
			
			dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
			if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
													 &num);
				for(i = 0; i < num; i++){
					dbus_message_iter_append_basic (&iter,
														 DBUS_TYPE_UINT32,
														 &(wtp_head[i].WtpId));
					dbus_message_iter_append_basic (&iter,
														 DBUS_TYPE_BYTE,
														 &(wtp_head[i].FailReason));
				}	
				
				if(wtp_head!=NULL){
					WID_FREE(wtp_head);
					wtp_head = NULL;	
				}
			}
		
			return reply;

}

#else
DBusMessage * wid_dbus_interface_set_wtp_sta_wapi_info_interval(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	unsigned int interval = 0;
	int i = 0;/*wcl add for globle variable*/
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&interval,
								DBUS_TYPE_INVALID))){


		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid == 0){
		gAP_STA_WAPI_REPORT_INTERVAL = interval;
		for(i=0;i<WTP_NUM;i++){
			if(AC_WTP[i] != NULL){
				if(gWTPs[i].currentState == CW_ENTER_RUN){
					if(AC_WTP[i]->ap_sta_wapi_report_interval == interval){
						ret = WID_DBUS_SUCCESS;
					}else{
						AC_WTP[i]->ap_sta_wapi_report_interval = interval;
						if(AC_WTP[i]->ap_sta_wapi_report_switch == 1)
						{
							ret = wid_set_ap_sta_wapi_info_report(i);
						}
					}
				}
			}
		}
	}/*wcl modify for globle variable*/
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtpid]->ap_sta_wapi_report_interval == interval)
	{
		ret = WID_DBUS_SUCCESS;
	}
	else
	{
		AC_WTP[wtpid]->ap_sta_wapi_report_interval = interval;
		if(AC_WTP[wtpid]->ap_sta_wapi_report_switch == 1)
			{
				ret = wid_set_ap_sta_wapi_info_report(wtpid);
			}
	}
	
		
	reply = dbus_message_new_method_return(msg);

	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_wtp_if_info_report_enable(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusError err;
	DBusMessageIter  iter;
	DBusMessage* reply =NULL;
	
	int i = 0;
	int num =0 ;
	int policy = 0;
	unsigned int ID = 0;
	unsigned int type = 0;

	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Wtp_List  *wtp_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;

	dbus_error_init(&err);
	
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(type == 0){
		if(ID == 0){
			gINFOREPORTSWITCH = policy;
			for(i=0;i<WTP_NUM;i++){				
				if(AC_WTP[i] != NULL){
					AC_WTP[i]->apifinfo.report_switch = gINFOREPORTSWITCH;
					ret = wid_set_ap_if_info_report(i);
				}
			}
		}	/*wcl add for globle variable*/

		else if(AC_WTP[ID] == NULL){
			ret = WTP_ID_NOT_EXIST;
		}
		
		else if(AC_WTP[ID]->apifinfo.report_switch == policy){
			ret = WID_DBUS_SUCCESS;
		}
		else{
			AC_WTP[ID]->apifinfo.report_switch = policy;
			ret = wid_set_ap_if_info_report(ID);
		}
	}

	else if(type == 1){
		printf("******** type == 1 *****\n");
		if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
			tmp = WTP_GROUP[ID]->WTP_M;
			wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
			
			while(tmp){
				ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
				
				if(ret_check == WID_DBUS_SUCCESS){
					ret2 = wid_set_ap_if_info_report(tmp->WTPID);
					
					if(ret2 != WID_DBUS_SUCCESS){
						wtp_head[num].WtpId = tmp->WTPID;
						wtp_head[num].FailReason = ret2;
						num++;
					}
					tmp = tmp->next;
				}
				ret = WID_DBUS_SUCCESS;
			}
		}
			
		else{
			ret = GROUP_ID_NOT_EXIST;
		}
	}

	reply = dbus_message_new_method_return(msg);

	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	if(type == 1){
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &num);
		for(i = 0; i < num; i++){
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_UINT32,
												 &(wtp_head[i].WtpId));
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_BYTE,
												 &(wtp_head[i].FailReason));
		}	
		
		if(wtp_head!=NULL){
			WID_FREE(wtp_head);
			wtp_head = NULL;	
		}
	}

	return reply;
	
}
#else
DBusMessage * wid_dbus_interface_set_wtp_if_info_report_enable(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	int policy = 0;
	int i = 0; /*wcl add for globle variable*/
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid == 0){
		gINFOREPORTSWITCH = policy;
		for(i=0;i<WTP_NUM;i++){ 			
			if(AC_WTP[i] != NULL){
				if(AC_WTP[i]->apifinfo.report_switch == policy)
				{
					ret = WID_DBUS_SUCCESS;
				}
				else
				{
					AC_WTP[i]->apifinfo.report_switch = policy;
					ret = wid_set_ap_if_info_report(i);
				}
			}
		}
	}	/*wcl add for globle variable*/
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	/*else if(gWTPs[wtpid].currentState != CW_ENTER_RUN)
	{
		ret = WTP_NOT_IN_RUN_STATE;
	}*/
	else if(AC_WTP[wtpid]->apifinfo.report_switch == policy)
	{
		ret = WID_DBUS_SUCCESS;
	}
	else
	{
		AC_WTP[wtpid]->apifinfo.report_switch = policy;

		ret = wid_set_ap_if_info_report(wtpid);
	}
	
		
	reply = dbus_message_new_method_return(msg);

	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	return reply;
	
}
#endif

#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_wtp_if_info_report_interval(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusError err;
	DBusMessageIter  iter;
	DBusMessage* reply =NULL;
	
	int i = 0;
	int num =0 ;

	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned int interval = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Wtp_List  *wtp_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	
	dbus_error_init(&err);
	
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&interval,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type == 0){
		if(ID == 0){
			gINFOREPORTINTERVAL = interval;
			for(i=0;i<WTP_NUM;i++){		//not sure huxf
				if(AC_WTP[i] != NULL){
					AC_WTP[i]->apifinfo.report_interval = interval;
					ret = wid_set_ap_if_info_report(i);
				}
			}
		} /*wcl modify for globle variable*/
		else if(AC_WTP[ID] == NULL){
			ret = WTP_ID_NOT_EXIST;
		}
		else if(gWTPs[ID].currentState != CW_ENTER_RUN){
			ret = WTP_NOT_IN_RUN_STATE;
		}
		else if(AC_WTP[ID]->apifinfo.report_interval == interval){
			ret = WID_DBUS_SUCCESS;
		}
		else{
			AC_WTP[ID]->apifinfo.report_interval = interval;
			ret = wid_set_ap_if_info_report(ID);
		}
	}

	else if(type == 1){
		printf("******** type == 1 *****\n");
		if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
			tmp = WTP_GROUP[ID]->WTP_M;
			wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
			
			while(tmp){
				ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
				
				if(ret_check == WID_DBUS_SUCCESS){
					ret2 = wid_set_ap_if_info_report(tmp->WTPID);
					
					if(ret2 != WID_DBUS_SUCCESS){
						wtp_head[num].WtpId = tmp->WTPID;
						wtp_head[num].FailReason = ret2;
						num++;
					}
					else {
						AC_WTP[tmp->WTPID]->apifinfo.report_interval = interval;
					}

					printf("ret = %d",ret);
					tmp = tmp->next;
				}
				ret = WID_DBUS_SUCCESS;
			}
		}
			
		else{
			ret = GROUP_ID_NOT_EXIST;
		}
	}
		
	reply = dbus_message_new_method_return(msg);

	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if(type == 1){
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &num);
		for(i = 0; i < num; i++){
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_UINT32,
												 &(wtp_head[i].WtpId));
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_BYTE,
												 &(wtp_head[i].FailReason));
		}	
		
		if(wtp_head!=NULL){
			WID_FREE(wtp_head);
			wtp_head = NULL;	
		}
	}
	
	return reply;
}

#else
DBusMessage * wid_dbus_interface_set_wtp_if_info_report_interval(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	unsigned int interval = 0;
	int i = 0; /*wcl add for globle variable*/
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&interval,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid == 0){
		gINFOREPORTINTERVAL = (unsigned short)interval;
		for(i=0;i<WTP_NUM;i++){
			if(AC_WTP[i] != NULL){
				AC_WTP[i]->apifinfo.report_interval = (unsigned short)interval;
				ret = wid_set_ap_if_info_report(i);
			}
		}
	} /*wcl modify for globle variable*/
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtpid]->apifinfo.report_interval == (unsigned short)interval)
	{
		ret = WID_DBUS_SUCCESS;
	}
	else
	{
		AC_WTP[wtpid]->apifinfo.report_interval = (unsigned short)interval;

		ret = wid_set_ap_if_info_report(wtpid);
	}
	
		
	reply = dbus_message_new_method_return(msg);

	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}
#endif

DBusMessage * wid_dbus_interface_set_dhcp_flooding_status(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter  iter;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;

	unsigned char status = 0;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&status,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	gdhcp_flooding_status = status;
	
	reply = dbus_message_new_method_return(msg);

	dbus_message_iter_init_append(reply, &iter);
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
}


DBusMessage * wid_dbus_interface_show_dhcp_flooding_status(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter  iter;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;

	unsigned char status = 0;
	dbus_error_init(&err);

	reply = dbus_message_new_method_return(msg);

	if(ret != WID_DBUS_SUCCESS)
	{
		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	}
	else
	{
		status = gdhcp_flooding_status;

		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &status);
	}
	
	return reply;
}
DBusMessage * wid_dbus_interface_show_wtp_wids_item(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter  iter;
	DBusError err;
	unsigned int wtpid = 0;
	int ret = WID_DBUS_SUCCESS;

	wid_wids_set wids = {0};
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
		
	reply = dbus_message_new_method_return(msg);

	if(ret != WID_DBUS_SUCCESS)
	{
		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	}
	else
	{
		wids = gwids;

		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &wids.flooding);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &wids.sproof);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &wids.weakiv);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &gwidsinterval);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &gprobethreshold);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &gotherthreshold);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &glasttimeinblack);
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &gwidspolicy);
	}
	
	return reply;


}

DBusMessage * wid_dbus_interface_set_wtp_wids_item(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	wid_wids_set wids = {0};
	int i = 0;
	unsigned int able = 2;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_BYTE,&wids.flooding,
								DBUS_TYPE_BYTE,&wids.sproof,
								DBUS_TYPE_BYTE,&wids.weakiv,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(wids.flooding != 2)
	{
		gwids.flooding = wids.flooding;
	}
	if(wids.sproof != 2)
	{
		gwids.sproof= wids.sproof;
	}
	if(wids.weakiv != 2)
	{
		gwids.weakiv= wids.weakiv;
	}
	
	for(i=0; i<WTP_NUM; i++)
	{
		if((AC_WTP[i] != NULL)&&(gWTPs[i].currentState == CW_ENTER_RUN))
		{
			ret = wid_set_ap_wids_set(i);
		}
	}

	
	able = gwids.flooding;
	wid_asd_send_wids_able(able);
		
	reply = dbus_message_new_method_return(msg);

	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}
DBusMessage * wid_dbus_interface_set_wtp_wids_interval(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned char interval = 0;
	
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&interval,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if((gwids.flooding == 1)||(gwids.sproof == 1)||(gwids.weakiv == 1))
	{
		ret = SWITCH_IS_DISABLE;
	}
	else
	{
		gwidsinterval = interval;
	}	
		
	reply = dbus_message_new_method_return(msg);

	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}
DBusMessage * wid_dbus_interface_set_wtp_wids_policy(DBusConnection *conn, DBusMessage *msg, void *user_data)
{

	DBusMessage* reply;
	DBusMessageIter  iter;
	DBusError err;
	unsigned char policy = 0;
	
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if((gwids.flooding == 1)||(gwids.sproof == 1)||(gwids.weakiv == 1))
	{
		ret = SWITCH_IS_DISABLE;
	}
	else
	{
		gwidspolicy = policy;
	}	
		
	reply = dbus_message_new_method_return(msg);

	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}

DBusMessage * wid_dbus_interface_set_wtp_wids_threshold(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned char threshold = 0;
	unsigned char policy = 2;
	
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&policy,
								DBUS_TYPE_BYTE,&threshold,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if((gwids.flooding == 1)||(gwids.sproof == 1)||(gwids.weakiv == 1))
	{
		ret = SWITCH_IS_DISABLE;
	}
	else
	{
		if(policy == 0)//probe
		{
			gprobethreshold = threshold;
		}
		else if(policy == 1)//other
		{
			gotherthreshold = threshold;
		}
	}	
		
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}
DBusMessage * wid_dbus_interface_set_wtp_wids_lasttime_in_black(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int time = 0;
	
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&time,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	glasttimeinblack = time;
		
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}

/*fengwenchao add 20120117 for onlinebug-96*/
DBusMessage * wid_dbus_interface_set_ac_master_bak_correct_wtp_state_timer(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply = NULL;
	DBusMessageIter  iter;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	int interval = 0;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&interval,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	gwtpstate_mb = interval;
	
	reply = dbus_message_new_method_return(msg);


	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	return reply;
}


/*fengwenchao add end*/


DBusMessage * wid_dbus_interface_set_ac_state_ip(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply = NULL;
	DBusMessageIter  iter;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	unsigned int ip = 0;
	char type = 0;
#ifdef __nouseif__
	char * ifname = NULL;
#endif
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&type,
								DBUS_TYPE_UINT32,&ip,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
#if 0
	struct ifi_info *ifi_tmp = (struct ifi_info*)calloc(1, sizeof(struct ifi_info));
	memset(ifi_tmp->ifi_name,0,sizeof(ifi_tmp->ifi_name));
	strncpy(ifi_tmp->ifi_name,ifname,sizeof(ifi_tmp->ifi_name));
	
	ret = Get_Interface_Info(ifname,ifi_tmp);

	((struct sockaddr_in *)(ifi_tmp->ifi_addr))->sin_addr.s_addr = ip;
	ret = Bind_Interface_For_WID(ifi_tmp,WID_LIC_AC_PORT);		
#endif
	if((type != 3)&&(Lic_ip.lic_active_ac_ip != 0)&&(Lic_ip.lic_active_ac_ip != ip)){
		ret = INVALID_TYPE;
		wid_syslog_info("%s,%d,ret=%d.\n",__func__,__LINE__,ret);
	}else{
		/*
		* if the device now is master state, must disable it;if it is bakup state, must disable it also.
		* explain for next if condition
		* type = 1: want to be master; type = 2: want to be bakup; type = 3: want to be disable
		* isActive = 1: now is master; isActive = 2: now is bakup; isActive = 0: now is disable
		*     If the current device's state is master, it's isActive's value is 1. If the engineer want to 
		* change it to bakup state, type's value is 2, isActive << 1 = 2, (isActive << 1 == type) is true,
		* (type << 1 == isActive) is false, so, must disable it first.
		*     Another kind of circumstance is the same which the current device state is bakup, but the 
		* engineer want chang it to be master.
		*
		* Do this, some advantages follow:
		*    short-circuit evaluation;
		*    read variables's value and cache it;  
		*/
		if (((type << 1) == Lic_ip.isActive) || (((Lic_ip.isActive) << 1) == type))
		{
			wid_syslog_debug_debug(WID_DBUS, "%s %d this device's state is %s\n", __func__, __LINE__, (Lic_ip.isActive == 1) ? "MASTER" : "BAKUP");
			ret = AC_STATE_FIRST_DISABLE;
		}
		else
		{
			if(type == 1){
				Lic_ip.lic_active_ac_ip = ip;
				ret = Check_And_Bind_Ipaddr_For_WID(Lic_ip.lic_active_ac_ip,LIC_TYPE);
				Lic_ip.isActive = 1;
				set_active_ac_listenning();
				wid_syslog_info("%s,%d,active,ip:%d.%d.%d.%d.",__func__,__LINE__,(ip>>24)&0xFF,(ip>>16)&0xFF,(ip>>8)&0xFF,(ip&0xFF));
			}else if(type == 2){
				Lic_ip.lic_active_ac_ip = ip;
				Lic_ip.isActive = 2;
				set_bakup_ac_update_license();
				wid_syslog_info("%s,%d,bakup,ip:%d.%d.%d.%d.",__func__,__LINE__,(ip>>24)&0xFF,(ip>>16)&0xFF,(ip>>8)&0xFF,(ip&0xFF));
			}else if (type == 3){
				wid_syslog_info("%s,%d,type=%d,set ac state to disable from %s.",__func__,__LINE__,type,(Lic_ip.isActive == 1)?"active":"bakup");
				if (Lic_ip.isActive == 2)
				{
					if (Lic_ip.lic_active_ac_ip == ip)
					{
						Lic_ip.isActive = 0;
						Lic_ip.lic_active_ac_ip = 0;
						ret = WID_DBUS_SUCCESS;
					}
					else
					{
						ret = AC_STATE_IP_NOT_EXIST;
					}
				}
				else if (Lic_ip.isActive == 1)
				{
					if (ip == Lic_ip.lic_active_ac_ip)
					{
						ret = DELETE_LISTENNING_IPADDR(Lic_ip.lic_active_ac_ip, LIC_TYPE);
						if (ret == 0)
						{
							Lic_ip.isActive = 0;
							Lic_ip.lic_active_ac_ip = 0;
						}
						else
						{
							ret = AC_STATE_IP_NOT_EXIST;
						}
					}
					else
					{
						ret = AC_STATE_IP_NOT_EXIST;
					}
				}
				else
				{
					ret = AC_STATE_IP_NOT_EXIST;
				}
			}
			else
			{}
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
#if 0
	if(ifi_tmp->ifi_addr != NULL){
		free(ifi_tmp->ifi_addr);
		ifi_tmp->ifi_addr = NULL;
	}		
	if(ifi_tmp->ifi_brdaddr != NULL){
		free(ifi_tmp->ifi_brdaddr);
		ifi_tmp->ifi_brdaddr = NULL;
	}
	free(ifi_tmp);
	ifi_tmp = NULL;
#endif
	return reply;
}

DBusMessage * wid_dbus_interface_show_neighbordead_interval(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter  iter;
	//DBusError err;
	int ret = WID_DBUS_SUCCESS;
	int neighbordead_interval = gCWNeighborDeadInterval;
		
	reply = dbus_message_new_method_return(msg);


	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &neighbordead_interval);


	return reply;


}

DBusMessage * wid_dbus_interface_set_neighbordead_interval(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	int i = 0;

	
	int ret = WID_DBUS_SUCCESS;
	int neighbordead_interval = 60;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&neighbordead_interval,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	
	for(i=0; i<WTP_NUM; i++)
	{
		if((AC_WTP[i] != NULL))
		{
			ret = wid_set_neighbordead_intervalt(i,neighbordead_interval);
		}
	}

	gCWNeighborDeadInterval = neighbordead_interval;
		
	reply = dbus_message_new_method_return(msg);

	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}

DBusMessage * wid_dbus_interface_set_ap_update_timer(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	int timer = 0;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&timer,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
   
	if(timer == gCWImageDataPendingTimer)
	{
		ret = WID_DBUS_SUCCESS;
	}
	else
	{
		gCWImageDataPendingTimer =timer;
	}
	wid_syslog_debug_debug(WID_DBUS,"gCWImageDataPendingTimer %d timer %d\n",gCWImageDataPendingTimer,timer);
	reply = dbus_message_new_method_return(msg);

	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}

DBusMessage * wid_dbus_interface_set_ap_update_fail_count(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	unsigned char count = 0;  //fengwenchao change int to char,20111215 for AXSSZFI-646
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&count,  //fengwenchao change int to char,20111215 for AXSSZFI-646
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
   
	if(count == updatemaxfailcount)
	{
		ret = WID_DBUS_SUCCESS;
	}
	else
	{
		updatemaxfailcount = count;
	}
	
	reply = dbus_message_new_method_return(msg);

	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;
	
}

DBusMessage * wid_dbus_interface_show_ap_update_fail_count(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	
	int count = updatemaxfailcount;
	
	dbus_error_init(&err);
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &count);
	
	return reply;
	
}

DBusMessage * wid_dbus_interface_show_ap_update_timer(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	
	int timer = gCWImageDataPendingTimer;
	
	dbus_error_init(&err);
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &timer);
	
	return reply;
	
}

#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_ap_if_updown(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter  iter;

	int i = 0;
	int num =0 ;
	unsigned int ID = 0;
	unsigned int type1 = 0;
	unsigned char type = 0;
	unsigned char ifindex = 0;
	unsigned char policy = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Wtp_List  *wtp_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;

	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type1,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&type,
								DBUS_TYPE_BYTE,&ifindex,
								DBUS_TYPE_BYTE,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type1==0)
		{
			if(AC_WTP[ID] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else if(gWTPs[ID].currentState != CW_ENTER_RUN)
				{
					ret = WTP_NOT_IN_RUN_STATE;
				}
			else 
				{
					ret = wid_set_ap_if_updown(ID,type,ifindex,policy);
				}
		}

	if(type1==1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
			
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
				
							if(ret_check == WID_DBUS_SUCCESS)
								{
									if(AC_WTP[tmp->WTPID]->WTPStat != 5)
										{
											ret2 = WTP_NOT_IN_RUN_STATE;
											wid_syslog_debug_debug(WID_DEFAULT,"WTP%d NOT RUN\n",tmp->WTPID);
										}
									
									else
										{
											ret2 = wid_set_ap_if_updown(tmp->WTPID,type,ifindex,policy);
										}
									if(ret2 != WID_DBUS_SUCCESS)
										{
											wtp_head[num].WtpId = tmp->WTPID;
											wtp_head[num].FailReason = ret2;
											num++;
										}

						
									tmp = tmp->next;
								}
							ret = WID_DBUS_SUCCESS;
						}
				}
			
		else
			{
				ret = GROUP_ID_NOT_EXIST;
			}
		}
	printf("num = %d  \n",num);
	reply = dbus_message_new_method_return(msg);

	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &num);
		for(i = 0; i < num; i++){
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_UINT32,
												 &(wtp_head[i].WtpId));
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_BYTE,
												 &(wtp_head[i].FailReason));
		}	
		
		if(wtp_head!=NULL){
			WID_FREE(wtp_head);
			wtp_head = NULL;	
		}
	}
	
	return reply;
}

#else
DBusMessage * wid_dbus_interface_set_ap_if_updown(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter  iter;
	
	unsigned int wtpid = 0;
	unsigned char type = 0;
	unsigned char ifindex = 0;
	unsigned char policy = 0;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_BYTE,&type,
								DBUS_TYPE_BYTE,&ifindex,
								DBUS_TYPE_BYTE,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(gWTPs[wtpid].currentState != CW_ENTER_RUN)
	{
		ret = WTP_NOT_IN_RUN_STATE;
	}
	else 
	{
		ret = wid_set_ap_if_updown(wtpid,type,ifindex,policy);
	}
	
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	return reply;
	
}
#endif

#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_ap_if_eth_rate(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter  iter;
	
	int i = 0;
	int num =0 ;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned char ifindex = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	unsigned int rate = 100;
	struct Wtp_List  *wtp_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;

	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_BYTE,&ifindex,
								DBUS_TYPE_UINT32,&rate,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{	
			if(ID == 0){
				gAPIFINFOETH_RATE[ifindex] = rate;
				for(i=0;i<WTP_NUM;i++){				
					if(AC_WTP[i] != NULL){
						if(ifindex >= AC_WTP[i]->apifinfo.eth_num){
							ret = ETH_NOT_EXIST;
						}else{
								char apcmd[WID_SYSTEM_CMD_LENTH];
								memset(apcmd,0,WID_SYSTEM_CMD_LENTH);
						
								sprintf(apcmd,"ethtool -s eth0 autoneg off;ethtool -s eth%d speed %d",ifindex,rate);
								//printf("apcmd %s\n",apcmd);
					
								ret = wid_radio_set_extension_command(i,apcmd);
								if(ret == 0)
									{
										if(ifindex<AC_WTP[i]->apifinfo.eth_num)
											{
												AC_WTP[i]->apifinfo.eth[ifindex].eth_rate= rate;

											}
									}
						}
					}
				}
			}	/*wcl add for globle variable*/
			else if(AC_WTP[ID] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			/*else if(gWTPs[ID].currentState != CW_ENTER_RUN)   //fengwenchao comment 20110601
				{
					ret = WTP_NOT_IN_RUN_STATE;
				}*/
			else if(ifindex >= AC_WTP[ID]->apifinfo.eth_num)
				{
					ret = ETH_NOT_EXIST;
				}
			else 
				{
					char apcmd[WID_SYSTEM_CMD_LENTH];
					memset(apcmd,0,WID_SYSTEM_CMD_LENTH);
			
					sprintf(apcmd,"ethtool -s eth0 autoneg off;ethtool -s eth%d speed %d",ifindex,rate);
					//printf("apcmd %s\n",apcmd);
		
					ret = wid_radio_set_extension_command(ID,apcmd);
					if(ret == 0)
						{
							if(ifindex<AC_WTP[ID]->apifinfo.eth_num)
								{
									AC_WTP[ID]->apifinfo.eth[ifindex].eth_rate= rate;

								}
						}
				}
		}

	if(type==1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
			
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
				
							if(ret_check == WID_DBUS_SUCCESS)
								{
									/*if(AC_WTP[tmp->WTPID]->WTPStat != 5)  //fengwenchao comment 20110601
										{
											ret2 = WTP_NOT_IN_RUN_STATE;
											wid_syslog_debug_debug(WID_DEFAULT,"WTP%d NOT RUN\n",tmp->WTPID);
										}*/
									 if(ifindex >= AC_WTP[tmp->WTPID]->apifinfo.eth_num)
										{
											ret2 = ETH_NOT_EXIST;
											wid_syslog_debug_debug(WID_DEFAULT,"WTP%d ETH NOT EXIST\n",tmp->WTPID);
										}
									else
										{
											char apcmd[WID_SYSTEM_CMD_LENTH];
											memset(apcmd,0,WID_SYSTEM_CMD_LENTH);
			
											sprintf(apcmd,"ethtool -s eth0 autoneg off;ethtool -s eth%d speed %d",ifindex,rate);
											//printf("apcmd %s\n",apcmd);
		
											ret2 = wid_radio_set_extension_command(tmp->WTPID,apcmd);
											if(ret2 == 0)
												{
													if(ifindex<AC_WTP[tmp->WTPID]->apifinfo.eth_num)
														{
															AC_WTP[tmp->WTPID]->apifinfo.eth[ifindex].eth_rate= rate;

														}
												}
										}
									if(ret2 != WID_DBUS_SUCCESS)
										{
											wtp_head[num].WtpId = tmp->WTPID;
											wtp_head[num].FailReason = ret2;
											num++;
										}
									tmp = tmp->next;
								}
							ret = WID_DBUS_SUCCESS;
						}
				}
			
		else
			{
				ret = GROUP_ID_NOT_EXIST;
			}
		}
		printf("num = %d  \n",num);
		reply = dbus_message_new_method_return(msg);

		dbus_message_iter_init_append(reply, &iter);
	
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

		if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &num);
		for(i = 0; i < num; i++){
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_UINT32,
												 &(wtp_head[i].WtpId));
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_BYTE,
												 &(wtp_head[i].FailReason));
		}	
		
		if(wtp_head!=NULL){
			WID_FREE(wtp_head);
			wtp_head = NULL;	
		}
	}
	
	return reply;	

	
}

#else
DBusMessage * wid_dbus_interface_set_ap_if_eth_rate(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter  iter;
	
	unsigned int wtpid = 0;
	unsigned char type = 0;
	unsigned char ifindex = 0;
	unsigned int rate = 100;
	int i = 0; /*wcl modify for globle variable*/
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_BYTE,&type,
								DBUS_TYPE_BYTE,&ifindex,
								DBUS_TYPE_UINT32,&rate,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid == 0){
		gAPIFINFOETH_RATE[ifindex] = rate;
		for(i=0;i<WTP_NUM;i++){				
			if(AC_WTP[i] != NULL){
				if(ifindex >= AC_WTP[i]->apifinfo.eth_num){
					ret = ETH_NOT_EXIST;
				}else{
						char apcmd[WID_SYSTEM_CMD_LENTH];
						memset(apcmd,0,WID_SYSTEM_CMD_LENTH);
				
						sprintf(apcmd,"ethtool -s eth0 autoneg off;ethtool -s eth%d speed %d",ifindex,rate);
						//printf("apcmd %s\n",apcmd);
			
						ret = wid_radio_set_extension_command(i,apcmd);
						if(ret == 0)
							{
								if(ifindex<AC_WTP[i]->apifinfo.eth_num)
									{
										AC_WTP[i]->apifinfo.eth[ifindex].eth_rate= rate;

									}
							}
				}
			}
		}
	}	/*wcl add for globle variable*/
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	/*else if(gWTPs[wtpid].currentState != CW_ENTER_RUN)  //fengwenchao comment 20110601
	{
		ret = WTP_NOT_IN_RUN_STATE;
	}*/
	else if(ifindex >= AC_WTP[wtpid]->apifinfo.eth_num)
	{
		ret = ETH_NOT_EXIST;
	}
	else 
	{
		char apcmd[WID_SYSTEM_CMD_LENTH];
		memset(apcmd,0,WID_SYSTEM_CMD_LENTH);
		
		sprintf(apcmd,"ethtool -s eth0 autoneg off;ethtool -s eth%d speed %d",ifindex,rate);
		//printf("apcmd %s\n",apcmd);
		
		ret = wid_radio_set_extension_command(wtpid,apcmd);
		if(ret == 0){
			if(ifindex<AC_WTP[wtpid]->apifinfo.eth_num){
				AC_WTP[wtpid]->apifinfo.eth[ifindex].eth_rate= rate;

			}
		}
	}
	
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	return reply;
	
}
#endif
DBusMessage * wid_dbus_interface_show_ap_if_info(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter  iter;
	DBusError err;
	unsigned int wtpid = 0;
	int i = 0;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	ret = WID_CHECK_ID(WID_WTP_CHECK,wtpid);
	
	if(ret != WID_DBUS_SUCCESS)
	{
		printf("wtp id not correct \n");
	}
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtpid]->apifinfo.report_switch == 0)
	{
		ret = SWITCH_IS_DISABLE;
	}

		
	reply = dbus_message_new_method_return(msg);

	if(ret != WID_DBUS_SUCCESS)
	{
		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	}
	else
	{
		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->apifinfo.report_switch));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->apifinfo.report_interval));
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->apifinfo.eth_num));

		for(i=0;i<AC_WTP[wtpid]->apifinfo.eth_num;i++)
		{
			dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->apifinfo.eth[i].type));

			dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->apifinfo.eth[i].ifindex));

			dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->apifinfo.eth[i].state));

			dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->apifinfo.eth[i].state_time));
			dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->apifinfo.eth[i].eth_rate));

			dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->apifinfo.eth[i].eth_mtu));  //fengwenchao add 20110126 for XJDEX-32  from 2.0
		}

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->apifinfo.wifi_num));
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->RadioCount));	//xiaodawei add for radiocount from wtpcompatible.xml, 20110124
		for(i=0;i<AC_WTP[wtpid]->apifinfo.wifi_num && i<AC_WTP[wtpid]->RadioCount;i++)
		{
			dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->apifinfo.wifi[i].type));

			dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->apifinfo.wifi[i].ifindex));

			dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(AC_WTP[wtpid]->apifinfo.wifi[i].state));

			dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->apifinfo.wifi[i].state_time));
		}
	}
	return reply;
	
}

#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_wtp_ntp(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusError err;
	DBusMessage* reply;
	DBusMessageIter  iter;

	int i = 0;
	int num =0 ;
	unsigned int ID = 0;
	unsigned int type = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	struct Wtp_List  *wtp_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	unsigned int policy = 0;
	unsigned int ntpinterval = 0;
	

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
							 	DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_UINT32,&ntpinterval,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
if(type==0)
{
	if(ID == 0){
		gNTP_STATE = policy;
		gNTP_INTERVAL = ntpinterval;
		for(i=0;i<WTP_NUM;i++)
		{
			if(AC_WTP[i] != NULL){
				AC_WTP[i]->ntp_state = policy;
				if(ntpinterval > 0){
					AC_WTP[i]->ntp_interval = ntpinterval;
				}
				ret = wid_set_wtp_ntp(i);
			}
		}
	}/*wcl add for globle variable*/
	else if(AC_WTP[ID] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
/*
	else if(gWTPs[ID].currentState != CW_ENTER_RUN)
	{
		ret = WTP_NOT_IN_RUN_STATE;
	}
*/
	else
	{
        AC_WTP[ID]->ntp_state = policy;
		if(ntpinterval > 0){
			AC_WTP[ID]->ntp_interval = ntpinterval;
		}
		ret = wid_set_wtp_ntp(ID);
	}
}
if(type==1)
	{
		printf("******** type == 1 *****\n");
		if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
			{
				tmp = WTP_GROUP[ID]->WTP_M;
				wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
		
				while(tmp)
					{
						ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
			
						if(ret_check == WID_DBUS_SUCCESS)
							{
								if(AC_WTP[tmp->WTPID] == NULL)
								{
									ret2 = WTP_ID_NOT_EXIST;
									wid_syslog_debug_debug(WID_DEFAULT,"WTP%d NOT EXIST\n",tmp->WTPID);
								}
/*
								else if(AC_WTP[tmp->WTPID]->WTPStat!= 5)
								{
									ret2 = WTP_NOT_IN_RUN_STATE;
									wid_syslog_debug_debug(WID_DEFAULT,"WTP%d NOT RUN\n",tmp->WTPID);
								}
*/
								else
								{
									AC_WTP[tmp->WTPID]->ntp_state = policy;
									if(ntpinterval > 0)
										{
											AC_WTP[tmp->WTPID]->ntp_interval = ntpinterval;
										}
									ret2 = wid_set_wtp_ntp(tmp->WTPID);
									printf("22222222\n");
								}

								if(ret2 != WID_DBUS_SUCCESS)
									{
										wtp_head[num].WtpId = tmp->WTPID;
										wtp_head[num].FailReason = ret2;
										num++;
									}
								tmp = tmp->next;
							}
						ret = WID_DBUS_SUCCESS;
					}
			}
		
	else
		{
			ret = GROUP_ID_NOT_EXIST;
		}
	}
	printf("num = %d  \n",num);
	reply = dbus_message_new_method_return(msg);

	dbus_message_iter_init_append(reply, &iter);

	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
	for(i = 0; i < num; i++){
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &(wtp_head[i].WtpId));
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_BYTE,
											 &(wtp_head[i].FailReason));
	}	
	
	if(wtp_head!=NULL){
		WID_FREE(wtp_head);
		wtp_head = NULL;	
	}
}

return reply;	

	
	
	
}

#else
DBusMessage * wid_dbus_interface_set_wtp_ntp(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter  iter;
	
	unsigned int wtpid = 0;
	unsigned int policy = 0;
	unsigned int ntpinterval = 0;
	int i = 0;/*wcl add for globle variable*/
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
							 	DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_UINT32,&ntpinterval,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid == 0){
		gNTP_STATE = policy;
		gNTP_INTERVAL = ntpinterval;
		for(i=0;i<WTP_NUM;i++)
		{
			if(AC_WTP[i] != NULL){
				AC_WTP[i]->ntp_state = policy;
				if(ntpinterval > 0){
					AC_WTP[i]->ntp_interval = ntpinterval;
				}
				ret = wid_set_wtp_ntp(i);
			}
		}
	}/*wcl add for globle variable*/
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
/*
	else if(gWTPs[wtpid].currentState != CW_ENTER_RUN)
	{
		ret = WTP_NOT_IN_RUN_STATE;
	}
*/
	else
	{
        AC_WTP[wtpid]->ntp_state = policy;
		if(ntpinterval > 0){
			AC_WTP[wtpid]->ntp_interval = ntpinterval;
		}
		ret = wid_set_wtp_ntp(wtpid);
	}
	
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	return reply;
	
}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_ap_reboot(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter  iter;
	
	int i = 0;
	int num =0 ;
	unsigned int ID = 0;
	unsigned int type = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	struct Wtp_List  *wtp_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;

	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
if(type==0)
{
	if(AC_WTP[ID] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(gWTPs[ID].currentState != CW_ENTER_RUN)
	{
		ret = WTP_NOT_IN_RUN_STATE;
	}
	else
	{
		ret = wid_set_ap_reboot(ID);
	}
}

if(type==1)
	{
		printf("******** type == 1 *****\n");
		if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
			{
				tmp = WTP_GROUP[ID]->WTP_M;
				wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
		
				while(tmp)
					{
						ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
			
						if(ret_check == WID_DBUS_SUCCESS)
							{
								if(AC_WTP[tmp->WTPID] == NULL)
								{
									ret2 = WTP_ID_NOT_EXIST;
									wid_syslog_debug_debug(WID_DEFAULT,"WTP%d NOT EXIST\n",tmp->WTPID);
								}
								else if(AC_WTP[tmp->WTPID]->WTPStat!= 5)
								{
									ret2 = WTP_NOT_IN_RUN_STATE;
									wid_syslog_debug_debug(WID_DEFAULT,"WTP%d NOT RUN\n",tmp->WTPID);
								}
								else
								{
									ret2 = wid_set_ap_reboot(tmp->WTPID);
								}

								if(ret2 != WID_DBUS_SUCCESS)
									{
										wtp_head[num].WtpId = tmp->WTPID;
										wtp_head[num].FailReason = ret2;
										num++;
									}
								tmp = tmp->next;
							}
						ret = WID_DBUS_SUCCESS;
					}
			}
		
	else
		{
			ret = GROUP_ID_NOT_EXIST;
		}
	}
	printf("num = %d  \n",num);
	reply = dbus_message_new_method_return(msg);

	dbus_message_iter_init_append(reply, &iter);

	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
	for(i = 0; i < num; i++){
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &(wtp_head[i].WtpId));
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_BYTE,
											 &(wtp_head[i].FailReason));
	}	
	
	if(wtp_head!=NULL){
		WID_FREE(wtp_head);
		wtp_head = NULL;	
	}
}

return reply;	

	
}


#else
DBusMessage * wid_dbus_interface_set_ap_reboot(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter  iter;
	
	unsigned int wtpid = 0;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(gWTPs[wtpid].currentState != CW_ENTER_RUN)
	{
		ret = WTP_NOT_IN_RUN_STATE;
	}
	else
	{
		ret = wid_set_ap_reboot(wtpid);
	}
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	return reply;
	
}
#endif
DBusMessage * wid_dbus_interface_set_ap_reboot_all(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter  iter;
	int i = 0;
	//unsigned int wtpid = 0;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);

	for(i=0;i<WTP_NUM;i++)
	{
		if(AC_WTP[i] != NULL)
		{
			if(gWTPs[i].currentState == CW_ENTER_RUN)
			{
				wid_set_ap_reboot(i);
			}
		}
	}
	
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	return reply;
	
}
DBusMessage * wid_dbus_interface_set_ap_reboot_by_wlanid(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter  iter;
	int i = 0;
	int j = 0;
	int result = 0;
	unsigned int wlanid = 0;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wlanid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else 
	{
		for(i=0;i<WTP_NUM;i++)
		{
			result = 0;
			if(AC_WTP[i] != NULL)
			{
				if(gWTPs[i].currentState == CW_ENTER_RUN)
				{
					for(j=0;j<AC_WTP[i]->RadioCount;j++)
					{
						if(AC_WTP[i]->WTP_Radio[j] != NULL)
						{
							if(AC_WTP[i]->WTP_Radio[j]->Wlan_Id != NULL)
							{
								struct wlanid *list = AC_WTP[i]->WTP_Radio[j]->Wlan_Id;
								while(list != NULL)
								{	
									if(list->wlanid == wlanid)
									{
										result = 1;
										wid_set_ap_reboot(i);
										break;
									}
									list = list->next;
								}
							}
						}
						if(result == 1)
						{
							break;
						}
					}
				}
			}
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	return reply;
	
}
DBusMessage * wid_dbus_interface_set_ap_reboot_by_interface(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter  iter;
	int i = 0;
	unsigned int ifindex = 0;
	char * ifname;
	WTPQUITREASON quitreason = WTP_INIT;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_STRING,&ifname,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	unsigned char ret_flag = 0;
	char *name;
	name = (char*)WID_MALLOC(strlen(ifname)+5);
	memset(name,0,strlen(ifname)+5);
	if(check_ve_interface(ifname,name)){
		wid_syslog_debug_debug(WID_DBUS,"input ve interface dosen't exist!\n");
		ret = APPLY_IF_FAIL;
		ret_flag = 1;
	}
	/*check interface && get ifindex*/
	if(ret_flag == 0){
		ret = Check_Interface_Config(name,&quitreason);
		if(ret == 0)
		{
			int sockfd;
			struct ifreq	ifr;
			sockfd = socket(AF_INET, SOCK_DGRAM, 0);
			strncpy(ifr.ifr_name,name, sizeof(ifr.ifr_name));			
			if (ioctl(sockfd, SIOCGIFINDEX, &ifr) == -1)
			{
				wid_syslog_debug_debug(WID_DBUS,"SIOCGIFINDEX error\n");
				ret = APPLY_IF_FAIL;
			}
			else
			{
				ifindex = ifr.ifr_ifindex;
			}
			close(sockfd);
			wid_syslog_debug_debug(WID_DBUS,"ifindex %d\n",ifindex);
		}

	
	if(ret == 0)
	{
		for(i=0;i<WTP_NUM;i++)
		{
			if(AC_WTP[i] != NULL)
			{
				if(gWTPs[i].currentState == CW_ENTER_RUN)
				{
					if(AC_WTP[i]->BindingSystemIndex == ifindex)
					{
						//printf("1 i %d\n",i);
						wid_set_ap_reboot(i);
						}
					}
				}
			}
		}
	}
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret); 
	WID_FREE(name);
	name = NULL;
	return reply;
	
}
DBusMessage * wid_dbus_interface_set_ap_reboot_by_model(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter  iter;
	int i = 0;
	unsigned int len1,len2;
	char *model;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	int result = 0;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_STRING,&model,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	CWThreadMutexLock(&(gAllThreadMutex));		

	CWConfigVersionInfo *pnode = gConfigVersionInfo;
	while(pnode != NULL)
	{
		if(strcmp(pnode->str_ap_model,model) == 0)
		{
			result = 1;
			break;
		}
		pnode = pnode->next;
	}
	
	CWThreadMutexUnlock(&(gAllThreadMutex));		
	if(result == 0)
	{
		ret = MODEL_NO_EXIST;
	}
	else
	{
		for(i=0;i<WTP_NUM;i++)
		{
			if(AC_WTP[i] != NULL)
			{
				if(gWTPs[i].currentState == CW_ENTER_RUN)
				{
					if(AC_WTP[i]->WTPModel != NULL)
					{
						len1 = strlen(AC_WTP[i]->WTPModel);
						len2 = strlen(model);
						if((len1 == len2)&&(memcmp(AC_WTP[i]->WTPModel,model,len1) == 0))
						{
							wid_set_ap_reboot(i);
						}
					}
				}
			}
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	return reply;
	
}

DBusMessage * wid_dbus_interface_set_ap_reboot_by_list(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter  iter;
	DBusMessageIter iter_array;
	int i = 0;
	unsigned int list[4096];
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	int num = 0;
	memset(list,0, sizeof(list));
	
	dbus_error_init(&err);
		
	dbus_message_iter_init(msg,&iter);
	
	dbus_message_iter_get_basic(&iter,&num);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_recurse(&iter, &iter_array);
	if(num > 0 )
	{		
		for (i = 0; i < num; i++) 		/* Huangleilei add it by AXSSZFI-1621: dbus may be not accept more than 255 elements, as string add to it */
		{
			DBusMessageIter iter_struct;
			dbus_message_iter_recurse(&iter_array, &iter_struct);
			dbus_message_iter_get_basic(&iter_struct, &list[i]);
			dbus_message_iter_next(&iter_array);
		}
	}
	#if 0
	if(num > 0 )		/* Huangleilei add it by AXSSZFI-1621: dbus may be not accept more than 255 elements, as string add to it */	{		
		dbus_message_iter_next(&iter);	
		
		for (i = 0; i < num; i++) 
		{
			
			dbus_message_iter_get_basic(&iter,&list[i]);
			
			dbus_message_iter_next(&iter);	
		
		}
		
	}
	#endif

	
	for(i=0;i<num;i++)
	{
		if(AC_WTP[(list[i])] != NULL)
		{
			if(gWTPs[(list[i])].currentState == CW_ENTER_RUN)
			{
				wid_set_ap_reboot(list[i]);
			}
		}
	}
	
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	return reply;
	
}

#if _GROUP_POLICY

DBusMessage * wid_dbus_interface_get_wtp_bss_pkt_info(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter  iter;
	DBusError err;

	int i = 0;
	int num =0 ;
	unsigned int ID = 0;
	unsigned int type = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	struct Wtp_List  *wtp_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

if(type==0)
{
	if(AC_WTP[ID] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else
	{
		ret = wid_to_wsm_bss_pkt_info_get(ID);

		if(ret == CW_FALSE)
		{
			ret = WID_DBUS_ERROR;
		}
		else if(ret == CW_TRUE)
		{
			ret = WID_DBUS_SUCCESS;
		}
	}
}
if(type==1)
	{
		printf("******** type == 1 *****\n");
		if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
			{
				tmp = WTP_GROUP[ID]->WTP_M;
				wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
		
				while(tmp)
					{
						ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
			
						if(ret_check == WID_DBUS_SUCCESS)
							{
								if(AC_WTP[tmp->WTPID] == NULL)
								{
									ret2 = WTP_ID_NOT_EXIST;
									wid_syslog_debug_debug(WID_DEFAULT,"WTP%d NOT EXIST\n",tmp->WTPID);
								}

								else
								{
									ret2 = wid_to_wsm_bss_pkt_info_get(tmp->WTPID);
									if(ret2 == CW_FALSE)
									{
										ret2 = WID_DBUS_ERROR;
									}
									else if(ret2 == CW_TRUE)
									{
										ret2 = WID_DBUS_SUCCESS;
									}
								}

								if(ret2 != WID_DBUS_SUCCESS)
									{
										wtp_head[num].WtpId = tmp->WTPID;
										wtp_head[num].FailReason = ret2;
										num++;
									}
								tmp = tmp->next;
							}
						ret = WID_DBUS_SUCCESS;
					}
			}
		
	else
		{
			ret = GROUP_ID_NOT_EXIST;
		}
	}
	printf("num = %d  \n",num);
	reply = dbus_message_new_method_return(msg);

	dbus_message_iter_init_append(reply, &iter);

	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
	for(i = 0; i < num; i++){
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &(wtp_head[i].WtpId));
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_BYTE,
											 &(wtp_head[i].FailReason));
	}	
	
	if(wtp_head!=NULL){
		WID_FREE(wtp_head);
		wtp_head = NULL;	
	}
}

return reply;	


	
}

#else
DBusMessage * wid_dbus_interface_get_wtp_bss_pkt_info(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter  iter;
	DBusError err;
	unsigned int wtpid = 0;
	
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else
	{
		ret = wid_to_wsm_bss_pkt_info_get(wtpid);

		if(ret == CW_FALSE)
		{
			ret = WID_DBUS_ERROR;
		}
		else if(ret == CW_TRUE)
		{
			ret = WID_DBUS_SUCCESS;
		}
	}
	reply = dbus_message_new_method_return(msg);

	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	
	return reply;
	
}
#endif
DBusMessage * wid_dbus_interface_show_wtp_bss_pkt_info(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter  iter,iter_array;
	DBusError err;
	unsigned int wtpid = 0;
	int i = 0;
	int j = 0;
	int ret = WID_DBUS_SUCCESS;
	unsigned int count = 0;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	CWThreadMutexLock(&(gWTPs[wtpid].WTPThreadMutex));//fengwenchao add 20121123 for AXSSZFI-1050	
	ret = WID_CHECK_ID(WID_WTP_CHECK,wtpid);	
	CWThreadMutexUnlock(&(gWTPs[wtpid].WTPThreadMutex));
	
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(ret == WID_DBUS_SUCCESS){
		for(i=0;i<L_RADIO_NUM;i++)
		{
			if(AC_WTP[wtpid]->WTP_Radio[i] != NULL)
			{
				for(j=0;j<L_BSS_NUM;j++)
				{
					if(AC_WTP[wtpid]->WTP_Radio[i]->BSS[j] != NULL)
					{
						count++;
					}
				}
			}
		}
	}
	reply = dbus_message_new_method_return(msg);

	if(ret != WID_DBUS_SUCCESS)
	{
		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	}
	else
	{
		dbus_message_iter_init_append (reply, &iter);
		
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
		
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&count);
			
		dbus_message_iter_open_container (&iter,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_UINT32_AS_STRING
												DBUS_TYPE_UINT32_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
										DBUS_STRUCT_END_CHAR_AS_STRING,
										&iter_array);

		for(i=0;i<L_RADIO_NUM;i++)
		{
			if(AC_WTP[wtpid]->WTP_Radio[i] != NULL)
			{
				for(j=0;j<L_BSS_NUM;j++)
				{
					if(AC_WTP[wtpid]->WTP_Radio[i]->BSS[j] != NULL)
					{
						
						DBusMessageIter iter_struct;
									
						dbus_message_iter_open_container (&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
						
						dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT32, &AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.BSSIndex);
						
						dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT32, &AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.Radio_G_ID);

						dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.rx_unicast);

						dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.tx_unicast);

						dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.rx_broadcast);

						dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.tx_broadcast);

						dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.rx_pkt_unicast);

						dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.tx_pkt_unicast);

						dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.rx_pkt_broadcast);

						dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.tx_pkt_broadcast);

						dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.retry);

						dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.retry_pkt);

						dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.err);

						dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_BYTE, &AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->WlanID);
						
						dbus_message_iter_close_container (&iter_array, &iter_struct);
					}
				}
			}
		}
		dbus_message_iter_close_container (&iter, &iter_array);
	}	
	return reply;
	
}
DBusMessage * wid_dbus_interface_show_wtp_radio_pkt_info(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter  iter,iter_array;
	DBusError err;
	unsigned int wtpid = 0;
	int i = 0;
	int j = 0;
//	int radiocount = 0;
	int ret = WID_DBUS_SUCCESS;
	BSSStatistics info[L_RADIO_NUM];
	memset(info,0,sizeof(BSSStatistics)*L_RADIO_NUM);
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	ret = WID_CHECK_ID(WID_WTP_CHECK,wtpid);
	
	if(ret != WID_DBUS_SUCCESS)
	{
		printf("wtp id is not correct. \n");
	}
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else
	{
		for(i=0;i<L_RADIO_NUM;i++)
		{
			if(AC_WTP[wtpid]->WTP_Radio[i] != NULL)
			{
				info[i].Radio_G_ID = AC_WTP[wtpid]->WTP_Radio[i]->Radio_G_ID;
				for(j=0;j<TOTAL_AP_IF_NUM;j++){
					if(AC_WTP[wtpid]->apstatsinfo[j].type == 0){

						info[i].rx_unicast += AC_WTP[wtpid]->apstatsinfo[j].rx_unicast;
						info[i].tx_unicast += AC_WTP[wtpid]->apstatsinfo[j].tx_unicast;
						info[i].rx_broadcast += AC_WTP[wtpid]->apstatsinfo[j].rx_multicast;
						info[i].tx_broadcast += AC_WTP[wtpid]->apstatsinfo[j].tx_multicast;
						info[i].rx_pkt_unicast += AC_WTP[wtpid]->apstatsinfo[j].rx_pkt_unicast;
						info[i].tx_pkt_unicast += AC_WTP[wtpid]->apstatsinfo[j].tx_pkt_unicast;
						info[i].rx_pkt_broadcast += AC_WTP[wtpid]->apstatsinfo[j].rx_pkt_multicast;
						info[i].tx_pkt_broadcast += AC_WTP[wtpid]->apstatsinfo[j].tx_pkt_multicast;
						info[i].retry	+= AC_WTP[wtpid]->apstatsinfo[j].rx_pkt_retry;
						info[i].retry_pkt	+= AC_WTP[wtpid]->apstatsinfo[j].rx_pkt_retry;
						info[i].err		+= AC_WTP[wtpid]->apstatsinfo[j].rx_errors;
					}
				}
			}
		}
	}
		
	reply = dbus_message_new_method_return(msg);

	if(ret != WID_DBUS_SUCCESS)
	{
		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	}
	else
	{
		dbus_message_iter_init_append (reply, &iter);
		
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
		
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_BYTE,&(AC_WTP[wtpid]->RadioCount));
			
		dbus_message_iter_open_container (&iter,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_UINT32_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
										DBUS_STRUCT_END_CHAR_AS_STRING,
										&iter_array);
		i = 0;
		for(i=0;i<(AC_WTP[wtpid]->RadioCount);i++)
		{
			DBusMessageIter iter_struct;
							
			dbus_message_iter_open_container (&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
			
			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT32, &(info[i].Radio_G_ID));
			
			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &info[i].rx_unicast);

			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &info[i].tx_unicast);

			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &info[i].rx_broadcast);

			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &info[i].tx_broadcast);

			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &info[i].rx_pkt_unicast);

			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &info[i].tx_pkt_unicast);

			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &info[i].rx_pkt_broadcast);

			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &info[i].tx_pkt_broadcast);

			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &info[i].retry);

			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &info[i].retry_pkt);

			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &info[i].err);
			
			dbus_message_iter_close_container (&iter_array, &iter_struct);
				
		}
	
		dbus_message_iter_close_container (&iter, &iter_array);
	}
	return reply;
	
}

DBusMessage * wid_dbus_interface_show_wtp_radio_pkt_info_tunnel(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter  iter,iter_array;
	DBusError err;
	unsigned int wtpid = 0;
	int i = 0;
	int j = 0;
	int ret = WID_DBUS_SUCCESS;
	BSSStatistics info[L_RADIO_NUM];
	memset(info,0,sizeof(BSSStatistics)*L_RADIO_NUM);
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	ret = WID_CHECK_ID(WID_WTP_CHECK,wtpid);
	
	if(ret != WID_DBUS_SUCCESS)
	{
		printf("wtp id not correct \n");
	}
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else
	{
		for(i=0;i<L_RADIO_NUM;i++)
		{
			if(AC_WTP[wtpid]->WTP_Radio[i] != NULL)
			{
				info[i].Radio_G_ID = AC_WTP[wtpid]->WTP_Radio[i]->Radio_G_ID;
				for(j=0;j<L_BSS_NUM;j++)
				{
					if(AC_WTP[wtpid]->WTP_Radio[i]->BSS[j] != NULL)
					{
						info[i].rx_unicast += AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.rx_unicast;
						info[i].tx_unicast += AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.tx_unicast;
						info[i].rx_broadcast += AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.rx_broadcast;
						info[i].tx_broadcast += AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.tx_broadcast;
						info[i].rx_pkt_unicast += AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.rx_pkt_unicast;
						info[i].tx_pkt_unicast += AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.tx_pkt_unicast;
						info[i].rx_pkt_broadcast += AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.rx_pkt_broadcast;
						info[i].tx_pkt_broadcast += AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.tx_pkt_broadcast;
						info[i].retry += AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.retry;
						info[i].retry_pkt += AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.retry_pkt;
						info[i].err += AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.err;
					}
				}	
			}
		}
	}
		
	reply = dbus_message_new_method_return(msg);

	if(ret != WID_DBUS_SUCCESS)
	{
		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	}
	else
	{
		dbus_message_iter_init_append (reply, &iter);
		
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
		
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_BYTE,&(AC_WTP[wtpid]->RadioCount));
			
		dbus_message_iter_open_container (&iter,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_UINT32_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
												DBUS_TYPE_UINT64_AS_STRING
										DBUS_STRUCT_END_CHAR_AS_STRING,
										&iter_array);

		for(i=0;i<(AC_WTP[wtpid]->RadioCount);i++)
		{
			DBusMessageIter iter_struct;
							
			dbus_message_iter_open_container (&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
			
			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT32, &(info[i].Radio_G_ID));
			
			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &info[i].rx_unicast);

			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &info[i].tx_unicast);

			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &info[i].rx_broadcast);

			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &info[i].tx_broadcast);

			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &info[i].rx_pkt_unicast);

			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &info[i].tx_pkt_unicast);

			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &info[i].rx_pkt_broadcast);

			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &info[i].tx_pkt_broadcast);

			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &info[i].retry);

			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &info[i].retry_pkt);

			dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT64, &info[i].err);
			
			dbus_message_iter_close_container (&iter_array, &iter_struct);
				
		}
	
		dbus_message_iter_close_container (&iter, &iter_array);
	}
	return reply;
	
}

DBusMessage * wid_dbus_interface_show_wtp_eth_pkt_info(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter  iter;
	DBusError err;
	unsigned int wtpid = 0;
	int i = 0;
	int j = 0;
	int ret = WID_DBUS_SUCCESS;
	BSSStatistics info;
	{
		info.BSSIndex = 0;
		info.Radio_G_ID = 0;
		info.rx_unicast = 0;
		info.tx_unicast = 0;
		info.rx_broadcast = 0;
		info.tx_broadcast = 0;
		info.rx_pkt_unicast = 0;
		info.tx_pkt_unicast = 0;
		info.rx_pkt_broadcast = 0;
		info.tx_pkt_broadcast = 0;
		info.retry = 0;
		info.retry_pkt = 0;
		info.err = 0;
	}
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	ret = WID_CHECK_ID(WID_WTP_CHECK,wtpid);
	
	if(ret != WID_DBUS_SUCCESS)
	{
		printf("wtp id not correct. \n");
	}
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else
	{
		for(i=0;i<L_RADIO_NUM;i++)
		{
			if(AC_WTP[wtpid]->WTP_Radio[i] != NULL)
			{
				for(j=0;j<L_BSS_NUM;j++)
				{
					if(AC_WTP[wtpid]->WTP_Radio[i]->BSS[j] != NULL)
					{
						info.rx_unicast += AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.rx_unicast;
						info.tx_unicast += AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.tx_unicast;
						info.rx_broadcast += AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.rx_broadcast;
						info.tx_broadcast += AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.tx_broadcast;
						info.rx_pkt_unicast += AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.rx_pkt_unicast;
						info.tx_pkt_unicast += AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.tx_pkt_unicast;
						info.rx_pkt_broadcast += AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.rx_pkt_broadcast;
						info.tx_pkt_broadcast += AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.tx_pkt_broadcast;
						info.retry += AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.retry;
						info.retry_pkt += AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.retry_pkt;
						info.err += AC_WTP[wtpid]->WTP_Radio[i]->BSS[j]->BSS_pkt_info.err;
					
					}
				}
			}
		}
	}	
	reply = dbus_message_new_method_return(msg);

	if(ret != WID_DBUS_SUCCESS)
	{
		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	}
	else
	{
		dbus_message_iter_init_append (reply, &iter);
		
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT64, &info.rx_unicast);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT64, &info.tx_unicast);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT64, &info.rx_broadcast);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT64, &info.tx_broadcast);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT64, &info.rx_pkt_unicast);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT64, &info.tx_pkt_unicast);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT64, &info.rx_pkt_broadcast);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT64, &info.tx_pkt_broadcast);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT64, &info.retry);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT64, &info.retry_pkt);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT64, &info.err);
		
	}	
	return reply;
	
}

DBusMessage * wid_dbus_interface_show_wtp_sample_throughput_infomation(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wtpid = 0;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	ret = WID_CHECK_ID(WID_WTP_CHECK,wtpid);
	
	if(ret != WID_DBUS_SUCCESS)
	{
		printf("wtp id not correct. \n");
	}
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(WID_SAMPLE_INFORMATION.sample_switch == 0)
	{
		ret = SAMPLE_THROUGHPUT_NOT_ENABLE;
	}
	else if(gWTPs[wtpid].currentState != CW_ENTER_RUN)
	{
		ret = WTP_NOT_IN_RUN_STATE;
	}

		
	reply = dbus_message_new_method_return(msg);

	if(ret != WID_DBUS_SUCCESS)
	{
		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	}
	else
	{
		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_BYTE, &(WID_SAMPLE_INFORMATION.sample_time));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wid_sample_throughput.past_uplink_throughput));
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wid_sample_throughput.past_downlink_throughput));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wid_sample_throughput.current_uplink_throughput));
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wid_sample_throughput.current_downlink_throughput));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wid_sample_throughput.uplink_rate));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WTP[wtpid]->wid_sample_throughput.downlink_rate));

		
	}
	return reply;
	
}

DBusMessage * wid_dbus_interface_show_ap_model_infomation(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter	 iter;
	unsigned int model = 0;//1110t 1/2010 2/ 2110 3/AQ1000 4/AQ1000-H 5/AQ3110-H 6/AQ3120-H 7
	DBusError err;
	int ret = WID_DBUS_SUCCESS;

	//assemble model infomation
	model_infomation *model_info;
	model_info = (model_infomation *)WID_MALLOC(sizeof(model_infomation));

	model_info->ap_eth_num = 0;
	model_info->ap_wifi_num = 0;

	
	model_info->ap_if_mtu = 1500;
	model_info->ap_if_rate = 100;

	model_info->sw_name = (char *)WID_MALLOC(19);
	memset(model_info->sw_name,0,19);		
	memcpy(model_info->sw_name,"AQWAREv1.1.9#1.BIN",18);

	model_info->sw_supplier = (char *)WID_MALLOC(8);
	memset(model_info->sw_supplier,0,8);	
	memcpy(model_info->sw_supplier,"AUTELAN",7);

	model_info->supplier = (char *)WID_MALLOC(8);
	memset(model_info->supplier,0,8);	
	memcpy(model_info->supplier,"AUTELAN",7);
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&model,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		CW_FREE_OBJECT_WID(model_info->sw_name);
		CW_FREE_OBJECT_WID(model_info->sw_supplier);
		CW_FREE_OBJECT_WID(model_info->supplier);
		CW_FREE_OBJECT_WID(model_info);
		return NULL;
	}
	if(gConfigVersionInfo == NULL)
	{
		ret = SUPPORT_VERSION_NOT_EXIST;
	}
	else if(model == 0)
	{
		ret = VERSION_NOT_SUPPORTED;
	}
	if(model == 1)//1110T
	{
		model_info->model = (char *)WID_MALLOC(8);
		memset(model_info->model,0,8);		
		memcpy(model_info->model,"1110T",5);

		model_info->ap_eth_num = 1;
		model_info->ap_wifi_num = 1;
		model_info->hw_version = (char *)WID_MALLOC(8);
		memset(model_info->hw_version,0,8);		
		memcpy(model_info->hw_version,"1.0.3",5);
		
		model_info->sw_version = (char *)WID_MALLOC(8);
		memset(model_info->sw_version,0,8);		
		memcpy(model_info->sw_version,"1.1.2",5);

		model_info->ap_11a_antenna_gain = 5;
		model_info->ap_11bg_antenna_gain = 5;

	}
	else if(model == 2)//2010
	{
		model_info->model = (char *)WID_MALLOC(8);
		memset(model_info->model,0,8);		
		memcpy(model_info->model,"2010",4);
	
		model_info->ap_eth_num = 1;
		model_info->ap_wifi_num = 1;
		model_info->hw_version = (char *)WID_MALLOC(8);
		memset(model_info->hw_version,0,8);		
		memcpy(model_info->hw_version,"1.0.3",5);
	
		model_info->sw_version = (char *)WID_MALLOC(8);
		memset(model_info->sw_version,0,8);		
		memcpy(model_info->sw_version,"1.0.19",6);

		model_info->ap_11a_antenna_gain = 5;
		model_info->ap_11bg_antenna_gain = 5;
	
	}
	else if(model == 3)//2110
	{
		model_info->model = (char *)WID_MALLOC(8);
		memset(model_info->model,0,8);		
		memcpy(model_info->model,"2110",4);

		model_info->ap_eth_num = 2;
		model_info->ap_wifi_num = 2;
		model_info->hw_version = (char *)WID_MALLOC(8);
		memset(model_info->hw_version,0,8);		
		memcpy(model_info->hw_version,"1.20",4);
		
		model_info->sw_version = (char *)WID_MALLOC(8);
		memset(model_info->sw_version,0,8);		
		memcpy(model_info->sw_version,"1.1.9",5);

		model_info->ap_11a_antenna_gain = 5;
		model_info->ap_11bg_antenna_gain = 5;

	}
	else if(model == 4)//AQ1000
	{
		model_info->model = (char *)WID_MALLOC(8);
		memset(model_info->model,0,8);		
		memcpy(model_info->model,"AQ1000",6);

		model_info->ap_eth_num = 1;
		model_info->ap_wifi_num = 1;
		model_info->hw_version = (char *)WID_MALLOC(8);
		memset(model_info->hw_version,0,8);		
		memcpy(model_info->hw_version,"1.20",4);
		
		model_info->sw_version = (char *)WID_MALLOC(8);
		memset(model_info->sw_version,0,8);		
		memcpy(model_info->sw_version,"1.1.9",5);

		model_info->ap_11a_antenna_gain = 3;
		model_info->ap_11bg_antenna_gain = 3;

	}
	else if(model == 5)//AQ1000-H
	{
		model_info->model = (char *)WID_MALLOC(9);
		memset(model_info->model,0,9);		
		memcpy(model_info->model,"AQ1000-H",8);

		model_info->ap_eth_num = 1;
		model_info->ap_wifi_num = 1;
		model_info->hw_version = (char *)WID_MALLOC(8);
		memset(model_info->hw_version,0,8);		
		memcpy(model_info->hw_version,"1.20",4);
		
		model_info->sw_version = (char *)WID_MALLOC(8);
		memset(model_info->sw_version,0,8);		
		memcpy(model_info->sw_version,"1.1.9",5);

		model_info->ap_11a_antenna_gain = 5;
		model_info->ap_11bg_antenna_gain = 5;

	}
	else if(model == 6)//AQ3110-H
	{
		model_info->model = (char *)WID_MALLOC(9);
		memset(model_info->model,0,9);		
		memcpy(model_info->model,"AQ3110-H",8);

		model_info->ap_eth_num = 1;
		model_info->ap_wifi_num = 1;
		model_info->hw_version = (char *)WID_MALLOC(8);
		memset(model_info->hw_version,0,8);		
		memcpy(model_info->hw_version,"1.20",4);
		
		model_info->sw_version = (char *)WID_MALLOC(8);
		memset(model_info->sw_version,0,8);		
		memcpy(model_info->sw_version,"1.1.9",5);

		model_info->ap_11a_antenna_gain = 12;
		model_info->ap_11bg_antenna_gain = 12;

	}
	else if(model == 7)//AQ3120-H
	{
		model_info->model = (char *)WID_MALLOC(9);
		memset(model_info->model,0,9);		
		memcpy(model_info->model,"AQ3120-H",8);

		model_info->ap_eth_num = 1;
		model_info->ap_wifi_num = 2;
		model_info->hw_version = (char *)WID_MALLOC(8);
		memset(model_info->hw_version,0,8);		
		memcpy(model_info->hw_version,"1.20",4);
		
		model_info->sw_version = (char *)WID_MALLOC(8);
		memset(model_info->sw_version,0,8);		
		memcpy(model_info->sw_version,"1.1.9",5);

		model_info->ap_11a_antenna_gain = 12;
		model_info->ap_11bg_antenna_gain = 12;

	}
	
	reply = dbus_message_new_method_return(msg);
	
	if(ret != WID_DBUS_SUCCESS)
	{
		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	}
	else
	{
		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &model_info->model);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT16, &model_info->ap_11a_antenna_gain);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT16, &model_info->ap_11bg_antenna_gain);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT16, &model_info->ap_eth_num);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT16, &model_info->ap_wifi_num);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &model_info->hw_version);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &model_info->sw_name);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &model_info->sw_version);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &model_info->sw_supplier);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &model_info->supplier);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &model_info->ap_if_mtu);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &model_info->ap_if_rate);
	}
	
	CW_FREE_OBJECT_WID(model_info->hw_version);
	CW_FREE_OBJECT_WID(model_info->model);
	CW_FREE_OBJECT_WID(model_info->sw_version);
	CW_FREE_OBJECT_WID(model_info->sw_name);
	CW_FREE_OBJECT_WID(model_info->sw_supplier);
	CW_FREE_OBJECT_WID(model_info->supplier);
	CW_FREE_OBJECT_WID(model_info);
	return reply;
	
}


int read_ac_info(char *FILENAME,char *buff)
{
	int len,fd;
	
	fd = open(FILENAME,O_RDONLY);
	if (fd < 0) {
		return 1;
	}	
	len = read(fd,buff,DEFAULT_LEN);	
	
	if (len < 0) {
		close(fd);
		return 1;
	}
	if(len != 0)
	{
		if(buff[len-1] == '\n')
		{
			buff[len-1] = '\0';
		}
	}
	close(fd);
	return 0;
}
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_radio_11n_cwmmode(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;

	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned int l_radioid = 0;
	unsigned int wtpid = 0;
	unsigned char able = 0;
	unsigned char wlanid = 0;

	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;	

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_BYTE,&able,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			wtpid = ID/L_RADIO_NUM;
	 		l_radioid = ID%L_RADIO_NUM;

			if(AC_WTP[wtpid] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_WLAN[wlanid] == NULL)
				{
					ret = WLAN_ID_NOT_EXIST;
				}
			else if(gWTPs[wtpid].currentState != CW_ENTER_RUN)
				{
					ret = WTP_NOT_IN_RUN_STATE;
				}
			else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
				{
					ret = WTP_IS_NOT_BINDING_WLAN_ID;
				}
			else 
				{
					struct wlanid *wlan_id = AC_WTP[wtpid]->WTP_Radio[l_radioid]->Wlan_Id;
					while(wlan_id != NULL)
						{	
							if(wlan_id->wlanid == wlanid)
								{
									ret = WID_DBUS_SUCCESS;
									break;
								}
							wlan_id = wlan_id->next;
						}
					if(wlan_id == NULL)
						{
							ret = WTP_IS_NOT_BINDING_WLAN_ID;
						}
		
				}
			if(ret == WID_DBUS_SUCCESS)
				{
					ret = wid_set_radio_11n_cwmmode(wtpid,l_radioid,wlanid,able);
		
					if(ret == -1)
						{
							ret = WTP_OVER_MAX_BSS_NUM;
						}
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
										if(AC_WTP[tmp->WTPID] == NULL)
											{
												ret2 = WTP_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d id is NOT exist\n",tmp->WTPID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WLAN[wlanid] == NULL)
											{
												ret2 = WLAN_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"wlan id is not exist\n");
											}
										else if(gWTPs[tmp->WTPID].currentState != CW_ENTER_RUN)
											{
												ret2 = WTP_NOT_IN_RUN_STATE;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d is not in run state\n",tmp->WTPID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->isBinddingWlan == 0)
											{
												ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d is not binding wlan id\n",tmp->WTPID);
											}
										else 
											{
												struct wlanid *wlan_id = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Wlan_Id;
												while(wlan_id != NULL)
													{	
														if(wlan_id->wlanid == wlanid)
															{
																ret2 = WID_DBUS_SUCCESS;
																break;
															}
														wlan_id = wlan_id->next;
													}
												if(wlan_id == NULL)
													{
														ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
													}
										
											}
										if(ret2 == WID_DBUS_SUCCESS)
											{
												ret2 = wid_set_radio_11n_cwmmode(tmp->WTPID,i,wlanid,able);
										
												if(ret2 == -1)
													{
														ret2 = WTP_OVER_MAX_BSS_NUM;
													}
											}
										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;

	
}

#else
DBusMessage * wid_dbus_interface_set_radio_11n_cwmmode(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	unsigned char able = 0;
	unsigned int radioid = 0;
	unsigned char wlanid = 0;
	
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_BYTE,&able,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	int wtpid = radioid/L_RADIO_NUM;
	int l_radioid = radioid%L_RADIO_NUM;

	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else if(gWTPs[wtpid].currentState != CW_ENTER_RUN)
	{
		ret = WTP_NOT_IN_RUN_STATE;
	}
	else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
	{
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}
	else 
	{
		struct wlanid *wlan_id = AC_WTP[wtpid]->WTP_Radio[l_radioid]->Wlan_Id;
		while(wlan_id != NULL)
		{	
			if(wlan_id->wlanid == wlanid)
			{
				ret = WID_DBUS_SUCCESS;
				break;
			}
			wlan_id = wlan_id->next;
		}
		if(wlan_id == NULL)
		{
			ret = WTP_IS_NOT_BINDING_WLAN_ID;
		}
		
	}
	
	if(ret == WID_DBUS_SUCCESS)
	{
		ret = wid_set_radio_11n_cwmmode(wtpid,l_radioid,wlanid,able);
		
		if(ret == -1)
		{
			ret = WTP_OVER_MAX_BSS_NUM;
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	
}
#endif
DBusMessage * wid_dbus_interface_show_ap_model_code_infomation(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 
	DBusMessageIter  iter;
	DBusError err;
	
	int ret = WID_DBUS_SUCCESS;
	char *model;
	//char *code;
	int i;
	wid_code_infomation *model_info;
	char Enterprise_name[] = "/devinfo/enterprise_name";
	char name[DEFAULT_LEN];
	memset(name,0,DEFAULT_LEN);
	if(read_ac_info(Enterprise_name,name) == 1){
		memcpy(name,"Autelan",7);
	}
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_STRING,&model,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	wid_syslog_debug_debug(WID_DBUS,"recrive model:%s\n",model);
	
	CWThreadMutexLock(&(gAllThreadMutex));		
	CWConfigVersionInfo *pnode = gConfigVersionInfo;
	CWConfigVersionInfo_new *pnode_new = gConfigVerInfo;

	while(pnode != NULL)
	{
		if(strcmp(pnode->str_ap_model,model) == 0)
		{
			break;
		}
		pnode = pnode->next;
	}	
	while(pnode_new != NULL)
	{
		if(strcmp(pnode_new->str_ap_model,model) == 0)
		{
			break;
		}
		pnode_new = pnode_new->next;
	}	
	CWThreadMutexUnlock(&(gAllThreadMutex));		

	if(pnode == NULL)
	{
		ret = MODEL_NO_EXIST;
	}
	if(ret == WID_DBUS_SUCCESS)
	{
	    /*
		code = (char *)malloc(sizeof(char)*128);
		memset(code,0,128);
		memcpy(code,pnode->str_ap_code,strlen(pnode->str_ap_code));
		model_info->code = (char *)malloc(sizeof(char)*128);
		memset(model_info->code,0,128);
		memcpy(model_info->code,code,strlen(code));*/
		model_info = (wid_code_infomation *)WID_MALLOC(sizeof(wid_code_infomation));
		
		if((!strncmp(model,"1010",4))||(!strncmp(model,"2010",4)))
		{
			model_info->cpu_type = 1;//soc
			model_info->flash_capacity = 16;//M
			model_info->ap_eth_num = 1;

			model_info->hw_version = (char *)WID_MALLOC(8);
			memset(model_info->hw_version,0,8);		
			memcpy(model_info->hw_version,"3.00",4);
			
			if(pnode_new != NULL && pnode_new->code_info != NULL && pnode_new->code_info->str_ap_version_name != NULL){
				char *path = pnode_new->code_info->str_ap_version_name;
				model_info->sw_version = (char *)WID_MALLOC(strlen(path)+1);
				memset(model_info->sw_version,0,strlen(path)+1);		
				memcpy(model_info->sw_version,path,strlen(path));
			}else{
				model_info->sw_version = (char *)WID_MALLOC(2);
				memset(model_info->sw_version,0,2);		
				memcpy(model_info->sw_version," ",1);
			}
		}
		else
		{
			model_info->cpu_type = 2;//octeon5010
			model_info->flash_capacity = 256;//M
			model_info->ap_eth_num = 2;

			model_info->hw_version = (char *)WID_MALLOC(8);
			memset(model_info->hw_version,0,8);		
			memcpy(model_info->hw_version,"1.21",4);
			
			if(pnode_new != NULL && pnode_new->code_info != NULL && pnode_new->code_info->str_ap_version_name != NULL){
				char *path = pnode_new->code_info->str_ap_version_name;
				model_info->sw_version = (char *)WID_MALLOC(strlen(path)+1);
				memset(model_info->sw_version,0,strlen(path)+1);		
				memcpy(model_info->sw_version,path,strlen(path));
			}else{
				model_info->sw_version = (char *)WID_MALLOC(2);
				memset(model_info->sw_version,0,2);		
				memcpy(model_info->sw_version," ",1);
			}
		}
		model_info->mem_type = 1;//flash type
		model_info->card_capacity = 0;//not use card mode,use flash mode
		
		if((!strncmp(model,"1010",4))||(!strncmp(model,"1110",4))||(!strncmp(model,"2010",4))
			||(!strncmp(model,"2110",4))||(!strncmp(model,"3110",4))
			||(!strncmp(model,"210-N",5))||(!strncmp(model,"2000-PN2",8))||(!strncmp(model,"2000-PNH",8))||(!strncmp(model,"2000-QN2",8)))
		{
			model_info->ap_wifi_num = 1;
		}
		else
		{
			model_info->ap_wifi_num = 2;
		}

		for(i=0;i<L_RADIO_NUM;i++)
		{
			model_info->support_mode[i] = 3;//b-1/g-2/n-4/a-8//default bg
		}
		if((!strncmp(model,"1110-N",6))||(!strncmp(model,"2110-N",6))||(!strncmp(model,"2120-N",6))
			||(!strncmp(model,"3110-N",6))||(!strncmp(model,"3120-N",6))
			||(!strncmp(model,"350-N",5))||(!strncmp(model,"210-N",5))||(!strncmp(model,"2000-PN2",8))||(!strncmp(model,"2000-PNH",8))||(!strncmp(model,"2000-QN2",8)))
		{
			model_info->support_mode[0] = 7;//bgn
		}
		else if((!strncmp(model,"2110",4))||(!strncmp(model,"2110-H",6))||(!strncmp(model,"3110",4))
			||(!strncmp(model,"3110-H",6)))
		{
			model_info->support_mode[0] = 11;//abg
		}

		if((!strncmp(model,"2120-N",6))||(!strncmp(model,"3120-N",6))||(!strncmp(model,"350-N",5)))
		{	
			model_info->support_mode[1] = 12;//an
		}
		else if((!strncmp(model,"2120-H",6))||(!strncmp(model,"3120-H",6))||(!strncmp(model,"2120",4))||(!strncmp(model,"3120",4)))
		{
			model_info->support_mode[1] = 11;//abg
		}

		if((!strncmp(model,"3110-H",6))||(!strncmp(model,"3120-H",6)))
		{	
			model_info->ap_antenna_gain = 12;
		}
		else if((!strncmp(model,"1010",4)))
		{
			model_info->ap_antenna_gain = 3;
		}
		else
		{
			model_info->ap_antenna_gain = 5;
		}
		
		model_info->ap_if_mtu = 1500;
		model_info->ap_if_rate = 100;
		
		if(pnode_new != NULL && pnode_new->code_info != NULL && pnode_new->code_info->str_ap_version_path != NULL){
			char *path = pnode_new->code_info->str_ap_version_path;
			model_info->sw_name = (char *)WID_MALLOC(strlen(path)+1);
			memset(model_info->sw_name,0,strlen(path)+1);		
			memcpy(model_info->sw_name,path,strlen(path));
		}else{
			model_info->sw_name = (char *)WID_MALLOC(2);
			memset(model_info->sw_name,0,2); 	
			memcpy(model_info->sw_name," ",1);
		}
		
		model_info->sw_supplier = (char *)WID_MALLOC(strlen(name)+1);
		memset(model_info->sw_supplier,0,strlen(name)+1);	
		memcpy(model_info->sw_supplier,name,strlen(name));

		model_info->supplier = (char *)WID_MALLOC(strlen(name)+1);
		memset(model_info->supplier,0,strlen(name)+1);	
		memcpy(model_info->supplier,name,strlen(name));

	}
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	if(ret == WID_DBUS_SUCCESS)
	{
		//dbus_message_iter_append_basic(&iter,DBUS_TYPE_STRING,&(model_info->code));			

		dbus_message_iter_append_basic(&iter,DBUS_TYPE_STRING,&(model_info->hw_version));	

		dbus_message_iter_append_basic(&iter,DBUS_TYPE_STRING,&(model_info->supplier));	

		dbus_message_iter_append_basic(&iter,DBUS_TYPE_STRING,&(model_info->sw_name));	

		dbus_message_iter_append_basic(&iter,DBUS_TYPE_STRING,&(model_info->sw_version));	

		dbus_message_iter_append_basic(&iter,DBUS_TYPE_STRING,&(model_info->sw_supplier));

		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&model_info->ap_if_mtu);

		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&model_info->ap_if_rate);

		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&model_info->card_capacity);

		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&model_info->flash_capacity);
		
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_BYTE,&model_info->cpu_type);	

		dbus_message_iter_append_basic (&iter,DBUS_TYPE_BYTE,&model_info->mem_type);

		dbus_message_iter_append_basic (&iter,DBUS_TYPE_BYTE,&model_info->ap_eth_num);
		
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_BYTE,&model_info->ap_wifi_num);
		
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_BYTE,&model_info->ap_antenna_gain);
		for(i=0; i<model_info->ap_wifi_num;i++)
		{
			dbus_message_iter_append_basic (&iter,DBUS_TYPE_BYTE,&model_info->support_mode[i]);	
		}
//		WID_FREE(code);
//		code = NULL;
//		WID_FREE(model_info->code);
		WID_FREE(model_info->hw_version);
		WID_FREE(model_info->sw_name);
		WID_FREE(model_info->sw_version);
		WID_FREE(model_info->sw_supplier);
		WID_FREE(model_info->supplier);
		WID_FREE(model_info);		
	}
	
	return reply;	

}

#if _GROUP_POLICY

DBusMessage * wid_dbus_interface_wtp_channel_disturb_trap(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusError err;
	DBusMessage * reply;
	DBusMessageIter	 iter;
	int i = 0;
	int num =0 ;
	unsigned int ID = 0;
	unsigned int type = 0;
	int  policy = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Wtp_List  *wtp_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;

	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,								
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(type==0)
		{
			if(AC_WTP[ID] == NULL)
			{
				ret = WTP_ID_NOT_EXIST;
			}
			else
			{
		
				if(policy == 1)
				{
					ret = wid_trap_channel_disturb_enable(ID);
				}
				else
				{
					ret = wid_trap_channel_disturb_disable(ID);
				}

			}
		}

	if(type==1)
	{
		printf("******** type == 1 *****\n");
		if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
			{
				tmp = WTP_GROUP[ID]->WTP_M;
				wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
		
				while(tmp)
					{
						ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
			
						if(ret_check == WID_DBUS_SUCCESS)
							{
								if(AC_WTP[tmp->WTPID] == NULL)
								{
									ret2 = WTP_ID_NOT_EXIST;
									wid_syslog_debug_debug(WID_DEFAULT,"WTP%d NOT EXIST\n",tmp->WTPID);
								}

								else
								{
									if(policy == 1)
									{
										ret2 = wid_trap_channel_disturb_enable(tmp->WTPID);
										wid_syslog_debug_debug(WID_DEFAULT,"WTP%d set channel trap enable successful\n",tmp->WTPID);
									}
									else
									{
										ret2 = wid_trap_channel_disturb_disable(tmp->WTPID);
										wid_syslog_debug_debug(WID_DEFAULT,"WTP%d set channel trap disable successful\n",tmp->WTPID);
									}

								}

								if(ret2 != WID_DBUS_SUCCESS)
									{
										wtp_head[num].WtpId = tmp->WTPID;
										wtp_head[num].FailReason = ret2;
										num++;
									}
								tmp = tmp->next;
							}
						ret = WID_DBUS_SUCCESS;
					}
			}
		
	else
		{
			ret = GROUP_ID_NOT_EXIST;
		}
	}
	printf("num = %d  \n",num);
	reply = dbus_message_new_method_return(msg);

	dbus_message_iter_init_append(reply, &iter);

	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
	for(i = 0; i < num; i++){
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &(wtp_head[i].WtpId));
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_BYTE,
											 &(wtp_head[i].FailReason));
	}	
	
	if(wtp_head!=NULL){
		WID_FREE(wtp_head);
		wtp_head = NULL;	
	}
}

return reply;	

}

#else
DBusMessage * wid_dbus_interface_wtp_channel_disturb_trap(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter	 iter;
	int able;
	int wtpid;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,								
								DBUS_TYPE_UINT32,&able,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else
	{
		
		if(able == 1)
		{
			ret = wid_trap_channel_disturb_enable(wtpid);
		}
		else
		{
			ret = wid_trap_channel_disturb_disable(wtpid);
		}

	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	
}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_ap_l2_siolation(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;
	int i = 0;
	int num =0 ;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned char wlanid = 0;
	int  able = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Wtp_List  *wtp_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&able,
								DBUS_TYPE_BYTE,&wlanid,
								
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(type == 0)
		{
			if(AC_WTP[ID] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else if(AC_WLAN[wlanid] == NULL)
				{
					ret = WLAN_ID_NOT_EXIST;
				}
			else if(gWTPs[ID].currentState != CW_ENTER_RUN)
				{
					ret = WTP_NOT_IN_RUN_STATE;
				}
			else if(AC_WTP[ID]->WTP_Radio[0]->isBinddingWlan == 0)
				{
					ret = WTP_IS_NOT_BINDING_WLAN_ID;
				}
			else 
				{
					struct wlanid *wlan_id = AC_WTP[ID]->WTP_Radio[0]->Wlan_Id;
					while(wlan_id != NULL)
						{	
							if(wlan_id->wlanid == wlanid)
								{
									ret = WID_DBUS_SUCCESS;
									break;
								}
							wlan_id = wlan_id->next;
						}	
					if(wlan_id == NULL)
						{
							ret = WTP_IS_NOT_BINDING_WLAN_ID;
						}
		
				}
	
			if(ret == WID_DBUS_SUCCESS)
				{
		
					if(able == 1)
						{
							ret = wid_set_ap_l2_isolation_enable(ID,wlanid);
						}
					else
						{
							ret = wid_set_ap_l2_isolation_disable(ID,wlanid);
						}
					if(ret == -2)											/*xiaodawei add for l2 isolation enable or disable already, 20101207*/
						{
							ret = AP_L2_ISOLATION_ENABLE_OR_DIS_ALREADY;
						}
		
					if(ret == -1)
						{
							ret = WTP_OVER_MAX_BSS_NUM;
						}
				}
		}
	
	else if(type == 1){
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
				tmp = WTP_GROUP[ID]->WTP_M;
				wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
				
				while(tmp){
					ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
					
					if(ret_check == WID_DBUS_SUCCESS){
	
						if(AC_WTP[tmp->WTPID]->WTPStat != 5)
							{
								ret2 = WTP_NOT_IN_RUN_STATE; 
								wid_syslog_debug_debug(WID_DEFAULT,"WTP%d NOT RUN\n",tmp->WTPID);
							}
						else if(AC_WLAN[wlanid]==NULL)
							{
								ret2 = WLAN_ID_NOT_EXIST;
								wid_syslog_debug_debug(WID_DEFAULT,"WLAN %d NOT EXIST\n",wlanid);
							}
						else if(AC_WTP[tmp->WTPID]->WTP_Radio[0]->isBinddingWlan == 0)
							{
								ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
								wid_syslog_debug_debug(WID_DEFAULT,"WTP%d NOT BINDING WLAN ID\n",tmp->WTPID);
							}
						else
							{
								struct wlanid *wlan_id = AC_WTP[tmp->WTPID]->WTP_Radio[0]->Wlan_Id;
								while(wlan_id != NULL)
									{	
										if(wlan_id->wlanid == wlanid)
											{
												ret2 = WID_DBUS_SUCCESS;
												break;
											}
										wlan_id = wlan_id->next;
									}	
								if(wlan_id == NULL)
									{
										ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
									}
							}
						if(ret2 == WID_DBUS_SUCCESS)
							{
		
								if(able == 1)
									{
										ret2 = wid_set_ap_l2_isolation_enable(tmp->WTPID,wlanid);
									}
								else
									{
										ret2 = wid_set_ap_l2_isolation_disable(tmp->WTPID,wlanid);
									}
								if(ret2 == -2)											/*xiaodawei add for l2 isolation enable or disable already, 20101207*/
									{
										ret2 = AP_L2_ISOLATION_ENABLE_OR_DIS_ALREADY;
									}
		
								if(ret2 == -1)
									{
										ret2 = WTP_OVER_MAX_BSS_NUM;
									}
							}
						if(ret2 != WID_DBUS_SUCCESS){
							wtp_head[num].WtpId = tmp->WTPID;
							wtp_head[num].FailReason = ret2;
							num++;
		
						}
						tmp = tmp->next;
					}
					ret = WID_DBUS_SUCCESS;
				}
			}
				
			else{
				ret = GROUP_ID_NOT_EXIST;
				}
		}

		reply = dbus_message_new_method_return(msg);
	
		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
		if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_UINT32,
												 &num);
			printf("num= %d",num);
			for(i = 0; i < num; i++){
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
													 &(wtp_head[i].WtpId));
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_BYTE,
													 &(wtp_head[i].FailReason));
			}	
			
			if(wtp_head!=NULL){
				WID_FREE(wtp_head);
				wtp_head = NULL;	
			}
		}
		
		return reply;
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	
}

#else
DBusMessage * wid_dbus_interface_set_ap_l2_siolation(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	int able = 0;
	int wtpid = 0;
	unsigned char wlanid = 0;
	
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&able,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if(gWTPs[wtpid].currentState != CW_ENTER_RUN)
	{
		ret = WTP_NOT_IN_RUN_STATE;
	}
	else if(AC_WTP[wtpid]->WTP_Radio[0]->isBinddingWlan == 0)
	{
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}
	else 
	{
		struct wlanid *wlan_id = AC_WTP[wtpid]->WTP_Radio[0]->Wlan_Id;
		while(wlan_id != NULL)
		{	
			if(wlan_id->wlanid == wlanid)
			{
				ret = WID_DBUS_SUCCESS;
				break;
			}
			wlan_id = wlan_id->next;
		}
		if(wlan_id == NULL)
		{
			ret = WTP_IS_NOT_BINDING_WLAN_ID;
		}
		
	}
	
	if(ret == WID_DBUS_SUCCESS)
	{
		
		if(able == 1)
		{
			ret = wid_set_ap_l2_isolation_enable(wtpid,wlanid);
		}
		else
		{
			ret = wid_set_ap_l2_isolation_disable(wtpid,wlanid);
		}
		if(ret == -2)											/*xiaodawei add for l2 isolation enable or disable already, 20101207*/
		{
			ret = AP_L2_ISOLATION_ENABLE_OR_DIS_ALREADY;
		}
		if(ret == -1)
		{
			ret = WTP_OVER_MAX_BSS_NUM;
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	
}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_radio_l2_siolation(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;	
	
	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;


	unsigned int able = 0;
	unsigned char wlanid = 0;

	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;	

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&able,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			int wtpid = ID/L_RADIO_NUM;
			int l_radioid = ID%L_RADIO_NUM;
			if(AC_WTP[wtpid] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_WLAN[wlanid] == NULL)
				{
					ret = WLAN_ID_NOT_EXIST;
				}
			//if(gWTPs[wtpid].currentState != CW_ENTER_RUN)
			//{
			//	ret = WTP_NOT_IN_RUN_STATE;
			//}
			else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
				{
					ret = WTP_IS_NOT_BINDING_WLAN_ID;
				}
			else 
				{
					struct wlanid *wlan_id = AC_WTP[wtpid]->WTP_Radio[l_radioid]->Wlan_Id;
					while(wlan_id != NULL)
					{	
						if(wlan_id->wlanid == wlanid)
							{
								ret = WID_DBUS_SUCCESS;
								break;
							}
						wlan_id = wlan_id->next;
					}
					if(wlan_id == NULL)
						{
							ret = WTP_IS_NOT_BINDING_WLAN_ID;
						}
				}
			if(ret == WID_DBUS_SUCCESS)
				{
					if(able == 1)
						{
							ret = wid_set_radio_l2_isolation_enable(wtpid,l_radioid,wlanid);
						}
					else
						{
							ret = wid_set_radio_l2_isolation_disable(wtpid,l_radioid,wlanid);
						}
		
					if(ret == -1)
						{
							ret = WTP_OVER_MAX_BSS_NUM;
						}
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
										if(AC_WTP[tmp->WTPID] == NULL)
											{
												ret2 = WTP_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d id is NOT exist\n",tmp->WTPID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WLAN[wlanid] == NULL)
											{
												ret2 = WLAN_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"wlan id not exist\n");
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->isBinddingWlan == 0)
											{
												ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d is not bindding wlan id\n",tmp->WTPID);
											}
										else 
											{
												struct wlanid *wlan_id = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Wlan_Id;
												while(wlan_id != NULL)
												{	
													if(wlan_id->wlanid == wlanid)
														{
															ret2 = WID_DBUS_SUCCESS;
															break;
														}
													wlan_id = wlan_id->next;
												}
												if(wlan_id == NULL)
													{
														ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
													}
											}
										if(ret2 == WID_DBUS_SUCCESS)
											{
												if(able == 1)
													{
														ret2 = wid_set_radio_l2_isolation_enable(tmp->WTPID,i,wlanid);
														wid_syslog_debug_debug(WID_DEFAULT,"WTP%d RADIO%d access into set radio L2 isolation enable\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
													}
												else
													{
														ret2 = wid_set_radio_l2_isolation_disable(tmp->WTPID,i,wlanid);
														wid_syslog_debug_debug(WID_DEFAULT,"WTP%d RADIO%d access into set radio L2 isolation disable\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
													}
										
												if(ret2 == -1)
													{
														ret2 = WTP_OVER_MAX_BSS_NUM;
														wid_syslog_debug_debug(WID_DEFAULT,"WTP%d over max bss num\n",tmp->WTPID);
													}
											}

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;

}

#else
DBusMessage * wid_dbus_interface_set_radio_l2_siolation(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	int able = 0;
	int radioid = 0;
	unsigned char wlanid = 0;
	
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&able,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	int wtpid = radioid/L_RADIO_NUM;
	int l_radioid = radioid%L_RADIO_NUM;
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	//if(gWTPs[wtpid].currentState != CW_ENTER_RUN)
	//{
	//	ret = WTP_NOT_IN_RUN_STATE;
	//}
	else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
	{
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}
	else 
	{
		struct wlanid *wlan_id = AC_WTP[wtpid]->WTP_Radio[l_radioid]->Wlan_Id;
		while(wlan_id != NULL)
		{	
			if(wlan_id->wlanid == wlanid)
			{
				ret = WID_DBUS_SUCCESS;
				break;
			}
			wlan_id = wlan_id->next;
		}
		if(wlan_id == NULL)
		{
			ret = WTP_IS_NOT_BINDING_WLAN_ID;
		}
		
	}
	
	if(ret == WID_DBUS_SUCCESS)
	{
		
		if(able == 1)
		{
			ret = wid_set_radio_l2_isolation_enable(wtpid,l_radioid,wlanid);
		}
		else
		{
			ret = wid_set_radio_l2_isolation_disable(wtpid,l_radioid,wlanid);
		}
		
		if(ret == -1)
		{
			ret = WTP_OVER_MAX_BSS_NUM;
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	
}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_radio_auto_channel_able(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;

	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned int l_radioid = 0;
	unsigned int wtpid = 0;
	unsigned int able = 0;

	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,								
								DBUS_TYPE_UINT32,&able,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			wtpid = ID/L_RADIO_NUM;
			l_radioid = ID%L_RADIO_NUM;
			if(AC_WTP[wtpid] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else
				{
					ret = wid_set_radio_auto_channel_able(wtpid,l_radioid,able);
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
										if(AC_WTP[tmp->WTPID] == NULL)
											{
												ret2 = WTP_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d id is NOT exist\n",tmp->WTPID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else
											{
												ret2 = wid_set_radio_auto_channel_able(tmp->WTPID,i,able);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d access into set auto channel able\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;

}

#else
DBusMessage * wid_dbus_interface_set_radio_auto_channel_able(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	unsigned int able;
	unsigned int radioid;
	unsigned int l_radioid;
	unsigned int wtpid;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,								
								DBUS_TYPE_UINT32,&able,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	wtpid = radioid/L_RADIO_NUM;
	l_radioid = radioid%L_RADIO_NUM;
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else
	{
		ret = wid_set_radio_auto_channel_able(wtpid,l_radioid,able);
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_radio_auto_channel_cont_able(DBusConnection *conn, DBusMessage *msg, void *user_data)
	{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;	

	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned int l_radioid = 0;
	unsigned int wtpid = 0;
	unsigned int able = 0;
	unsigned char RadioChan = 0;

	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,	
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,								
								DBUS_TYPE_UINT32,&able,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			wtpid = ID/L_RADIO_NUM;
			l_radioid = ID%L_RADIO_NUM;
			if(AC_WTP[wtpid] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			printf("set radio auto en_dis  1111\n");
			if(ret==WID_DBUS_SUCCESS)
				{			
					printf("set radio auto en_dis  2222\n");
					if(able == 0)
						{
							RadioChan = 0;					
							printf("set radio auto en_dis  3333  radio id %d\n",ID);
							ret = WID_RADIO_SET_CHAN(ID,RadioChan);				
							AC_WTP[wtpid]->WTP_Radio[l_radioid]->auto_channel_cont = able;
							printf("set radio auto en_dis  4444  radio id %d\n",ID);
						}
					else 
						{
							printf("set radio auto en_dis  5555  radio id %d\n",ID);
							RadioChan = AC_WTP[wtpid]->WTP_Radio[l_radioid]->Radio_Chan;
							ret = WID_RADIO_SET_CHAN(ID,RadioChan);				
							printf("set radio auto en_dis  6666  radio id %d\n",ID);
							AC_WTP[wtpid]->WTP_Radio[l_radioid]->auto_channel_cont = able;
						}
				}	
			printf("set radio auto en_dis  7777  radio id %d\n",ID);
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
										if(AC_WTP[tmp->WTPID] == NULL)
											{
												ret2 = WTP_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d id is NOT exist\n",tmp->WTPID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										if(ret2==WID_DBUS_SUCCESS)
											{			
												printf("set radio auto en_dis  2222\n");
												if(able == 0)
													{
														RadioChan = 0;					
														printf("set radio auto en_dis  3333  radio id %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
														ret2 = WID_RADIO_SET_CHAN(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,RadioChan); 			
														AC_WTP[tmp->WTPID]->WTP_Radio[i]->auto_channel_cont = able;
														printf("set radio auto en_dis  4444  radio id %d\n",ID);
														wid_syslog_debug_debug(WID_DEFAULT,"WTP%d RADIO%d access into set chan and save the able\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
													}
												else 
													{
														printf("set radio auto en_dis  5555  radio id %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
														RadioChan = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_Chan;
														ret2 = WID_RADIO_SET_CHAN(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,RadioChan); 			
														printf("set radio auto en_dis  6666  radio id %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
														AC_WTP[tmp->WTPID]->WTP_Radio[i]->auto_channel_cont = able;
														wid_syslog_debug_debug(WID_DEFAULT,"WTP%d RADIO%d access into set chan and save the able\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
													}
											}	
										printf("set radio auto en_dis  7777  radio id %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);


										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;

}

#else
DBusMessage * wid_dbus_interface_set_radio_auto_channel_cont_able(DBusConnection *conn, DBusMessage *msg, void *user_data)
	{
	DBusMessage * reply;
	DBusMessageIter  iter;
	unsigned int able;
	unsigned int radioid;
	unsigned int l_radioid;
	unsigned int wtpid;
	unsigned int ret = WID_DBUS_SUCCESS;
	unsigned char RadioChan;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,								
								DBUS_TYPE_UINT32,&able,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	wtpid = radioid/L_RADIO_NUM;
	l_radioid = radioid%L_RADIO_NUM;
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	printf("set radio auto en_dis  1111\n");
	if(ret==WID_DBUS_SUCCESS){			
		printf("set radio auto en_dis  2222\n");
		if(able == 0){
				RadioChan = 0;					
				printf("set radio auto en_dis  3333  radio id %d\n",radioid);
				ret = WID_RADIO_SET_CHAN(radioid,RadioChan);				
				AC_WTP[wtpid]->WTP_Radio[l_radioid]->auto_channel_cont = able;
				printf("set radio auto en_dis  4444  radio id %d\n",radioid);
		}else {
				printf("set radio auto en_dis  5555  radio id %d\n",radioid);
				RadioChan = AC_WTP[wtpid]->WTP_Radio[l_radioid]->Radio_Chan;
				ret = WID_RADIO_SET_CHAN(radioid,RadioChan);				
				printf("set radio auto en_dis  6666  radio id %d\n",radioid);
				AC_WTP[wtpid]->WTP_Radio[l_radioid]->auto_channel_cont = able;
		}
	}
	printf("set radio auto en_dis  7777  radio id %d\n",radioid);
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_radio_diversity_able(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;
	
	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned int l_radioid = 0;
	unsigned int wtpid = 0;
	unsigned int able = 0;

	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,		
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,								
								DBUS_TYPE_UINT32,&able,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			wtpid = ID/L_RADIO_NUM;
			l_radioid = ID%L_RADIO_NUM;
			if(AC_WTP[wtpid] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else
				{
					int code_result = 0;
					int codelen = strlen(AC_WTP[wtpid]->APCode);
					if((AC_WTP[wtpid]->APCode[codelen-1] == 'H')||(AC_RADIO[ID]->ishighpower == 1))
						{
							code_result = 1;
						}
					if(code_result != 1)
						{
							if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->diversity == able)
								{
									ret = WID_DBUS_SUCCESS;
								}
							else
								{
									ret = wid_set_radio_diversity(wtpid,l_radioid,able);
									AC_WTP[wtpid]->WTP_Radio[l_radioid]->diversity = able;
								}
						}
					else
						{
							ret = MODEL_NO_EXIST;
						}
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
										if(AC_WTP[tmp->WTPID] == NULL)
											{
												ret2 = WTP_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d id is NOT exist\n",tmp->WTPID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else
											{
												int code_result = 0;
												int codelen = strlen(AC_WTP[tmp->WTPID]->APCode);
												if((AC_WTP[tmp->WTPID]->APCode[codelen-1] == 'H')||(AC_WTP[tmp->WTPID]->WTP_Radio[i]->ishighpower == 1))
													{
														code_result = 1;
													}
												if(code_result != 1)
													{
														if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->diversity == able)
															{
																ret2 = WID_DBUS_SUCCESS;
																wid_syslog_debug_debug(WID_DEFAULT,"WTP%d RADIO%d had this able yet\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
															}
														else
															{
																ret2 = wid_set_radio_diversity(tmp->WTPID,i,able);
																AC_WTP[tmp->WTPID]->WTP_Radio[i]->diversity = able;
																wid_syslog_debug_debug(WID_DEFAULT,"WTP%d RADIO%d access into set diversity and save the able\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
															}
													}
												else
													{
														ret2 = MODEL_NO_EXIST;
													}
											}

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;

}

#else
DBusMessage * wid_dbus_interface_set_radio_diversity_able(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	unsigned int able;
	unsigned int radioid;
	unsigned int l_radioid;
	unsigned int wtpid;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,								
								DBUS_TYPE_UINT32,&able,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	wtpid = radioid/L_RADIO_NUM;
	l_radioid = radioid%L_RADIO_NUM;
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else
	{
		int code_result = 0;
		int codelen = 0;
		/* book modify */
		if(AC_RADIO[radioid]->ishighpower == 1)
		    code_result = 1;
		if((code_result == 0) && (AC_WTP[wtpid]->APCode != NULL))
		{
		    codelen = strlen(AC_WTP[wtpid]->APCode);
    		if((AC_WTP[wtpid]->APCode[codelen-1] == 'H'))
    		    code_result = 1;
		}

		if(code_result != 1)
		{
			if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->diversity == able)
			{
				ret = WID_DBUS_SUCCESS;
			}
			else
			{
				ret = wid_set_radio_diversity(wtpid,l_radioid,able);
				AC_WTP[wtpid]->WTP_Radio[l_radioid]->diversity = able;
			}
		}
		else
		{
			ret = MODEL_NO_EXIST;
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_radio_txantenna_able(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;	
	
	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned int l_radioid = 0;
	unsigned int wtpid = 0;
	unsigned int able = 0;

	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,								
								DBUS_TYPE_UINT32,&able,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			
			wtpid = ID/L_RADIO_NUM;
			l_radioid = ID%L_RADIO_NUM;
			if(AC_WTP[wtpid] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else
				{
					if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->txantenna != able)
						{
							int code_result = 0;
							unsigned int txantenna = 0;
							code_result = wid_parse_wtp_code_for_radio_set(wtpid);
							/*1 means hardware right; 2 means the second wifi need to be changed;0 means all wifi need to be changed*/
							/*this will be change after ap hardware changed soon  sz 09-07-17*/
				//			printf("ap code %s ;result %d\n",AC_WTP[wtpid]->APCode,code_result);
							if(code_result == 1)
								{
									ret = wid_set_radio_txantenna(wtpid,l_radioid,able);
								}
							else if(code_result == 0)
								{
									if(able == 1)
										{
											txantenna = 2;
											ret = wid_set_radio_txantenna(wtpid,l_radioid,txantenna);
										}
									else if(able == 2)
										{
											txantenna = 1;
											ret = wid_set_radio_txantenna(wtpid,l_radioid,txantenna);
										}
									else
										{
											txantenna = 0;
											ret = wid_set_radio_txantenna(wtpid,l_radioid,txantenna);
										}
								}
							else if(code_result == 2)
								{
									if(l_radioid != 1)
										{
											ret = wid_set_radio_txantenna(wtpid,l_radioid,able);
										}
									else
										{
											if(able == 1)
												{
													txantenna = 2;
													ret = wid_set_radio_txantenna(wtpid,l_radioid,txantenna);
												}
											else if(able == 2)
												{
													txantenna = 1;
													ret = wid_set_radio_txantenna(wtpid,l_radioid,txantenna);
												}
											else
												{
													txantenna = 0;
													ret = wid_set_radio_txantenna(wtpid,l_radioid,txantenna);
												}
										}
								}
			
							AC_WTP[wtpid]->WTP_Radio[l_radioid]->txantenna = able;
						}
					else
						{
							ret = WID_DBUS_SUCCESS;
						}
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
										if(AC_WTP[tmp->WTPID] == NULL)
											{
												ret2 = WTP_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d id is NOT exist\n",tmp->WTPID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else
											{
												if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->txantenna != able)
													{
														int code_result = 0;
														unsigned int txantenna = 0;
														code_result = wid_parse_wtp_code_for_radio_set(tmp->WTPID);
														/*1 means hardware right; 2 means the second wifi need to be changed;0 means all wifi need to be changed*/
														/*this will be change after ap hardware changed soon  sz 09-07-17*/
											//			printf("ap code %s ;result %d\n",AC_WTP[wtpid]->APCode,code_result);
														if(code_result == 1)
															{
																ret2 = wid_set_radio_txantenna(tmp->WTPID,i,able);
															}
														else if(code_result == 0)
															{
																if(able == 1)
																	{
																		txantenna = 2;
																		ret2 = wid_set_radio_txantenna(tmp->WTPID,i,txantenna);
																	}
																else if(able == 2)
																	{
																		txantenna = 1;
																		ret2 = wid_set_radio_txantenna(tmp->WTPID,i,txantenna);
																	}
																else
																	{
																		txantenna = 0;
																		ret2 = wid_set_radio_txantenna(tmp->WTPID,i,txantenna);
																	}
															}
														else if(code_result == 2)
															{
																if(i != 1)
																	{
																		ret2 = wid_set_radio_txantenna(tmp->WTPID,i,able);
																	}
																else
																	{
																		if(able == 1)
																			{
																				txantenna = 2;
																				ret2 = wid_set_radio_txantenna(tmp->WTPID,i,txantenna);
																			}
																		else if(able == 2)
																			{
																				txantenna = 1;
																				ret2 = wid_set_radio_txantenna(tmp->WTPID,i,txantenna);
																			}
																		else
																			{
																				txantenna = 0;
																				ret2 = wid_set_radio_txantenna(tmp->WTPID,i,txantenna);
																			}
																	}
															}
										
														AC_WTP[tmp->WTPID]->WTP_Radio[i]->txantenna = able;
													}
												else
													{
														ret2 = WID_DBUS_SUCCESS;
													}
											}

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;

}

#else
DBusMessage * wid_dbus_interface_set_radio_txantenna_able(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	unsigned int able;
	unsigned int radioid;
	unsigned int l_radioid;
	unsigned int wtpid;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,								
								DBUS_TYPE_UINT32,&able,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	wtpid = radioid/L_RADIO_NUM;
	l_radioid = radioid%L_RADIO_NUM;
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else
	{
		if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->txantenna != able)
		{
			int code_result = 0;
			unsigned int txantenna = 0;
			code_result = wid_parse_wtp_code_for_radio_set(wtpid);
			/*1 means hardware right; 2 means the second wifi need to be changed;0 means all wifi need to be changed*/
			/*this will be change after ap hardware changed soon  sz 09-07-17*/
//			printf("ap code %s ;result %d\n",AC_WTP[wtpid]->APCode,code_result);
			if(code_result == 1)
			{
				ret = wid_set_radio_txantenna(wtpid,l_radioid,able);
			}
			else if(code_result == 0)
			{
				if(able == 1)
				{
					txantenna = 2;
					ret = wid_set_radio_txantenna(wtpid,l_radioid,txantenna);
				}
				else if(able == 2)
				{
					txantenna = 1;
					ret = wid_set_radio_txantenna(wtpid,l_radioid,txantenna);
				}
				else
				{
					txantenna = 0;
					ret = wid_set_radio_txantenna(wtpid,l_radioid,txantenna);
				}
			}
			else if(code_result == 2)
			{
				if(l_radioid != 1)
				{
					ret = wid_set_radio_txantenna(wtpid,l_radioid,able);
				}
				else
				{
					if(able == 1)
					{
						txantenna = 2;
						ret = wid_set_radio_txantenna(wtpid,l_radioid,txantenna);
					}
					else if(able == 2)
					{
						txantenna = 1;
						ret = wid_set_radio_txantenna(wtpid,l_radioid,txantenna);
					}
					else
					{
						txantenna = 0;
						ret = wid_set_radio_txantenna(wtpid,l_radioid,txantenna);
					}
				}
			}

			AC_WTP[wtpid]->WTP_Radio[l_radioid]->txantenna = able;
		}
		else
		{
			ret = WID_DBUS_SUCCESS;
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}
#endif
#if _GROUP_POLICY
/*nl add 20100120*/
DBusMessage * wid_dbus_interface_set_radio_inter_vap_forwarding_able(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;

	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned int l_radioid = 0;
	unsigned int wtpid = 0;
	unsigned char policy = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,								
								DBUS_TYPE_BYTE,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(type==0)
		{
			wtpid = ID/L_RADIO_NUM;
			l_radioid = ID%L_RADIO_NUM;
			if(AC_WTP[wtpid] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
				{
					ret = WTP_IS_NOT_BINDING_WLAN_ID;
				}
			else if(AC_RADIO[ID]->REFlag != 1)
				{
					ret = RADIO_NOT_SUPPORT_COMMAND;
				}	
			if(ret == WID_DBUS_SUCCESS)
				{
					if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->inter_vap_able != policy)
						{
							AC_WTP[wtpid]->WTP_Radio[l_radioid]->inter_vap_able = policy;
							ret = wid_radio_set_inter_vap_forwarding_able(wtpid,l_radioid,policy);
						}
				}			
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
										if(AC_WTP[tmp->WTPID] == NULL)
											{
												ret2 = WTP_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d id is NOT exist\n",tmp->WTPID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->isBinddingWlan == 0)
											{
												ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT bind wlan\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->REFlag != 1)
											{
												ret2 = RADIO_NOT_SUPPORT_COMMAND;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT support command\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										
										if(ret2 == WID_DBUS_SUCCESS)
											{
												if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->inter_vap_able != policy)
													{
														AC_WTP[tmp->WTPID]->WTP_Radio[i]->inter_vap_able  = policy;
														ret2 = wid_radio_set_inter_vap_forwarding_able(tmp->WTPID,i,policy);
														wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d set inter vap forwarding successful\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
													}
											}


										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;


}

#else
/*nl add 20100120*/
DBusMessage * wid_dbus_interface_set_radio_inter_vap_forwarding_able(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage * reply;
	DBusMessageIter  iter;
	unsigned int radioid;
	unsigned int l_radioid;
	unsigned int wtpid;
	unsigned char policy = 0;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,								
								DBUS_TYPE_BYTE,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	wtpid = radioid/L_RADIO_NUM;
	l_radioid = radioid%L_RADIO_NUM;
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
	{
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}
	else if(AC_RADIO[radioid]->REFlag != 1){
		ret = RADIO_NOT_SUPPORT_COMMAND;
	}
	
	if(ret == WID_DBUS_SUCCESS)
	{
		if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->inter_vap_able != policy){
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->inter_vap_able = policy;
			ret = wid_radio_set_inter_vap_forwarding_able(wtpid,l_radioid,policy);
		}
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}
#endif
#if _GROUP_POLICY
/*nl add 20100120*/
DBusMessage * wid_dbus_interface_set_radio_intra_vap_forwarding_able(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;

	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned int l_radioid = 0;
	unsigned int wtpid = 0;
	unsigned char policy = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,								
								DBUS_TYPE_BYTE,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			wtpid = ID/L_RADIO_NUM;
			l_radioid = ID%L_RADIO_NUM;
			if(AC_WTP[wtpid] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
	
			else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
				{
					ret = WTP_IS_NOT_BINDING_WLAN_ID;
				}
			else if(AC_RADIO[ID]->REFlag != 1)
				{
					ret = RADIO_NOT_SUPPORT_COMMAND;
				}
	
			if(ret == WID_DBUS_SUCCESS)
				{
					if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->intra_vap_able != policy)
						{
							AC_WTP[wtpid]->WTP_Radio[l_radioid]->intra_vap_able = policy;
							ret = wid_radio_set_intra_vap_forwarding_able(wtpid,l_radioid,policy);
						}
				}			
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
										if(AC_WTP[tmp->WTPID] == NULL)
											{
												ret2 = WTP_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d id is NOT exist\n",tmp->WTPID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->isBinddingWlan == 0)
											{
												ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT bind wlan\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->REFlag != 1)
											{
												ret2 = RADIO_NOT_SUPPORT_COMMAND;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT support command\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										
										if(ret2 == WID_DBUS_SUCCESS)
											{
												if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->intra_vap_able != policy)
													{
														AC_WTP[tmp->WTPID]->WTP_Radio[i]->intra_vap_able  = policy;
														ret2 = wid_radio_set_intra_vap_forwarding_able(tmp->WTPID,i,policy);
														wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d set intra vap forwarding successful\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
													}
											}


										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;



}

#else
/*nl add 20100120*/
DBusMessage * wid_dbus_interface_set_radio_intra_vap_forwarding_able(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage * reply;
	DBusMessageIter  iter;
	unsigned int radioid;
	unsigned int l_radioid;
	unsigned int wtpid;
	unsigned char policy;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,								
								DBUS_TYPE_BYTE,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	wtpid = radioid/L_RADIO_NUM;
	l_radioid = radioid%L_RADIO_NUM;
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	
	else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
	{
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}
	else if(AC_RADIO[radioid]->REFlag != 1){
		ret = RADIO_NOT_SUPPORT_COMMAND;
	}
	
	if(ret == WID_DBUS_SUCCESS)
	{
		if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->intra_vap_able != policy){
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->intra_vap_able = policy;
			ret = wid_radio_set_intra_vap_forwarding_able(wtpid,l_radioid,policy);
		}
	}

	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}
#endif
#if _GROUP_POLICY
/*nl add 20100128*/
DBusMessage * wid_dbus_interface_set_radio_keep_alive_period_value(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;

	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned int l_radioid = 0;
	unsigned int wtpid = 0;
	unsigned int period = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,								
								DBUS_TYPE_UINT32,&period,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(type==0)
		{
			wtpid = ID/L_RADIO_NUM;
			l_radioid = ID%L_RADIO_NUM;
			if(AC_WTP[wtpid] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
	
			else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
				{
					ret = WTP_IS_NOT_BINDING_WLAN_ID;
				}
			else if(AC_RADIO[ID]->REFlag != 1)
				{
					ret = RADIO_NOT_SUPPORT_COMMAND;
				}
	
			if(ret == WID_DBUS_SUCCESS)
				{
					if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->keep_alive_period != period)
						{
							AC_WTP[wtpid]->WTP_Radio[l_radioid]->keep_alive_period  = period;
							ret = wid_radio_set_keep_alive_period_value(wtpid,l_radioid,period);
						}
				}	
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
										if(AC_WTP[tmp->WTPID] == NULL)
											{
												ret2 = WTP_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d id is NOT exist\n",tmp->WTPID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->isBinddingWlan == 0)
											{
												ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT bind wlan\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->REFlag != 1)
											{
												ret2 = RADIO_NOT_SUPPORT_COMMAND;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT support command\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										
										if(ret2 == WID_DBUS_SUCCESS)
											{
												if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->keep_alive_period != period)
													{
														AC_WTP[tmp->WTPID]->WTP_Radio[i]->keep_alive_period  = period;
														ret2 = wid_radio_set_keep_alive_period_value(tmp->WTPID,i,period);
														wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d set keep alive period value successful\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
													}
											}


										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;


}

#else
/*nl add 20100128*/
DBusMessage * wid_dbus_interface_set_radio_keep_alive_period_value(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage * reply;
	DBusMessageIter  iter;
	unsigned int radioid;
	unsigned int l_radioid;
	unsigned int wtpid;
	unsigned int period;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,								
								DBUS_TYPE_UINT32,&period,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	wtpid = radioid/L_RADIO_NUM;
	l_radioid = radioid%L_RADIO_NUM;
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	
	else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
	{
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}
	else if(AC_RADIO[radioid]->REFlag != 1){
		ret = RADIO_NOT_SUPPORT_COMMAND;
	}
	
	if(ret == WID_DBUS_SUCCESS)
	{
		if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->keep_alive_period != period){
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->keep_alive_period  = period;
			ret = wid_radio_set_keep_alive_period_value(wtpid,l_radioid,period);
		}
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}
#endif
#if _GROUP_POLICY
/*nl add 20100129*/
DBusMessage * wid_dbus_interface_set_radio_keep_alive_idle_time_value(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;
	
	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned int l_radioid = 0;
	unsigned int wtpid = 0;
	unsigned int idle_time = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;	

	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,								
								DBUS_TYPE_UINT32,&idle_time,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(type==0)
		{
			wtpid = ID/L_RADIO_NUM;
			l_radioid = ID%L_RADIO_NUM;
			if(AC_WTP[wtpid] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
	
			else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
				{
					ret = WTP_IS_NOT_BINDING_WLAN_ID;
				}
			else if(AC_RADIO[ID]->REFlag != 1)
				{
					ret = RADIO_NOT_SUPPORT_COMMAND;
				}
			if(ret == WID_DBUS_SUCCESS)
				{
					if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->keep_alive_idle_time != idle_time)
						{
							AC_WTP[wtpid]->WTP_Radio[l_radioid]->keep_alive_idle_time  = idle_time;
							ret = wid_radio_set_keep_alive_idle_time_value(wtpid,l_radioid,idle_time);
						}
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
										if(AC_WTP[tmp->WTPID] == NULL)
											{
												ret2 = WTP_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d id is NOT exist\n",tmp->WTPID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->isBinddingWlan == 0)
											{
												ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT bind wlan\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->REFlag != 1)
											{
												ret2 = RADIO_NOT_SUPPORT_COMMAND;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT support command\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										
										if(ret2 == WID_DBUS_SUCCESS)
											{
												if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->keep_alive_idle_time != idle_time)
													{
														AC_WTP[tmp->WTPID]->WTP_Radio[i]->keep_alive_idle_time  = idle_time;
														ret2 = wid_radio_set_keep_alive_idle_time_value(tmp->WTPID,i,idle_time);
														wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d set keep alive idle time value successful\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
													}
											}


										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;


}

#else
/*nl add 20100129*/
DBusMessage * wid_dbus_interface_set_radio_keep_alive_idle_time_value(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage * reply;
	DBusMessageIter  iter;
	unsigned int radioid;
	unsigned int l_radioid;
	unsigned int wtpid;
	unsigned int idle_time;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,								
								DBUS_TYPE_UINT32,&idle_time,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	wtpid = radioid/L_RADIO_NUM;
	l_radioid = radioid%L_RADIO_NUM;
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	
	else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
	{
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}
	else if(AC_RADIO[radioid]->REFlag != 1){
		ret = RADIO_NOT_SUPPORT_COMMAND;
	}
	if(ret == WID_DBUS_SUCCESS)
	{
		if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->keep_alive_idle_time != idle_time){
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->keep_alive_idle_time  = idle_time;
			ret = wid_radio_set_keep_alive_idle_time_value(wtpid,l_radioid,idle_time);
			}
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}
#endif
#if _GROUP_POLICY
/*nl add 20100130*/
DBusMessage * wid_dbus_interface_set_radio_congestion_avoid_state(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;

	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned int l_radioid = 0;
	unsigned int wtpid = 0;
	unsigned int congestion_avoidance = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;	

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,								
								DBUS_TYPE_UINT32,&congestion_avoidance,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			wtpid = ID/L_RADIO_NUM;
			l_radioid = ID%L_RADIO_NUM;
			if(AC_WTP[wtpid] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
	
			else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
				{
					ret = WTP_IS_NOT_BINDING_WLAN_ID;
				}
			else if(AC_RADIO[ID]->REFlag != 1)
				{
					ret = RADIO_NOT_SUPPORT_COMMAND;
				}
	
			if(ret == WID_DBUS_SUCCESS)
				{
					if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->congestion_avoidance != congestion_avoidance)
						{
							AC_WTP[wtpid]->WTP_Radio[l_radioid]->congestion_avoidance  = congestion_avoidance;
							ret = wid_radio_set_congestion_avoid_state(wtpid,l_radioid,congestion_avoidance);
						}
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
										if(AC_WTP[tmp->WTPID] == NULL)
											{
												ret2 = WTP_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d id is NOT exist\n",tmp->WTPID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->isBinddingWlan == 0)
											{
												ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT bind wlan\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->REFlag != 1)
											{
												ret2 = RADIO_NOT_SUPPORT_COMMAND;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT support command\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										
										if(ret2 == WID_DBUS_SUCCESS)
											{
												if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->congestion_avoidance != congestion_avoidance)
													{
														AC_WTP[tmp->WTPID]->WTP_Radio[i]->congestion_avoidance  = congestion_avoidance;
														ret2 = wid_radio_set_congestion_avoid_state(tmp->WTPID,i,congestion_avoidance);
														wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d set congestion_avoidance successful\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
													}
											}


										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;

}

#else
/*nl add 20100130*/
DBusMessage * wid_dbus_interface_set_radio_congestion_avoid_state(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage * reply;
	DBusMessageIter  iter;
	unsigned int radioid;
	unsigned int l_radioid;
	unsigned int wtpid;
	unsigned int congestion_avoidance;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,								
								DBUS_TYPE_UINT32,&congestion_avoidance,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	wtpid = radioid/L_RADIO_NUM;
	l_radioid = radioid%L_RADIO_NUM;
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	
	else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
	{
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}
	else if(AC_RADIO[radioid]->REFlag != 1){
		ret = RADIO_NOT_SUPPORT_COMMAND;
	}
	
	if(ret == WID_DBUS_SUCCESS)
	{
		if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->congestion_avoidance != congestion_avoidance){
			AC_WTP[wtpid]->WTP_Radio[l_radioid]->congestion_avoidance  = congestion_avoidance;
			ret = wid_radio_set_congestion_avoid_state(wtpid,l_radioid,congestion_avoidance);
			}
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}
#endif
#if _GROUP_POLICY
/*taffic limit area*/
DBusMessage * wid_dbus_interface_set_radio_wlan_traffic_limit_able(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;	

	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned char wlanid = 0;
	unsigned int wtpid = 0;
	unsigned char policy = 0;
	unsigned int l_radioid = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,								
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_BYTE,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			wtpid = ID/L_RADIO_NUM;
			l_radioid = ID%L_RADIO_NUM;
			if(AC_WTP[wtpid] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_WLAN[wlanid] == NULL)
				{
					ret = WLAN_ID_NOT_EXIST;
				}
			else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
				{
					ret = WTP_IS_NOT_BINDING_WLAN_ID;
				}
			else 
				{
					struct wlanid *wlan_id = AC_WTP[wtpid]->WTP_Radio[l_radioid]->Wlan_Id;
					while(wlan_id != NULL)
					{	
						if(wlan_id->wlanid == wlanid)
							{
								ret = WID_DBUS_SUCCESS;
								break;
							}
						wlan_id = wlan_id->next;
					}
					if(wlan_id == NULL)
						{
							ret = WTP_IS_NOT_BINDING_WLAN_ID;
						}
				}
			if(ret == WID_DBUS_SUCCESS)
				{
					ret = wid_radio_set_wlan_traffic_limit_able(wtpid,l_radioid,wlanid,policy);
				}	
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
										if(AC_WTP[tmp->WTPID] == NULL)
											{
												ret2 = WTP_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d id is NOT exist\n",tmp->WTPID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WLAN[wlanid] == NULL)
											{
												ret2 = WLAN_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"wlan id is NOT exist\n");
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->isBinddingWlan == 0)
											{
												ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is not binding wlan\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else 
											{
												struct wlanid *wlan_id = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Wlan_Id;
												while(wlan_id != NULL)
												{	
													if(wlan_id->wlanid == wlanid)
														{
															ret2 = WID_DBUS_SUCCESS;
															break;
														}
													wlan_id = wlan_id->next;
												}
												if(wlan_id == NULL)
													{
														ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
														wid_syslog_debug_debug(WID_DEFAULT,"WTP%d is not binding wlan\n",tmp->WTPID);
													}
										
											}
										
										if(ret2 == WID_DBUS_SUCCESS)
											{
												ret2 = wid_radio_set_wlan_traffic_limit_able(tmp->WTPID,i,wlanid,policy);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d access into set wlan traffic limit able\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;	

}
#else
/*taffic limit area*/
DBusMessage * wid_dbus_interface_set_radio_wlan_traffic_limit_able(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	unsigned int radioid;
	unsigned int l_radioid;
	unsigned int wtpid;
	unsigned char wlanid;
	unsigned char policy;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,								
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_BYTE,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	wtpid = radioid/L_RADIO_NUM;
	l_radioid = radioid%L_RADIO_NUM;
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
	{
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}
	else 
	{
		struct wlanid *wlan_id = AC_WTP[wtpid]->WTP_Radio[l_radioid]->Wlan_Id;
		while(wlan_id != NULL)
		{	
			if(wlan_id->wlanid == wlanid)
			{
				ret = WID_DBUS_SUCCESS;
				break;
			}
			wlan_id = wlan_id->next;
		}
		if(wlan_id == NULL)
		{
			ret = WTP_IS_NOT_BINDING_WLAN_ID;
		}
		
	}

	if(ret == WID_DBUS_SUCCESS)
	{
		ret = wid_radio_set_wlan_traffic_limit_able(wtpid,l_radioid,wlanid,policy);
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_radio_wlan_traffic_limit_value(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;	

	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned char wlanid = 0;
	unsigned char issend = 0;	
	unsigned int wtpid = 0;
	unsigned int value = 0;
	unsigned int l_radioid = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,								
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&value,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(type==0)
		{
			wtpid = ID/L_RADIO_NUM;
			l_radioid = ID%L_RADIO_NUM;
			if(AC_WTP[wtpid] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_WLAN[wlanid] == NULL)
				{
					ret = WLAN_ID_NOT_EXIST;
				}
			else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
				{
					ret = WTP_IS_NOT_BINDING_WLAN_ID;
				}
			else 
				{
					struct wlanid *wlan_id = AC_WTP[wtpid]->WTP_Radio[l_radioid]->Wlan_Id;
					while(wlan_id != NULL)
					{	
						if(wlan_id->wlanid == wlanid)
							{
								ret = WID_DBUS_SUCCESS;
								break;
							}
						wlan_id = wlan_id->next;
					}
					if(wlan_id == NULL)
						{
							ret = WTP_IS_NOT_BINDING_WLAN_ID;
						}
				}
			if(ret == WID_DBUS_SUCCESS)
				{
					ret = wid_radio_set_wlan_traffic_limit_value(wtpid,l_radioid,wlanid,value,issend);
				}	
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
										if(AC_WTP[tmp->WTPID] == NULL)
											{
												ret2 = WTP_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d id is NOT exist\n",tmp->WTPID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WLAN[wlanid] == NULL)
											{
												ret2 = WLAN_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"wlan id is NOT exist\n");
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->isBinddingWlan == 0)
											{
												ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is not binding wlan\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else 
											{
												struct wlanid *wlan_id = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Wlan_Id;
												while(wlan_id != NULL)
												{	
													if(wlan_id->wlanid == wlanid)
														{
															ret2 = WID_DBUS_SUCCESS;
															break;
														}
													wlan_id = wlan_id->next;
												}
												if(wlan_id == NULL)
													{
														ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
														wid_syslog_debug_debug(WID_DEFAULT,"WTP%d is not binding wlan\n",tmp->WTPID);
													}
										
											}
										
										if(ret2 == WID_DBUS_SUCCESS)
											{
												ret2 = wid_radio_set_wlan_traffic_limit_value(tmp->WTPID,i,wlanid,value,issend);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d access into set wlan traffic limit value\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;	

}

#else
DBusMessage * wid_dbus_interface_set_radio_wlan_traffic_limit_value(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	unsigned int radioid;
	unsigned int l_radioid;
	unsigned int wtpid;
	unsigned char wlanid;
	unsigned int value;
	unsigned int ret = WID_DBUS_SUCCESS;
	unsigned char issend = 0;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,								
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&value,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	wtpid = radioid/L_RADIO_NUM;
	l_radioid = radioid%L_RADIO_NUM;
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
	{
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}
	else 
	{
		struct wlanid *wlan_id = AC_WTP[wtpid]->WTP_Radio[l_radioid]->Wlan_Id;
		while(wlan_id != NULL)
		{	
			if(wlan_id->wlanid == wlanid)
			{
				ret = WID_DBUS_SUCCESS;
				break;
			}
			wlan_id = wlan_id->next;
		}
		if(wlan_id == NULL)
		{
			ret = WTP_IS_NOT_BINDING_WLAN_ID;
		}
		
	}

	if(ret == WID_DBUS_SUCCESS)
	{
		ret = wid_radio_set_wlan_traffic_limit_value(wtpid,l_radioid,wlanid,value,issend);
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_radio_wlan_traffic_limit_average_value(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;	

	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned char wlanid = 0;
	unsigned char issend = 0;	
	unsigned int wtpid = 0;
	unsigned int value = 0;
	unsigned int l_radioid = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,								
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&value,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			wtpid = ID/L_RADIO_NUM;
			l_radioid = ID%L_RADIO_NUM;
			if(AC_WTP[wtpid] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_WLAN[wlanid] == NULL)
				{
					ret = WLAN_ID_NOT_EXIST;
				}
			else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
				{
					ret = WTP_IS_NOT_BINDING_WLAN_ID;
				}
			else 
				{
					struct wlanid *wlan_id = AC_WTP[wtpid]->WTP_Radio[l_radioid]->Wlan_Id;
					while(wlan_id != NULL)
					{	
						if(wlan_id->wlanid == wlanid)
							{
								ret = WID_DBUS_SUCCESS;
								break;
							}
					wlan_id = wlan_id->next;
					}
					if(wlan_id == NULL)
						{
							ret = WTP_IS_NOT_BINDING_WLAN_ID;
						}
			
				}

			if(ret == WID_DBUS_SUCCESS)
				{
					ret = wid_radio_set_wlan_traffic_limit_average_value(wtpid,l_radioid,wlanid,value,issend);
				}	
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
										if(AC_WTP[tmp->WTPID] == NULL)
											{
												ret2 = WTP_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d id is NOT exist\n",tmp->WTPID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WLAN[wlanid] == NULL)
											{
												ret2 = WLAN_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"wlan id is NOT exist\n");
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->isBinddingWlan == 0)
											{
												ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is not binding wlan\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else 
											{
												struct wlanid *wlan_id = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Wlan_Id;
												while(wlan_id != NULL)
												{	
													if(wlan_id->wlanid == wlanid)
														{
															ret2 = WID_DBUS_SUCCESS;
															break;
														}
													wlan_id = wlan_id->next;
												}
												if(wlan_id == NULL)
													{
														ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
														wid_syslog_debug_debug(WID_DEFAULT,"WTP%d is not binding wlan\n",tmp->WTPID);
													}
										
											}
										
										if(ret2 == WID_DBUS_SUCCESS)
											{
												ret2 = wid_radio_set_wlan_traffic_limit_average_value(tmp->WTPID,i,wlanid,value,issend);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d access into set wlan traffic limit value\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;	

}

#else
DBusMessage * wid_dbus_interface_set_radio_wlan_traffic_limit_average_value(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	unsigned int radioid;
	unsigned int l_radioid;
	unsigned int wtpid;
	unsigned char wlanid;
	unsigned int value;
	unsigned int ret = WID_DBUS_SUCCESS;
	unsigned char issend = 0;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,								
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&value,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	wtpid = radioid/L_RADIO_NUM;
	l_radioid = radioid%L_RADIO_NUM;
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
	{
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}
	else 
	{
		struct wlanid *wlan_id = AC_WTP[wtpid]->WTP_Radio[l_radioid]->Wlan_Id;
		while(wlan_id != NULL)
		{	
			if(wlan_id->wlanid == wlanid)
			{
				ret = WID_DBUS_SUCCESS;
				break;
			}
			wlan_id = wlan_id->next;
		}
		if(wlan_id == NULL)
		{
			ret = WTP_IS_NOT_BINDING_WLAN_ID;
		}
		
	}

	if(ret == WID_DBUS_SUCCESS)
	{
		ret = wid_radio_set_wlan_traffic_limit_average_value(wtpid,l_radioid,wlanid,value,issend);
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}
#endif
/*fengwenchao add 20130416 for AXSSZFI-1374*/
DBusMessage * wid_dbus_interface_set_radio_wlan_traffic_limit_cancel_average_send_value(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply = NULL;
	DBusMessageIter  iter;
	unsigned int radioid;
	unsigned int l_radioid;
	unsigned int wtpid;
	unsigned char wlanid;
	unsigned int ret = WID_DBUS_SUCCESS;
	unsigned char issend = 1;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,								
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	wtpid = radioid/L_RADIO_NUM;
	l_radioid = radioid%L_RADIO_NUM;
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
	{
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}
	else 
	{
		struct wlanid *wlan_id = AC_WTP[wtpid]->WTP_Radio[l_radioid]->Wlan_Id;
		while(wlan_id != NULL)
		{	
			if(wlan_id->wlanid == wlanid)
			{
				ret = WID_DBUS_SUCCESS;
				break;
			}
			wlan_id = wlan_id->next;
		}
		if(wlan_id == NULL)
		{
			ret = WTP_IS_NOT_BINDING_WLAN_ID;
		}
		
	}

	if(ret == WID_DBUS_SUCCESS)
	{
		ret = wid_radio_set_wlan_traffic_limit_cancel_average_value(wtpid,l_radioid,wlanid,issend);
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	

}

DBusMessage * wid_dbus_interface_set_radio_wlan_traffic_limit_cancel_average_value(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply = NULL;
	DBusMessageIter  iter;
	unsigned int radioid;
	unsigned int l_radioid;
	unsigned int wtpid;
	unsigned char wlanid;
	unsigned int ret = WID_DBUS_SUCCESS;
	unsigned char issend = 0;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,								
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	wtpid = radioid/L_RADIO_NUM;
	l_radioid = radioid%L_RADIO_NUM;
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
	{
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}
	else 
	{
		struct wlanid *wlan_id = AC_WTP[wtpid]->WTP_Radio[l_radioid]->Wlan_Id;
		while(wlan_id != NULL)
		{	
			if(wlan_id->wlanid == wlanid)
			{
				ret = WID_DBUS_SUCCESS;
				break;
			}
			wlan_id = wlan_id->next;
		}
		if(wlan_id == NULL)
		{
			ret = WTP_IS_NOT_BINDING_WLAN_ID;
		}
		
	}

	if(ret == WID_DBUS_SUCCESS)
	{
		ret = wid_radio_set_wlan_traffic_limit_cancel_average_value(wtpid,l_radioid,wlanid,issend);
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}
/*fengwenchao add end*/
DBusMessage * wid_dbus_interface_set_radio_wlan_traffic_limit_sta_value(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	unsigned int radioid;
	unsigned int l_radioid;
	unsigned int wtpid;
	unsigned char wlanid;
	unsigned char mac[MAC_LEN];
	unsigned int value;
	unsigned int ret = WID_DBUS_SUCCESS;
	unsigned char issend = 0;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&radioid,								
								DBUS_TYPE_UINT32,&value,
								DBUS_TYPE_BYTE,&mac[0],
								DBUS_TYPE_BYTE,&mac[1],
								DBUS_TYPE_BYTE,&mac[2],
								DBUS_TYPE_BYTE,&mac[3],
								DBUS_TYPE_BYTE,&mac[4],
								DBUS_TYPE_BYTE,&mac[5],
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	wtpid = radioid/L_RADIO_NUM;
	l_radioid = radioid%L_RADIO_NUM;
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
	{
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}
	else 
	{
		struct wlanid *wlan_id = AC_WTP[wtpid]->WTP_Radio[l_radioid]->Wlan_Id;
		while(wlan_id != NULL)
		{	
			if(wlan_id->wlanid == wlanid)
			{
				ret = WID_DBUS_SUCCESS;
				break;
			}
			wlan_id = wlan_id->next;
		}
		if(wlan_id == NULL)
		{
			ret = WTP_IS_NOT_BINDING_WLAN_ID;
		}
		
	}

	if(ret == WID_DBUS_SUCCESS)
	{
		ret = wid_radio_set_wlan_traffic_limit_sta_value(wtpid,l_radioid,wlanid,mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],value,issend);
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}
DBusMessage * wid_dbus_interface_set_radio_wlan_traffic_limit_cancel_sta_value(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	unsigned int radioid;
	unsigned int l_radioid;
	unsigned int wtpid;
	unsigned char wlanid;
	unsigned char cancel_flag = 0;
	unsigned char mac[MAC_LEN];
	unsigned int ret = WID_DBUS_SUCCESS;
	unsigned char issend = 0;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,								
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_BYTE,&cancel_flag,
								DBUS_TYPE_BYTE,&mac[0],
								DBUS_TYPE_BYTE,&mac[1],
								DBUS_TYPE_BYTE,&mac[2],
								DBUS_TYPE_BYTE,&mac[3],
								DBUS_TYPE_BYTE,&mac[4],
								DBUS_TYPE_BYTE,&mac[5],
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	wtpid = radioid/L_RADIO_NUM;
	l_radioid = radioid%L_RADIO_NUM;
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
	{
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}
	else 
	{
		struct wlanid *wlan_id = AC_WTP[wtpid]->WTP_Radio[l_radioid]->Wlan_Id;
		while(wlan_id != NULL)
		{	
			if(wlan_id->wlanid == wlanid)
			{
				ret = WID_DBUS_SUCCESS;
				break;
			}
			wlan_id = wlan_id->next;
		}
		if(wlan_id == NULL)
		{
			ret = WTP_IS_NOT_BINDING_WLAN_ID;
		}
		
	}

	if(ret == WID_DBUS_SUCCESS)
	{
		ret = wid_radio_set_wlan_traffic_limit_cancel_sta_value(wtpid,l_radioid,wlanid,mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],cancel_flag,issend);
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_radio_wlan_traffic_limit_send_value(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;
	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned char wlanid = 0;
	unsigned char issend = 1;	
	unsigned int wtpid = 0;
	unsigned int value = 0;
	unsigned int l_radioid = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,								
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&value,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			wtpid = ID/L_RADIO_NUM;
			l_radioid = ID%L_RADIO_NUM;
			if(AC_WTP[wtpid] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_WLAN[wlanid] == NULL)
				{
					ret = WLAN_ID_NOT_EXIST;
				}
			else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
				{
					ret = WTP_IS_NOT_BINDING_WLAN_ID;
				}
			else 
				{
					struct wlanid *wlan_id = AC_WTP[wtpid]->WTP_Radio[l_radioid]->Wlan_Id;
					while(wlan_id != NULL)
					{	
						if(wlan_id->wlanid == wlanid)
							{
								ret = WID_DBUS_SUCCESS;
								break;
							}
						wlan_id = wlan_id->next;
					}
					if(wlan_id == NULL)
						{
							ret = WTP_IS_NOT_BINDING_WLAN_ID;
						}
		
				}

			if(ret == WID_DBUS_SUCCESS)
				{
					ret = wid_radio_set_wlan_traffic_limit_value(wtpid,l_radioid,wlanid,value,issend);
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
										if(AC_WTP[tmp->WTPID] == NULL)
											{
												ret2 = WTP_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d id is NOT exist\n",tmp->WTPID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WLAN[wlanid] == NULL)
											{
												ret2 = WLAN_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"wlan id is NOT exist\n");
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->isBinddingWlan == 0)
											{
												ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is not binding wlan\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else 
											{
												struct wlanid *wlan_id = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Wlan_Id;
												while(wlan_id != NULL)
												{	
													if(wlan_id->wlanid == wlanid)
														{
															ret2 = WID_DBUS_SUCCESS;
															break;
														}
													wlan_id = wlan_id->next;
												}
												if(wlan_id == NULL)
													{
														ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
														wid_syslog_debug_debug(WID_DEFAULT,"WTP%d is not binding wlan\n",tmp->WTPID);
													}
										
											}
										
										if(ret2 == WID_DBUS_SUCCESS)
											{
												ret2 = wid_radio_set_wlan_traffic_limit_value(tmp->WTPID,i,wlanid,value,issend);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d access into set wlan traffic limit value\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;	
}

#else
DBusMessage * wid_dbus_interface_set_radio_wlan_traffic_limit_send_value(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	unsigned int radioid;
	unsigned int l_radioid;
	unsigned int wtpid;
	unsigned char wlanid;
	unsigned int value;
	unsigned int ret = WID_DBUS_SUCCESS;
	unsigned char issend = 1;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,								
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&value,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	wtpid = radioid/L_RADIO_NUM;
	l_radioid = radioid%L_RADIO_NUM;
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
	{
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}
	else 
	{
		struct wlanid *wlan_id = AC_WTP[wtpid]->WTP_Radio[l_radioid]->Wlan_Id;
		while(wlan_id != NULL)
		{	
			if(wlan_id->wlanid == wlanid)
			{
				ret = WID_DBUS_SUCCESS;
				break;
			}
			wlan_id = wlan_id->next;
		}
		if(wlan_id == NULL)
		{
			ret = WTP_IS_NOT_BINDING_WLAN_ID;
		}
		
	}

	if(ret == WID_DBUS_SUCCESS)
	{
		ret = wid_radio_set_wlan_traffic_limit_value(wtpid,l_radioid,wlanid,value,issend);
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_radio_wlan_traffic_limit_average_send_value(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;	
	
	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned char wlanid = 0;
	unsigned char issend = 1;	
	unsigned int wtpid = 0;
	unsigned int value = 0;
	unsigned int l_radioid = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,								
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&value,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			wtpid = ID/L_RADIO_NUM;
			l_radioid = ID%L_RADIO_NUM;
			if(AC_WTP[wtpid] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_WLAN[wlanid] == NULL)
				{
					ret = WLAN_ID_NOT_EXIST;
				}
			else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
				{
					ret = WTP_IS_NOT_BINDING_WLAN_ID;
				}
			else 
				{
					struct wlanid *wlan_id = AC_WTP[wtpid]->WTP_Radio[l_radioid]->Wlan_Id;
					while(wlan_id != NULL)
					{	
						if(wlan_id->wlanid == wlanid)
							{
								ret = WID_DBUS_SUCCESS;
								break;
							}
						wlan_id = wlan_id->next;
					}
					if(wlan_id == NULL)
						{
							ret = WTP_IS_NOT_BINDING_WLAN_ID;
						}
			
				}
		
			if(ret == WID_DBUS_SUCCESS)
				{
					ret = wid_radio_set_wlan_traffic_limit_average_value(wtpid,l_radioid,wlanid,value,issend);
				}
			
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
										if(AC_WTP[tmp->WTPID] == NULL)
											{
												ret2 = WTP_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d id is NOT exist\n",tmp->WTPID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WLAN[wlanid] == NULL)
											{
												ret2 = WLAN_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"wlan id is NOT exist\n");
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->isBinddingWlan == 0)
											{
												ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is not binding wlan\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else 
											{
												struct wlanid *wlan_id = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Wlan_Id;
												while(wlan_id != NULL)
												{	
													if(wlan_id->wlanid == wlanid)
														{
															ret2 = WID_DBUS_SUCCESS;
															break;
														}
													wlan_id = wlan_id->next;
												}
												if(wlan_id == NULL)
													{
														ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
														wid_syslog_debug_debug(WID_DEFAULT,"WTP%d is not binding wlan\n",tmp->WTPID);
													}
										
											}
										
										if(ret2 == WID_DBUS_SUCCESS)
											{
												ret2 = wid_radio_set_wlan_traffic_limit_average_value(tmp->WTPID,i,wlanid,value,issend);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d access into set wlan traffic limit average value\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}



										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;

}

#else
DBusMessage * wid_dbus_interface_set_radio_wlan_traffic_limit_average_send_value(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	unsigned int radioid;
	unsigned int l_radioid;
	unsigned int wtpid;
	unsigned char wlanid;
	unsigned int value;
	unsigned int ret = WID_DBUS_SUCCESS;
	unsigned char issend = 1;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,								
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&value,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	wtpid = radioid/L_RADIO_NUM;
	l_radioid = radioid%L_RADIO_NUM;
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
	{
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}
	else 
	{
		struct wlanid *wlan_id = AC_WTP[wtpid]->WTP_Radio[l_radioid]->Wlan_Id;
		while(wlan_id != NULL)
		{	
			if(wlan_id->wlanid == wlanid)
			{
				ret = WID_DBUS_SUCCESS;
				break;
			}
			wlan_id = wlan_id->next;
		}
		if(wlan_id == NULL)
		{
			ret = WTP_IS_NOT_BINDING_WLAN_ID;
		}
		
	}

	if(ret == WID_DBUS_SUCCESS)
	{
		ret = wid_radio_set_wlan_traffic_limit_average_value(wtpid,l_radioid,wlanid,value,issend);
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}
#endif
DBusMessage * wid_dbus_interface_set_radio_wlan_traffic_limit_sta_send_value(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	unsigned int radioid;
	unsigned int l_radioid;
	unsigned int wtpid;
	unsigned char wlanid;
	unsigned char mac[MAC_LEN];
	unsigned int value;
	unsigned int ret = WID_DBUS_SUCCESS;
	unsigned char issend = 1;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&radioid,								
								DBUS_TYPE_UINT32,&value,
								DBUS_TYPE_BYTE,&mac[0],
								DBUS_TYPE_BYTE,&mac[1],
								DBUS_TYPE_BYTE,&mac[2],
								DBUS_TYPE_BYTE,&mac[3],
								DBUS_TYPE_BYTE,&mac[4],
								DBUS_TYPE_BYTE,&mac[5],
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	wtpid = radioid/L_RADIO_NUM;
	l_radioid = radioid%L_RADIO_NUM;
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
	{
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}
	else 
	{
		struct wlanid *wlan_id = AC_WTP[wtpid]->WTP_Radio[l_radioid]->Wlan_Id;
		while(wlan_id != NULL)
		{	
			if(wlan_id->wlanid == wlanid)
			{
				ret = WID_DBUS_SUCCESS;
				break;
			}
			wlan_id = wlan_id->next;
		}
		if(wlan_id == NULL)
		{
			ret = WTP_IS_NOT_BINDING_WLAN_ID;
		}
		
	}

	if(ret == WID_DBUS_SUCCESS)
	{
		ret = wid_radio_set_wlan_traffic_limit_sta_value(wtpid,l_radioid,wlanid,mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],value,issend);
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}
DBusMessage * wid_dbus_interface_set_radio_wlan_traffic_limit_cancel_sta_send_value(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	unsigned int radioid;
	unsigned int l_radioid;
	unsigned int wtpid;
	unsigned char wlanid;
	unsigned char cancel_flag = 0;
	unsigned char mac[MAC_LEN];
	unsigned int ret = WID_DBUS_SUCCESS;
	unsigned char issend = 1;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,								
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_BYTE,&cancel_flag,
								DBUS_TYPE_BYTE,&mac[0],
								DBUS_TYPE_BYTE,&mac[1],
								DBUS_TYPE_BYTE,&mac[2],
								DBUS_TYPE_BYTE,&mac[3],
								DBUS_TYPE_BYTE,&mac[4],
								DBUS_TYPE_BYTE,&mac[5],
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	wtpid = radioid/L_RADIO_NUM;
	l_radioid = radioid%L_RADIO_NUM;
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret =  WID_WANT_TO_DELETE_WLAN;
	}
	else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
	{
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}
	else 
	{
		struct wlanid *wlan_id = AC_WTP[wtpid]->WTP_Radio[l_radioid]->Wlan_Id;
		while(wlan_id != NULL)
		{	
			if(wlan_id->wlanid == wlanid)
			{
				ret = WID_DBUS_SUCCESS;
				break;
			}
			wlan_id = wlan_id->next;
		}
		if(wlan_id == NULL)
		{
			ret = WTP_IS_NOT_BINDING_WLAN_ID;
		}
		
	}

	if(ret == WID_DBUS_SUCCESS)
	{
		ret = wid_radio_set_wlan_traffic_limit_cancel_sta_value(wtpid,l_radioid,wlanid,mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],cancel_flag,issend);
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}

DBusMessage * wid_dbus_interface_set_radio_wlan_sta_vlanid(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	unsigned int radioid;
	unsigned int l_radioid;
	unsigned int vlanid;
	unsigned int wtpid;
	unsigned char wlanid;
	unsigned char mac[MAC_LEN];
//	unsigned int value;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	dbus_error_init(&err);

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid, 							
								DBUS_TYPE_UINT32,&radioid,
								DBUS_TYPE_UINT32,&vlanid,
								DBUS_TYPE_BYTE,&mac[0],
								DBUS_TYPE_BYTE,&mac[1],
								DBUS_TYPE_BYTE,&mac[2],
								DBUS_TYPE_BYTE,&mac[3],
								DBUS_TYPE_BYTE,&mac[4],
								DBUS_TYPE_BYTE,&mac[5],
								DBUS_TYPE_INVALID))){

		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	wtpid = radioid/L_RADIO_NUM;
	l_radioid = radioid%L_RADIO_NUM;
	
	if(AC_WTP[wtpid] == NULL){
		ret = WTP_ID_NOT_EXIST;
	}else if(AC_RADIO[radioid] == NULL){
		ret = RADIO_ID_NOT_EXIST;
	}else if(AC_WLAN[wlanid] == NULL){
		ret = WLAN_ID_NOT_EXIST;
	}else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0){
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}else {
		wid_set_sta_vlan_id(wtpid,l_radioid,wlanid,mac,vlanid);
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	
	return reply;	
}

#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_radio_wlan_sta_dhcp_before_autherized(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;	
	
	int able = 0;
	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned char wlanid = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	printf("!!!!!!!!!!!\n");
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;	

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&able,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	printf("type= %d,ID= %d,wlanid = %d,able= %d\n",type,ID,wlanid,able);
	if(type==0)
		{
			int wtpid = ID/L_RADIO_NUM;
			int l_radioid = ID%L_RADIO_NUM;
			if(AC_WTP[wtpid] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else if(gWTPs[wtpid].currentState != CW_ENTER_RUN)
				{
					ret = WTP_NOT_IN_RUN_STATE;
				}
			else if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_WLAN[wlanid] == NULL)
				{
					ret = WLAN_ID_NOT_EXIST;
				}
			else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
				{
					ret = WTP_IS_NOT_BINDING_WLAN_ID;
				}
			else 
				{
					wid_set_dhcp_before_autherized(wtpid,l_radioid,wlanid,able);
				}	
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
										if(AC_WTP[tmp->WTPID] == NULL)
											{
												ret2 = WTP_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d id is NOT exist\n",tmp->WTPID);
											}
										else if(gWTPs[tmp->WTPID].currentState != CW_ENTER_RUN)
											{
												ret2 = WTP_NOT_IN_RUN_STATE;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d not in run\n",tmp->WTPID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WLAN[wlanid] == NULL)
											{
												ret2 = WLAN_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"wlan id is NOT exist\n");
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->isBinddingWlan == 0)
											{
												ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is not binding wlan\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else 
											{
												ret2 = wid_set_dhcp_before_autherized(tmp->WTPID,i,wlanid,able);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d access into set dhcp before autherized\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}


										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;

}

#else
DBusMessage * wid_dbus_interface_set_radio_wlan_sta_dhcp_before_autherized(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	int able = 0;
	int radioid = 0;
	unsigned char wlanid = 0;
	
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&able,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	int wtpid = radioid/L_RADIO_NUM;
	int l_radioid = radioid%L_RADIO_NUM;
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(gWTPs[wtpid].currentState != CW_ENTER_RUN)
	{
		ret = WTP_NOT_IN_RUN_STATE;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
	{
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}
	else 
	{
		wid_set_dhcp_before_autherized(wtpid,l_radioid,wlanid,able);
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	
}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_radio_wlan_sta_ip_mac_binding(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;	
	
	int able = 0;
	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned char wlanid = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;	


	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&able,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(type==0)
		{
			int wtpid = ID/L_RADIO_NUM;
			int l_radioid = ID%L_RADIO_NUM;
			if(AC_WTP[wtpid] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_WLAN[wlanid] == NULL)
				{
					ret = WLAN_ID_NOT_EXIST;
				}
			else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
				{
					ret = WTP_IS_NOT_BINDING_WLAN_ID;
				}
			else 
				{
					wid_set_sta_ip_mac_binding(wtpid,l_radioid,wlanid,able);
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
										if(AC_WTP[tmp->WTPID] == NULL)
											{
												ret2 = WTP_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d id is NOT exist\n",tmp->WTPID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WLAN[wlanid] == NULL)
											{
												ret2 = WLAN_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"wlan id is NOT exist\n");
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->isBinddingWlan == 0)
											{
												ret2 = WTP_IS_NOT_BINDING_WLAN_ID;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is not binding wlan\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else 
											{
												ret2 = wid_set_sta_ip_mac_binding(tmp->WTPID,i,wlanid,able);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d access into set sta ip mac binding\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}


										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;

	

}

#else
DBusMessage * wid_dbus_interface_set_radio_wlan_sta_ip_mac_binding(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	int able = 0;
	int radioid = 0;
	unsigned char wlanid = 0;
	
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT32,&able,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	int wtpid = radioid/L_RADIO_NUM;
	int l_radioid = radioid%L_RADIO_NUM;
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else if(AC_WTP[wtpid]->WTP_Radio[l_radioid]->isBinddingWlan == 0)
	{
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}
	else 
	{
		wid_set_sta_ip_mac_binding(wtpid,l_radioid,wlanid,able);
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	
}
#endif
#if _GROUP_POLICY

DBusMessage * wid_dbus_interface_set_radio_sector_value(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;
	
	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int policy = 0;
	unsigned short int sectorid = 0;	
	unsigned int type = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;	

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT16,&sectorid,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type==0)
		{
			int wtpid = ID/L_RADIO_NUM;
			int l_radioid = ID%L_RADIO_NUM;
	
			if(AC_WTP[wtpid] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID]->REFlag == 0)
				{
					ret = RADIO_NOT_SUPPORT_COMMAND;
				}
			else 
				{
					wid_set_radio_sector_value(wtpid,l_radioid,sectorid,policy);
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
										if(AC_WTP[tmp->WTPID] == NULL)
											{
												ret2 = WTP_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d id is NOT exist\n",tmp->WTPID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->REFlag == 0)
											{
												ret2 = RADIO_NOT_SUPPORT_COMMAND;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d NOT support command\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else 
											{
												ret2 = wid_set_radio_sector_value(tmp->WTPID,i,sectorid,policy);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d set radio sector value\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;

	
}

#else
DBusMessage * wid_dbus_interface_set_radio_sector_value(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	unsigned short int sectorid = 0;
	int radioid = 0;
//	unsigned char wlanid = 0;
	unsigned int policy = 0;
	
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,
								DBUS_TYPE_UINT16,&sectorid,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	int wtpid = radioid/L_RADIO_NUM;
	int l_radioid = radioid%L_RADIO_NUM;
	//printf("wtp id is %d;radio id is %d;g_radio id is %d.\n",wtpid,l_radioid,radioid);
	//printf("sectorid111 is %d.\n",sectorid);
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}else if(AC_RADIO[radioid]->REFlag == 0){
		ret = RADIO_NOT_SUPPORT_COMMAND;
	}
	else 
	{
		wid_set_radio_sector_value(wtpid,l_radioid,sectorid,policy);
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	
}
#endif
#if _GROUP_POLICY
/*nl add 20100312*/
DBusMessage * wid_dbus_interface_set_radio_tx_chainmask_value(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;
		
	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int policy = 0;
	unsigned int type = 0;
	unsigned  char tx_chainmaskid = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;	
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&tx_chainmaskid,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(type == 0)
		{
			int wtpid = ID/L_RADIO_NUM;
			int l_radioid = ID%L_RADIO_NUM;
		
			if(AC_WTP[wtpid] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else 
				{	
					wid_set_radio_tx_chainmask_value(wtpid,l_radioid,tx_chainmaskid,policy);
				}
		}

	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
										if(AC_WTP[tmp->WTPID] == NULL)
											{
												ret2 = WTP_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d id is NOT exist\n",tmp->WTPID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else 
											{
												ret2 =wid_set_radio_tx_chainmask_value(tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_L_ID,tx_chainmaskid,policy);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d set radio tx_chainmask value\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}


										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;
}

#else
/*nl add 20100312*/
DBusMessage * wid_dbus_interface_set_radio_tx_chainmask_value(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	unsigned  char tx_chainmaskid = 0;
	int radioid = 0;
//	unsigned char wlanid = 0;
	unsigned int policy = 0;
	
	unsigned int ret = WID_DBUS_SUCCESS;
	
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,
								DBUS_TYPE_BYTE,&tx_chainmaskid,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	int wtpid = radioid/L_RADIO_NUM;
	int l_radioid = radioid%L_RADIO_NUM;
	
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else 
	{	
		wid_set_radio_tx_chainmask_value(wtpid,l_radioid,tx_chainmaskid,policy);
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	
}
#endif
#if 0
DBusMessage * wid_dbus_interface_set_radio_tx_chainmask_value_v2(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	unsigned int radioid = 0;
	unsigned char wlanid = 0;
	unsigned char policy = 0;
	unsigned char chainmask = 0;
	unsigned int ret = WID_DBUS_SUCCESS;
	
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,
								DBUS_TYPE_BYTE,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	int wtpid = radioid/L_RADIO_NUM;
	int l_radioid = radioid%L_RADIO_NUM;
	
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if((AC_RADIO[radioid]->Radio_Type&IEEE80211_11N) != IEEE80211_11N)
	{
		ret = RADIO_MODE_IS_11N;
	}
	else 
	{	
		if(policy == 1)
			chainmask = 1;
		else if(policy == 2)
			chainmask = 3;
		else if(policy == 3)
			chainmask = 5;
		else if(policy == 4)
			chainmask = 7;
		else{} 
		if(AC_RADIO[radioid]->tx_chainmask_state_value != chainmask){
			AC_RADIO[radioid]->tx_chainmask_state_value = chainmask;
			ret = wid_radio_set_tx_chainmask(radioid);
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	
}
#endif
#if _GROUP_POLICY
/* zhangshu add for set chainmask, 2010-10-09 */
DBusMessage * wid_dbus_interface_set_radio_chainmask_value(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;

	int i = 0;

	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int TYPE = 0;

	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	unsigned char chainmask = 0;
	unsigned char type = 0;	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;	

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&TYPE,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_BYTE,&chainmask,
								DBUS_TYPE_BYTE,&type,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(TYPE==0)
		{
			int wtpid = ID/L_RADIO_NUM;			
			
			if(AC_WTP[wtpid] == NULL) {
				ret = WTP_ID_NOT_EXIST;
			}else if(AC_RADIO[ID] == NULL) {
				ret = RADIO_ID_NOT_EXIST;
			}else if((AC_RADIO[ID]->Radio_Type&IEEE80211_11N) != IEEE80211_11N) {
				ret = RADIO_MODE_IS_11N;
			}else {	
				if(type == 1) {
		    		if(AC_RADIO[ID]->tx_chainmask_state_value != chainmask){
		    		    if((AC_RADIO[ID]->chainmask_num == 1) && (chainmask > 1)){
		    			    ret = RADIO_CHAINMASK_NUM_1;
		    			}else if((AC_RADIO[ID]->chainmask_num == 2) && (chainmask > 3)) {
		    			    ret = RADIO_CHAINMASK_NUM_2;
		    			}else {
		    			    AC_RADIO[ID]->tx_chainmask_state_value = chainmask;
		    			    ret = wid_radio_set_chainmask(ID,type);
		    			}
		    		}
				}else {
				    if(AC_RADIO[ID]->rx_chainmask_state_value != chainmask) {
		    			if((AC_RADIO[ID]->chainmask_num == 1) && (chainmask > 1)){
		    			    ret = RADIO_CHAINMASK_NUM_1;
		    			}else if((AC_RADIO[ID]->chainmask_num == 2) && (chainmask > 3)) {
		    			    ret = RADIO_CHAINMASK_NUM_2;
		    			}else {
		    			    AC_RADIO[ID]->rx_chainmask_state_value = chainmask;
		    			    ret = wid_radio_set_chainmask(ID,type);
		    			}
		    		}
				}
			}
		}
	else if(TYPE == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
				
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{

										if(AC_WTP[tmp->WTPID] == NULL)
											{
												ret2 = WTP_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d is not exist\n",tmp->WTPID);
												//printf("222222222222222222\n");
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i] == NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is not exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
												//printf("33333333333333333333333\n");
											}			
										else if((AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_Type&IEEE80211_11N) != IEEE80211_11N)
											{
												ret2 = RADIO_MODE_IS_11N;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d mode is 11N\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else { 
												if(type == 1) {
													if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->tx_chainmask_state_value != chainmask){
														if((AC_WTP[tmp->WTPID]->WTP_Radio[i]->chainmask_num == 1) && (chainmask > 1)){
															ret2 = RADIO_CHAINMASK_NUM_1;
															wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d chainmask_num_1\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
														}else if((AC_WTP[tmp->WTPID]->WTP_Radio[i]->chainmask_num == 2) && (chainmask > 3)) {
															ret2 = RADIO_CHAINMASK_NUM_2;
															wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d chainmask_num_2\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
														}else {
															AC_WTP[tmp->WTPID]->WTP_Radio[i]->tx_chainmask_state_value = chainmask;
															ret2 = wid_radio_set_chainmask(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,type);
															wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d access into set chainmask\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
														}
													}
												}else {
													if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->rx_chainmask_state_value != chainmask) {
														if((AC_WTP[tmp->WTPID]->WTP_Radio[i]->chainmask_num == 1) && (chainmask > 1)){
															ret2 = RADIO_CHAINMASK_NUM_1;
															wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d chainmask_num_1\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
														}else if((AC_WTP[tmp->WTPID]->WTP_Radio[i]->chainmask_num == 2) && (chainmask > 3)) {
															ret2 = RADIO_CHAINMASK_NUM_2;
															wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d chainmask_num_2\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
														}else {
															AC_WTP[tmp->WTPID]->WTP_Radio[i]->rx_chainmask_state_value = chainmask;
															ret2 = wid_radio_set_chainmask(AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID,type);
															wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d access into set chainmask\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
														}
													}
												}
											}
								
										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((TYPE == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;	
}

#else
/* zhangshu add for set chainmask, 2010-10-09 */
DBusMessage * wid_dbus_interface_set_radio_chainmask_value(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	unsigned int radioid = 0;
	unsigned char chainmask = 0;
	unsigned char type = 0;
	unsigned int ret = WID_DBUS_SUCCESS;
	
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,
								DBUS_TYPE_BYTE,&chainmask,
								DBUS_TYPE_BYTE,&type,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	int wtpid = radioid/L_RADIO_NUM;
//	int l_radioid = radioid%L_RADIO_NUM;
	
	
	if(AC_WTP[wtpid] == NULL) {
		ret = WTP_ID_NOT_EXIST;
	}else if(AC_RADIO[radioid] == NULL) {
		ret = RADIO_ID_NOT_EXIST;
	}else if((AC_RADIO[radioid]->Radio_Type&IEEE80211_11N) != IEEE80211_11N) {
		ret = RADIO_MODE_IS_11N;
	}else {	
		if(type == 1) {
    		if(AC_RADIO[radioid]->tx_chainmask_state_value != chainmask){
    		    if((AC_RADIO[radioid]->chainmask_num == 1) && (chainmask > 1)){
    			    ret = RADIO_CHAINMASK_NUM_1;
    			}else if((AC_RADIO[radioid]->chainmask_num == 2) && (chainmask > 3)) {
    			    ret = RADIO_CHAINMASK_NUM_2;
    			}else {
    			    AC_RADIO[radioid]->tx_chainmask_state_value = chainmask;
    			    ret = wid_radio_set_chainmask(radioid,type);
    			}
    		}
		}else {
		    if(AC_RADIO[radioid]->rx_chainmask_state_value != chainmask) {
    			if((AC_RADIO[radioid]->chainmask_num == 1) && (chainmask > 1)){
    			    ret = RADIO_CHAINMASK_NUM_1;
    			}else if((AC_RADIO[radioid]->chainmask_num == 2) && (chainmask > 3)) {
    			    ret = RADIO_CHAINMASK_NUM_2;
    			}else {
    			    AC_RADIO[radioid]->rx_chainmask_state_value = chainmask;
    			    ret = wid_radio_set_chainmask(radioid,type);
    			}
    		}
		}
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	
}
/* zhangshu add for chainmask END */
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_radio_tx_power_sector_value(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;
	
	int s_state = 0;
	int i = 0;
	int j = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned int sectorvalue = 0;
	unsigned short int sectorid = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;	

	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT16,&sectorid,
								DBUS_TYPE_UINT32,&sectorvalue,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(type==0)
		{
			int wtpid = ID/L_RADIO_NUM;
			int l_radioid = ID%L_RADIO_NUM;
	
			for(i=0;i<4;i++)
				{
					s_state += AC_RADIO[ID]->sector[i]->state;
				}
			if(AC_WTP[wtpid] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID]->REFlag == 0)
				{
					ret = RADIO_NOT_SUPPORT_COMMAND;
				}
			else if((sectorid<4)&&(AC_RADIO[ID]->sector[sectorid]->state == 0))
				{
					ret = RADIO_SECTOR_DISABLE;
				}
			else if((sectorid==4)&&(s_state !=4))
				{
					ret = RADIO_SECTOR_DISABLE;
				}
			else 
				{
					wid_set_radio_sector_tx_power_value(wtpid,l_radioid,sectorid,sectorvalue);
				}			
		}

	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
				
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										//printf("wtpid = %d\n",tmp->WTPID);
										//printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
										/*for(j=0;i<4;i++)
											{
												s_state +=AC_WTP[tmp->WTPID]->WTP_Radio[i]->sector[i]->state;
												printf("111111111111111\n");
											}*/
											for(j=0;j<4;j++)
											{
												s_state +=AC_WTP[tmp->WTPID]->WTP_Radio[i]->sector[j]->state;
												//printf("111111111111111\n");
											}
										if(AC_WTP[tmp->WTPID] == NULL)
											{
												ret2 = WTP_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d is not exist\n",tmp->WTPID);
												//printf("222222222222222222\n");
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i] == NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is not exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
												//printf("33333333333333333333333\n");
											}
										
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->REFlag == 0)
											{
											//printf("4444444444444444444\n");
												ret2 = RADIO_NOT_SUPPORT_COMMAND;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d not support command\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										
										else if((sectorid<4)&&(AC_WTP[tmp->WTPID]->WTP_Radio[i]->sector[sectorid]->state == 0))
											{
											//printf("55555555555555555555\n");
												ret2 = RADIO_SECTOR_DISABLE;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d sector disable\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										
										else if((sectorid==4)&&(s_state !=4))
											{
											//printf("666666666666666666666\n");
												ret2 = RADIO_SECTOR_DISABLE;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d sector disable\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										
										else 
											{
											//printf("7777777777777777777777\n");
												ret2 = wid_set_radio_sector_tx_power_value(tmp->WTPID,i,sectorid,sectorvalue);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d access set radio txpower sector value\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}	
								
										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;	

}

#else
DBusMessage * wid_dbus_interface_set_radio_tx_power_sector_value(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	unsigned int sectorvalue = 0;
	unsigned short int sectorid = 0;
	int i = 0;
	int s_state = 0;
	int radioid = 0;
//	unsigned char wlanid = 0;
	
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,
								DBUS_TYPE_UINT16,&sectorid,
								DBUS_TYPE_UINT32,&sectorvalue,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	int wtpid = radioid/L_RADIO_NUM;
	int l_radioid = radioid%L_RADIO_NUM;
	//printf("wtp id is %d;radio id is %d;g_radio id is %d.\n",wtpid,l_radioid,radioid);
	for(i=0;i<4;i++){
		s_state += AC_RADIO[radioid]->sector[i]->state;
	}
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}else if(AC_RADIO[radioid]->REFlag == 0){
		ret = RADIO_NOT_SUPPORT_COMMAND;
	}
	else if((sectorid<4)&&(AC_RADIO[radioid]->sector[sectorid]->state == 0)){
			ret = RADIO_SECTOR_DISABLE;
	}
	else if((sectorid==4)&&(s_state !=4)){
			ret = RADIO_SECTOR_DISABLE;
	}
	else 
	{
		wid_set_radio_sector_tx_power_value(wtpid,l_radioid,sectorid,sectorvalue);
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	
}
#endif
#if _GROUP_POLICY

DBusMessage * wid_dbus_interface_set_radio_supper_g_type_state(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;

	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	unsigned short super_g_type = 0;
	unsigned int super_g_state = 0;	
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT16,&super_g_type,
								DBUS_TYPE_UINT32,&super_g_state,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(type == 0)
		{
			int wtpid = ID/L_RADIO_NUM;
			int l_radioid = ID%L_RADIO_NUM;
			printf("wtp id is %d;radio id is %d;g_radio id is %d.\n",wtpid,l_radioid,ID);

			if(AC_WTP[wtpid] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID] == NULL)
				{
					ret = RADIO_ID_NOT_EXIST;
				}
			else if(AC_RADIO[ID]->REFlag == 0)
				{
					ret = RADIO_NOT_SUPPORT_COMMAND;
				}
			else 
				{
					wid_set_radio_netgear_supper_g_technology_state(wtpid,l_radioid,super_g_type,super_g_state);
				}
	
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
										if(AC_WTP[tmp->WTPID] == NULL)
											{
												ret2 = WTP_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d id is NOT exist\n",tmp->WTPID);
											}
										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]== NULL)
											{
												ret2 = RADIO_ID_NOT_EXIST;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT exist\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}

										else if(AC_WTP[tmp->WTPID]->WTP_Radio[i]->REFlag == 0)
											{
												ret2 = RADIO_NOT_SUPPORT_COMMAND;
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d is NOT support command\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
										else 
											{
												wid_set_radio_netgear_supper_g_technology_state(tmp->WTPID,i,super_g_type,super_g_state);
												wid_syslog_debug_debug(WID_DEFAULT,"WTP%d radio%d set radio supper g_technology_state successful\n",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
											}
								
										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;


}

#else
DBusMessage * wid_dbus_interface_set_radio_supper_g_type_state(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	//unsigned int sectorvalue = 0;
	//unsigned short int sectorid = 0;
	int radioid = 0;
//	unsigned char wlanid = 0;
	unsigned short super_g_type;
	unsigned int super_g_state;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,
								DBUS_TYPE_UINT16,&super_g_type,
								DBUS_TYPE_UINT32,&super_g_state,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	int wtpid = radioid/L_RADIO_NUM;
	int l_radioid = radioid%L_RADIO_NUM;
	printf("wtp id is %d;radio id is %d;g_radio id is %d.\n",wtpid,l_radioid,radioid);
//	printf("sectorvalue is %d.\n",sectorvalue);
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}else if(AC_RADIO[radioid]->REFlag == 0){
		ret = RADIO_NOT_SUPPORT_COMMAND;
	}
	else 
	{
		wid_set_radio_netgear_supper_g_technology_state(wtpid,l_radioid,super_g_type,super_g_state);
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	
}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_ap_dos_def(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;
	int i = 0;
	int num =0 ;
	unsigned int ID = 0;
	unsigned int type = 0;
	int  able = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Wtp_List  *wtp_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,								
								DBUS_TYPE_UINT32,&able,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(type== 0 )
		{
			if(gWTPs[ID].currentState != CW_ENTER_RUN)
				{
					ret = WTP_NOT_IN_RUN_STATE;
				}
			else if(AC_WTP[ID] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else
				{
		
				if(able == 1)
					{
						ret = wid_set_ap_dos_def_enable(ID);
					}
				else
					{
						ret = wid_set_ap_dos_def_disable(ID);
					}

				}
		}

	else if(type == 1){
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
				tmp = WTP_GROUP[ID]->WTP_M;
				wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
				
				while(tmp){
					ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
					
					if(ret_check == WID_DBUS_SUCCESS){
	
						if(AC_WTP[tmp->WTPID]->WTPStat == 5)
							{
								if(able == 1)
									{
										ret2 = wid_set_ap_dos_def_enable(tmp->WTPID);
									
									}
								else
									{
										ret2 = wid_set_ap_dos_def_disable(tmp->WTPID);
							
									}
						
							}
						else {ret2 = WTP_NOT_IN_RUN_STATE; 
							wid_syslog_debug_debug(WID_DEFAULT,"WTP%d NOT RUN\n",tmp->WTPID);}
						if(ret2 != WID_DBUS_SUCCESS){
							wtp_head[num].WtpId = tmp->WTPID;
							wtp_head[num].FailReason = ret2;
							num++;
		
						}
						tmp = tmp->next;
					}
					ret = WID_DBUS_SUCCESS;
				}
			}
				
			else{
				ret = GROUP_ID_NOT_EXIST;
				}
		}

		reply = dbus_message_new_method_return(msg);
	
		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
		if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_UINT32,
												 &num);
			printf("num= %d",num);
			for(i = 0; i < num; i++){
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
													 &(wtp_head[i].WtpId));
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_BYTE,
													 &(wtp_head[i].FailReason));
			}	
			
			if(wtp_head!=NULL){
				WID_FREE(wtp_head);
				wtp_head = NULL;	
			}
		}
		
		return reply;

}

#else
DBusMessage * wid_dbus_interface_set_ap_dos_def(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	int able;
	int wtpid;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,								
								DBUS_TYPE_UINT32,&able,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(gWTPs[wtpid].currentState != CW_ENTER_RUN)
	{
		ret = WTP_NOT_IN_RUN_STATE;
	}
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else
	{
		
		if(able == 1)
		{
			ret = wid_set_ap_dos_def_enable(wtpid);
		}
		else
		{
			ret = wid_set_ap_dos_def_disable(wtpid);
		}

	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	
}
#endif
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_set_ap_igmp_snoop(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	int i = 0;
	int num =0 ;
	unsigned int ID = 0;
	unsigned int type = 0;
	int  able = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Wtp_List  *wtp_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;

	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,								
								DBUS_TYPE_UINT32,&able,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(type==0)
		{
			if(gWTPs[ID].currentState != CW_ENTER_RUN)
				{	
					ret = WTP_NOT_IN_RUN_STATE;
				}
			else if(AC_WTP[ID] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else
				{
		
					if(able == 1)
					{
						ret = wid_set_ap_igmp_snoop_enable(ID);
					}
					else
					{
						ret = wid_set_ap_igmp_snoop_disable(ID);
					}

				}
		}
	
	else if(type == 1){
		printf("******** type == 1 *****\n");
		if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
			tmp = WTP_GROUP[ID]->WTP_M;
			wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
			
			while(tmp){
				ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
				
				if(ret_check == WID_DBUS_SUCCESS){

					if(AC_WTP[tmp->WTPID]->WTPStat == 5)
						{
							if(able == 1)
								{
									ret2 = wid_set_ap_igmp_snoop_enable(tmp->WTPID);
									//printf("1111ret2 =  %d",ret2);
								}
							else
								{
									ret2 = wid_set_ap_igmp_snoop_disable(tmp->WTPID);
									//printf("22222ret2 =  %d",ret2);
								}
					
						}
					else {ret2 = WTP_NOT_IN_RUN_STATE; 
					wid_syslog_debug_debug(WID_DEFAULT,"WTP%d NOT RUN\n",tmp->WTPID);}
					if(ret2 != WID_DBUS_SUCCESS){
						wtp_head[num].WtpId = tmp->WTPID;
						wtp_head[num].FailReason = ret2;
						num++;
						//printf("3333ret2 =  %d",ret2);
					}
					tmp = tmp->next;
				}
				ret = WID_DBUS_SUCCESS;
			}
		}
			
		else{
			ret = GROUP_ID_NOT_EXIST;
			}
	}
		//printf("####ret2 =  %d",ret2);
	reply = dbus_message_new_method_return(msg);

	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &num);
		printf("num= %d",num);
		for(i = 0; i < num; i++){
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_UINT32,
												 &(wtp_head[i].WtpId));
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_BYTE,
												 &(wtp_head[i].FailReason));
		}	
		
		if(wtp_head!=NULL){
			WID_FREE(wtp_head);
			wtp_head = NULL;	
		}
	}
	
	return reply;
}


#else
DBusMessage * wid_dbus_interface_set_ap_igmp_snoop(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	int able;
	int wtpid;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,								
								DBUS_TYPE_UINT32,&able,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(gWTPs[wtpid].currentState != CW_ENTER_RUN)
	{
		ret = WTP_NOT_IN_RUN_STATE;
	}
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else
	{
		
		if(able == 1)
		{
			ret = wid_set_ap_igmp_snoop_enable(wtpid);
		}
		else
		{
			ret = wid_set_ap_igmp_snoop_disable(wtpid);
		}

	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	
}
#endif
DBusMessage * wid_dbus_interface_show_ap_mib_info(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply = NULL;
	DBusError err;
	DBusMessageIter  iter;
	DBusMessageIter  iter_array;
	DBusMessageIter  iter_struct;
	int ret = WID_DBUS_SUCCESS;
	int i = 0;
	unsigned int wtpid = 0;
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	ret = WID_CHECK_ID(WID_WTP_CHECK,wtpid);
	
	if (AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}

	
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 

	if(ret == 0)
	{
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_BYTE,&AC_WTP[wtpid]->mib_info.dos_def_switch); 
		
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_BYTE,&AC_WTP[wtpid]->mib_info.igmp_snoop_switch); 
		/*fengwenchao modify 20120502 for autelan-2917*/
		dbus_message_iter_open_container (&iter,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING  //wlanid
												DBUS_TYPE_BYTE_AS_STRING  //l2_isolation_switch
										DBUS_STRUCT_END_CHAR_AS_STRING,
										&iter_array);		
		for(i=0;i<L_BSS_NUM;i++)
		{
			dbus_message_iter_open_container (&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
																																			
			dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&AC_WTP[wtpid]->mib_info.wlan_l2isolation[i].wlanid); 

			dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&AC_WTP[wtpid]->mib_info.wlan_l2isolation[i].l2_isolation_switch); 

			dbus_message_iter_close_container (&iter_array, &iter_struct);
		}

		dbus_message_iter_close_container (&iter, &iter_array);
		/*fengwenchao modify end*/
	}
	return reply;

}
DBusMessage * wid_dbus_interface_show_ap_cm_statistics(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int wtpid = 0;
	char *cpu_type =NULL;
	char *flash_type =NULL;
	char *mem_type =NULL;
	cpu_type =(char*) WID_MALLOC(WTP_TYPE_DEFAULT_LEN+1);
	if(NULL == cpu_type){
		return NULL;
	}
	flash_type =(char*) WID_MALLOC(WTP_TYPE_DEFAULT_LEN+1);
	if(NULL == flash_type){
		CW_FREE_OBJECT_WID(cpu_type);
		return NULL;
	}
	mem_type =(char*) WID_MALLOC(WTP_TYPE_DEFAULT_LEN+1);
	if(NULL == mem_type){
		CW_FREE_OBJECT_WID(cpu_type);
		CW_FREE_OBJECT_WID(mem_type);
		return NULL;
	}
	memset(cpu_type,0,WTP_TYPE_DEFAULT_LEN+1);
	memset(flash_type,0,WTP_TYPE_DEFAULT_LEN+1);
	memset(mem_type,0,WTP_TYPE_DEFAULT_LEN+1);
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		WID_FREE(cpu_type);
		cpu_type = NULL;
		WID_FREE(flash_type);
		flash_type = NULL;
		WID_FREE(mem_type);
		mem_type = NULL;
		return NULL;
	}
	
	ret = WID_CHECK_ID(WID_WTP_CHECK,wtpid);
		
	if(ret != WID_DBUS_SUCCESS)
	{
		printf("wtp id not correct. \n");
	}
	else if (AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}


	
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 

	if(ret == 0)
	{
		memcpy(cpu_type,AC_WTP[wtpid]->cpuType,WTP_TYPE_DEFAULT_LEN);
		memcpy(flash_type,AC_WTP[wtpid]->flashType,WTP_TYPE_DEFAULT_LEN);
		memcpy(mem_type,AC_WTP[wtpid]->memType,WTP_TYPE_DEFAULT_LEN);
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&AC_WTP[wtpid]->apcminfo.cpu_average); 
		
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&AC_WTP[wtpid]->apcminfo.cpu_peak_value); 
		
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&AC_WTP[wtpid]->apcminfo.cpu_times); 

		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&AC_WTP[wtpid]->apcminfo.mem_average); 

		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&AC_WTP[wtpid]->apcminfo.mem_peak_value); 

		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&AC_WTP[wtpid]->apcminfo.mem_times); 
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_STRING,&cpu_type);
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_STRING,&flash_type);
		//dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&(AC_WTP[wtpid]->flashSize)); 
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_STRING,&mem_type);
		//dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&(AC_WTP[wtpid]->memSize)); 
	}
	WID_FREE(cpu_type);
	cpu_type = NULL;
	WID_FREE(flash_type);
	flash_type = NULL;
	WID_FREE(mem_type);
	mem_type = NULL;
	return reply;

}
DBusMessage * wid_dbus_interface_show_wtp_wifi_snr_info(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int wtpid = 0;
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	ret = WID_CHECK_ID(WID_WTP_CHECK,wtpid);
	
	if(ret != WID_DBUS_SUCCESS)
	{
		printf("wtp id not correct. \n");
	}
	else if (AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if (AC_WTP[wtpid]->wifi_extension_reportswitch == 0)
	{
		ret = SWITCH_IS_DISABLE;
	}
	
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 

	if(ret == 0)
	{
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&AC_WTP[wtpid]->wtp_wifi_snr_stats.ifindex); 
		
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&AC_WTP[wtpid]->wtp_wifi_snr_stats.snr_average); 
		
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&AC_WTP[wtpid]->wtp_wifi_snr_stats.snr_max); 

		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&AC_WTP[wtpid]->wtp_wifi_snr_stats.snr_min); 
	}
	return reply;

}
DBusMessage * wid_dbus_interface_show_ap_max_txpower(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	
	unsigned int wtpid = 0;
	unsigned int txpower = 0;
	
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	ret = WID_CHECK_ID(WID_WTP_CHECK,wtpid);
	
	if(ret != WID_DBUS_SUCCESS)
	{
		printf("wtp id not correct  \n");
	}
	else if (AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if ((AC_WTP[wtpid]->WTPModel == NULL)||(AC_WTP[wtpid]->APCode == NULL))
	{
		ret = MODEL_NO_EXIST;
	}
	else
	{
		int modellen = strlen(AC_WTP[wtpid]->APCode);

		if((AC_WTP[wtpid]->APCode[modellen-1] == 'H')||(AC_RADIO[wtpid*L_RADIO_NUM]->ishighpower == 1))
		{
			txpower = 27;
		}
		else
		{
			txpower = 20;
		}
	}
	
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 

	if(ret == 0)
	{
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_STRING,&AC_WTP[wtpid]->WTPModel); 
		
		dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&txpower); 
	}
	return reply;

}

//ethereal bridge area
DBusMessage *wid_dbus_interface_ebr_add_del_ebr(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage * reply;
	DBusMessageIter	 iter;
	int isAdd;
	char* EBRName;
	unsigned int EBRID;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&isAdd,								
								DBUS_TYPE_UINT32,&EBRID,
								DBUS_TYPE_STRING,&EBRName,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(isAdd)
	{
		if(WID_EBR[EBRID] == NULL)
		{
			ret = WID_ADD_ETHEREAL_BRIDGE(EBRName,EBRID);
		}
		else
		{
			ret = WID_EBR_BE_USED;
		}
	}
	else
	{
		if(WID_EBR[EBRID] == NULL)
		{
			ret = WID_EBR_NOT_EXIST;
		}
		else if(WID_EBR[EBRID]->state == 1)
		{
			ret = WID_EBR_SHOULD_BE_DISABLE;
		}
		else
		{
			ret = WID_DELETE_ETHEREAL_BRIDGE(EBRID);
		}

	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;


}
DBusMessage * wid_dbus_interface_ebr_show_ebr(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage * reply;
	DBusMessageIter	 iter;
	DBusError err;
	DBusMessageIter	 iter_array;		
	int EBRID = 0;
	int ret=WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&EBRID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(WID_EBR[EBRID] == NULL)
	{
		ret = WID_EBR_NOT_EXIST;
	}
	
	int i;
	unsigned int num = 0;
	unsigned int num2 = 0;
	ETHEREAL_BRIDGE *ebr ;
	EBR_IF_LIST *ifi;
	if (ret == 0) {

	  ebr = WID_EBR[EBRID];
	  ifi = ebr->iflist;

	  while(ifi != NULL){
		num++;
		ifi = ifi->ifnext;
	  }
	  
	  ifi = ebr->uplinklist;
	  while(ifi != NULL){
		num2++;
		ifi = ifi->ifnext;
	  }
	}
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	if(ret == 0)
	{
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &(WID_EBR[EBRID]->EBRID));
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_STRING,
										 &(WID_EBR[EBRID]->name));
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(WID_EBR[EBRID]->state));
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(WID_EBR[EBRID]->isolation_policy));

		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(WID_EBR[EBRID]->multicast_isolation_policy));

		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(WID_EBR[EBRID]->sameportswitch));
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(WID_EBR[EBRID]->bridge_ucast_solicit_stat));

		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(WID_EBR[EBRID]->bridge_mcast_solicit_stat));

		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(WID_EBR[EBRID]->multicast_fdb_learn));
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num);
			
		dbus_message_iter_open_container (&iter,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_STRING_AS_STRING
										DBUS_STRUCT_END_CHAR_AS_STRING,
										&iter_array);

		ifi = ebr->iflist;	

		for(i = 0; i < num; i++){			
			DBusMessageIter iter_struct;
				
			dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
				
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_STRING,
						  &(ifi->ifname));

			dbus_message_iter_close_container (&iter_array, &iter_struct);

			ifi = ifi->ifnext;
		}
					
		dbus_message_iter_close_container (&iter, &iter_array);		

		//add uplink interface
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &num2);			
		dbus_message_iter_open_container (&iter,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_STRING_AS_STRING
										DBUS_STRUCT_END_CHAR_AS_STRING,
										&iter_array);

		ifi = ebr->uplinklist;	
		for(i = 0; i < num2; i++){			
			DBusMessageIter iter_struct;
				
			dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);				
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_STRING,
						  &(ifi->ifname));

			dbus_message_iter_close_container (&iter_array, &iter_struct);

			ifi = ifi->ifnext;
		}
					
		dbus_message_iter_close_container (&iter, &iter_array);				
			
	}			
	return reply;	
}
DBusMessage * wid_dbus_interface_show_ebr_list(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;
	dbus_error_init(&err);
	unsigned int num=0;
	int ret = WID_DBUS_SUCCESS;
	int i=0;
	ETHEREAL_BRIDGE *ebr[EBR_NUM];

	while(i<EBR_NUM){
		if(WID_EBR[i] != NULL)
		{
			ebr[num] = WID_EBR[i];
			num++;
		}
		i++;
	}
	if(num == 0)
	{
		ret = WID_EBR_NOT_EXIST;
	}
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	if(ret == WID_DBUS_SUCCESS)
	{	
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &num);
			
		dbus_message_iter_open_container (&iter,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_UINT32_AS_STRING
												DBUS_TYPE_STRING_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
										DBUS_STRUCT_END_CHAR_AS_STRING,
										&iter_array);

		for(i = 0; i < num; i++){			
			DBusMessageIter iter_struct;
				
			dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(ebr[i]->EBRID));
				
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_STRING,
						  &(ebr[i]->name));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(ebr[i]->state));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(ebr[i]->isolation_policy));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(ebr[i]->multicast_isolation_policy));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						DBUS_TYPE_BYTE,
						&(ebr[i]->bridge_ucast_solicit_stat)
						);
			dbus_message_iter_append_basic
						(&iter_struct,
						DBUS_TYPE_BYTE,
						&(ebr[i]->bridge_mcast_solicit_stat)
						);
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(ebr[i]->multicast_fdb_learn));

			dbus_message_iter_close_container (&iter_array, &iter_struct);


		}
					
		dbus_message_iter_close_container (&iter, &iter_array);
	}			
	
	return reply;	
}

DBusMessage * wid_dbus_interface_ebr(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	unsigned int EBRID;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&EBRID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(WID_EBR[EBRID] == NULL)
	{
		ret = WID_EBR_NOT_EXIST;
	}
	reply = dbus_message_new_method_return(msg);
	dbus_message_append_args(reply,
							 DBUS_TYPE_UINT32,&ret,
							 DBUS_TYPE_INVALID);
	return reply;
	
}
DBusMessage * wid_dbus_interface_set_ebr_enable(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	unsigned char state = 0;
	unsigned int ebrid = 0;
	
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&ebrid,
								DBUS_TYPE_BYTE,&state,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if (WID_EBR[ebrid] == NULL)
	{
		ret = WID_EBR_NOT_EXIST;
	}
	else if (WID_EBR[ebrid]->state == state)
	{ 
		ret = WID_DBUS_SUCCESS;
	}
	else
	{
		if(state)
		{
			ret = WID_SET_ETHEREAL_BRIDGE_ENABLE(ebrid);
		}
		else
		{
			ret = WID_SET_ETHEREAL_BRIDGE_DISABLE(ebrid);
		}
	}	
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 

	return reply;

}

DBusMessage * wid_dbus_interface_set_ebr_isolation(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	unsigned char state = 0;
	unsigned int ebrid = 0;
	
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&ebrid,
								DBUS_TYPE_BYTE,&state,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if (WID_EBR[ebrid] == NULL)
	{
		ret = WID_EBR_NOT_EXIST;
	}
	//else if (WID_EBR[ebrid]->state == 1)
	//{ 
	//	ret = WID_EBR_SHOULD_BE_DISABLE;
	//}
	else if (WID_EBR[ebrid]->sameportswitch == 1)
	{ 
		ret = ISOLATION_CONFLICT;
	}
	else if (WID_EBR[ebrid]->isolation_policy == state)
	{ 
		ret = WID_DBUS_SUCCESS;
	}
	else
	{
		ret = wid_set_ebr_isolation(ebrid,state);
	}	
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 

	return reply;

}
DBusMessage * wid_dbus_interface_set_ebr_multicast_isolation(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	unsigned char state = 0;
	unsigned int ebrid = 0;
	
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&ebrid,
								DBUS_TYPE_BYTE,&state,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if (WID_EBR[ebrid] == NULL)
	{
		ret = WID_EBR_NOT_EXIST;
	}
	//else if (WID_EBR[ebrid]->state == 1)
	//{ 
	//	ret = WID_EBR_SHOULD_BE_DISABLE;
	//}
	else if (WID_EBR[ebrid]->sameportswitch == 1)
	{ 
		ret = ISOLATION_CONFLICT;
	}
	else if (WID_EBR[ebrid]->multicast_isolation_policy == state)
	{ 
		ret = WID_DBUS_SUCCESS;
	}
	else
	{
		ret = wid_set_ebr_multcast_isolation(ebrid,state);
	}	
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 

	return reply;

}
DBusMessage * wid_dbus_interface_set_ebr_sameportswitch(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	unsigned char state = 0;
	unsigned int ebrid = 0;
	
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&ebrid,
								DBUS_TYPE_BYTE,&state,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if (WID_EBR[ebrid] == NULL)
	{
		ret = WID_EBR_NOT_EXIST;
	}
	//else if (WID_EBR[ebrid]->state == 1)
	//{ 
	//	ret = WID_EBR_SHOULD_BE_DISABLE;
	//}
	else if ((WID_EBR[ebrid]->isolation_policy == 1)||(WID_EBR[ebrid]->multicast_isolation_policy == 1))
	{ 
		ret = ISOLATION_CONFLICT;
	}
	else if (WID_EBR[ebrid]->sameportswitch == state)
	{ 
		ret = WID_DBUS_SUCCESS;
	}
	else
	{
		ret = wid_set_ebr_sameportswitch(ebrid,state);
	}	
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 

	return reply;

}
DBusMessage * wid_dbus_interface_ebr_check_interface(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	unsigned int ebrid = 0;
	
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&ebrid,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if (WID_EBR[ebrid] == NULL)
	{
		ret = WID_EBR_NOT_EXIST;
	}
	else
	{
		int result = 0;
		WTPQUITREASON quitreason = WTP_INIT;
		char brname[ETH_IF_NAME_LEN];
		memset(brname,0,ETH_IF_NAME_LEN);
		
		//check br 
		if(local)
			sprintf(brname,"ebrl%d-%d-%d",slotid,vrrid,ebrid);
		else
			sprintf(brname,"ebr%d-%d-%d",slotid,vrrid,ebrid);
		result = Check_Interface_Exist(brname,&quitreason);
		if(result != 0)
		{
			ret = WID_EBR_ERROR;
		}
	}	
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 

	return reply;

}

DBusMessage * wid_dbus_interface_set_ebr_add_del_if(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	unsigned int ebrid = 0;
	unsigned int isadd = 0;
	char *ifname;
	char name[32];	
	int wtpid = 0;
	int radioid = 0;
	int wlanid = 0;
	int g_radio_id = 0;
//	unsigned char id;
	int is_radio = 0;
	unsigned int vrrid1 = 0;	
//	int slotid1 = 0;
	memset(name, 0, 32);
	//WTPQUITREASON quitreason = WTP_INIT;
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&ebrid,
								DBUS_TYPE_UINT32,&isadd,
								DBUS_TYPE_STRING,&ifname,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	unsigned char ret_flag = 0;
	char *vename;
	vename = (char*)WID_MALLOC(strlen(ifname)+5);
	memset(vename,0,strlen(ifname)+5);
	if(check_ve_interface(ifname,vename)){
		wid_syslog_debug_debug(WID_DBUS,"input ve interface dosen't exist!\n");
		ret = APPLY_IF_FAIL;
		ret_flag = 1;
	}
	wid_syslog_info("interface name is %s",vename);
	if(ret_flag == 0){
	if (WID_EBR[ebrid] == NULL)
	{
		ret = WID_EBR_NOT_EXIST;
	}
	//else if (WID_EBR[ebrid]->state == 1)
	//{
	//	ret = WID_EBR_SHOULD_BE_DISABLE;
	//}
	else
	{
		//ret = Check_Interface_Config(ifname,&quitreason);
		
		if (!strncasecmp(vename,"radio",5)){
			if(parse_radio_ifname(vename+5, &wtpid,&radioid,&wlanid) == 0){
				if(local)
					sprintf(name,"r%d-%d-%d.%d",vrrid,wtpid,radioid,wlanid);
				else
					sprintf(name,"r%d-%d-%d-%d.%d",slotid,vrrid,wtpid,radioid,wlanid);
			}else if(parse_radio_ifname_v2(vename+5, &wtpid,&radioid,&wlanid,&vrrid1) == 0){
				if(local)
					sprintf(name,"r%d-%d-%d.%d",vrrid1,wtpid,radioid,wlanid);
				else
					sprintf(name,"r%d-%d-%d-%d.%d",slotid,vrrid1,wtpid,radioid,wlanid);
			}
			//for add r1-1-1-0.1 in ebr error
			else if(parse_radio_ifname_v2(vename+7, &wtpid,&radioid,&wlanid,&vrrid1) == 0){
				if(local)
					sprintf(name,"r%d-%d-%d.%d",vrrid1,wtpid,radioid,wlanid);
				else
					sprintf(name,"r%d-%d-%d-%d.%d",slotid,vrrid1,wtpid,radioid,wlanid);
			}
			else{
				sprintf(name,"r%s",vename+5);				
			}
			is_radio = 1;
		}else if (!strncasecmp(vename,"r",1)){
			if(parse_radio_ifname(vename+1, &wtpid,&radioid,&wlanid) == 0){
				if(local)
					sprintf(name,"r%d-%d-%d.%d",vrrid,wtpid,radioid,wlanid);
				else
					sprintf(name,"r%d-%d-%d-%d.%d",slotid,vrrid,wtpid,radioid,wlanid);
			}else if(parse_radio_ifname_v2(vename+1, &wtpid,&radioid,&wlanid,&vrrid1) == 0){
				if(local)
					sprintf(name,"r%d-%d-%d.%d",vrrid1,wtpid,radioid,wlanid);
				else
					sprintf(name,"r%d-%d-%d-%d.%d",slotid,vrrid1,wtpid,radioid,wlanid);
			}
			//for add r1-1-1-0.1 in ebr error
			else if(parse_radio_ifname_v2(vename+3, &wtpid,&radioid,&wlanid,&vrrid1) == 0){
				if(local)
					sprintf(name,"r%d-%d-%d.%d",vrrid1,wtpid,radioid,wlanid);
				else
					sprintf(name,"r%d-%d-%d-%d.%d",slotid,vrrid1,wtpid,radioid,wlanid);
			}
			else{
				sprintf(name,"%s",vename);
			}
			is_radio = 1;
		}
		else{
			memcpy(name,vename,strlen(vename));
		}
		if (is_radio == 1)
		{
			if (AC_WLAN[wlanid] == NULL)
			{
				ret = WLAN_ID_NOT_EXIST;
			}
			else if (AC_WLAN[wlanid]->want_to_delete == 1)	/* hll add for AXSSZFI-1742 */
			{
				ret = WID_WANT_TO_DELETE_WLAN;
			}
		}
		if(ret == WID_DBUS_SUCCESS)
		{
			g_radio_id = wtpid*L_RADIO_NUM+radioid;
			if(isadd)
			{
				ret = WID_SET_ETHEREAL_BRIDGE_IF_UPLINK(ebrid,name,is_radio,g_radio_id,wlanid);
			}
			else
			{
				ret = WID_SET_ETHEREAL_BRIDGE_IF_DOWNLINK(ebrid,name,is_radio,g_radio_id,wlanid);
			}
		}
	}
	}
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 
	WID_FREE(vename);
	vename = NULL;
	return reply;

}

DBusMessage * wid_dbus_interface_set_ebr_multicast_fdb_learn(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	unsigned char state = 0;
	unsigned int ebrid = 0;
	
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&ebrid,
								DBUS_TYPE_BYTE,&state,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if (WID_EBR[ebrid] == NULL)
	{
		ret = WID_EBR_NOT_EXIST;
	}
	else if (WID_EBR[ebrid]->multicast_fdb_learn == state)
	{ 
		ret = WID_DBUS_SUCCESS;
	}
	else
	{
		ret = wid_set_ebr_multicast_fdb_learn(ebrid,state);
	}	
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 

	return reply;

}
//////////////////////////////////////////////////////////
//very bad try to fix liuzhenhua 2010-7-7

/*zhaoruijia,20101013,add all the radio infomation of wlan display,start*/
DBusMessage *wid_dbus_interface_show_wlan_radio_information(DBusConnection *conn, DBusMessage *msg, void *user_data){

    DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusMessageIter iter_struct;
//	DBusMessageIter iter_sub_array;
//	DBusMessageIter iter_sub_struct;

	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
//    unsigned int wtp_num = 0;
	int i = 0,j = 0,k = 0;
	int ii = 0;
	unsigned int wtpid = 0;
	unsigned char radio_l_id = 0;
    unsigned char wlanId = 0;
    unsigned int wlan_num = 0;

	for(j=0;j<WLAN_NUM;j++){
		if(AC_WLAN[j]!=NULL && (AC_WLAN[j]->want_to_delete != 1)){		/* Huangleilei add for ASXXZFI-1622 */
				 wlan_num++;
				}
	}

	if(wlan_num == 0){
		ret = WLAN_ID_NOT_EXIST;
	}

	
	    reply = dbus_message_new_method_return(msg);
			
		dbus_message_iter_init_append (reply, &iter);
			
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &ret);
		// Total slot count
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &wlan_num);


		dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
	                                     DBUS_TYPE_UINT32_AS_STRING		//rx_rate
										 DBUS_TYPE_UINT32_AS_STRING      //tx_rate
										 DBUS_TYPE_BYTE_AS_STRING      //wlan_id
                                    DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);
		for(i=0;i<WLAN_NUM;i++){
            if(AC_WLAN[i]!=NULL){
				   unsigned int rx_rate = 0;
				   unsigned int tx_rate = 0;
				   wlanId = AC_WLAN[i]->WlanID;
                   for(j = 0; j < WTP_NUM; j++){
				   	  if(AC_WTP[j] != NULL){
	                       wtpid = j;
	                       for(k=0;k<L_RADIO_NUM;k++){
	                          
							    if(AC_WTP[j]->WTP_Radio[k] != NULL){

									radio_l_id = AC_WTP[j]->WTP_Radio[k]->Radio_L_ID;
									
	                                if(check_radio_bind_wlan(wtpid,radio_l_id,wlanId)){
                                      for(ii = 0; ii< TOTAL_AP_IF_NUM; ii++){
                                         if((2 ==AC_WTP[j]->apstatsinfo[ii].type)&& //wifi --2
											(radio_l_id == AC_WTP[j]->apstatsinfo[ii].wlanId)){ //  Because ap report wlanid equivalent to radio_l_id  in the wifi

											  rx_rate += AC_WTP[j]->apstatsinfo[ii].rx_rate;//radio base wlan downlink rate
											  tx_rate += AC_WTP[j]->apstatsinfo[ii].tx_rate;//radio base wlan uplink rate
										     
										}

										
									  }
							        }
                                 }
	                        }
	                   }
	                 }
              dbus_message_iter_open_container(&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
			  dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_UINT32,&rx_rate);
			  dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_UINT32,&tx_rate);
			  dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&wlanId);
			  dbus_message_iter_close_container(&iter_array,&iter_struct);
       }

    }
   	dbus_message_iter_close_container(&iter,&iter_array);
	return reply;
}
/*zhaoruijia,20101013,add all the radio infomation of wlan display,end*/

DBusMessage *wid_dbus_interface_show_conflict_wtp_list(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
    DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusMessageIter iter_struct;
	DBusMessageIter iter_sub_array;
	DBusMessageIter iter_sub_struct;

	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
    unsigned int conflict_wtp_num = 0;
	unsigned int list_len = 0;
	int wtpid = 0;
	char mac[MAC_LEN];
	struct ConflictWtp *tmp_node = NULL;
	struct conflict_wtp_info *list = NULL;
	list = allif.wtp_list;
	list_len = allif.list_len;
    reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &list_len);
	wid_syslog_info("%s,%d,list_len=%d.\n",__func__,__LINE__,list_len);

	dbus_message_iter_open_container (&iter,
								DBUS_TYPE_ARRAY,
								DBUS_STRUCT_BEGIN_CHAR_AS_STRING
                                     DBUS_TYPE_BYTE_AS_STRING
                                     DBUS_TYPE_BYTE_AS_STRING
                                     DBUS_TYPE_BYTE_AS_STRING
                                     DBUS_TYPE_BYTE_AS_STRING
                                     DBUS_TYPE_BYTE_AS_STRING
                                     DBUS_TYPE_BYTE_AS_STRING
									 DBUS_TYPE_UINT32_AS_STRING 
										DBUS_TYPE_ARRAY_AS_STRING
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
										DBUS_STRUCT_END_CHAR_AS_STRING
                                DBUS_STRUCT_END_CHAR_AS_STRING,
								&iter_array);
	//for(i=0;i<list_len;i++){
	list = allif.wtp_list;
    while(list != NULL){
			memset(mac,0,MAC_LEN);
			memcpy(mac,list->wtpmac,MAC_LEN);
			conflict_wtp_num = list->conf_num;
			wid_syslog_debug_debug(WID_DBUS,"%s,%d,conflict_wtp_num=%d.\n",__func__,__LINE__,conflict_wtp_num);
			dbus_message_iter_open_container(&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
			
			dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&mac[0]);
			dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&mac[1]);
			dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&mac[2]);
			dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&mac[3]);
			dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&mac[4]);
			dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_BYTE,&mac[5]);
			dbus_message_iter_append_basic (&iter_struct,DBUS_TYPE_UINT32,&conflict_wtp_num);
			wid_syslog_debug_debug(WID_DBUS,"%s,%d.\n",__func__,__LINE__);
			dbus_message_iter_open_container (&iter_struct,
											DBUS_TYPE_ARRAY,
											DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_UINT32_AS_STRING
											DBUS_STRUCT_END_CHAR_AS_STRING,
											&iter_sub_array);
			printf("%s,%d.\n",__func__,__LINE__);
			wid_syslog_debug_debug(WID_DBUS,"%s,%d.\n",__func__,__LINE__);
			//for(j = 0; j < conflict_wtp_num; j++){	
			
			tmp_node = list->wtpindexInfo;
			while((tmp_node)&&(conflict_wtp_num > 0)){
				conflict_wtp_num --;
				wtpid = tmp_node->wtpindex;
				dbus_message_iter_open_container (&iter_sub_array,
												DBUS_TYPE_STRUCT,
												NULL,
												&iter_sub_struct);
				printf("%s,%d,tmp_node=%p.\n",__func__,__LINE__,tmp_node);
				wid_syslog_debug_debug(WID_DBUS,"%s,%d.\n",__func__,__LINE__);
				dbus_message_iter_append_basic (&iter_sub_struct,
												 DBUS_TYPE_UINT32,
												 &(wtpid));
				printf("%s,%d,%d.\n",__func__,__LINE__,wtpid);
				wid_syslog_debug_debug(WID_DBUS,"%s,%d.\n",__func__,__LINE__);
				wid_syslog_debug_debug(WID_DBUS,"%s,%d,wtpid %d.\n",__func__,__LINE__,wtpid);
				tmp_node = tmp_node->next;
				dbus_message_iter_close_container (&iter_sub_array, &iter_sub_struct);				
							
			}
			wid_syslog_debug_debug(WID_DBUS,"%s,%d.\n",__func__,__LINE__);
			list = list->next;
			dbus_message_iter_close_container(&iter_struct, &iter_sub_array);	
			dbus_message_iter_close_container(&iter_array,&iter_struct);
			
       }
    //}
   	dbus_message_iter_close_container(&iter,&iter_array);
	return reply;
}

int compare_fdbs(const void *_f0, const void *_f1)
{
	const struct fdb_entry *f0 = _f0;
	const struct fdb_entry *f1 = _f1;

	return memcmp(f0->mac_addr, f1->mac_addr, 6);
}
DBusMessage * wid_dbus_interface_show_fdb_summary_detail(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter iter;
	DBusMessageIter iter_fdb_array;
	DBusMessageIter iter_fdb; 
	int ret = WID_DBUS_SUCCESS;
	unsigned int ebrid = 0;	
	unsigned int is_detail=0;
	
	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&ebrid,
								DBUS_TYPE_UINT32,&is_detail,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	//printf("11\n");
	char ebrname[ETH_IF_NAME_LEN];
	memset(ebrname,0,ETH_IF_NAME_LEN);
	WTPQUITREASON quitreason = WTP_INIT;
	
	if(WID_EBR[ebrid]==NULL){
		ret=WID_EBR_NOT_EXIST;
	}
	if(local)
		sprintf(ebrname,"ebrl%d-%d-%d",slotid,vrrid,ebrid);
	else
		sprintf(ebrname,"ebr%d-%d-%d",slotid,vrrid,ebrid);
	ret = Check_Interface_Exist(ebrname,&quitreason);
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 

	if(ret!=WID_DBUS_SUCCESS)
		return reply;
	
	#define CHUNK 512
	int i, n;
	int offset = 0;
	struct fdb_entry *fdb = NULL;
	struct fdb_entry *new_fdb=(struct fdb_entry *)WID_MALLOC((offset + CHUNK) * sizeof(struct fdb_entry));
	

	printf("222\n");
	for(;;) {
		printf("realloc\n");
		fdb=new_fdb;
		if (!fdb) {
			fprintf(stderr, "Out of memory\n");
			break ;
		}
		printf("reading~~\n");
		
		n = br_read_fdb(ebrname, fdb+offset, offset, CHUNK);
		if (n == 0)
			break;

		if (n < 0) {
			fprintf(stderr, "read of forward table failed: %s\n",
				strerror(errno));
			if(fdb){
				WID_FREE(fdb);
				fdb=NULL;
			}
			return reply;
		}
		offset += n;
		new_fdb = realloc(fdb, (offset + CHUNK) * sizeof(struct fdb_entry));
	}
	qsort(fdb, offset, sizeof(struct fdb_entry), compare_fdbs);
	
	dbus_message_iter_append_basic(&iter,DBUS_TYPE_UINT32,&offset);
	//printf("333\n");
	//printf("fdb_count= %d\n",offset);
	if(is_detail && offset>0){
	//	printf("4444\n");
		dbus_message_iter_open_container(&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
										DBUS_TYPE_UINT32_AS_STRING	//port_no
										DBUS_TYPE_BYTE_AS_STRING	//is_local
										DBUS_TYPE_BYTE_AS_STRING	//mac-0
										DBUS_TYPE_BYTE_AS_STRING	//mac-1
										DBUS_TYPE_BYTE_AS_STRING	//mac-2
										DBUS_TYPE_BYTE_AS_STRING	//mac-3
										DBUS_TYPE_BYTE_AS_STRING	//mac-4
										DBUS_TYPE_BYTE_AS_STRING	//mac-5
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_fdb_array);
		for (i = 0; i < offset; i++) {
			const struct fdb_entry *f = fdb + i;
			int port_no=f->port_no;
		//	printf("%.2x:%.2x:%.2x:%.2x:%.2x:%.2x\t",
		 //      f->mac_addr[0], f->mac_addr[1], f->mac_addr[2],
		//       f->mac_addr[3], f->mac_addr[4], f->mac_addr[5]);
			dbus_message_iter_open_container(&iter_fdb_array,DBUS_TYPE_STRUCT,NULL,&iter_fdb);
			dbus_message_iter_append_basic(&iter_fdb,DBUS_TYPE_UINT32,&port_no);
			dbus_message_iter_append_basic(&iter_fdb,DBUS_TYPE_BYTE,&f->is_local);
			dbus_message_iter_append_basic(&iter_fdb,DBUS_TYPE_BYTE,&f->mac_addr[0]);
			dbus_message_iter_append_basic(&iter_fdb,DBUS_TYPE_BYTE,&f->mac_addr[1]);
			dbus_message_iter_append_basic(&iter_fdb,DBUS_TYPE_BYTE,&f->mac_addr[2]);
			dbus_message_iter_append_basic(&iter_fdb,DBUS_TYPE_BYTE,&f->mac_addr[3]);
			dbus_message_iter_append_basic(&iter_fdb,DBUS_TYPE_BYTE,&f->mac_addr[4]);
			dbus_message_iter_append_basic(&iter_fdb,DBUS_TYPE_BYTE,&f->mac_addr[5]);
			
			dbus_message_iter_close_container(&iter_fdb_array,&iter_fdb);
		}
		dbus_message_iter_close_container(&iter,&iter_fdb_array);
	}	
	
	if(fdb){
		WID_FREE(fdb);
		fdb=NULL;
	}
	return reply;

}

DBusMessage * wid_dbus_interface_set_ebr_add_del_uplink(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter  iter;
	int ret = WID_DBUS_SUCCESS;
	unsigned int ebrid = 0;
	unsigned int isadd = 0;
	char *ifname;
	char name[32];	
	int wtpid,radioid,wlanid;
//	unsigned char id;
	unsigned int vrrid1;
	memset(name, 0, 32);

	dbus_error_init(&err);
		
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&ebrid,
								DBUS_TYPE_UINT32,&isadd,
								DBUS_TYPE_STRING,&ifname,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	unsigned char ret_flag = 0;
	char *vename;
	vename = (char*)WID_MALLOC(strlen(ifname)+5);
	memset(vename,0,strlen(ifname)+5);
	if(check_ve_interface(ifname,vename)){
		wid_syslog_debug_debug(WID_DBUS,"intput ve interface dosen't exist!\n");
		ret = APPLY_IF_FAIL;
		ret_flag = 1;
	}
	wid_syslog_info("interface name is %s",vename);
	if(ret_flag == 0){
	if (WID_EBR[ebrid] == NULL)
	{
		ret = WID_EBR_NOT_EXIST;
	}
	else
	{
		//ret = Check_Interface_Config(ifname,&quitreason);
		
		if (!strncasecmp(vename,"radio",5)){
			if(parse_radio_ifname(vename+5, &wtpid,&radioid,&wlanid) == 0){
				if(local)
					sprintf(name,"r%d-%d-%d.%d",vrrid,wtpid,radioid,wlanid);
				else
					sprintf(name,"r%d-%d-%d-%d.%d",slotid,vrrid,wtpid,radioid,wlanid);					
			}else if(parse_radio_ifname_v2(vename+5, &wtpid,&radioid,&wlanid,&vrrid1) == 0){
				if(local)
					sprintf(name,"r%d-%d-%d.%d",vrrid1,wtpid,radioid,wlanid);
				else
					sprintf(name,"r%d-%d-%d-%d.%d",slotid,vrrid1,wtpid,radioid,wlanid);					
			}
			else{
				sprintf(name,"r%s",vename+5);
			}	  
		}else if (!strncasecmp(vename,"r",1)){
			if(parse_radio_ifname(vename+1, &wtpid,&radioid,&wlanid) == 0){
				if(local)
					sprintf(name,"r%d-%d-%d.%d",vrrid,wtpid,radioid,wlanid);
				else
					sprintf(name,"r%d-%d-%d-%d.%d",slotid,vrrid,wtpid,radioid,wlanid);
			}else if(parse_radio_ifname_v2(vename+5, &wtpid,&radioid,&wlanid,&vrrid1) == 0){
				if(local)
					sprintf(name,"r%d-%d-%d.%d",vrrid1,wtpid,radioid,wlanid);
				else
					sprintf(name,"r%d-%d-%d-%d.%d",slotid,vrrid1,wtpid,radioid,wlanid);					
			}
			else{
				sprintf(name,"%s",vename);
			}	  
		}
		else{
			memcpy(name,vename,strlen(vename));
		}
		if(ret == WID_DBUS_SUCCESS)
		{
			if(isadd)
			{
				ret = wid_set_ethereal_bridge_add_uplink(ebrid,name);
			}
			else
			{
				ret = wid_set_ethereal_bridge_del_uplink(ebrid,name);
			}
		}
	}
	}
	reply = dbus_message_new_method_return(msg);
					
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret); 
	WID_FREE(vename);
	vename = NULL;
	
	return reply;
}


DBusMessage *wid_dbus_set_ac_local_hansi_state(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter	 iter;	
	DBusMessageIter	 iter2;	
	DBusMessageIter	 iter_array;	
	DBusMessageIter	 iter_array1;		
	DBusMessageIter	 iter_array2;	
	int vrid;
	int flag;
	int Inst_UNum;
	char * Inst_Uplink[IF_NAME_MAX];
	int Inst_DNum;
	char * Inst_Downlink[IF_NAME_MAX];
	int Inst_GNum;
	char * Inst_Gateway[IF_NAME_MAX];		
	int i;
//	msgq qmsg;	
	int WTPMsgqID;
	CWGetMsgQueue(&WTPMsgqID);
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;	
	dbus_error_init(&err);
//	struct bak_sock *bak = NULL;
//	struct bak_sock *bak2 = NULL;
	wid_syslog_debug_debug(WID_DBUS,"%s\n",__func__);	
	dbus_message_iter_init(msg,&iter);
	dbus_message_iter_get_basic(&iter,&vrid);

	dbus_message_iter_next(&iter);
	dbus_message_iter_get_basic(&iter,&(flag));

	dbus_message_iter_next(&iter);
	dbus_message_iter_get_basic(&iter,&(Inst_UNum));
	
	dbus_message_iter_next(&iter);	
	dbus_message_iter_recurse(&iter,&iter_array);
	for(i = 0; i < Inst_UNum; i++){
		DBusMessageIter iter_struct;
		dbus_message_iter_recurse(&iter_array,&iter_struct);					
		dbus_message_iter_get_basic(&iter_struct,&(Inst_Uplink[i]));				
		dbus_message_iter_next(&iter_array);
	}	
	dbus_message_iter_next(&iter);
	dbus_message_iter_get_basic(&iter,&(Inst_DNum));
	
	dbus_message_iter_next(&iter);	
	dbus_message_iter_recurse(&iter,&iter_array1);
	for(i = 0; i < Inst_DNum; i++){
		DBusMessageIter iter_struct;
		dbus_message_iter_recurse(&iter_array1,&iter_struct);					
		dbus_message_iter_get_basic(&iter_struct,&(Inst_Downlink[i]));				
		dbus_message_iter_next(&iter_array1);
	}	
	dbus_message_iter_next(&iter);
	dbus_message_iter_get_basic(&iter,&(Inst_GNum));
	
	dbus_message_iter_next(&iter);	
	dbus_message_iter_recurse(&iter,&iter_array2);
	for(i = 0; i < Inst_DNum; i++){
		DBusMessageIter iter_struct;
		dbus_message_iter_recurse(&iter_array2,&iter_struct);					
		dbus_message_iter_get_basic(&iter_struct,&(Inst_Gateway[i]));				
		dbus_message_iter_next(&iter_array2);
	}	
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter2);
	
	dbus_message_iter_append_basic (&iter2,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;

}

void reset_mcast_solicit()
{
	int ret = -1;
	
	ret = system("reset_ebr_wlan_mcast.sh &");	
	ret = WEXITSTATUS(ret);
	if(0 != ret)
	{
		wid_syslog_debug_debug(WID_DBUS,"set ebr mcast_solicit error \n");
	}
	wid_syslog_debug_debug(WID_DBUS,"in line %d func %s ~~~~~~~~ret is %d\n",__LINE__,__func__,ret);

}


DBusMessage *wid_dbus_set_ac_as_secondary(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter	 iter;	
	DBusMessageIter	 iter2;	
	DBusMessageIter	 iter_array;	
	DBusMessageIter	 iter_array1;	
	int flag,vrid,*master_uplinkip,*master_downlinkip,*bak_uplinkip,*bak_downlinkip,*vir_uplinkip,*vir_downlinkip,global_ht_ip,global_ht_opposite_ip;
	int uplink_cnt, downlink_cnt;
	char **vir_uplinkname;
	char **vir_downlinkname;
	char *global_ht_ifname;	
	int WTPID = 0;
	int i = 0;
	msgq qmsg;	
	int WTPMsgqID;
	CWGetMsgQueue(&WTPMsgqID);
	unsigned int ret = WID_DBUS_SUCCESS;
	//qiuchen add it for AXSSZFI-1191
	char master_to_disable = 0;
	//end
	DBusError err;	
	dbus_error_init(&err);
	struct bak_sock *bak = NULL;
	struct bak_sock *bak2 = NULL;
	wid_syslog_debug_debug(WID_DBUS,"%s\n",__func__);	
#if 0	
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&vrid,
								DBUS_TYPE_UINT32,&flag,
								DBUS_TYPE_UINT32,&master_uplinkip,
								DBUS_TYPE_UINT32,&master_downlinkip,
								DBUS_TYPE_UINT32,&bak_uplinkip,
								DBUS_TYPE_UINT32,&bak_downlinkip,
								DBUS_TYPE_UINT32,&vir_uplinkip,
								DBUS_TYPE_UINT32,&vir_downlinkip,
								DBUS_TYPE_STRING,&vir_uplinkname,
								DBUS_TYPE_STRING,&vir_downlinkname,								
								DBUS_TYPE_STRING,&global_ht_ifname,
								DBUS_TYPE_UINT32,&global_ht_ip,
								DBUS_TYPE_UINT32,&global_ht_opposite_ip,
								DBUS_TYPE_INVALID))){

				
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return NULL;
	}
#endif	
	dbus_message_iter_init(msg,&iter);
	dbus_message_iter_get_basic(&iter,&vrid);

	dbus_message_iter_next(&iter);
	dbus_message_iter_get_basic(&iter,&(flag));

	dbus_message_iter_next(&iter);
	dbus_message_iter_get_basic(&iter,&(uplink_cnt));
	master_uplinkip = NULL;
	bak_uplinkip = NULL;
	vir_uplinkip = NULL;
	vir_uplinkname = NULL;
	if(uplink_cnt > 0){
		master_uplinkip = (int *)WID_MALLOC(uplink_cnt*(sizeof(int)));
		bak_uplinkip  = (int *)WID_MALLOC(uplink_cnt*(sizeof(int)));
		vir_uplinkip = (int *)WID_MALLOC(uplink_cnt*(sizeof(int)));
		vir_uplinkname = WID_MALLOC(uplink_cnt*(sizeof(char*)));
	}
	
	dbus_message_iter_next(&iter);	
	dbus_message_iter_recurse(&iter,&iter_array);
	for(i = 0; i < uplink_cnt; i++){
		DBusMessageIter iter_struct;
		dbus_message_iter_recurse(&iter_array,&iter_struct);					
		dbus_message_iter_get_basic(&iter_struct,&master_uplinkip[i]);
		dbus_message_iter_next(&iter_struct);
		dbus_message_iter_get_basic(&iter_struct,&bak_uplinkip[i]);
		dbus_message_iter_next(&iter_struct);
		dbus_message_iter_get_basic(&iter_struct,&vir_uplinkip[i]);
		dbus_message_iter_next(&iter_struct);
		dbus_message_iter_get_basic(&iter_struct,&(vir_uplinkname[i]));				
		dbus_message_iter_next(&iter_array);
	}	
	dbus_message_iter_next(&iter);
	dbus_message_iter_get_basic(&iter,&(downlink_cnt));
	master_downlinkip = NULL;
	bak_downlinkip = NULL;
	vir_downlinkip = NULL;
	vir_downlinkname = NULL;
	if(downlink_cnt > 0){
		master_downlinkip = (int *)WID_MALLOC(downlink_cnt*(sizeof(int)));
		bak_downlinkip  = (int *)WID_MALLOC(downlink_cnt*(sizeof(int)));
		vir_downlinkip = (int *)WID_MALLOC(downlink_cnt*(sizeof(int)));
		vir_downlinkname = WID_MALLOC(downlink_cnt*(sizeof(char*)));
	}
	
	dbus_message_iter_next(&iter);	
	dbus_message_iter_recurse(&iter,&iter_array1);
	for(i = 0; i < downlink_cnt; i++){
		DBusMessageIter iter_struct;
		dbus_message_iter_recurse(&iter_array1,&iter_struct);					
		dbus_message_iter_get_basic(&iter_struct,&master_downlinkip[i]);
		dbus_message_iter_next(&iter_struct);
		dbus_message_iter_get_basic(&iter_struct,&bak_downlinkip[i]);
		dbus_message_iter_next(&iter_struct);
		dbus_message_iter_get_basic(&iter_struct,&vir_downlinkip[i]);
		dbus_message_iter_next(&iter_struct);
		dbus_message_iter_get_basic(&iter_struct,&(vir_downlinkname[i]));				
		dbus_message_iter_next(&iter_array1);
	}	
	
	dbus_message_iter_next(&iter);
	dbus_message_iter_get_basic(&iter,&(global_ht_ifname));

	dbus_message_iter_next(&iter);
	dbus_message_iter_get_basic(&iter,&(global_ht_ip));

	dbus_message_iter_next(&iter);
	dbus_message_iter_get_basic(&iter,&(global_ht_opposite_ip));

	//printf("ip %x\n",global_ht_opposite_ip);
	//printf("state %d\n",flag);
	//printf("name %s\n",vir_downlinkname);
	for(i=0;i<uplink_cnt;i++)
	{
		wid_syslog_debug_debug(WID_DBUS,"master_uplinkip %x\n",master_uplinkip[i]);	
		wid_syslog_debug_debug(WID_DBUS,"bak_uplinkip %x\n",bak_uplinkip[i]);	
		wid_syslog_debug_debug(WID_DBUS,"vir_uplinkip %x\n",vir_uplinkip[i]);	
		wid_syslog_debug_debug(WID_DBUS,"vir_uplinkname %s\n",vir_uplinkname[i]);	
	}

	for(i=0;i<downlink_cnt;i++)
	{
		wid_syslog_debug_debug(WID_DBUS,"master_downlinkip %x\n",master_downlinkip[i]);	
		wid_syslog_debug_debug(WID_DBUS,"bak_downlinkip %x\n",bak_downlinkip[i]);	
		wid_syslog_debug_debug(WID_DBUS,"vir_downlinkip %x\n",vir_downlinkip[i]);	
		wid_syslog_debug_debug(WID_DBUS,"vir_downlinkname %s\n",vir_downlinkname[i]);	
	}
	wid_syslog_debug_debug(WID_DBUS,"ip %x\n",global_ht_opposite_ip);
	wid_syslog_debug_debug(WID_DBUS,"state %d\n",flag);
//	wid_syslog_debug_debug(WID_DBUS,"name %s\n",vir_downlinkname[0]);
	vinfo.vrrid = vrid;
	if(uplink_cnt > 0){
		vinfo.master_uplinkip = master_uplinkip[0];
		vinfo.bak_uplinkip = bak_uplinkip[0];
		vinfo.vir_uplinkip = vir_uplinkip[0];
		if(vinfo.vir_uplinkname != NULL){
			WID_FREE(vinfo.vir_uplinkname);
			vinfo.vir_uplinkname = NULL;
		}
		vinfo.vir_uplinkname = WID_MALLOC(strlen(vir_uplinkname[0])+1);
		memset(vinfo.vir_uplinkname, 0, strlen(vir_uplinkname[0])+1);
		memcpy(vinfo.vir_uplinkname,vir_uplinkname[0],strlen(vir_uplinkname[0]));
	}else{
		if(vinfo.vir_uplinkname != NULL){
			WID_FREE(vinfo.vir_uplinkname);
			vinfo.vir_uplinkname = NULL;
		}
		vinfo.vir_uplinkname = WID_MALLOC(1);
		memset(vinfo.vir_uplinkname, 0, 1);
	}
	if(downlink_cnt > 0){
		vinfo.master_downlinkip = master_downlinkip[0];
		vinfo.bak_downlinkip = bak_downlinkip[0];
		vinfo.vir_downlinkip = vir_downlinkip[0];
		if(vinfo.vir_downlinkname != NULL){
			WID_FREE(vinfo.vir_downlinkname);
			vinfo.vir_downlinkname = NULL;
		}
		vinfo.vir_downlinkname = WID_MALLOC(strlen(vir_downlinkname[0])+1);
		memset(vinfo.vir_downlinkname, 0, strlen(vir_downlinkname[0])+1);
		memcpy(vinfo.vir_downlinkname,vir_downlinkname[0],strlen(vir_downlinkname[0]));
	}else{
		if(vinfo.vir_downlinkname != NULL){
			WID_FREE(vinfo.vir_downlinkname);
			vinfo.vir_downlinkname = NULL;
		}
		vinfo.vir_downlinkname = WID_MALLOC(1);
		memset(vinfo.vir_downlinkname, 0, 1);
	}
	vinfo.global_ht_ip = global_ht_ip;
	vinfo.global_ht_opposite_ip = global_ht_opposite_ip;
	if(vinfo.global_ht_ifname != NULL){
		WID_FREE(vinfo.global_ht_ifname);
		vinfo.global_ht_ifname = NULL;
	}
	vinfo.global_ht_ifname = WID_MALLOC(strlen(global_ht_ifname)+1);
	memset(vinfo.global_ht_ifname, 0, strlen(global_ht_ifname)+1);
	memcpy(vinfo.global_ht_ifname,global_ht_ifname,strlen(global_ht_ifname));

	v_mac[0] = 0x00;
	v_mac[1] = 0x00;
	v_mac[2] = 0x5E;
	v_mac[3] = 0x00;
	v_mac[4] = 0x01;
	v_mac[5] = vrid;
	vrrid = vrid;
	if(flag==3){
//		printf("1\n");
		//primary  ac		
		if(is_secondary != 0){
			/* houxx add for ONLINEBUG-1044 */
			reset_mcast_solicit();
			/*fengwenchao add 20120117 for onlinebug-96*/
			if(gwtpstate_mb !=0)
			{
				CWTimerRequest(gwtpstate_mb, NULL, &(gwtpstate_mb_timer), 911, 0);
			}
			/*fengwenchao add end*/
				//pthread_exit((void *) &ASD_BAK);
			CWThreadMutexLock(&MasterBak);	
			CWTimerCancel(&bak_check_timer,1);
			bak = bak_list;
			while(bak != NULL){
				bak2 = bak->next;
		#ifndef _AC_BAK_UDP_
				close(bak->sock);
		#endif
				WID_FREE(bak);
				bak = bak2;
			}
			CWThreadMutexUnlock(&MasterBak);
			bak_list = NULL;
			is_secondary=0;	
			UpdateWifiHansiState();
			vinfo.state = 0;
			pthread_attr_t attr;
//			size_t ss;	
			int s = PTHREAD_CREATE_DETACHED;
			pthread_attr_init(&attr);
			pthread_attr_setdetachstate(&attr,s);
			if(pthread_create(&WID_MASTER, &attr, wid_master_thread, NULL) != 0) {
				return NULL;
			}
			if(downlink_cnt > 0)
				WIDBAKInfoToASD(is_secondary,(struct sockaddr_in *)&M_addr,global_ht_opposite_ip,vrid,vir_downlinkname[0],WID_ADD);
			else
				WIDBAKInfoToASD(is_secondary,(struct sockaddr_in *)&M_addr,global_ht_opposite_ip,vrid,"NONE",WID_ADD);
				
			if((set_vmac_state == 1)&&(set_vmac == 0)){
				set_wid_mac(v_mac,1);
				set_vmac = 1;
			}
			AC_SYNCHRONIZE_WSM_TABLE_INFO();
		}	
	}
	else if(flag==99){
		//primary  ac	
		
//		printf("2\n");

		if(is_secondary == 1){
		}		
		/*fengwenchao add 20120117 for onlinebug-96*/
		CWTimerCancel(&(gwtpstate_mb_timer), 1);
		/*fengwenchao add end*/

		//qiuchen add it for AXSSZIF-1191
		if(is_secondary == 0){
			master_to_disable = 1;
		}
		//end
		is_secondary=2;			
		vinfo.state = 2;
		UpdateWifiHansiState();
		for(WTPID=1;WTPID<WTP_NUM;WTPID++){
			if((AC_WTP[WTPID]!=NULL)&&(AC_WTP[WTPID]->WTPStat != 7))
			{		
					AC_WTP[WTPID]->master_to_disable = master_to_disable;//qiuchen add it
					gWTPs[WTPID].isRequestClose = CW_TRUE;	
					syslog_wtp_log(WTPID, 0, "Critical Timer Expired", 0);
					if(gWIDLOGHN & 0x01)
						syslog_wtp_log_hn(WTPID,0,6);
					if(gWIDLOGHN & 0x02)
						wid_syslog_auteview(LOG_WARNING,AP_DOWN,AC_WTP[WTPID],4);
					memset((char*)&qmsg, 0, sizeof(qmsg));
					qmsg.mqid = WTPID%THREAD_NUM+1;
					qmsg.mqinfo.WTPID = WTPID;
					qmsg.mqinfo.type = CONTROL_TYPE;
					qmsg.mqinfo.subtype = WTP_S_TYPE;
					qmsg.mqinfo.u.WtpInfo.Wtp_Op = WTP_REBOOT;
					qmsg.mqinfo.u.WtpInfo.WTPID = WTPID;
					if (msgsnd(WTPMsgqID, (msgq *)&qmsg, sizeof(qmsg.mqinfo), 0) == -1){
						wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
						perror("msgsnd");
					}
				}
		
		}
		CWThreadMutexLock(&MasterBak);
		CWTimerCancel(&bak_check_timer,1);
		bak = bak_list;
		while(bak != NULL){
			bak2 = bak->next;
#ifndef _AC_BAK_UDP_
			close(bak->sock);
#endif
			WID_FREE(bak);
			bak = bak2;
		}
		bak_list = NULL;
		CWThreadMutexUnlock(&MasterBak);
		if(downlink_cnt > 0)
			WIDBAKInfoToASD(is_secondary,(struct sockaddr_in *)&M_addr,global_ht_opposite_ip,vrid,vir_downlinkname[0],WID_ADD);
		else
			WIDBAKInfoToASD(is_secondary,(struct sockaddr_in *)&M_addr,global_ht_opposite_ip,vrid,"NONE",WID_ADD);
		if(set_vmac_state == 1)			
			set_wid_src_mac();

		
		wid_syslog_info("####%s####goto disable and reset lic######## glicensecount = %d.\n",__func__,glicensecount);
		CWThreadMutexLock(&ACLicense);
		CWWIDReInit();
		CWThreadMutexUnlock(&ACLicense);
	}else if(flag==2){
		//secondary  ac
		
//		printf("3\n");
		if(is_secondary != 1){
			/*fengwenchao add 20120117 for onlinebug-96*/
			CWTimerCancel(&(gwtpstate_mb_timer ), 1);
			/*fengwenchao add end*/
			is_secondary = 1;			
			vinfo.state = 1;
			UpdateWifiHansiState();
			for(WTPID=1;WTPID<WTP_NUM;WTPID++){
				if((AC_WTP[WTPID]!=NULL)&&(AC_WTP[WTPID]->WTPStat != 7))
				{
						gWTPs[WTPID].isRequestClose = CW_TRUE;	
						syslog_wtp_log(WTPID, 0, "Critical Timer Expired", 0);
						if(gWIDLOGHN & 0x01)
							syslog_wtp_log_hn(WTPID,0,6);
						if(gWIDLOGHN & 0x02)
							wid_syslog_auteview(LOG_WARNING,AP_DOWN,AC_WTP[WTPID],4);
						memset((char*)&qmsg, 0, sizeof(qmsg));
						qmsg.mqid = WTPID%THREAD_NUM+1;
						qmsg.mqinfo.WTPID = WTPID;
						qmsg.mqinfo.type = CONTROL_TYPE;
						qmsg.mqinfo.subtype = WTP_S_TYPE;
						qmsg.mqinfo.u.WtpInfo.Wtp_Op = WTP_REBOOT;
						qmsg.mqinfo.u.WtpInfo.WTPID = WTPID;
						if (msgsnd(WTPMsgqID, (msgq *)&qmsg, sizeof(qmsg.mqinfo), 0) == -1){
							wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
							perror("msgsnd");
						}
					}

			}
			/*if(WID_BAK == 0)*/{
				
				bak = bak_list;
				while(bak != NULL){
					bak2 = bak->next;
#ifndef _AC_BAK_UDP_
					close(bak->sock);
#endif
					WID_FREE(bak);
					bak = bak2;
				}
				bak_list = NULL;
				pthread_attr_t attr;
//				size_t ss;	
				int s = PTHREAD_CREATE_DETACHED;	
				struct sockaddr_in *inaddr = (struct sockaddr_in *)&M_addr;
				inaddr->sin_family = AF_INET;	
				inaddr->sin_port = htons(WID_BAK_AC_PORT+ local*MAX_INSTANCE+vrrid);
				//memcpy(&M_addr.sin_addr.s_addr,&global_ht_opposite_ip,sizeof(int));				
				inaddr->sin_addr.s_addr = global_ht_opposite_ip;	
				memset(inaddr->sin_zero, '\0', sizeof(inaddr->sin_zero));
				if(downlink_cnt > 0){
					WIDBAKInfoToASD(is_secondary,(struct sockaddr_in *)&M_addr,global_ht_opposite_ip,vrid,vir_downlinkname[0],WID_ADD);
					//GetBakIFInfo(vir_downlinkname[0],vir_downlinkip[0]);
				}
				else
					WIDBAKInfoToASD(is_secondary,(struct sockaddr_in *)&M_addr,global_ht_opposite_ip,vrid,"NONE",WID_ADD);
					
				pthread_attr_init(&attr);
				pthread_attr_setdetachstate(&attr,s);
				if(pthread_create(&WID_BAK, &attr, wid_bak_thread, NULL) != 0) {
					return NULL;
				}				
				if((set_vmac_state == 1)&&(set_vmac == 0)){
					set_wid_mac(v_mac,1);
					set_vmac = 1;
				}
			}
		}
	}	
//	AsdCMDInfoToWID(0,&is_secondary,1,2);
/*	{
		// add your  code here.
		printf("is_secondary %d----0/1--primary/secondary\n",is_secondary);
	}
*/	
	if(uplink_cnt > 0){
		WID_FREE(master_uplinkip);
		master_uplinkip = NULL;
		WID_FREE(bak_uplinkip);
		bak_uplinkip  = NULL;
		WID_FREE(vir_uplinkip);
		vir_uplinkip = NULL;
		WID_FREE(vir_uplinkname);
		vir_uplinkname = NULL;
	}

	if(downlink_cnt > 0){
		WID_FREE(master_downlinkip);
		master_downlinkip = NULL;
		WID_FREE(bak_downlinkip);
		bak_downlinkip  = NULL;
		WID_FREE(vir_downlinkip);
		vir_downlinkip = NULL;
		WID_FREE(vir_downlinkname);
		vir_downlinkname = NULL;
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter2);
	
	dbus_message_iter_append_basic (&iter2,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;

}

DBusMessage *wid_dbus_set_local_hansi_state(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter	 iter;	
	DBusMessageIter	 iter2;	
	DBusMessageIter	 iter_array;	
	DBusMessageIter	 iter_array1;	
//	DBusMessageIter	 iter_array2;	
	int flag,vrid;
	int uplink_cnt, downlink_cnt, gateway_cnt;
	char **vir_uplinkname;
	char **vir_downlinkname;
	char **vir_gatewayname;
	int WTPID = 0;
	int i = 0;
	msgq qmsg;	
	int WTPMsgqID;
	CWGetMsgQueue(&WTPMsgqID);
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;	
	dbus_error_init(&err);
	struct bak_sock *bak = NULL;
	struct bak_sock *bak2 = NULL;
	wid_syslog_info("%s 1\n",__func__);	
	dbus_message_iter_init(msg,&iter);
	dbus_message_iter_get_basic(&iter,&vrid);

	dbus_message_iter_next(&iter);
	dbus_message_iter_get_basic(&iter,&(flag));

	dbus_message_iter_next(&iter);
	dbus_message_iter_get_basic(&iter,&(neighbor_slotid));

	dbus_message_iter_next(&iter);
	dbus_message_iter_get_basic(&iter,&(uplink_cnt));
	wid_syslog_info("%s2\n",__func__);	
	vir_uplinkname = NULL;
	if(uplink_cnt > 0){
		vir_uplinkname = WID_MALLOC(uplink_cnt*(sizeof(char*)));
	}
	
	dbus_message_iter_next(&iter);	
	dbus_message_iter_recurse(&iter,&iter_array);
	for(i = 0; i < uplink_cnt; i++){
		wid_syslog_info("%s3\n",__func__);	
		DBusMessageIter iter_struct;
		dbus_message_iter_recurse(&iter_array,&iter_struct);					
		dbus_message_iter_get_basic(&iter_struct,&(vir_uplinkname[i]));				
		dbus_message_iter_next(&iter_array);
	}	
	wid_syslog_info("%s4\n",__func__);	
	dbus_message_iter_next(&iter);
	dbus_message_iter_get_basic(&iter,&(downlink_cnt));

	vir_downlinkname = NULL;
	if(downlink_cnt > 0){
		vir_downlinkname = WID_MALLOC(downlink_cnt*(sizeof(char*)));
	}
	
	dbus_message_iter_next(&iter);	
	dbus_message_iter_recurse(&iter,&iter_array1);
	for(i = 0; i < downlink_cnt; i++){
		wid_syslog_info("%s6\n",__func__);	
		DBusMessageIter iter_struct;
		dbus_message_iter_recurse(&iter_array1,&iter_struct);					
		dbus_message_iter_get_basic(&iter_struct,&(vir_downlinkname[i]));				
		dbus_message_iter_next(&iter_array1);
	}	
	dbus_message_iter_next(&iter);
	dbus_message_iter_get_basic(&iter,&(gateway_cnt));
	
	vir_gatewayname = NULL;
	if(gateway_cnt > 0){
		vir_gatewayname = WID_MALLOC(gateway_cnt*(sizeof(char*)));
	}	

	dbus_message_iter_next(&iter);	
	dbus_message_iter_recurse(&iter,&iter_array1);
	for(i = 0; i < gateway_cnt; i++){
		wid_syslog_info("%s7\n",__func__);	
		DBusMessageIter iter_struct;
		dbus_message_iter_recurse(&iter_array1,&iter_struct);					
		dbus_message_iter_get_basic(&iter_struct,&(vir_gatewayname[i]));				
		dbus_message_iter_next(&iter_array1);
	}	


	for(i=0;i<uplink_cnt;i++)
	{
		wid_syslog_info("vir_uplinkname %s\n",vir_uplinkname[i]);	
	}

	for(i=0;i<downlink_cnt;i++)
	{
		wid_syslog_info("vir_downlinkname %s\n",vir_downlinkname[i]);	
	}

	vinfo.vrrid = vrid;
	if(uplink_cnt > 0){
		if(vinfo.vir_uplinkname != NULL){
			WID_FREE(vinfo.vir_uplinkname);
			vinfo.vir_uplinkname = NULL;
		}
		vinfo.vir_uplinkname = WID_MALLOC(strlen(vir_uplinkname[0])+1);
		memset(vinfo.vir_uplinkname, 0, strlen(vir_uplinkname[0])+1);
		memcpy(vinfo.vir_uplinkname,vir_uplinkname[0],strlen(vir_uplinkname[0]));
	}else{
		if(vinfo.vir_uplinkname != NULL){
			WID_FREE(vinfo.vir_uplinkname);
			vinfo.vir_uplinkname = NULL;
		}
		vinfo.vir_uplinkname = WID_MALLOC(1);
		memset(vinfo.vir_uplinkname, 0, 1);
	}
	if(downlink_cnt > 0){
		if(vinfo.vir_downlinkname != NULL){
			WID_FREE(vinfo.vir_downlinkname);
			vinfo.vir_downlinkname = NULL;
		}
		vinfo.vir_downlinkname = WID_MALLOC(strlen(vir_downlinkname[0])+1);
		memset(vinfo.vir_downlinkname, 0, strlen(vir_downlinkname[0])+1);
		memcpy(vinfo.vir_downlinkname,vir_downlinkname[0],strlen(vir_downlinkname[0]));
	}else{
		if(vinfo.vir_downlinkname != NULL){
			WID_FREE(vinfo.vir_downlinkname);
			vinfo.vir_downlinkname = NULL;
		}
		vinfo.vir_downlinkname = WID_MALLOC(1);
		memset(vinfo.vir_downlinkname, 0, 1);
	}

	v_mac[0] = 0x00;
	v_mac[1] = 0x00;
	v_mac[2] = 0x5E;
	v_mac[3] = 0x00;
	v_mac[4] = 0x01;
	v_mac[5] = vrid;
	vrrid = vrid;
	wid_syslog_info("%s8\n",__func__);	
	if(flag==3){
		wid_syslog_info("%s9\n",__func__);	
		if(is_secondary != 0){
			wid_syslog_info("%s10\n",__func__);	
			CWThreadMutexLock(&MasterBak);	
			CWTimerCancel(&bak_check_timer,1);
			bak = bak_list;
			wid_syslog_info("%s11\n",__func__);	
			while(bak != NULL){
				bak2 = bak->next;
				WID_FREE(bak);
				bak = bak2;
			}
			CWThreadMutexUnlock(&MasterBak);
			wid_syslog_info("%s12\n",__func__);	
			bak_list = NULL;
			is_secondary=0;	
			UpdateWifiHansiState();
			vinfo.state = 0;
			wid_syslog_info("%s13\n",__func__);	
			pthread_attr_t attr;
//			size_t ss;	
			int s = PTHREAD_CREATE_DETACHED;
			pthread_attr_init(&attr);
			pthread_attr_setdetachstate(&attr,s);
			wid_syslog_info("%s14\n",__func__);	
			if(pthread_create(&WID_MASTER, &attr, wid_master_thread, NULL) != 0) {
				return NULL;
			}
			wid_syslog_info("%s15\n",__func__);	
			WIDLocalBAKInfoToASD(is_secondary,neighbor_slotid,vrid,WID_ADD);
				
			if((set_vmac_state == 1)&&(set_vmac == 0)){
				set_wid_mac(v_mac,1);
				set_vmac = 1;
			}
			wid_syslog_info("%s16\n",__func__);	
			AC_SYNCHRONIZE_WSM_TABLE_INFO();
			wid_syslog_info("%s17\n",__func__);	
		}	
	}
	else if(flag==99){
		//primary  ac	
		
//		printf("2\n");

		if(is_secondary == 1){
		}		
		is_secondary=2;			
		vinfo.state = 2;
		UpdateWifiHansiState();
		for(WTPID=1;WTPID<WTP_NUM;WTPID++){
			if((AC_WTP[WTPID]!=NULL)&&(AC_WTP[WTPID]->WTPStat != 7))
			{
					gWTPs[WTPID].isRequestClose = CW_TRUE;	
					syslog_wtp_log(WTPID, 0, "Critical Timer Expired", 0);
					if(gWIDLOGHN & 0x01)
						syslog_wtp_log_hn(WTPID,0,6);
					if(gWIDLOGHN & 0x02)
						wid_syslog_auteview(LOG_WARNING,AP_DOWN,AC_WTP[WTPID],4);
					memset((char*)&qmsg, 0, sizeof(qmsg));
					qmsg.mqid = WTPID%THREAD_NUM+1;
					qmsg.mqinfo.WTPID = WTPID;
					qmsg.mqinfo.type = CONTROL_TYPE;
					qmsg.mqinfo.subtype = WTP_S_TYPE;
					qmsg.mqinfo.u.WtpInfo.Wtp_Op = WTP_REBOOT;
					qmsg.mqinfo.u.WtpInfo.WTPID = WTPID;
					if (msgsnd(WTPMsgqID, (msgq *)&qmsg, sizeof(qmsg.mqinfo), 0) == -1){
						wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
						perror("msgsnd");
					}
				}
		
		}
		CWThreadMutexLock(&MasterBak);
		CWTimerCancel(&bak_check_timer,1);
		bak = bak_list;
		while(bak != NULL){
			bak2 = bak->next;
#ifndef _AC_BAK_UDP_
			close(bak->sock);
#endif
			WID_FREE(bak);
			bak = bak2;
		}
		bak_list = NULL;
		CWThreadMutexUnlock(&MasterBak);
		WIDLocalBAKInfoToASD(is_secondary,neighbor_slotid,vrid,WID_ADD);
		if(set_vmac_state == 1)			
			set_wid_src_mac();
		
		wid_syslog_info("########goto disable and reset lic######## glicensecount = %d.\n",glicensecount);
		CWThreadMutexLock(&ACLicense);
		CWWIDReInit();
		CWThreadMutexUnlock(&ACLicense);
	}else if(flag==2){
		//secondary  ac
		
//		printf("3\n");
		if(is_secondary != 1){
			is_secondary = 1;			
			vinfo.state = 1;
			UpdateWifiHansiState();
			for(WTPID=1;WTPID<WTP_NUM;WTPID++){
				if((AC_WTP[WTPID]!=NULL)&&(AC_WTP[WTPID]->WTPStat != 7))
				{
						gWTPs[WTPID].isRequestClose = CW_TRUE;	
						syslog_wtp_log(WTPID, 0, "Critical Timer Expired", 0);
						if(gWIDLOGHN & 0x01)
							syslog_wtp_log_hn(WTPID,0,6);
						if(gWIDLOGHN & 0x02)
							wid_syslog_auteview(LOG_WARNING,AP_DOWN,AC_WTP[WTPID],4);
						memset((char*)&qmsg, 0, sizeof(qmsg));
						qmsg.mqid = WTPID%THREAD_NUM+1;
						qmsg.mqinfo.WTPID = WTPID;
						qmsg.mqinfo.type = CONTROL_TYPE;
						qmsg.mqinfo.subtype = WTP_S_TYPE;
						qmsg.mqinfo.u.WtpInfo.Wtp_Op = WTP_REBOOT;
						qmsg.mqinfo.u.WtpInfo.WTPID = WTPID;
						if (msgsnd(WTPMsgqID, (msgq *)&qmsg, sizeof(qmsg.mqinfo), 0) == -1){
							wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
							perror("msgsnd");
						}
					}

			}
			/*if(WID_BAK == 0)*/{
				
				bak = bak_list;
				while(bak != NULL){
					bak2 = bak->next;
#ifndef _AC_BAK_UDP_
					close(bak->sock);
#endif
					WID_FREE(bak);
					bak = bak2;
				}
				bak_list = NULL;
				pthread_attr_t attr;
//				size_t ss;	
				int s = PTHREAD_CREATE_DETACHED;
				struct sockaddr_tipc *tipcaddr = (struct sockaddr_tipc *)&M_addr;
				tipcaddr->family = AF_TIPC;
				tipcaddr->addrtype = TIPC_ADDR_NAME;
				tipcaddr->addr.name.name.type = SYN_WID_SERVER_TYPE;
				tipcaddr->addr.name.name.instance = SYN_SERVER_BASE_INST + vrrid*MAX_SLOT_NUM + neighbor_slotid;
				tipcaddr->addr.name.domain = 0;				
				WIDLocalBAKInfoToASD(is_secondary,neighbor_slotid,vrid,WID_ADD);
				wid_syslog_info("%s neighbor_slotid %d\n",__func__,neighbor_slotid);
				pthread_attr_init(&attr);
				pthread_attr_setdetachstate(&attr,s);
				if(pthread_create(&WID_BAK, &attr, wid_bak_thread, NULL) != 0) {
					return NULL;
				}				
				if((set_vmac_state == 1)&&(set_vmac == 0)){
					set_wid_mac(v_mac,1);
					set_vmac = 1;
				}
			}
		}
	}	
	if(uplink_cnt > 0){
		WID_FREE(vir_uplinkname);
		vir_uplinkname = NULL;
	}

	if(downlink_cnt > 0){
		WID_FREE(vir_downlinkname);
		vir_downlinkname = NULL;
	}
	if(gateway_cnt > 0){
		WID_FREE(vir_gatewayname);
		vir_gatewayname = NULL;
	}
	
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter2);
	
	dbus_message_iter_append_basic (&iter2,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;

}


DBusMessage *wid_dbus_update_bak_ac_info(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter	 iter;
	DBusError err;	
	dbus_error_init(&err);
	int ret = 0; 
	ret = AC_UPDATE_BAK_AC_WIRELESS_INFO();
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;

}

DBusMessage *wid_dbus_synchronize_wsm_info(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter	 iter;
	DBusError err;	
	dbus_error_init(&err);
	int ret = 0; 
	ret = AC_SYNCHRONIZE_WSM_TABLE_INFO();
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;

}

DBusMessage *wid_dbus_synchronize_asd_info(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter	 iter;
	DBusError err;	
	dbus_error_init(&err);
	int ret = 0; 
	ret = AC_SYNCHRONIZE_ASD_TABLE_INFO();
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;

}

int notice_vrrp_state_change(unsigned int vrrid,unsigned int state)
{	
	int ret;
	DBusMessage *query, *reply;
	DBusError err;
	
	query = dbus_message_new_method_call(VRRP_DBUS_BUSNAME,VRRP_DBUS_OBJPATH,\
						VRRP_DBUS_INTERFACE,VRRP_DBUS_METHOD_SET_TRANSFER_STATE );
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&vrrid,
							 DBUS_TYPE_UINT32,&state,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (wid_dbus_connection2,query,-1, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return 0;
	}
	
	if (dbus_message_get_args ( reply, &err,
					DBUS_TYPE_UINT32,&ret,
					DBUS_TYPE_INVALID)) {
		if(ret == 0){
//			printf("dbus notice vrrp successfull");
		}
	}
	dbus_message_unref(reply);
	return ret;
}

DBusMessage *wid_dbus_notice_vrrp(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter	 iter;
	DBusError err;	
	dbus_error_init(&err);
	int ret = 0; 
	ret = notice_vrrp_state_change(vrrid,0);
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;

}
int notice_hmd_update_state_change(unsigned int vrrid,unsigned int state)
{	
	int ret;
	DBusMessage *query, *reply;
	DBusError err;
	
	wid_syslog_info("%s,%d.\n",__func__,__LINE__);
	query = dbus_message_new_method_call(
				                         HMD_DBUS_BUSNAME,
				                         HMD_DBUS_OBJPATH,
										 HMD_DBUS_INTERFACE,
										 HMD_DBUS_METHOD_WID_NOTIFY_HMD_UPDATE_STATE);
	dbus_error_init(&err);

	dbus_message_append_args(query,
							 DBUS_TYPE_UINT32,&local,
							 DBUS_TYPE_UINT32,&vrrid,
							 DBUS_TYPE_UINT32,&state,
							 DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block (wid_dbus_connection2,query,150000, &err);
	
	dbus_message_unref(query);
	
	if (NULL == reply) {
		wid_syslog_err("%s,%d,fail.\n",__func__,__LINE__);
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return -1;
	}
	
	if (dbus_message_get_args ( reply, &err,
					DBUS_TYPE_UINT32,&ret,
					DBUS_TYPE_INVALID)) {
		if(ret == 0){
		}
	}
	dbus_message_unref(reply);
	wid_syslog_info("%s,%d,succeffull ret:%d.\n",__func__,__LINE__,ret);
	return 0;
}


DBusMessage *wid_dbus_vrrp_info(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	//DBusMessageIter	 iter;
	DBusError err;	
	dbus_error_init(&err);
	int ret = 0; 
	char name[] = "NULL";
	if(vinfo.vir_uplinkname == NULL){
		vinfo.vir_uplinkname = name;
		vinfo.vir_downlinkname = name;
		vinfo.global_ht_ifname = name;
		ret = 1;
	}
	reply = dbus_message_new_method_return(msg);
	dbus_message_append_args(reply,
		DBUS_TYPE_UINT32,&(vinfo.vrrid),
		DBUS_TYPE_UINT32,&(vinfo.state),
		DBUS_TYPE_UINT32,&(vinfo.master_uplinkip),
		DBUS_TYPE_UINT32,&(vinfo.master_downlinkip),
		DBUS_TYPE_UINT32,&(vinfo.bak_uplinkip),
		DBUS_TYPE_UINT32,&(vinfo.bak_downlinkip),
		DBUS_TYPE_UINT32,&(vinfo.vir_uplinkip),
		DBUS_TYPE_UINT32,&(vinfo.vir_downlinkip),
		DBUS_TYPE_STRING,&(vinfo.vir_uplinkname),
		DBUS_TYPE_STRING,&(vinfo.vir_downlinkname), 							
		DBUS_TYPE_STRING,&(vinfo.global_ht_ifname),
		DBUS_TYPE_UINT32,&(vinfo.global_ht_ip),
		DBUS_TYPE_UINT32,&(vinfo.global_ht_opposite_ip),
		DBUS_TYPE_INVALID);
	if(ret == 1){
		vinfo.vir_uplinkname = NULL;
		vinfo.vir_downlinkname = NULL;
		vinfo.global_ht_ifname = NULL;
	}
	return reply;

}

DBusMessage *wid_dbus_interface_update_wtpcompatible(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter	 iter;
	DBusError err;	
	dbus_error_init(&err);
	int ret = 0; 
	CWConfigVersionInfo * VersionInfo = NULL;
	CWConfigVersionInfo * VersionInfo1 = NULL;
	CWParseConfigVersionInfoXML(&VersionInfo);
	
	CWThreadMutexLock(&(gAllThreadMutex));		
	VersionInfo1 = gConfigVersionInfo;
	gConfigVersionInfo = VersionInfo;
	CWDistroyConfigVersionInfoXML(&VersionInfo1);
	
	CWThreadMutexUnlock(&(gAllThreadMutex));		
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;

}


DBusMessage *wid_dbus_add_ac_ip_list_group(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage * reply;
	DBusMessageIter	 iter;
	char* IFName;
	unsigned char ID;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&ID,
								DBUS_TYPE_STRING,&IFName,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	unsigned char ret_flag = 0;
	char *name;
	name = (char *)WID_MALLOC(strlen(IFName)+5);
	memset(name,0,strlen(IFName)+5);
	if(check_ve_interface(IFName,name)){
		wid_syslog_debug_debug(WID_DBUS,"input ve interface dosen't exist!\n");
		ret = APPLY_IF_FAIL;
		ret_flag = 1;
	}
	if(ret_flag == 0){		
	if(AC_IP_GROUP[ID] == NULL){
		CWThreadMutexLock(&ACIPLISTMutex);
		ret = create_ac_ip_list_group(ID,name);
		CWThreadMutexUnlock(&ACIPLISTMutex);
	}else{
		ret = WLAN_ID_BE_USED;
	}
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	WID_FREE(name);
	name = NULL;
	return reply;
	
}
DBusMessage *wid_dbus_del_ac_ip_list_group(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage * reply;
	DBusMessageIter	 iter;
//	char* IFName;
	unsigned char ID;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&ID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(AC_IP_GROUP[ID] != NULL){		
		CWThreadMutexLock(&ACIPLISTMutex);
		ret = delete_ac_ip_list_group(ID);		
		CWThreadMutexUnlock(&ACIPLISTMutex);
	}else{
		ret = WLAN_ID_NOT_EXIST;
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
	
}
DBusMessage *wid_dbus_add_ac_ip(DBusConnection *conn, DBusMessage *msg, void *user_data){	
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;

	unsigned char id = 0;
	unsigned char priority = 0;
	char *ip = NULL;
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&id,
								DBUS_TYPE_STRING,&ip,
								DBUS_TYPE_BYTE,&priority,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}
	
	if(AC_IP_GROUP[id] != NULL){		
		CWThreadMutexLock(&ACIPLISTMutex);
		ret = add_ac_ip(id,ip,priority);		
		CWThreadMutexUnlock(&ACIPLISTMutex);
	}else{
		ret = WLAN_ID_NOT_EXIST;
	}
	/*struct wid_ac_ip *tmp;
	tmp = AC_IP_GROUP[id]->ip_list;
	while(tmp != NULL){
		printf("ip %s,priority %d\n",tmp->ip,tmp->priority);
		tmp = tmp->next;
	}*/
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;


}
DBusMessage *wid_dbus_del_ac_ip(DBusConnection *conn, DBusMessage *msg, void *user_data){	
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;

	unsigned char id = 0;
	char *ip;
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&id,
								DBUS_TYPE_STRING,&ip,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}
	
	if(AC_IP_GROUP[id] != NULL){		
		CWThreadMutexLock(&ACIPLISTMutex);
		ret = delete_ac_ip(id,ip);
		CWThreadMutexUnlock(&ACIPLISTMutex);
	}else{
		ret = WLAN_ID_NOT_EXIST;
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;


}

DBusMessage *wid_dbus_set_ac_ip_priority(DBusConnection *conn, DBusMessage *msg, void *user_data){	
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;

	unsigned char id = 0;
	unsigned char priority = 0;
	char *ip = NULL;
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&id,
								DBUS_TYPE_STRING,&ip,
								DBUS_TYPE_BYTE,&priority,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}
	
	if(AC_IP_GROUP[id] != NULL){		
		CWThreadMutexLock(&ACIPLISTMutex);
		ret = set_ac_ip_priority(id,ip,priority);		
		CWThreadMutexUnlock(&ACIPLISTMutex);
	}else{
		ret = WLAN_ID_NOT_EXIST;
	}
	/*struct wid_ac_ip *tmp;
	tmp = AC_IP_GROUP[id]->ip_list;
	while(tmp != NULL){
		printf("ip %s,priority %d\n",tmp->ip,tmp->priority);
		tmp = tmp->next;
	}*/
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;


}

DBusMessage *wid_dbus_set_ac_ip_load_banlance(DBusConnection *conn, DBusMessage *msg, void *user_data){	
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;

	unsigned char id = 0;
	unsigned char load_banlance = 0;
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&id,
								DBUS_TYPE_BYTE,&load_banlance,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}
	
	if(AC_IP_GROUP[id] != NULL){		
		CWThreadMutexLock(&ACIPLISTMutex);
		ret = set_ac_ip_load_banlance(id,load_banlance);		
		CWThreadMutexUnlock(&ACIPLISTMutex);
	}else{
		ret = WLAN_ID_NOT_EXIST;
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;


}

DBusMessage *wid_dbus_set_ac_ip_diff_banlance(DBusConnection *conn, DBusMessage *msg, void *user_data){	
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;

	unsigned char id = 0;
	unsigned int diff_banlance = 0;
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&id,
								DBUS_TYPE_UINT32,&diff_banlance,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}
	
	if(AC_IP_GROUP[id] != NULL){		
		CWThreadMutexLock(&ACIPLISTMutex);
		ret = set_ac_ip_diff_banlance(id,diff_banlance);		
		CWThreadMutexUnlock(&ACIPLISTMutex);
	}else{
		ret = WLAN_ID_NOT_EXIST;
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;


}

DBusMessage *wid_dbus_set_ac_ip_threshold(DBusConnection *conn, DBusMessage *msg, void *user_data){	
	DBusMessage* reply;
	DBusError err;
	DBusMessageIter	 iter;

	unsigned char id = 0;
	unsigned int threshold = 0;
	char *ip = NULL;
	int ret = WID_DBUS_SUCCESS;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&id,
								DBUS_TYPE_STRING,&ip,
								DBUS_TYPE_UINT32,&threshold,
								DBUS_TYPE_INVALID)))
	{

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err))
		{
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
		
	}
	
	if(AC_IP_GROUP[id] != NULL){		
		CWThreadMutexLock(&ACIPLISTMutex);
		ret = set_ac_ip_diffcount(id,ip,threshold);		
		CWThreadMutexUnlock(&ACIPLISTMutex);
	}else{
		ret = WLAN_ID_NOT_EXIST;
	}

	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;


}

DBusMessage * wid_dbus_interface_show_ac_ip_list_one(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage * reply;
	DBusMessageIter	 iter;
	DBusError err;
	DBusMessageIter	 iter_array;		
	unsigned char ID = 0;
	int ret=WID_DBUS_SUCCESS;
	char *str = "NONE";
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&ID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_IP_GROUP[ID] == NULL)
	{
		ret = WID_EBR_NOT_EXIST;
	}
	
	int i;
	unsigned int num = 0;
//	wid_ac_ip_group *ac_ip_list ;
	struct wid_ac_ip *iplist;

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	if(ret == 0)
	{
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(AC_IP_GROUP[ID]->GroupID));
		
		if(AC_IP_GROUP[ID]->ifname){
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_STRING,
											 &(AC_IP_GROUP[ID]->ifname));
		}
		else{
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_STRING,
											 &(str));	
		}
		
		if(AC_IP_GROUP[ID]->ipaddr){
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_STRING,
											 &(AC_IP_GROUP[ID]->ipaddr));
		}
		else{//char ipaddr_str[]="no ip address";
			//char *ipaddr = ipaddr_str;
			dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_STRING,
											 &(str));	
		}
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_BYTE,
										 &(AC_IP_GROUP[ID]->load_banlance));			
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &(AC_IP_GROUP[ID]->diff_count));			
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &(AC_IP_GROUP[ID]->ipnum));
			
		dbus_message_iter_open_container (&iter,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_STRING_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_UINT32_AS_STRING
												DBUS_TYPE_UINT32_AS_STRING
										DBUS_STRUCT_END_CHAR_AS_STRING,
										&iter_array);

		iplist = AC_IP_GROUP[ID]->ip_list;
		num = AC_IP_GROUP[ID]->ipnum;
		for(i = 0; i < num; i++){			
			DBusMessageIter iter_struct;
				
			dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
				
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_STRING,
						  &(iplist->ip));
	
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(iplist->priority));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(iplist->threshold));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(iplist->wtpcount));			

			dbus_message_iter_close_container (&iter_array, &iter_struct);

			iplist = iplist->next;
		}
					
		dbus_message_iter_close_container (&iter, &iter_array);		
	}			
	return reply;	
}
DBusMessage * wid_dbus_interface_show_ac_ip_list(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;
	dbus_error_init(&err);
	unsigned int num=0;
	int ret = WID_DBUS_SUCCESS;
	int i=0;
	wid_ac_ip_group *ACIPLIST[ACIPLIST_NUM];

	while(i<ACIPLIST_NUM){
		if(AC_IP_GROUP[i] != NULL)
		{
			ACIPLIST[num] = AC_IP_GROUP[i];
			num++;
		}
		i++;
	}
	if(num == 0)
	{
		ret = WID_EBR_NOT_EXIST;
	}
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append (reply, &iter);
		
	dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &ret);
	if(ret == WID_DBUS_SUCCESS)
	{	
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &num);
			
		dbus_message_iter_open_container (&iter,
										DBUS_TYPE_ARRAY,
										DBUS_STRUCT_BEGIN_CHAR_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_STRING_AS_STRING
												DBUS_TYPE_BYTE_AS_STRING
												DBUS_TYPE_UINT32_AS_STRING
										DBUS_STRUCT_END_CHAR_AS_STRING,
										&iter_array);

		for(i = 0; i < num; i++){			
			DBusMessageIter iter_struct;
				
			dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(ACIPLIST[i]->GroupID));
				
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_STRING,
						  &(ACIPLIST[i]->ifname));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_BYTE,
						  &(ACIPLIST[i]->load_banlance));
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(ACIPLIST[i]->diff_count));				

			dbus_message_iter_close_container (&iter_array, &iter_struct);


		}
					
		dbus_message_iter_close_container (&iter, &iter_array);
	}			
	
	return reply;	
}


DBusMessage *wid_dbus_ac_ip_list_group_config(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage * reply;
	DBusMessageIter	 iter;
//	char* IFName;
	unsigned char ID;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&ID,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_IP_GROUP[ID] == NULL)
		ret = WLAN_ID_NOT_EXIST;
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
	
}

DBusMessage * wid_dbus_interface_set_wid_watch_dog(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
		
	int ret = WID_DBUS_SUCCESS;
	unsigned char open = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&open,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	WID_WATCH_DOG_OPEN = open;
	return reply;	

}

DBusMessage * wid_dbus_interface_show_vrrp_sock_list(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusMessageIter  iter_array;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int i = 0;
	int count = 0;
	struct bak_sock * tmp;
	if(bak_list == NULL)
		ret = 1;

	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if(ret == WID_DBUS_SUCCESS)
	{	
		tmp = bak_list;
		while(tmp != NULL){
			count++;
			tmp = tmp->next;
		}
		tmp = bak_list;
		
		dbus_message_iter_append_basic (&iter,
										 DBUS_TYPE_UINT32,
										 &count);
		
		
		dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING 
											DBUS_TYPE_UINT32_AS_STRING 
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);		

		for(i = 0; i < count; i++)
		{	
			
			
			DBusMessageIter iter_struct;
				
			dbus_message_iter_open_container (&iter_array,
											DBUS_TYPE_STRUCT,
											NULL,
											&iter_struct);
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(tmp->sock));
			
			dbus_message_iter_append_basic
						(&iter_struct,
						  DBUS_TYPE_UINT32,
						  &(tmp->ip));
			dbus_message_iter_close_container(&iter_array, &iter_struct);

			tmp = tmp->next;

		}
				
		dbus_message_iter_close_container (&iter, &iter_array);
	}			

	return reply;	

}

DBusMessage * wid_dbus_interface_set_ap_access_through_nat(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int policy = 0;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}



	if(policy != ApAccessNat)
	{	
		ApAccessNat = policy;
	}


	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	
	
	wid_syslog_debug_debug(WID_DBUS,"set ap hotreboot %d successfully\n",policy);
	
	return reply;	

}

DBusMessage * wid_dbus_interface_wtp_list_dhcp_snooping(DBusConnection *conn, DBusMessage *msg1, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusMessageIter  iter1;
	DBusMessageIter iter_array;
	DBusError err;	
	int ret = WID_DBUS_SUCCESS;
	unsigned int i =0;
	unsigned int wtpid;
	unsigned int policy;
	unsigned int num;
	msgq msg;
	int WTPIndex;
//	struct msgqlist *elem;
	
	dbus_error_init(&err);
	
	dbus_message_iter_init(msg1,&iter);
	dbus_message_iter_get_basic(&iter,&policy);
	printf("%s policy %d\n",__func__,policy);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&num);
	printf("%s num %d\n",__func__,num);
	
	dbus_message_iter_next(&iter);	
	dbus_message_iter_recurse(&iter, &iter_array);
		
	for (i = 0; i < num; i++) 		/* Huangleilei add it by AXSSZFI-1621: dbus may be not accept more than 255 elements, as string add to it */
	{
		DBusMessageIter iter_struct;
		dbus_message_iter_recurse(&iter_array, &iter_struct);
		dbus_message_iter_get_basic(&iter_struct, &wtpid);
		dbus_message_iter_next(&iter_array);

		WTPIndex = wtpid;
		if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->dhcp_snooping != policy))
		{
			printf("%s AC_WTP[wtpid]->dhcp_snooping %d\n",__func__,AC_WTP[wtpid]->dhcp_snooping);

			AC_WTP[wtpid]->dhcp_snooping = policy;
			
			if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPStat == 5))
			{
				CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
				if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
				{
					memset((char*)&msg, 0, sizeof(msg));
					msg.mqid = WTPIndex%THREAD_NUM+1;
					msg.mqinfo.WTPID = WTPIndex;
					msg.mqinfo.type = CONTROL_TYPE;
					msg.mqinfo.subtype = WTP_S_TYPE;
					msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_DHCP_SNOOPING;
					msg.mqinfo.u.WtpInfo.value2 = policy;
					if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
						wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
						perror("msgsnd");
					}
				}		
				CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
			}
			//delete unuseful code
			/*else if((AC_WTP[wtpid] != NULL)){
				memset((char*)&msg, 0, sizeof(msg));
				msg.mqid = WTPIndex%THREAD_NUM+1;
				msg.mqinfo.WTPID = WTPIndex;
				msg.mqinfo.type = CONTROL_TYPE;
				msg.mqinfo.subtype = WTP_S_TYPE;
				msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_DHCP_SNOOPING;
				msg.mqinfo.u.WtpInfo.value2 = policy;
			
				elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
				if(elem == NULL){
					wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
					perror("malloc");
					return 0;
				}
				memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
				elem->next = NULL;
				memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
				WID_INSERT_CONTROL_LIST(wtpid, elem);
				elem = NULL;
			}*/
		}
	}
#if 0
	for(i = 0; i < num; i++){

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&wtpid);
		//save parameter
		printf("%s wtpid %d\n",__func__,wtpid);
		WTPIndex = wtpid;
		if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->dhcp_snooping != policy))
		{
			printf("%s AC_WTP[wtpid]->dhcp_snooping %d\n",__func__,AC_WTP[wtpid]->dhcp_snooping);

			AC_WTP[wtpid]->dhcp_snooping = policy;
			
			if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPStat == 5))
			{
				CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
				if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
				{
					memset((char*)&msg, 0, sizeof(msg));
					msg.mqid = WTPIndex%THREAD_NUM+1;
					msg.mqinfo.WTPID = WTPIndex;
					msg.mqinfo.type = CONTROL_TYPE;
					msg.mqinfo.subtype = WTP_S_TYPE;
					msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_DHCP_SNOOPING;
					msg.mqinfo.u.WtpInfo.value2 = policy;
					if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
						wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
						perror("msgsnd");
					}
				}		
				CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
			}else if((AC_WTP[wtpid] != NULL)){
				memset((char*)&msg, 0, sizeof(msg));
				msg.mqid = WTPIndex%THREAD_NUM+1;
				msg.mqinfo.WTPID = WTPIndex;
				msg.mqinfo.type = CONTROL_TYPE;
				msg.mqinfo.subtype = WTP_S_TYPE;
				msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_DHCP_SNOOPING;
				msg.mqinfo.u.WtpInfo.value2 = policy;
			
				elem = (struct msgqlist*)WID_MALLOC(sizeof(struct msgqlist));
				if(elem == NULL){
					wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
					perror("malloc");
					return 0;
				}
				memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
				elem->next = NULL;
				memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
				WID_INSERT_CONTROL_LIST(wtpid, elem);
				elem = NULL;
			}
		}
	}
	#endif
	if(num == 0){
		for(i = 1; i < WTP_NUM; i++){	
			wtpid = i;
			WTPIndex = i;
			if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->dhcp_snooping != policy))
			{
				AC_WTP[wtpid]->dhcp_snooping = policy;
				
				if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPStat == 5))
				{
					CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
					if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
					{
						memset((char*)&msg, 0, sizeof(msg));
						msg.mqid = WTPIndex%THREAD_NUM+1;
						msg.mqinfo.WTPID = WTPIndex;
						msg.mqinfo.type = CONTROL_TYPE;
						msg.mqinfo.subtype = WTP_S_TYPE;
						msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_DHCP_SNOOPING;
						msg.mqinfo.u.WtpInfo.value2 = policy;
						if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
							wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
							perror("msgsnd");
						}
					}		
					CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
				}//delete unuseful code
				/*else if((AC_WTP[wtpid] != NULL)){
					memset((char*)&msg, 0, sizeof(msg));
					msg.mqid = WTPIndex%THREAD_NUM+1;
					msg.mqinfo.WTPID = WTPIndex;
					msg.mqinfo.type = CONTROL_TYPE;
					msg.mqinfo.subtype = WTP_S_TYPE;
					msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_DHCP_SNOOPING;
					msg.mqinfo.u.WtpInfo.value2 = policy;
				
					elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
					if(elem == NULL){
						wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
						perror("malloc");
						return 0;
					}
					memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
					elem->next = NULL;
					memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
					WID_INSERT_CONTROL_LIST(wtpid, elem);
					elem = NULL;
				}*/
			}

		}

	}
	
	reply = dbus_message_new_method_return(msg1);
		
	dbus_message_iter_init_append(reply, &iter1);
		
	dbus_message_iter_append_basic(&iter1, DBUS_TYPE_UINT32, &ret);

	return reply;	
}

#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_wtp_dhcp_snooping(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	int i = 0;
	int num =0 ;
	unsigned int ID = 0;
	unsigned int type = 0;
	int  policy = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Wtp_List  *wtp_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;

	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,								
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(type==0)
		{
			if(ID == 0){
				gDHCP_SNOOPING = policy;
				for(i=0;i<WTP_NUM;i++){
					if(AC_WTP[i] != NULL){
						if(AC_WTP[i]->dhcp_snooping == policy)
						{
							ret = WID_DBUS_SUCCESS;
						}
						else
						{
							ret = wtp_set_wtp_dhcp_snooping(i,policy);
						}
					}
				}
			}/*wcl add for globle variable*/
			else if(AC_WTP[ID] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else if(AC_WTP[ID]->dhcp_snooping == policy)/*wcl modify for globle variable*/
				{
					ret = WID_DBUS_SUCCESS;
				}
			else
				{
					ret = wtp_set_wtp_dhcp_snooping(ID,policy);/*wcl modify for globle variable*/
				}
		}
	
	else if(type == 1){
		printf("******** type == 1 *****\n");
		if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
			tmp = WTP_GROUP[ID]->WTP_M;
			wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
			
			while(tmp){
				ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
				
				if(ret_check == WID_DBUS_SUCCESS){

					if(AC_WTP[tmp->WTPID]->WTPStat == 5)
						{
							if(AC_WTP[tmp->WTPID]->dhcp_snooping == policy)/*wcl modify for globle variable*/
								{
									ret2 = WID_DBUS_SUCCESS;
									wid_syslog_debug_debug(WID_DEFAULT,"WTP%d HAD THIS POLICY YET\n",tmp->WTPID);
								}
							else
								{
									ret2 = wtp_set_wtp_dhcp_snooping(tmp->WTPID,policy);/*wcl modify for globle variable*/
									wid_syslog_debug_debug(WID_DEFAULT,"WTP%d SET POLICY OK\n",tmp->WTPID);
								}
					
						}
					else {ret2 = WTP_NOT_IN_RUN_STATE; 
					wid_syslog_debug_debug(WID_DEFAULT,"WTP%d NOT RUN\n",tmp->WTPID);}
					if(ret2 != WID_DBUS_SUCCESS){
						wtp_head[num].WtpId = tmp->WTPID;
						wtp_head[num].FailReason = ret2;
						num++;
						//printf("3333ret2 =  %d",ret2);
					}
					tmp = tmp->next;
				}
				ret = WID_DBUS_SUCCESS;
			}
		}
			
		else{
			ret = GROUP_ID_NOT_EXIST;
			}
	}
		//printf("####ret2 =  %d",ret2);
	reply = dbus_message_new_method_return(msg);

	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &num);
		printf("num= %d",num);
		for(i = 0; i < num; i++){
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_UINT32,
												 &(wtp_head[i].WtpId));
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_BYTE,
												 &(wtp_head[i].FailReason));
		}	
		
		if(wtp_head!=NULL){
			WID_FREE(wtp_head);
			wtp_head = NULL;	
		}
	}
	
	return reply;	
}

#else
DBusMessage * wid_dbus_interface_wtp_dhcp_snooping(DBusConnection *conn, DBusMessage *msg1, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusMessageIter  iter1;
	DBusError err;	
	int ret = WID_DBUS_SUCCESS;
	unsigned int i = 0;
	unsigned int wtpid;
	unsigned int policy;
	
	dbus_error_init(&err);
	
	dbus_message_iter_init(msg1,&iter);
	dbus_message_iter_get_basic(&iter,&policy);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&wtpid);
	printf("%s wtpid %d\n",__func__,wtpid);
/*	WTPIndex = wtpid;
	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->dhcp_snooping != policy))
	{
		printf("%s AC_WTP[wtpid]->dhcp_snooping %d\n",__func__,AC_WTP[wtpid]->dhcp_snooping);
		AC_WTP[wtpid]->dhcp_snooping = policy;
		
		if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPStat == 5))
		{
			CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
			if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
			{
				memset((char*)&msg, 0, sizeof(msg));
				msg.mqid = WTPIndex%THREAD_NUM+1;
				msg.mqinfo.WTPID = WTPIndex;
				msg.mqinfo.type = CONTROL_TYPE;
				msg.mqinfo.subtype = WTP_S_TYPE;
				msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_DHCP_SNOOPING;
				msg.mqinfo.u.WtpInfo.value2 = policy;
				if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
					wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
					perror("msgsnd");
				}
			}		
			CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
		}else if((AC_WTP[wtpid] != NULL)){
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_DHCP_SNOOPING;
			msg.mqinfo.u.WtpInfo.value2 = policy;
		
			elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if(elem == NULL){
				wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
				perror("malloc");
				return 0;
			}
			memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
			elem->next = NULL;
			memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
			WID_INSERT_CONTROL_LIST(wtpid, elem);
			elem = NULL;
		}
	}*/
	if(wtpid == 0){
		gDHCP_SNOOPING = policy;
		for(i=0;i<WTP_NUM;i++){
			if(AC_WTP[i] != NULL){
				if(AC_WTP[i]->dhcp_snooping == policy)
				{
					ret = WID_DBUS_SUCCESS;
				}
				else
				{
					ret = wtp_set_wtp_dhcp_snooping(i,policy);
				}
			}
		}
	}
	else if(AC_WTP[wtpid] == NULL)
		{
			ret = WTP_ID_NOT_EXIST;
		}
	else if(AC_WTP[wtpid]->dhcp_snooping == policy)
		{
			ret = WID_DBUS_SUCCESS;
		}
	else
		{
			ret = wtp_set_wtp_dhcp_snooping(wtpid,policy);
		}
			/*wcl add modify for globle variable*/
		

	reply = dbus_message_new_method_return(msg1);
		
	dbus_message_iter_init_append(reply, &iter1);
		
	dbus_message_iter_append_basic(&iter1, DBUS_TYPE_UINT32, &ret);

	return reply;	
}
#endif
DBusMessage * wid_dbus_interface_wtp_list_sta_info_report(DBusConnection *conn, DBusMessage *msg1, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusMessageIter  iter1;
	DBusMessageIter iter_array;
	DBusError err;	
	int ret = WID_DBUS_SUCCESS;
	unsigned int i = 0;
	unsigned int wtpid;
	unsigned int policy;
	unsigned int num;
	msgq msg;
	int WTPIndex;
//	struct msgqlist *elem;
	
	dbus_error_init(&err);
	
	dbus_message_iter_init(msg1,&iter);
	dbus_message_iter_get_basic(&iter,&policy);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&num);
	
	dbus_message_iter_next(&iter);	
	dbus_message_iter_recurse(&iter, &iter_array);
		
	for (i = 0; i < num; i++) 		/* Huangleilei add it by AXSSZFI-1621: dbus may be not accept more than 255 elements, as string add to it */
	{
		DBusMessageIter iter_struct;
		dbus_message_iter_recurse(&iter_array, &iter_struct);
		dbus_message_iter_get_basic(&iter_struct, &wtpid);
		dbus_message_iter_next(&iter_array);
		WTPIndex = wtpid;
		if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->sta_ip_report!= policy))
		{
			printf("%s AC_WTP[wtpid]->sta_ip_report %d\n",__func__,AC_WTP[wtpid]->sta_ip_report);
			AC_WTP[wtpid]->sta_ip_report = policy;
			
			if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPStat == 5))
			{
				CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
				if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
				{
					memset((char*)&msg, 0, sizeof(msg));
					msg.mqid = WTPIndex%THREAD_NUM+1;
					msg.mqinfo.WTPID = WTPIndex;
					msg.mqinfo.type = CONTROL_TYPE;
					msg.mqinfo.subtype = WTP_S_TYPE;
					msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_INFO_REPORT;
					msg.mqinfo.u.WtpInfo.value2 = policy;
					if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
						wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
						perror("msgsnd");
					}
				}		
				CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
			}//delete unusefule code
			
			/*else if((AC_WTP[wtpid] != NULL)){
				memset((char*)&msg, 0, sizeof(msg));
				msg.mqid = WTPIndex%THREAD_NUM+1;
				msg.mqinfo.WTPID = WTPIndex;
				msg.mqinfo.type = CONTROL_TYPE;
				msg.mqinfo.subtype = WTP_S_TYPE;
				msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_INFO_REPORT;
				msg.mqinfo.u.WtpInfo.value2 = policy;
			
				elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
				if(elem == NULL){
					wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
					perror("malloc");
					return 0;
				}
				memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
				elem->next = NULL;
				memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
				WID_INSERT_CONTROL_LIST(wtpid, elem);
				elem = NULL;
			}*/
		}
	}
#if 0
	for(i = 0; i < num; i++){

		dbus_message_iter_next(&iter);	
		dbus_message_iter_get_basic(&iter,&wtpid);
		//save parameter
		WTPIndex = wtpid;
		if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->sta_ip_report!= policy))
		{
			printf("%s AC_WTP[wtpid]->sta_ip_report %d\n",__func__,AC_WTP[wtpid]->sta_ip_report);
			AC_WTP[wtpid]->sta_ip_report = policy;
			
			if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPStat == 5))
			{
				CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
				if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
				{
					memset((char*)&msg, 0, sizeof(msg));
					msg.mqid = WTPIndex%THREAD_NUM+1;
					msg.mqinfo.WTPID = WTPIndex;
					msg.mqinfo.type = CONTROL_TYPE;
					msg.mqinfo.subtype = WTP_S_TYPE;
					msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_INFO_REPORT;
					msg.mqinfo.u.WtpInfo.value2 = policy;
					if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
						wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
						perror("msgsnd");
					}
				}		
				CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
			}else if((AC_WTP[wtpid] != NULL)){
				memset((char*)&msg, 0, sizeof(msg));
				msg.mqid = WTPIndex%THREAD_NUM+1;
				msg.mqinfo.WTPID = WTPIndex;
				msg.mqinfo.type = CONTROL_TYPE;
				msg.mqinfo.subtype = WTP_S_TYPE;
				msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_INFO_REPORT;
				msg.mqinfo.u.WtpInfo.value2 = policy;
			
				elem = (struct msgqlist*)WID_MALLOC(sizeof(struct msgqlist));
				if(elem == NULL){
					wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
					perror("malloc");
					return 0;
				}
				memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
				elem->next = NULL;
				memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
				WID_INSERT_CONTROL_LIST(wtpid, elem);
				elem = NULL;
			}
		}
	}
	#endif
	if(num == 0){
		for(i = 1; i < WTP_NUM; i++){	
			wtpid = i;
			WTPIndex = i;
			if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->sta_ip_report != policy))
			{
				AC_WTP[wtpid]->sta_ip_report = policy;
				
				if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPStat == 5))
				{
					CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
					if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
					{
						memset((char*)&msg, 0, sizeof(msg));
						msg.mqid = WTPIndex%THREAD_NUM+1;
						msg.mqinfo.WTPID = WTPIndex;
						msg.mqinfo.type = CONTROL_TYPE;
						msg.mqinfo.subtype = WTP_S_TYPE;
						msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_INFO_REPORT;
						msg.mqinfo.u.WtpInfo.value2 = policy;
						if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
							wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
							perror("msgsnd");
						}
					}		
					CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
				}//delete unuseful code
				/*else if((AC_WTP[wtpid] != NULL)){
					memset((char*)&msg, 0, sizeof(msg));
					msg.mqid = WTPIndex%THREAD_NUM+1;
					msg.mqinfo.WTPID = WTPIndex;
					msg.mqinfo.type = CONTROL_TYPE;
					msg.mqinfo.subtype = WTP_S_TYPE;
					msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_INFO_REPORT;
					msg.mqinfo.u.WtpInfo.value2 = policy;
				
					elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
					if(elem == NULL){
						wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
						perror("malloc");
						return 0;
					}
					memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
					elem->next = NULL;
					memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
					WID_INSERT_CONTROL_LIST(wtpid, elem);
					elem = NULL;
				}*/
			}

		}

	}
	
	reply = dbus_message_new_method_return(msg1);
		
	dbus_message_iter_init_append(reply, &iter1);
		
	dbus_message_iter_append_basic(&iter1, DBUS_TYPE_UINT32, &ret);

	return reply;	
}

#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_wtp_sta_info_report(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	int i = 0;
	int num =0 ;
	unsigned int ID = 0;
	unsigned int type = 0;
	int  policy = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Wtp_List  *wtp_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;

	DBusError err;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,								
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(type==0)
		{
			if(ID == 0){
				gSTAINFOREPORT = policy;
				for(i=0;i<WTP_NUM;i++){
					if(AC_WTP[i] != NULL){
							if(AC_WTP[i]->sta_ip_report != policy){
								ret = wtp_set_sta_info_report(i,policy);
							}	
					}
				}
			} /*wcl add for globle variable*/
			else if(AC_WTP[ID] == NULL)
				{
					ret = WTP_ID_NOT_EXIST;
				}
			else if(AC_WTP[ID]->sta_ip_report == policy)
				{
					ret = WID_DBUS_SUCCESS;
				}
			else
				{
					ret = wtp_set_sta_info_report(ID,policy);
				}
		}
	
	else if(type == 1){
		printf("******** type == 1 *****\n");
		if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL)){
			tmp = WTP_GROUP[ID]->WTP_M;
			wtp_head = (struct Wtp_List *)WID_MALLOC(WTP_GROUP[ID]->WTP_COUNT *(sizeof(struct Wtp_List)));
			
			while(tmp){
				ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);
				
				if(ret_check == WID_DBUS_SUCCESS){

					if(AC_WTP[tmp->WTPID]->WTPStat == 5)
						{
							if(AC_WTP[tmp->WTPID]->sta_ip_report == policy)
								{
									ret2 = WID_DBUS_SUCCESS;
									wid_syslog_debug_debug(WID_DEFAULT,"WTP%d HAD THIS POLICY YET\n",tmp->WTPID);
								}
							else
								{
									ret2 = wtp_set_sta_info_report(tmp->WTPID,policy);
									wid_syslog_debug_debug(WID_DEFAULT,"WTP%d SET POLICY OK\n",tmp->WTPID);
								}
					
						}
					else {ret2 = WTP_NOT_IN_RUN_STATE; 
					wid_syslog_debug_debug(WID_DEFAULT,"WTP%d NOT RUN\n",tmp->WTPID);}
					if(ret2 != WID_DBUS_SUCCESS){
						wtp_head[num].WtpId = tmp->WTPID;
						wtp_head[num].FailReason = ret2;
						num++;
						//printf("3333ret2 =  %d",ret2);
					}
					tmp = tmp->next;
				}
				ret = WID_DBUS_SUCCESS;
			}
		}
			
		else{
			ret = GROUP_ID_NOT_EXIST;
			}
	}
		//printf("####ret2 =  %d",ret2);
	reply = dbus_message_new_method_return(msg);

	dbus_message_iter_init_append(reply, &iter);
	
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	if((type == 1)&&(ret == WID_DBUS_SUCCESS)){
		dbus_message_iter_append_basic (&iter,
											 DBUS_TYPE_UINT32,
											 &num);
		printf("num= %d",num);
		for(i = 0; i < num; i++){
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_UINT32,
												 &(wtp_head[i].WtpId));
			dbus_message_iter_append_basic (&iter,
												 DBUS_TYPE_BYTE,
												 &(wtp_head[i].FailReason));
		}	
		
		if(wtp_head!=NULL){
			WID_FREE(wtp_head);
			wtp_head = NULL;	
		}
	}
	
	return reply;	
}
#else
DBusMessage * wid_dbus_interface_wtp_sta_info_report(DBusConnection *conn, DBusMessage *msg1, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusMessageIter  iter1;
	DBusError err;	
	int ret = WID_DBUS_SUCCESS;
	unsigned int i;
	unsigned int wtpid;
	unsigned int policy;
	
	dbus_error_init(&err);
	
	dbus_message_iter_init(msg1,&iter);
	dbus_message_iter_get_basic(&iter,&policy);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&wtpid);
/*	WTPIndex = wtpid;
	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->sta_ip_report != policy))
	{
		printf("%s AC_WTP[%d]->sta_ip_report %d\n",__func__,wtpid,AC_WTP[wtpid]->sta_ip_report);
		AC_WTP[wtpid]->sta_ip_report = policy;
		
		if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPStat == 5))
		{
			CWThreadMutexLock(&(gWTPs[WTPIndex].WTPThreadMutex));
			if(gWTPs[WTPIndex].isNotFree && (gWTPs[WTPIndex].currentState == CW_ENTER_RUN))
			{
				memset((char*)&msg, 0, sizeof(msg));
				msg.mqid = WTPIndex%THREAD_NUM+1;
				msg.mqinfo.WTPID = WTPIndex;
				msg.mqinfo.type = CONTROL_TYPE;
				msg.mqinfo.subtype = WTP_S_TYPE;
				msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_INFO_REPORT;
				msg.mqinfo.u.WtpInfo.value2 = policy;
				if (msgsnd(ACDBUS_MSGQ, (msgq *)&msg, sizeof(msg.mqinfo), 0) == -1){
					wid_syslog_crit("%s msgsend %s",__func__,strerror(errno));
					perror("msgsnd");
				}
			}		
			CWThreadMutexUnlock(&(gWTPs[WTPIndex].WTPThreadMutex));
		}else if((AC_WTP[wtpid] != NULL)){
			memset((char*)&msg, 0, sizeof(msg));
			msg.mqid = WTPIndex%THREAD_NUM+1;
			msg.mqinfo.WTPID = WTPIndex;
			msg.mqinfo.type = CONTROL_TYPE;
			msg.mqinfo.subtype = WTP_S_TYPE;
			msg.mqinfo.u.WtpInfo.Wtp_Op = WTP_STA_INFO_REPORT;
			msg.mqinfo.u.WtpInfo.value2 = policy;
		
			elem = (struct msgqlist*)malloc(sizeof(struct msgqlist));
			if(elem == NULL){
				wid_syslog_crit("%s malloc %s",__func__,strerror(errno));
				perror("malloc");
				return 0;
			}
			memset((char*)&(elem->mqinfo), 0, sizeof(msgqdetail));
			elem->next = NULL;
			memcpy((char*)&(elem->mqinfo),(char*)&(msg.mqinfo),sizeof(msg.mqinfo));
			WID_INSERT_CONTROL_LIST(wtpid, elem);
			elem = NULL;
		}
	}
*/ /*wcl modify for globle variable*/
	if(wtpid == 0){
		gSTAINFOREPORT = policy;
		for(i=0;i<WTP_NUM;i++){
			if(AC_WTP[i] != NULL){
					if(AC_WTP[i]->sta_ip_report != policy){
						ret = wtp_set_sta_info_report(i,policy);
					}
			}
		}
	} 
	/*wcl add for globle variable*/
	   else if(AC_WTP[wtpid] == NULL)
		   {
			   ret = WTP_ID_NOT_EXIST;
		   }
	   else if(AC_WTP[wtpid]->sta_ip_report == policy)
		   {
			   ret = WID_DBUS_SUCCESS;
		   }
	   else
		   {
			   ret = wtp_set_sta_info_report(wtpid,policy);
		   }

	reply = dbus_message_new_method_return(msg1);
		
	dbus_message_iter_init_append(reply, &iter1);
		
	dbus_message_iter_append_basic(&iter1, DBUS_TYPE_UINT32, &ret);

	return reply;	
}
#endif
DBusMessage * wid_dbus_interface_wlan_sta_ip_mac_binding(DBusConnection *conn, DBusMessage *msg1, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusMessageIter  iter1;
	DBusError err;	
	int ret = WID_DBUS_SUCCESS;
	int i;
	int j;
	unsigned char wlanid;
	unsigned int policy;
//	unsigned int num;
//	msgq msg;
//	int WTPIndex;
//	struct msgqlist *elem;
	
	dbus_error_init(&err);
	
	dbus_message_iter_init(msg1,&iter);
	dbus_message_iter_get_basic(&iter,&policy);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&wlanid);

	if((AC_WLAN[wlanid] != NULL)&&(AC_WLAN[wlanid]->sta_ip_mac_bind != policy) && (AC_WLAN[wlanid]->want_to_delete != 1)){		/* Huangleilei add for ASXXZFI-1622 */
		AC_WLAN[wlanid]->sta_ip_mac_bind = policy;
		for(i=0; i<WTP_NUM; i++)
		{
			if((AC_WTP[i]!=NULL)&&(AC_WTP[i]->isused == 1))
			{
				for(j=0; j<AC_WTP[i]->RadioCount; j++)//zhanglei change L_RADIO_NUM to AC_WTP[i]->RadioCount
				{
					if(AC_WLAN[wlanid]->S_WTP_BSS_List[i][j] != 0)
					{
						int bssindex = AC_WLAN[wlanid]->S_WTP_BSS_List[i][j];
						int wtpid = (bssindex/L_BSS_NUM)/L_RADIO_NUM;
						int radioid = j;
						wid_set_sta_ip_mac_binding(wtpid,radioid,wlanid,policy);					
					}
				}
			}

		}

	}
	else if ((AC_WLAN[wlanid] != NULL) && (AC_WLAN[wlanid]->want_to_delete == 1))		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else
	{
	}

	reply = dbus_message_new_method_return(msg1);
		
	dbus_message_iter_init_append(reply, &iter1);
		
	dbus_message_iter_append_basic(&iter1, DBUS_TYPE_UINT32, &ret);

	return reply;	
}

DBusMessage * wid_dbus_interface_wlan_timer_able(DBusConnection *conn, DBusMessage *msg1, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusMessageIter  iter1;
	DBusError err;	
	int ret = WID_DBUS_SUCCESS;
//	int i;
//	int j;
	unsigned char wlanid;
	unsigned int policy;
	int timerflag = 0;	
	time_t timep;  
	struct tm *p; 
	int times;	
	int timer;
	dbus_error_init(&err);
	
	dbus_message_iter_init(msg1,&iter);
	dbus_message_iter_get_basic(&iter,&policy);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&timerflag);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&wlanid);
printf("1\n");
	if(timerflag == 1){
		
		printf("2\n");
		if(AC_WLAN[wlanid] != NULL && (AC_WLAN[wlanid]->want_to_delete !=  1)){		/* Huangleilei add for ASXXZFI-1622 */
			printf("3\n");

			if(AC_WLAN[wlanid]->StartService.TimerState != policy){
				printf("4\n");

				if(policy == 1){
					printf("5\n");

					AC_WLAN[wlanid]->StartService.TimerState = policy;
					time(&timep);  
					p=localtime(&timep);
					
					printf("start time %d:%d:%d\n",p->tm_hour,p->tm_min,p->tm_sec);
					times = p->tm_hour*3600 + p->tm_min*60 + p->tm_sec;
					if(times < AC_WLAN[wlanid]->StartService.times){
						timer = AC_WLAN[wlanid]->StartService.times - times; 
					}else{
						timer = 24*3600 - times + AC_WLAN[wlanid]->StartService.times;
					}
					printf("6\n");
					printf("times %d\n",times);
					printf(" AC_WLAN[wlanid]->StartService.times %d\n", AC_WLAN[wlanid]->StartService.times);
					printf("timer %d \n",timer);

					if(!(CWTimerRequest(timer, NULL, &(AC_WLAN[wlanid]->StartService.TimerID), 501,wlanid))) {
						ret = WID_DBUS_ERROR;
					}	
					
					printf("AC_WLAN[wlanid]->StartService.TimerID11111111 %d\n",AC_WLAN[wlanid]->StartService.TimerID);
					printf("7\n");

				}else{
					AC_WLAN[wlanid]->StartService.TimerState = policy;
					printf("AC_WLAN[wlanid]->StartService.TimerID22222222 %d\n",AC_WLAN[wlanid]->StartService.TimerID);
					if(!CWTimerCancel(&(AC_WLAN[wlanid]->StartService.TimerID),1)) {
						ret = WID_DBUS_ERROR;
					}
				}
			}
		}
	}
	else if(timerflag == 0){
		if(AC_WLAN[wlanid] != NULL && (AC_WLAN[wlanid]->want_to_delete != 1)){		/* Huangleilei add for ASXXZFI-1622 */
			if(AC_WLAN[wlanid]->StopService.TimerState != policy){
				if(policy == 1){
					AC_WLAN[wlanid]->StopService.TimerState = policy;
					time(&timep);  
					p=localtime(&timep);
					printf("stop time %d:%d:%d\n",p->tm_hour,p->tm_min,p->tm_sec);
					times = p->tm_hour*3600 + p->tm_min*60 + p->tm_sec;
					if(times < AC_WLAN[wlanid]->StopService.times){
						timer = AC_WLAN[wlanid]->StopService.times -times; 
					}else{
						timer = 24*3600 - times + AC_WLAN[wlanid]->StopService.times;
					}
					printf("times %d\n",times);
					printf(" AC_WLAN[wlanid]->StopService.times %d\n", AC_WLAN[wlanid]->StopService.times);
					printf("timer %d \n",timer);
					if(!(CWTimerRequest(timer, NULL, &(AC_WLAN[wlanid]->StopService.TimerID), 502,wlanid))) {
						ret = WID_DBUS_ERROR;
					}		
					printf("AC_WLAN[wlanid]->StopService.TimerID11111111 %d\n",AC_WLAN[wlanid]->StopService.TimerID);
				}else{
					AC_WLAN[wlanid]->StopService.TimerState = policy;
					printf("AC_WLAN[wlanid]->StopService.TimerID22222222 %d\n",AC_WLAN[wlanid]->StopService.TimerID);
					if(!CWTimerCancel(&(AC_WLAN[wlanid]->StopService.TimerID),1)) {
						ret = WID_DBUS_ERROR;
					}
				}
			}
		}
	}
	if (AC_WLAN[wlanid] != NULL && (AC_WLAN[wlanid]->want_to_delete == 1))		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	
	reply = dbus_message_new_method_return(msg1);
		
	dbus_message_iter_init_append(reply, &iter1);
		
	dbus_message_iter_append_basic(&iter1, DBUS_TYPE_UINT32, &ret);

	return reply;	
}
DBusMessage * wid_dbus_interface_wlan_wtp_list_sta_static_arp(DBusConnection *conn, DBusMessage *msg1, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusMessageIter  iter1;
	DBusMessageIter  iter_array;/*wcl add for AUTELAN-2836*/
	DBusError err;	
	int ret = WID_DBUS_SUCCESS;
	unsigned int i;
	unsigned int wtpid;
	unsigned int policy;
	unsigned char wlanid;
	char *ifname = NULL;
	unsigned int num;
//	int WTPIndex;
	int j = 0;
	unsigned int BSSIndex;
	WTPQUITREASON quitreason = WTP_INIT;/*wcl add for AUTELAN-2836*/
	dbus_error_init(&err);
	
	dbus_message_iter_init(msg1,&iter);
	dbus_message_iter_get_basic(&iter,&policy);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&wlanid);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&ifname);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&num);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_recurse(&iter,&iter_array);

	ret = Check_Interface_Exist(ifname,&quitreason);
	if(ret == WID_DBUS_SUCCESS)
	{

		for(i = 0; i < num; i++){

			/*dbus_message_iter_next(&iter);	
			dbus_message_iter_get_basic(&iter,&wtpid);*/
			//save parameter
			DBusMessageIter iter_struct;
			dbus_message_iter_recurse(&iter_array,&iter_struct);
						
			dbus_message_iter_get_basic(&iter_struct,&wtpid);
			dbus_message_iter_next(&iter_array);/*wcl modify for AUTELAN-2836*/
			if(AC_WLAN[wlanid] != NULL && (AC_WLAN[wlanid]->want_to_delete != 1)){		/* Huangleilei add for ASXXZFI-1622 */
				for(j = 0; j < L_RADIO_NUM; j++){
					BSSIndex = AC_WLAN[wlanid]->S_WTP_BSS_List[wtpid][j];
					if((BSSIndex != 0)&&(AC_BSS[BSSIndex] != NULL)){
						AC_BSS[BSSIndex]->sta_static_arp_policy = policy;
						if(strlen(ifname) < ETH_IF_NAME_LEN){
							memset(AC_BSS[BSSIndex]->arp_ifname,0,ETH_IF_NAME_LEN);
							memcpy(AC_BSS[BSSIndex]->arp_ifname,ifname, strlen(ifname));
						}else{
							AC_BSS[BSSIndex]->sta_static_arp_policy = 0;
							continue;
						}
						if(AC_BSS[BSSIndex]->State == 1){
							AsdWsm_BSSOp(BSSIndex, WID_MODIFY, 0);						
						}
					}
				}
			}
			else if (AC_WLAN[wlanid] != NULL && (AC_WLAN[wlanid]->want_to_delete == 1))		/* Huangleilei add for ASXXZFI-1622 */
			{
				ret = WID_WANT_TO_DELETE_WLAN;
			}
			else{
				ret = WLAN_ID_NOT_EXIST;
			}
		}	
	}
	reply = dbus_message_new_method_return(msg1);
		
	dbus_message_iter_init_append(reply, &iter1);
		
	dbus_message_iter_append_basic(&iter1, DBUS_TYPE_UINT32, &ret);

	return reply;	
}
#if _GROUP_POLICY
DBusMessage * wid_dbus_interface_wlan_wtp_sta_static_arp(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;	


	unsigned int policy = 0;
	unsigned char wlanid;
	char *ifname;

	unsigned int BSSIndex;
	int i = 0;
	int num =0 ;
    int radionum = 0;
	unsigned int ID = 0;
	unsigned int type = 0;
	int ret = WID_DBUS_SUCCESS;
	int ret2 = WID_DBUS_SUCCESS;
	int ret_check = WID_DBUS_SUCCESS;
	
	struct Radio_List  *radio_head = NULL;
	struct WTP_GROUP_MEMBER *tmp = NULL;
	struct WTP_GROUP_MEMBER *radiotmp = NULL;	
	dbus_error_init(&err);
	
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_STRING,&ifname,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(type==0)
		{
			int wtpid = ID/L_RADIO_NUM;
			int l_radioid = ID%L_RADIO_NUM;
	
			if(AC_WLAN[wlanid] != NULL)
				{
					BSSIndex = AC_WLAN[wlanid]->S_WTP_BSS_List[wtpid][l_radioid];
					if((BSSIndex != 0)&&(AC_BSS[BSSIndex] != NULL))
						{
							AC_BSS[BSSIndex]->sta_static_arp_policy = policy;
							if(strlen(ifname) < ETH_IF_NAME_LEN)
								{
									memset(AC_BSS[BSSIndex]->arp_ifname,0,ETH_IF_NAME_LEN);
									memcpy(AC_BSS[BSSIndex]->arp_ifname,ifname, strlen(ifname));
								}
							else
								{
									AC_BSS[BSSIndex]->sta_static_arp_policy = 0;
								}
							if(AC_BSS[BSSIndex]->State == 1)
								{
									AsdWsm_BSSOp(BSSIndex, WID_MODIFY, 0);						
								}
						}
				}
			else
				{
					ret = WLAN_ID_NOT_EXIST;
				}
		}
	else if(type == 1)
		{
			printf("******** type == 1 *****\n");
			if((WTP_GROUP[ID] != NULL)&&(WTP_GROUP[ID]->WTP_M!=NULL))
				{
					tmp = WTP_GROUP[ID]->WTP_M;
					radiotmp = WTP_GROUP[ID]->WTP_M;
					while(radiotmp)
						{
							radionum +=AC_WTP[radiotmp->WTPID]->RadioCount;
							radiotmp = radiotmp->next;
						}
					radio_head = (struct Radio_List *)WID_MALLOC(radionum*(sizeof(struct Radio_List)));
					while(tmp)
						{
							ret_check = WID_CHECK_ID(WID_WTP_CHECK,tmp->WTPID);

							if(ret_check == WID_DBUS_SUCCESS)
								{								
									for(i=0;i<AC_WTP[tmp->WTPID]->RadioCount;i++)
									{
										printf("wtpid = %d\n",tmp->WTPID);
										printf("radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
										printf("local radioid = %d\n",AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_L_ID);
										printf("i = %d \n",i);
										if(AC_WLAN[wlanid] != NULL)
											{
												BSSIndex = AC_WLAN[wlanid]->S_WTP_BSS_List[tmp->WTPID][i];
												if((BSSIndex != 0)&&(AC_BSS[BSSIndex] != NULL))
													{
														AC_BSS[BSSIndex]->sta_static_arp_policy = policy;
														if(strlen(ifname) < ETH_IF_NAME_LEN)
															{
																memset(AC_BSS[BSSIndex]->arp_ifname,0,ETH_IF_NAME_LEN);
																memcpy(AC_BSS[BSSIndex]->arp_ifname,ifname, strlen(ifname));
																printf("save ifname\n");
															}
														else
															{
																AC_BSS[BSSIndex]->sta_static_arp_policy = 0;
																printf("sta static arp policy = 0");
															}
														if(AC_BSS[BSSIndex]->State == 1)
															{
																AsdWsm_BSSOp(BSSIndex, WID_MODIFY, 0);
																wid_syslog_debug_debug(WID_DEFAULT,"wtpid%d radio%d,send to asd",tmp->WTPID,AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID);
															}
													}
											}
										else
											{
												ret2 = WLAN_ID_NOT_EXIST;
											}

										if(ret2 != WID_DBUS_SUCCESS)
											{
												radio_head[num].RadioId = AC_WTP[tmp->WTPID]->WTP_Radio[i]->Radio_G_ID;
												radio_head[num].FailReason = ret2;
												num++;
											}
									}
								}
							tmp = tmp->next;
						}
					ret = WID_DBUS_SUCCESS;
				}	
			else
				{
					ret = GROUP_ID_NOT_EXIST;
				}
		}
		
		reply = dbus_message_new_method_return(msg);
		
		dbus_message_iter_init_append(reply, &iter);
			
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
			
		if((type == 1)&&(ret == WID_DBUS_SUCCESS))
			{
				dbus_message_iter_append_basic (&iter,
													 DBUS_TYPE_UINT32,
											 &num);
				printf("num = %d\n",num);		
				for(i = 0; i < num; i++)
					{
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_UINT32,
															 &(radio_head[i].RadioId));
						dbus_message_iter_append_basic (&iter,
															 DBUS_TYPE_BYTE,
															 &(radio_head[i].FailReason));
					}	
				
				if(radio_head!=NULL)
					{
						WID_FREE(radio_head);
						radio_head = NULL;	
					}
			}
			return reply;

}

#else
DBusMessage * wid_dbus_interface_wlan_wtp_sta_static_arp(DBusConnection *conn, DBusMessage *msg1, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusMessageIter  iter1;
	DBusError err;	
	int ret = WID_DBUS_SUCCESS;
//	unsigned int i;
	unsigned int wtpid;
	unsigned int policy;
	unsigned char wlanid;
	char *ifname;
//	unsigned int num;
//	int WTPIndex;
	int j = 0;
	unsigned int BSSIndex;
	unsigned int radioid;
	WTPQUITREASON quitreason = WTP_INIT;/*wcl add for AUTELAN-2832*/
	dbus_error_init(&err);
	
	dbus_message_iter_init(msg1,&iter);
	dbus_message_iter_get_basic(&iter,&policy);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&wlanid);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&radioid);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&ifname);

	j = radioid%L_RADIO_NUM;
	wtpid = radioid/L_RADIO_NUM;
	ret = Check_Interface_Exist(ifname,&quitreason);
	if(ret == WID_DBUS_SUCCESS)
	{
		if(AC_WLAN[wlanid] != NULL && (AC_WLAN[wlanid]->want_to_delete != 1)){		/* Huangleilei add for ASXXZFI-1622 */
			BSSIndex = AC_WLAN[wlanid]->S_WTP_BSS_List[wtpid][j];
			if((BSSIndex != 0)&&(AC_BSS[BSSIndex] != NULL)){
				AC_BSS[BSSIndex]->sta_static_arp_policy = policy;
				if(strlen(ifname) < ETH_IF_NAME_LEN){
					memset(AC_BSS[BSSIndex]->arp_ifname,0,ETH_IF_NAME_LEN);
					memcpy(AC_BSS[BSSIndex]->arp_ifname,ifname, strlen(ifname));
				}else{
					AC_BSS[BSSIndex]->sta_static_arp_policy = 0;
				}
				if(AC_BSS[BSSIndex]->State == 1){
					AsdWsm_BSSOp(BSSIndex, WID_MODIFY, 0);						
				}
			}
		}
		else if (AC_WLAN[wlanid] != NULL && (AC_WLAN[wlanid]->want_to_delete == 1))		/* Huangleilei add for ASXXZFI-1622 */
		{
			ret = WID_WANT_TO_DELETE_WLAN;
		}
		else{
			ret = WLAN_ID_NOT_EXIST;
		}
	}
	reply = dbus_message_new_method_return(msg1);
		
	dbus_message_iter_init_append(reply, &iter1);
		
	dbus_message_iter_append_basic(&iter1, DBUS_TYPE_UINT32, &ret);

	return reply;	
}

#endif
DBusMessage * wid_dbus_interface_wlan_service_control_timer(DBusConnection *conn, DBusMessage *msg1, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusMessageIter  iter1;
	DBusError err;	
	int ret = WID_DBUS_SUCCESS;
//	int i;
//	int j;
	unsigned char wlanid;
	unsigned int policy;
	unsigned int is_once;
	unsigned int time;
	unsigned int wday;
	dbus_error_init(&err);
	
	dbus_message_iter_init(msg1,&iter);
	dbus_message_iter_get_basic(&iter,&policy);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&wlanid);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&is_once);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&time);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&wday);

	if(AC_WLAN[wlanid] != NULL && (AC_WLAN[wlanid]->want_to_delete != 1)){		/* Huangleilei add for ASXXZFI-1622 */
		if(policy == 1){
			if(AC_WLAN[wlanid]->StartService.TimerState == 0){
				memset(&(AC_WLAN[wlanid]->StartService), 0, sizeof(WID_WSC));
				AC_WLAN[wlanid]->StartService.times = time;
				AC_WLAN[wlanid]->StartService.is_once = is_once;
				if(wday & 0x01){
					AC_WLAN[wlanid]->StartService.wday[1] = 1;
				}
				if(wday & 0x02){
					AC_WLAN[wlanid]->StartService.wday[2] = 1;
				}
				if(wday & 0x04){
					AC_WLAN[wlanid]->StartService.wday[3] = 1;
				}
				if(wday & 0x08){
					AC_WLAN[wlanid]->StartService.wday[4] = 1;
				}
				if(wday & 0x10){
					AC_WLAN[wlanid]->StartService.wday[5] = 1;
				}
				if(wday & 0x20){
					AC_WLAN[wlanid]->StartService.wday[6] = 1;
				}
				if(wday & 0x40){
					AC_WLAN[wlanid]->StartService.wday[0] = 1;
				}
				
			}else{
				ret = WLAN_SERVICE_CONTROL_BE_USED;
			}
		}else{
			if(AC_WLAN[wlanid]->StopService.TimerState == 0){
				memset(&(AC_WLAN[wlanid]->StopService), 0, sizeof(WID_WSC));
				
				AC_WLAN[wlanid]->StopService.times = time;
				AC_WLAN[wlanid]->StopService.is_once = is_once;
				if(wday & 0x01){
					AC_WLAN[wlanid]->StopService.wday[1] = 1;
				}
				if(wday & 0x02){
					AC_WLAN[wlanid]->StopService.wday[2] = 1;
				}
				if(wday & 0x04){
					AC_WLAN[wlanid]->StopService.wday[3] = 1;
				}
				if(wday & 0x08){
					AC_WLAN[wlanid]->StopService.wday[4] = 1;
				}
				if(wday & 0x10){
					AC_WLAN[wlanid]->StopService.wday[5] = 1;
				}
				if(wday & 0x20){
					AC_WLAN[wlanid]->StopService.wday[6] = 1;
				}
				if(wday & 0x40){
					AC_WLAN[wlanid]->StopService.wday[0] = 1;
				}
			}else{
				ret = WLAN_SERVICE_CONTROL_BE_USED;
			}
		}
	}
	else if (AC_WLAN[wlanid] != NULL && (AC_WLAN[wlanid]->want_to_delete == 1))		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else{
		ret = WLAN_ID_NOT_EXIST;
	}
	reply = dbus_message_new_method_return(msg1);
		
	dbus_message_iter_init_append(reply, &iter1);
		
	dbus_message_iter_append_basic(&iter1, DBUS_TYPE_UINT32, &ret);

	return reply;	
}

DBusMessage *wid_dbus_set_wireless_interface_vmac(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter	 iter;
	DBusError err;	
	dbus_error_init(&err);
	int ret = 0; 
	unsigned int policy;
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_INVALID))){
	
		printf("Unable to get input args\n");
					
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	set_vmac_state = policy;
	if((set_vmac_state == 0)&&(set_vmac == 1)){
		set_wid_src_mac();
	}
	else if((set_vmac_state == 1)&&(is_secondary != 2)&&(set_vmac == 0)){
		set_wid_mac(v_mac,1);
		set_vmac = 1;
	}
		
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;

}

DBusMessage *wid_dbus_set_wtp_link_detect(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	unsigned char type;
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&type,
								DBUS_TYPE_INVALID))){

				
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return NULL;
	}
	reply = dbus_message_new_method_return(msg);
	wtp_link_detect = type;
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
		
	return reply;	

}

DBusMessage *wid_dbus_set_wsm_switch(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	unsigned int type;
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_INVALID))){

				
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return NULL;
	}
	reply = dbus_message_new_method_return(msg);
	if(wsmswitch != type){		
		int fd = open("/dev/wifi0", O_RDWR);		
		ret = ioctl(fd, WIFI_IOC_WSM_SWITCH, &type);
		wsmswitch = type;
		close(fd);
	}
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
		
	return reply;	

}

DBusMessage *wid_dbus_set_vlan_switch(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	unsigned char type;
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&type,
								DBUS_TYPE_INVALID))){

				
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return NULL;
	}
	reply = dbus_message_new_method_return(msg);
	if(vlanSwitch != type){		
		vlanSwitch = type;
		UpdateWifiHansiState();
	}
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
		
	return reply;	

}

DBusMessage *wid_dbus_set_dhcp_option82_switch(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	unsigned char type;
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&type,
								DBUS_TYPE_INVALID))){

				
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return NULL;
	}
	reply = dbus_message_new_method_return(msg);
	if(DhcpOption82Switch != type){		
		DhcpOption82Switch = type;
		UpdateWifiHansiState();
	}
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
		
	return reply;	

}


DBusMessage *wid_dbus_add_ap_group(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage * reply;
	DBusMessageIter	 iter;
	char* Name;
	unsigned int ID;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_STRING,&Name,
								DBUS_TYPE_INVALID))){

		wid_syslog_err("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			wid_syslog_err("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(WTP_GROUP[ID] == NULL){
		ret = create_ap_group(ID,Name);
	}else{
		ret = GROUP_ID_EXIST;
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
	
}
DBusMessage *wid_dbus_del_ap_group(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage * reply;
	DBusMessageIter	 iter;
//	char* IFName;
	unsigned int ID;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_INVALID))){

		wid_syslog_err("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			wid_syslog_err("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(WTP_GROUP[ID] != NULL){		
		wid_syslog_debug_debug(WID_DEFAULT, "delete ap-group %d\n", ID);
		ret = delete_ap_group(ID);		
	}else{
		wid_syslog_debug_debug(WID_DEFAULT, "ap-group %d is not exist\n", ID);
		ret = GROUP_ID_NOT_EXIST;
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
	
}

DBusMessage *wid_dbus_show_ap_group_all(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusMessageIter  iter1;
	DBusError err;	
	int ret = WID_DBUS_SUCCESS;
	unsigned int count = 0;
	int i; 
	
	dbus_error_init(&err);
	
	dbus_message_iter_init(msg,&iter);	

	for (i=0; i<WTP_GROUP_NUM; i++) {
		if (WTP_GROUP[i] != NULL) {
			count++;
		}
	}
    
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter1);
		
	dbus_message_iter_append_basic(&iter1, DBUS_TYPE_UINT32, &ret);

	dbus_message_iter_append_basic (&iter1,	DBUS_TYPE_UINT32, &count);

	for (i=0; i<WTP_GROUP_NUM; i++) {
		if (WTP_GROUP[i] != NULL) {
			dbus_message_iter_append_basic(&iter1,
											DBUS_TYPE_UINT32,
											&WTP_GROUP[i]->GID
											);
			dbus_message_iter_append_basic(&iter1,
											DBUS_TYPE_STRING,
											&WTP_GROUP[i]->GNAME
											);
		}
	}

	return reply;	
}

DBusMessage *wid_dbus_show_ap_group_members_all(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	unsigned int count = 0;
	int i; 
	struct WTP_GROUP_MEMBER *temp;
	DBusMessageIter	 iter_array;
	dbus_error_init(&err);
	
	dbus_message_iter_init(msg,&iter);	

	for (i=0; i<WTP_GROUP_NUM; i++) {
		if (WTP_GROUP[i] != NULL) {
			count++;
		}
	}
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	dbus_message_iter_append_basic (&iter, DBUS_TYPE_UINT32, &count);

	for (i=0; i<WTP_GROUP_NUM; i++) {
		if (WTP_GROUP[i] != NULL) {
			dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &WTP_GROUP[i]->GID);
			dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &WTP_GROUP[i]->GNAME);
			dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &WTP_GROUP[i]->WTP_COUNT);

			dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);
			
			temp = WTP_GROUP[i]->WTP_M;
			while (temp) {
				DBusMessageIter iter_struct;
				dbus_message_iter_open_container(&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
 				dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT32, &temp->WTPID);
				dbus_message_iter_close_container (&iter_array, &iter_struct);
				temp = temp->next;
			}
		}
		dbus_message_iter_close_container (&iter, &iter_array);
	}

	return reply;	
}

/* add by zhangshu  2010-09-16 */
DBusMessage *wid_dbus_show_ap_group_member(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;	
	int ret = WID_DBUS_SUCCESS;
//	unsigned int i =0;
	unsigned int groupid;
	unsigned int wtpid;
	unsigned int count = 0;
	//unsigned int *wtp_list;
	DBusMessageIter	 iter_array;
	struct WTP_GROUP_MEMBER * temp = NULL;
	dbus_error_init(&err);
	
	dbus_message_iter_init(msg,&iter);	
	dbus_message_iter_get_basic(&iter,&groupid);
	
	//wtp_list = malloc(num*sizeof(unsigned int));
	//memset(wtp_list, 0, num*sizeof(unsigned int));

    if(WTP_GROUP[groupid] == NULL) {
		wid_syslog_debug_debug(WID_DEFAULT, "ap-group %d is not exist\n", groupid);
		ret = GROUP_ID_NOT_EXIST;
    } else {
        count = WTP_GROUP[groupid]->WTP_COUNT;
		wid_syslog_debug_debug(WID_DEFAULT, "ap-group %u member count %u\n", groupid, count);
    }
    
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	dbus_message_iter_append_basic (&iter,	DBUS_TYPE_UINT32, &count);

	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);
	
	if(ret == WID_DBUS_SUCCESS)
	{
    	if(count != 0)
    	{
    		#if 0
    	    if(WTP_GROUP[groupid]->WTP_M != NULL)
    	    {
    	        printf("WTP_GROUP[groupid]->WTP_M->WTPID = %d\n",WTP_GROUP[groupid]->WTP_M->WTPID);
    	        if(WTP_GROUP[groupid]->WTP_M->hnext != NULL)
    	            printf("WTP_GROUP[groupid]->WTP_M->hnext->WTPID = %d\n",WTP_GROUP[groupid]->WTP_M->hnext->WTPID);
    	        if(WTP_GROUP[groupid]->WTP_M->next != NULL)
    	            printf("WTP_GROUP[groupid]->WTP_M->next->WTPID = %d\n",WTP_GROUP[groupid]->WTP_M->next->WTPID);   
    	    }
			#endif
    	    
        	temp = WTP_GROUP[groupid]->WTP_M;
        	while(temp != NULL)
        	{
        		DBusMessageIter iter_struct;
				
                wtpid = temp->WTPID;
				wid_syslog_debug_debug(WID_DEFAULT, "append wtp %u", wtpid);
				dbus_message_iter_open_container(&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
				dbus_message_iter_append_basic(&iter_struct, DBUS_TYPE_UINT32, &wtpid);
				wid_syslog_debug_debug(WID_DEFAULT, "done\n");
				dbus_message_iter_close_container (&iter_array, &iter_struct);
        		temp = temp->next;
        	}	
    	}
	}
	dbus_message_iter_close_container (&iter, &iter_array);
	return reply;	
}


DBusMessage *wid_dbus_add_del_ap_group_member(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply=NULL;
	DBusMessageIter  iter;
	DBusMessageIter  iter1;
	DBusError err;	
	int ret = WID_DBUS_SUCCESS;
	int ret1 = 0;
	unsigned int i =0;
	unsigned int groupid;
	unsigned int isadd;
	unsigned int num;
	unsigned int wtpid;
	unsigned int count = 0;
	unsigned int *wtp_list;
	DBusMessageIter  iter_array;
	
	dbus_error_init(&err);
	
	dbus_message_iter_init(msg,&iter);
	dbus_message_iter_get_basic(&iter,&isadd);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&groupid);
	wid_syslog_debug_debug(WID_DEFAULT, "%s for ap-group %d\n", isadd ? "add" : "delete", groupid);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&num);
	
	wid_syslog_debug_debug(WID_DEFAULT, "wtpnum =%d(0 for all)\n", num);

	if (num > 0) {
		wtp_list = WID_MALLOC(num*sizeof(unsigned int));
		if (!wtp_list) {
			ret = WID_DBUS_ERROR;
			wid_syslog_err("%s for ap-group %d malloc failed\n", isadd ? "add" : "delete", groupid);
			return reply;
		}
		memset(wtp_list, 0, num*sizeof(unsigned int));

		dbus_message_iter_next(&iter);	
		dbus_message_iter_recurse(&iter,&iter_array);

		for(i = 0; i < num; i++){
			DBusMessageIter iter_struct;
			dbus_message_iter_recurse(&iter_array,&iter_struct);
			dbus_message_iter_get_basic(&iter_struct,&wtpid);
			dbus_message_iter_next(&iter_array);
			wid_syslog_debug_debug(WID_DEFAULT, "wtpid %d\n",wtpid);

			if((isadd)&&(AC_WTP[wtpid]!=NULL)&&(AC_WTP[wtpid]->APGroupID == 0)){
				ret1 = add_ap_group_member(groupid,wtpid);
				wid_syslog_debug_debug(WID_DEFAULT, "ret1 %d for adding wtp %d to ap-group %d\n", ret1, wtpid, groupid);
				if (ret1 == WTP_BE_USING) {
					wid_syslog_debug_debug(WID_DEFAULT, "wtp %d at ap-group %d\n", wtpid, AC_WTP[wtpid]->APGroupID);
				}
				if (ret1 == WTP_ID_NOT_EXIST) {
					wid_syslog_debug_debug(WID_DEFAULT, "wtp %d not exist\n", wtpid);
				}
				if (ret1 == WID_DBUS_ERROR) {
					wid_syslog_debug_debug(WID_DEFAULT, "add ap-group %d for wtp %d malloc failed\n", groupid, wtpid);
				}
				if(ret1 == WTP_ID_NOT_EXIST || ret1 == WTP_BE_USING || ret1 == WID_DBUS_ERROR){
					wtp_list[count] = wtpid;
					count++;
				}
			}else if((isadd == 0) && (AC_WTP[wtpid]!=NULL)){
				if (AC_WTP[wtpid]->APGroupID == groupid) {
					ret1 = del_ap_group_member(groupid,wtpid);
					//wid_syslog_debug_debug(WID_DEFAULT, "ret1111 %d for deleting wtp %d from ap-group %d\n", ret1, wtpid, groupid);
				} else {
					wid_syslog_debug_debug(WID_DEFAULT, "wtp %d not at ap-group %d", wtpid, groupid);
				}
			}else{
				wid_syslog_err("unknow operate for wtp %d\n", wtpid);
				wtp_list[count] = wtpid;
				count++;
			}
		}
	} else {
		wid_syslog_debug_debug(WID_DEFAULT, "%s for ap-group %d all\n", isadd ? "add" : "delete", groupid);
		count = 0;
		
		//is group is exist
		if (WTP_GROUP[groupid] == NULL) {
			wid_syslog_err("ap-group %d is not exist\n", groupid);
			ret = WID_DBUS_ERROR;
		} else {
			wtp_list = WID_MALLOC(WTP_NUM*sizeof(unsigned int));
			//is malloc for result success
			if (!wtp_list) {
				ret = WID_DBUS_ERROR;
				wid_syslog_err("%s for ap-group %d malloc failed\n", isadd ? "add" : "delete", groupid);
			} else {
				memset(wtp_list, 0, WTP_NUM*sizeof(unsigned int));
				if (isadd) {
					for (i=1; i<WTP_NUM; i++) {
						if (AC_WTP[i] != NULL && AC_WTP[i]->APGroupID == 0) {
							ret1 = add_ap_group_member(groupid, i);
							if (ret1 != 0) {
								wtp_list[count] = i;
								count++;
							}
						}
					}
				} else {
					for (i=1; i<WTP_NUM; i++) {
						if (AC_WTP[i] != NULL && AC_WTP[i]->APGroupID == groupid)
							ret1 = del_ap_group_member(groupid, i);
					}
				}
			}
		}
	}
		
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter1);
		
	dbus_message_iter_append_basic(&iter1, DBUS_TYPE_UINT32, &ret);
	
	dbus_message_iter_append_basic (&iter1,
										 DBUS_TYPE_UINT32,
										 &count);
	wid_syslog_debug_debug(WID_DEFAULT, "count %d\n",count);
	for(i = 0; i < count; i++){
		
		dbus_message_iter_append_basic (&iter1,
											 DBUS_TYPE_UINT32,
											 &(wtp_list[i]));
		wid_syslog_debug_debug(WID_DEFAULT, "wtp_list[i] %d\n",wtp_list[i]);
	}	
	WID_FREE(wtp_list);
	wtp_list = NULL;
	return reply;	
}

DBusMessage *wid_dbus_ap_group_config(DBusConnection *conn, DBusMessage *msg, void *user_data){
	
	DBusMessage * reply;
	DBusMessageIter	 iter;
//	char* IFName;
	unsigned int ID;
	unsigned int ret = WID_DBUS_SUCCESS;
	DBusError err;
	
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&ID,
								DBUS_TYPE_INVALID))){

		wid_syslog_err("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			wid_syslog_err("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(WTP_GROUP[ID] == NULL)
		ret = WLAN_ID_NOT_EXIST;
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;
	
}

DBusMessage * wid_dbus_interface_radio_timer_able(DBusConnection *conn, DBusMessage *msg1, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusMessageIter  iter1;
	DBusError err;	
	int ret = WID_DBUS_SUCCESS;
//	int i;
//	int j;
	unsigned int radioid;
	unsigned int policy;
	int timerflag = 0;	
	time_t timep;  
	struct tm *p; 
	int times;	
	int timer;
	dbus_error_init(&err);
	
	dbus_message_iter_init(msg1,&iter);
	dbus_message_iter_get_basic(&iter,&policy);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&timerflag);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&radioid);
printf("1\n");
	if(timerflag == 1){
		
		printf("2\n");
		if(AC_RADIO[radioid] != NULL){
			printf("3\n");

			if(AC_RADIO[radioid]->StartService.TimerState != policy){
				printf("4\n");

				if(policy == 1){
					printf("5\n");

					AC_RADIO[radioid]->StartService.TimerState = policy;
					time(&timep);  
					p=localtime(&timep);
					
					printf("start time %d:%d:%d\n",p->tm_hour,p->tm_min,p->tm_sec);
					times = p->tm_hour*3600 + p->tm_min*60 + p->tm_sec;
					if(times < AC_RADIO[radioid]->StartService.times){
						timer = AC_RADIO[radioid]->StartService.times - times; 
					}else{
						timer = 24*3600 - times + AC_RADIO[radioid]->StartService.times;
					}
					printf("6\n");
					printf("times %d\n",times);
					printf(" AC_WLAN[wlanid]->StartService.times %d\n", AC_RADIO[radioid]->StartService.times);
					printf("timer %d \n",timer);

					if(!(CWTimerRequest(timer, NULL, &(AC_RADIO[radioid]->StartService.TimerID), 503,radioid))) {
						ret = WID_DBUS_ERROR;
					}	
					
					printf("AC_WLAN[wlanid]->StartService.TimerID11111111 %d\n",AC_RADIO[radioid]->StartService.TimerID);
					printf("7\n");

				}else{
					AC_RADIO[radioid]->StartService.TimerState = policy;
					printf("AC_WLAN[wlanid]->StartService.TimerID22222222 %d\n",AC_RADIO[radioid]->StartService.TimerID);
					if(!CWTimerCancel(&(AC_RADIO[radioid]->StartService.TimerID),1)) {
						ret = WID_DBUS_ERROR;
					}
				}
			}
		}
	}
	else if(timerflag == 0){
		if(AC_RADIO[radioid] != NULL){
			if(AC_RADIO[radioid]->StopService.TimerState != policy){
				if(policy == 1){
					AC_RADIO[radioid]->StopService.TimerState = policy;
					time(&timep);  
					p=localtime(&timep);
					printf("stop time %d:%d:%d\n",p->tm_hour,p->tm_min,p->tm_sec);
					times = p->tm_hour*3600 + p->tm_min*60 + p->tm_sec;
					if(times < AC_RADIO[radioid]->StopService.times){
						timer = AC_RADIO[radioid]->StopService.times -times; 
					}else{
						timer = 24*3600 - times + AC_RADIO[radioid]->StopService.times;
					}
					printf("times %d\n",times);
					printf(" AC_WLAN[wlanid]->StopService.times %d\n", AC_RADIO[radioid]->StopService.times);
					printf("timer %d \n",timer);
					if(!(CWTimerRequest(timer, NULL, &(AC_RADIO[radioid]->StopService.TimerID), 504,radioid))) {
						ret = WID_DBUS_ERROR;
					}		
					printf("AC_WLAN[wlanid]->StopService.TimerID11111111 %d\n",AC_RADIO[radioid]->StopService.TimerID);
				}else{
					AC_RADIO[radioid]->StopService.TimerState = policy;
					printf("AC_WLAN[wlanid]->StopService.TimerID22222222 %d\n",AC_RADIO[radioid]->StopService.TimerID);
					if(!CWTimerCancel(&(AC_RADIO[radioid]->StopService.TimerID),1)) {
						ret = WID_DBUS_ERROR;
					}
				}
			}
		}
	}
	
	reply = dbus_message_new_method_return(msg1);
		
	dbus_message_iter_init_append(reply, &iter1);
		
	dbus_message_iter_append_basic(&iter1, DBUS_TYPE_UINT32, &ret);

	return reply;	
}

DBusMessage * wid_dbus_interface_radio_multi_user_optimize_switch(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage *reply;
	DBusMessageIter iter;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	unsigned char wlanid = 0 ; 
	unsigned int radioid = 0 ; 
	unsigned char type  = 0 ;
	unsigned int i = 0 ; 
	dbus_error_init(&err);
	if(!(dbus_message_get_args(msg,&err,
						DBUS_TYPE_BYTE,&wlanid,
						DBUS_TYPE_UINT32,&radioid,
						DBUS_TYPE_BYTE,&type,
						DBUS_TYPE_INVALID))){
		printf("Unable to get input args\n");
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(AC_RADIO[radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	if(ret == WID_DBUS_SUCCESS)
	{
		ret = Wlan_IF_NOT_BE_BINDED;
		for( i = 0 ; i < L_BSS_NUM ; i++)
		{
			if((AC_RADIO[radioid]->BSS[i] != NULL)&&(AC_BSS[radioid*L_BSS_NUM+i] != NULL)&&(AC_RADIO[radioid]->BSS[i]->WlanID ==wlanid))
			{
				ret = WID_DBUS_SUCCESS;
				break;
			}
			continue;
		}
		if(ret == WID_DBUS_SUCCESS)
		{
			if(AC_RADIO[radioid]->BSS[i]->multi_user_optimize_switch != type){
				AC_RADIO[radioid]->BSS[i]->multi_user_optimize_switch = type;
				muti_user_optimize_switch(wlanid,radioid,type);
			}
		}
	}
	
	reply = dbus_message_new_method_return(msg);		
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 
	return reply;	

}

DBusMessage * wid_dbus_interface_wtp_5g_switch(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage *reply;
	DBusMessageIter iter;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	unsigned char wlanid = 0 ; 
	unsigned int wtpid = 0 ; 
	unsigned char type  = 0 ;
	unsigned int i = 0 ; 
	dbus_error_init(&err);
	if(!(dbus_message_get_args(msg,&err,
						DBUS_TYPE_BYTE,&wlanid,
						DBUS_TYPE_UINT32,&wtpid,
						DBUS_TYPE_BYTE,&type,
						DBUS_TYPE_INVALID))){
		printf("Unable to get input args\n");
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(0 == wtpid){
		wid_syslog_debug_debug(WID_DBUS,"%s,%d,wtpid=%d(0 -- all wtp),type=%d.\n",__func__,__LINE__,wtpid,type);
		g_radio_5g_sw = type;
		for(i=1;i<WTP_NUM;i++){
			if((AC_WTP[i] != NULL)&&(AC_WTP[i]->RadioCount >= 2)){
				AC_WTP[i]->radio_5g_sw = type;
				set_wtp_5g_switch(i,type);
			}
		}
	}else{
		if(!check_wtpid_func(wtpid)){
			ret = RADIO_ID_NOT_EXIST;
		}else{
			if(AC_WTP[wtpid] == NULL){
				ret = WTP_ID_NOT_EXIST;
			}else{
				if(AC_WTP[wtpid]->RadioCount < 2){
					ret = WID_SINGLE_RADIO;
				}else{
					AC_WTP[wtpid]->radio_5g_sw = type;
					set_wtp_5g_switch(wtpid,type);
					wid_syslog_debug_debug(WID_DBUS,"%s,%d,wtpid=%d,type=%d.\n",__func__,__LINE__,wtpid,type);
				}
			}
		}
	}
	
	wid_syslog_debug_debug(WID_DBUS,"%s,%d,wtpid=%d,type=%d,ret=%d.\n",__func__,__LINE__,wtpid,type,ret);
	reply = dbus_message_new_method_return(msg);		
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 
	return reply;	

}

DBusMessage * wid_dbus_interface_set_whole_wlan_bss_multi_user_optimize_switch(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage *reply;
	DBusMessageIter iter;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	unsigned char wlanid = 0 ; 
	unsigned char type = 0 ;
	unsigned int radioid = 0; 
	unsigned int m,m1,i ; 
	dbus_error_init(&err);
	if(!(dbus_message_get_args(msg,&err,
						DBUS_TYPE_BYTE,&wlanid,
						DBUS_TYPE_BYTE,&type,
						DBUS_TYPE_INVALID))){
		printf("Unable to get input args\n");
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	wid_syslog_debug_debug(WID_DEFAULT,"wlanid = %d\n",wlanid );
	 if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	 else
	 {
			AC_WLAN[wlanid]->multi_user_optimize_switch = type; 
			for( m = 0 ;  m <WTP_NUM ; m ++ )
			{
				if(AC_WTP[m] != NULL)
				{
					for( m1 = 0 ; m1 < AC_WTP[m]->RadioCount ; m1++)
					{
						if(AC_WTP[m]->WTP_Radio[m1]!=NULL)
						{
							radioid = AC_WTP[m]->WTP_Radio[m1]->Radio_G_ID;
							for( i = 0 ; i < L_BSS_NUM ; i++)
							{
								if((AC_RADIO[radioid]->BSS[i] != NULL)&&(AC_BSS[radioid*L_BSS_NUM+i] != NULL)&&(AC_RADIO[radioid]->BSS[i]->WlanID ==wlanid))
								{
								
									if(AC_RADIO[radioid]->BSS[i]->multi_user_optimize_switch != type){
										AC_RADIO[radioid]->BSS[i]->multi_user_optimize_switch = type;
										muti_user_optimize_switch(wlanid,radioid,type);
										ret = WID_DBUS_SUCCESS;
										break;
									}
								continue;
								}
							}
						}
					}
				}
	 		}				
	 }
	reply = dbus_message_new_method_return(msg);		
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 
	return reply;	

}

DBusMessage * wid_dbus_interface_radio_service_control_timer(DBusConnection *conn, DBusMessage *msg1, void *user_data)
{
	DBusMessage * reply;
	DBusMessageIter  iter;
	DBusMessageIter  iter1;
	DBusError err;	
	int ret = WID_DBUS_SUCCESS;
//	int i;
//	int j;
	unsigned int radioid;
	unsigned int policy;
	unsigned int is_once;
	unsigned int time;
	unsigned int wday;
	dbus_error_init(&err);
	
	dbus_message_iter_init(msg1,&iter);
	dbus_message_iter_get_basic(&iter,&policy);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&radioid);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&is_once);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&time);

	dbus_message_iter_next(&iter);	
	dbus_message_iter_get_basic(&iter,&wday);

	if(AC_RADIO[radioid] != NULL){
		if(policy == 1){
			if(AC_RADIO[radioid]->StartService.TimerState == 0){
				memset(&(AC_RADIO[radioid]->StartService), 0, sizeof(WID_WSC));
				AC_RADIO[radioid]->StartService.times = time;
				AC_RADIO[radioid]->StartService.is_once = is_once;
				if(wday & 0x01){
					AC_RADIO[radioid]->StartService.wday[1] = 1;
				}
				if(wday & 0x02){
					AC_RADIO[radioid]->StartService.wday[2] = 1;
				}
				if(wday & 0x04){
					AC_RADIO[radioid]->StartService.wday[3] = 1;
				}
				if(wday & 0x08){
					AC_RADIO[radioid]->StartService.wday[4] = 1;
				}
				if(wday & 0x10){
					AC_RADIO[radioid]->StartService.wday[5] = 1;
				}
				if(wday & 0x20){
					AC_RADIO[radioid]->StartService.wday[6] = 1;
				}
				if(wday & 0x40){
					AC_RADIO[radioid]->StartService.wday[0] = 1;
				}
				
			}else{
				ret = RADIO_SERVICE_CONTROL_BE_USED;
			}
		}else{
			if(AC_RADIO[radioid]->StopService.TimerState == 0){
				memset(&(AC_RADIO[radioid]->StopService), 0, sizeof(WID_WSC));
				
				AC_RADIO[radioid]->StopService.times = time;
				AC_RADIO[radioid]->StopService.is_once = is_once;
				if(wday & 0x01){
					AC_RADIO[radioid]->StopService.wday[1] = 1;
				}
				if(wday & 0x02){
					AC_RADIO[radioid]->StopService.wday[2] = 1;
				}
				if(wday & 0x04){
					AC_RADIO[radioid]->StopService.wday[3] = 1;
				}
				if(wday & 0x08){
					AC_RADIO[radioid]->StopService.wday[4] = 1;
				}
				if(wday & 0x10){
					AC_RADIO[radioid]->StopService.wday[5] = 1;
				}
				if(wday & 0x20){
					AC_RADIO[radioid]->StopService.wday[6] = 1;
				}
				if(wday & 0x40){
					AC_RADIO[radioid]->StopService.wday[0] = 1;
				}
			}else{
				ret = RADIO_SERVICE_CONTROL_BE_USED;
			}
		}
	}else{
		ret = RADIO_ID_NOT_EXIST;
	}
	reply = dbus_message_new_method_return(msg1);
		
	dbus_message_iter_init_append(reply, &iter1);
		
	dbus_message_iter_append_basic(&iter1, DBUS_TYPE_UINT32, &ret);

	return reply;	
}

DBusMessage * wid_dbus_wlan_show_running_config_start(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusMessageIter  iter;
	unsigned char num=0;
	char *showStr = NULL,*cursor = NULL;
	int totalLen = 0;
	int str_len = 0;    //fengwenchao add 20110504
	char *showStr_new = NULL;   //fengwenchao add 20110504
	DBusError err;
	//int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	int i=0;
	WID_WLAN *WLAN[WLAN_NUM];
	while(i<WLAN_NUM){
		if(AC_WLAN[i] != NULL && AC_WLAN[i]->want_to_delete != 1)		/* Huangleilei check wlan operation */
		{
			WLAN[num] = AC_WLAN[i];
			num++;
		}
		i++;
	}
	
	if(num == 0){
		showStr = (char*)WID_MALLOC(1024);		
		memset(showStr,0,1024);
		cursor = showStr;

		if(g_wid_wsm_error_handle_state != WID_WSM_ERROR_HANDLE_STATE_DEFAULT){
		totalLen += sprintf(cursor,"set wid error handle %s\n", g_wid_wsm_error_handle_state ? "enable":"disable");
		cursor = showStr + totalLen; 

	   }
		if(WID_WATCH_DOG_OPEN == 1){
			totalLen += sprintf(cursor,"set wid watch dog open\n");
			cursor = showStr + totalLen;
		}
		if(ApAccessNat == 1){
			totalLen += sprintf(cursor,"set ap access through nat enable\n");
			cursor = showStr + totalLen;
		}		
		if(set_vmac_state == 1){
			totalLen += sprintf(cursor,"set wireless interface vmac enable\n");
			cursor = showStr + totalLen;			
		}		
		if(dbus_count_switch == 1){
			totalLen += sprintf(cursor,"set wid dbus count enable\n");
			cursor = showStr + totalLen;
		}
		if(wtp_link_detect == 1){
			totalLen += sprintf(cursor,"set wtp link detect enable\n");
			cursor = showStr + totalLen;
		}		
		/*if(wsmswitch == 1){//wuwl del.share mem has been removed,so cannot get msg from wsm.
			totalLen += sprintf(cursor,"set wsm switch enable\n");
			cursor = showStr + totalLen;
		}*/
		if(vlanSwitch == 1){
			totalLen += sprintf(cursor,"set vlan switch enable\n");
			cursor = showStr + totalLen;
		}
		if(DhcpOption82Switch == 1){
			totalLen += sprintf(cursor,"set dhcp option82 switch enable\n");
			cursor = showStr + totalLen;
		}
		if(multicast_listen_state == 1){
			totalLen += sprintf(cursor,"set wireless multicast listen enable\n");
			cursor = showStr + totalLen;
		}
		wid_syslog_debug_debug(WID_DBUS,"no wlan config");
	}else{
		showStr = (char*)WID_MALLOC(num*1024);
		str_len = num*1024;    //fengwenchao add 20110504
		if(NULL == showStr) {
			//printf(("memory WID_MALLOC error\n"));
			wid_syslog_crit("memory malloc error\n");
			//return NULL;
		}else{
			memset(showStr,0,num*1024);
			cursor = showStr;	
			if(g_wid_wsm_error_handle_state != WID_WSM_ERROR_HANDLE_STATE_DEFAULT){
			  totalLen += sprintf(cursor,"set wid error handle %s\n", g_wid_wsm_error_handle_state ? "enable":"disable");
			  cursor = showStr + totalLen; 

	       }
			if(WID_WATCH_DOG_OPEN == 1){
				totalLen += sprintf(cursor,"set wid watch dog open\n");
				cursor = showStr + totalLen;
			}			
			if(ApAccessNat == 1){
				totalLen += sprintf(cursor,"set ap access through nat enable\n");
				cursor = showStr + totalLen;
			}
			if(ac_flow_num_balance_flag.state !=0)
			{
				totalLen += sprintf(cursor,"set ac balance method %s\n",(ac_flow_num_balance_flag.state == 1)?"number":"flow");
				cursor = showStr + totalLen; 
			}
			if(ac_flow_num_balance_flag.num_balance_para != 1)
			{
				totalLen += sprintf(cursor,"set ac number balance parameter %d\n",ac_flow_num_balance_flag.num_balance_para);
				cursor = showStr + totalLen; 
			}
			if(ac_flow_num_balance_flag.flow_balance_para != 1)
			{
				totalLen += sprintf(cursor,"set ac flow balance parameter %d\n",ac_flow_num_balance_flag.flow_balance_para);
				cursor = showStr + totalLen; 
			}			
			if(set_vmac_state == 1){
				totalLen += sprintf(cursor,"set wireless interface vmac enable\n");
				cursor = showStr + totalLen;			
			}		
			if(dbus_count_switch == 1){
				totalLen += sprintf(cursor,"set wid dbus count enable\n");
				cursor = showStr + totalLen;
			}
			if(wtp_link_detect == 1){
				totalLen += sprintf(cursor,"set wtp link detect enable\n");
				cursor = showStr + totalLen;
			}			
			/*if(wsmswitch == 1){//wuwl del.share mem has been removed,so cannot get msg from wsm.
				totalLen += sprintf(cursor,"set wsm switch enable\n");
				cursor = showStr + totalLen;
			}*/
			if(vlanSwitch == 1){
				totalLen += sprintf(cursor,"set vlan switch enable\n");
				cursor = showStr + totalLen;
			}			
			if(DhcpOption82Switch == 1){
				totalLen += sprintf(cursor,"set dhcp option82 switch enable\n");
				cursor = showStr + totalLen;
			}
			if(multicast_listen_state == 1){
				totalLen += sprintf(cursor,"set wireless multicast listen enable\n");
				cursor = showStr + totalLen;
			}
			/*fengwenchao add 20120323*/
			if(gWLAN_MAX_ALLOWED_STA_NUM_FOR_BSS != 128)
			{
				totalLen += sprintf(cursor," set wlan bss allow max stanum %d\n",gWLAN_MAX_ALLOWED_STA_NUM_FOR_BSS);
				cursor = showStr + totalLen;
			}
			if(gWLAN_ATH_L2_ISOLATION != 0)
			{
				totalLen += sprintf(cursor," set wlan l2 isolation enable\n");
				cursor = showStr + totalLen;
			}
			if(gWLAN_STA_STATIC_ARP_POLICY.policy != 0)
			{
				totalLen += sprintf(cursor," set wlan bss sta_static_arp enable base %s\n",gWLAN_STA_STATIC_ARP_POLICY.arp_ifname);
				cursor = showStr + totalLen;				
			}
			if(gWLAN_LIMIT_STA_RSSI != 0)
			{
				totalLen += sprintf(cursor," set  wlan access sta limit rssi %d\n",gWLAN_LIMIT_STA_RSSI);
				cursor = showStr + totalLen;				
			}
			
			if(g_auto_add_radio_to_ebr != 0)
			{
				totalLen += sprintf(cursor," set  radio auto add to ebr enable\n");
				cursor = showStr + totalLen;
			}
			
			if((gWLAN_UNI_MUTI_BRO_CAST.multicast_broadcast_policy ==1)||(gWLAN_UNI_MUTI_BRO_CAST.unicast_policy == 1)
				||(gWLAN_UNI_MUTI_BRO_CAST.rate != 10)||(gWLAN_UNI_MUTI_BRO_CAST.wifi_policy != 0))	
			{
				if((gWLAN_UNI_MUTI_BRO_CAST.multicast_broadcast_policy ==1)&&(gWLAN_UNI_MUTI_BRO_CAST.unicast_policy == 1))
				{
					totalLen += sprintf(cursor," set wlan unicast_and_multicast_broadcas isolation enable\n");
					cursor = showStr + totalLen;					
				}
				else if(gWLAN_UNI_MUTI_BRO_CAST.unicast_policy == 1)
				{	
					totalLen += sprintf(cursor," set wlan unicast isolation enable\n");
					cursor = showStr + totalLen;					
				}
				else if(gWLAN_UNI_MUTI_BRO_CAST.multicast_broadcast_policy == 1)
				{	
					totalLen += sprintf(cursor," set wlan multicast_broadcast isolation enable\n");
					cursor = showStr + totalLen;					
				}
				if(gWLAN_UNI_MUTI_BRO_CAST.wifi_policy == 1)
				{	
					totalLen += sprintf(cursor," set wlan wifi isolation enable\n");
					cursor = showStr + totalLen;					
				}	
				if(gWLAN_UNI_MUTI_BRO_CAST.rate != 10)
				{	
					totalLen += sprintf(cursor," set wlan multicast_broadcast_rate %d\n",gWLAN_UNI_MUTI_BRO_CAST.rate);
					cursor = showStr + totalLen;					
				}					
			}
			for(i=0; i<num; i++){		
				/*fengwenchao add 20110504*/
				if(totalLen + 1024 > str_len) {
					str_len *= 2;
					showStr_new = (char*)realloc(showStr,str_len);
					if(showStr_new == NULL){
						wid_syslog_info("show running realloc failed\n");
						break;
					}else {
						showStr = showStr_new;
						memset(showStr+str_len/2,0,str_len/2);
						showStr_new = NULL;
					}
					wid_syslog_debug_debug(WID_DBUS,"show running totalLen %d realloc strlen %d\n",totalLen,str_len);
				}
				cursor = showStr + totalLen;
				/*fengwenchao add end*/				
				if(WLAN[i] != NULL && WLAN[i]->want_to_delete != 1 && WLAN[i]->chinaEssid == 0){		/* Huangleilei check wlan operation */
					totalLen += sprintf(cursor,"create wlan %d %s %s\n",WLAN[i]->WlanID,WLAN[i]->WlanName,WLAN[i]->ESSID);
					cursor = showStr + totalLen;
				}else if(WLAN[i] != NULL && WLAN[i]->want_to_delete != 1 && WLAN[i]->chinaEssid == 1){	/* Huangleilei check wlan operation */
					totalLen += sprintf(cursor,"create wlan_ascii %d %s %s\n",WLAN[i]->WlanID,WLAN[i]->WlanName,WLAN[i]->ESSID_CN_STR);
					cursor = showStr + totalLen;
				}
				if((((int)WLAN[i]->SecurityID > 0)||(WLAN[i]->Wlan_Ifi != NULL)||(WLAN[i]->HideESSid !=0)) && WLAN[i]->want_to_delete != 1){	/* Huangleilei check wlan operation */
					totalLen += sprintf(cursor," config wlan %d\n",WLAN[i]->WlanID);
					cursor = showStr + totalLen;
					if (WLAN[i]->ebr_id != 0) {
						totalLen += sprintf(cursor," add ebr %d\n",WLAN[i]->ebr_id);
						cursor = showStr + totalLen;
					}
					
					if((int)WLAN[i]->SecurityID > 0){
						totalLen += sprintf(cursor," apply securityID %d\n",WLAN[i]->SecurityID);
						cursor = showStr + totalLen;	
					}
					if((WLAN[i]->Wlan_Ifi != NULL)){
						struct ifi *tmp;
						tmp = WLAN[i]->Wlan_Ifi;							
						while(tmp != NULL){
							/*
							if(tmp->isipv6addr == 1)
							{
								totalLen += sprintf(cursor," wlan apply ipv6interface %s\n",tmp->ifi_name);
								cursor = showStr + totalLen;
								tmp = tmp->ifi_next;
							}
							else
							*/
							/*fengwenchao add 20110504*/
							if(totalLen + 1024 > str_len) {
								str_len *= 2;
								showStr_new = (char*)realloc(showStr,str_len);
								if(showStr_new == NULL){
									wid_syslog_info("show running realloc failed\n");
									break;
								}else {
									showStr = showStr_new;
									memset(showStr+str_len/2,0,str_len/2);
									showStr_new = NULL;
								}
								wid_syslog_debug_debug(WID_DBUS,"show running totalLen %d realloc strlen %d\n",totalLen,str_len);
							}
							cursor = showStr + totalLen;
							/*fengwenchao add end*/	
							{
								/*if(tmp->nas_id_len == 0){  //fengwenchao comment 20111123
									totalLen += sprintf(cursor," wlan apply interface %s\n",tmp->ifi_name);
									cursor = showStr + totalLen;
									tmp = tmp->ifi_next;
								}else*/
								
								if(tmp->nas_id_len != 0)
								{
									char *nas_id = NULL;
									nas_id = WID_MALLOC(NAS_IDENTIFIER_NAME+1);
									if(nas_id == NULL)
									{
										printf("malloc error!\n");
										if(showStr){
											WID_FREE(showStr);
											showStr = NULL;
										}
										return NULL;
									}
									memset(nas_id,0,NAS_IDENTIFIER_NAME+1);
									memcpy(nas_id,tmp->nas_id,strlen(tmp->nas_id));
									nas_id[NAS_IDENTIFIER_NAME] = '\0';
									wid_syslog_debug_debug(WID_DEFAULT,"nas_id = %s\n",nas_id);
									totalLen += sprintf(cursor," wlan apply interface %s nas_identifier %s\n",tmp->ifi_name,nas_id);
									cursor = showStr + totalLen;
									tmp = tmp->ifi_next;
									WID_FREE(nas_id);
									nas_id = NULL;
								}
								else
									tmp = tmp->ifi_next;
							}
						}

					}
					if((int)WLAN[i]->HideESSid != 0){
						totalLen += sprintf(cursor," hideessid yes\n");
						cursor = showStr + totalLen;	
					}
					/*
					if(WLAN[i]->wlan_if_policy == WLAN_INTERFACE){						
						totalLen += sprintf(cursor,"wlan map interface\n");
						cursor = showStr + totalLen;	
					}else if(WLAN[i]->wlan_if_policy == BSS_INTERFACE){
						totalLen += sprintf(cursor,"wlan bss map interface\n");
						cursor = showStr + totalLen;	
					}
					*/
					if(WLAN[i]->wlan_max_allowed_sta_num!=65536){
						totalLen += sprintf(cursor," set wlan max sta num %d\n",WLAN[i]->wlan_max_allowed_sta_num);
						cursor = showStr + totalLen;
					}   //xm add 08/12/05
					/*fengwenchao add 20120331 for autelan-2886*/
					if(WLAN[i]->wlan_noResToStaProReqSW != 0)
					{
						totalLen += sprintf(cursor," set wlan no response to sta probe request enable\n");
						cursor = showStr + totalLen;						
					}
					/*fengwenchao add end*/
					/*fengwenchao add 20120323*/
					if(WLAN[i]->bss_allow_max_sta_num != gWLAN_MAX_ALLOWED_STA_NUM_FOR_BSS)
					{
						totalLen += sprintf(cursor," set wlan bss allow max stanum %d\n",WLAN[i]->bss_allow_max_sta_num);
						cursor = showStr + totalLen;						
					}
					if(WLAN[i]->wlan_ath_l2_isolation != gWLAN_ATH_L2_ISOLATION)
					{
						totalLen += sprintf(cursor," set wlan l2 isolation %s\n",(WLAN[i]->wlan_ath_l2_isolation == 1)?"enable":"disable");
						cursor = showStr + totalLen;	
					}
					if((WLAN[i]->wlan_sta_static_arp_policy != gWLAN_STA_STATIC_ARP_POLICY.policy)||(strcmp(WLAN[i]->wlan_arp_ifname,gWLAN_STA_STATIC_ARP_POLICY.arp_ifname) !=0))
					{
						totalLen += sprintf(cursor," set wlan bss sta_static_arp %s base %s\n",(WLAN[i]->wlan_sta_static_arp_policy == 1)?"enable":"disable",WLAN[i]->wlan_arp_ifname);
						cursor = showStr + totalLen;						
					}
					//wid_syslog_info("maddersky WLAN[i]->wlan_limit_sta_rssi = %d \n",WLAN[i]->wlan_limit_sta_rssi);
					//wid_syslog_info("maddersky gWLAN_LIMIT_STA_RSSI = %d \n",gWLAN_LIMIT_STA_RSSI);
					if(WLAN[i]->wlan_limit_sta_rssi != gWLAN_LIMIT_STA_RSSI)
					{
						totalLen += sprintf(cursor," set  wlan access sta limit rssi %d\n",WLAN[i]->wlan_limit_sta_rssi);
						cursor = showStr + totalLen;							
					}
					if((WLAN[i]->wlan_muti_bro_cast_sw != gWLAN_UNI_MUTI_BRO_CAST.multicast_broadcast_policy)||(WLAN[i]->wlan_unicast_sw != gWLAN_UNI_MUTI_BRO_CAST.unicast_policy)
						||(WLAN[i]->wlan_muti_rate != gWLAN_UNI_MUTI_BRO_CAST.rate)||(WLAN[i]->wlan_wifi_sw  != gWLAN_UNI_MUTI_BRO_CAST.wifi_policy))
					{
						if((WLAN[i]->wlan_muti_bro_cast_sw != gWLAN_UNI_MUTI_BRO_CAST.multicast_broadcast_policy)
							&&(WLAN[i]->wlan_unicast_sw !=  gWLAN_UNI_MUTI_BRO_CAST.unicast_policy)
							&&(WLAN[i]->wlan_muti_bro_cast_sw == WLAN[i]->wlan_unicast_sw))
						{
							totalLen += sprintf(cursor," set wlan unicast_and_multicast_broadcast isolation %s\n",(WLAN[i]->wlan_muti_bro_cast_sw == 1)?"enable":"disable");
							cursor = showStr + totalLen;		
						}
						else if(WLAN[i]->wlan_unicast_sw !=  gWLAN_UNI_MUTI_BRO_CAST.unicast_policy)
						{
							totalLen += sprintf(cursor," set wlan unicast isolation %s\n",(WLAN[i]->wlan_unicast_sw == 1)?"enable":"disable");
							cursor = showStr + totalLen;						
						}
						else if(WLAN[i]->wlan_muti_bro_cast_sw !=  gWLAN_UNI_MUTI_BRO_CAST.multicast_broadcast_policy)
						{
							totalLen += sprintf(cursor," set wlan multicast_broadcast isolation %s\n",(WLAN[i]->wlan_muti_bro_cast_sw == 1)?"enable":"disable");
							cursor = showStr + totalLen;						
						}	
						if(WLAN[i]->wlan_wifi_sw !=  gWLAN_UNI_MUTI_BRO_CAST.wifi_policy)
						{
							totalLen += sprintf(cursor," set wlan wifi isolation %s\n",(WLAN[i]->wlan_wifi_sw == 1)?"enable":"disable");
							cursor = showStr + totalLen;						
						}	
						if(WLAN[i]->wlan_muti_rate !=  gWLAN_UNI_MUTI_BRO_CAST.rate)
						{
							totalLen += sprintf(cursor," set  wlan multicast_broadcast_rate %d\n",WLAN[i]->wlan_muti_rate);
							cursor = showStr + totalLen;						
						}						
					}

					if(WLAN[i]->balance_para!=1){
						totalLen += sprintf(cursor," set wlan number balance parameter %d\n",WLAN[i]->balance_para);
						cursor = showStr + totalLen;
					}   //xm add 08/12/29

					if(WLAN[i]->flow_balance_para!=1){
						totalLen += sprintf(cursor," set wlan flow balance parameter %d\n",WLAN[i]->flow_balance_para);
						cursor = showStr + totalLen;
					}   //xm add 09/02/05
					if(WLAN[i]->balance_switch!=0){
						totalLen += sprintf(cursor," set wlan %s balance\n",(WLAN[i]->balance_method==1)?"number":"flow");
						cursor = showStr + totalLen;
					}   //xm add 08/12/05
					if(WLAN[i]->wlan_traffic_limit!=0){
						totalLen += sprintf(cursor," set wlan traffic limit value %d\n",WLAN[i]->wlan_traffic_limit);
						cursor = showStr + totalLen;
					}   //nl add 10/03/20
					if(WLAN[i]->wlan_send_traffic_limit!=0){
						totalLen += sprintf(cursor," set wlan send traffic limit value %d\n",WLAN[i]->wlan_send_traffic_limit);
						cursor = showStr + totalLen;
					} //nl add 10/03/20
					if(WLAN[i]->wlan_station_average_traffic_limit!=0){
						totalLen += sprintf(cursor," set wlan traffic limit station average value %d\n",WLAN[i]->wlan_station_average_traffic_limit);
						cursor = showStr + totalLen;
					}   //nl add 10/04/01
					if(WLAN[i]->wlan_station_average_send_traffic_limit!=0){
						totalLen += sprintf(cursor," set wlan traffic limit station send average value %d\n",WLAN[i]->wlan_station_average_send_traffic_limit);
						cursor = showStr + totalLen;
					} //nl add 10/04/01
					if(WLAN[i]->Roaming_Policy!=0){
						totalLen += sprintf(cursor," wlan l3 roaming policy enable\n");
						cursor = showStr + totalLen;
					}	//zhanglei

					if(WLAN[i]->vlanid != 0){
						totalLen += sprintf(cursor," set local wlan-vlan %d\n",WLAN[i]->vlanid);
						cursor = showStr + totalLen;
						if(WLAN[i]->wlan_1p_priority != 0)
						{
							totalLen += sprintf(cursor," set wlan-1p priority %d\n",WLAN[i]->wlan_1p_priority);
							cursor = showStr + totalLen;
						}
					} 
					if(WLAN[i]->sta_ip_mac_bind == 1){
						totalLen += sprintf(cursor," set wlan sta_ip_mac binding enable\n");
						cursor = showStr + totalLen;
					}   //zhanglei
					if(WLAN[i]->StartService.times != -1){
						if(WLAN[i]->StartService.is_once == 0){
							totalLen += sprintf(cursor," set wlan start service at %d:%d:%d %s %s %s %s %s %s %s %s\n",(WLAN[i]->StartService.times)/3600,((WLAN[i]->StartService.times)%3600)/60,((WLAN[i]->StartService.times)%3600)%60,
							(WLAN[i]->StartService.is_once == 1)?"once":"cycle",(WLAN[i]->StartService.wday[1]== 1)?"mon":"",(WLAN[i]->StartService.wday[2]== 1)?"tue":"",(WLAN[i]->StartService.wday[3]== 1)?"wed":"", 
							(WLAN[i]->StartService.wday[4]== 1)?"thu":"",(WLAN[i]->StartService.wday[5]== 1)?"fri":"",(WLAN[i]->StartService.wday[6]== 1)?"sat":"",(WLAN[i]->StartService.wday[0]== 1)?"sun":"");
							cursor = showStr + totalLen;
							if(WLAN[i]->StartService.TimerState == 1){
								totalLen += sprintf(cursor," set wlan starttimer enable\n");
								cursor = showStr + totalLen;
							}
						}
					}					
					if(WLAN[i]->StopService.times != -1){
						if(WLAN[i]->StopService.is_once == 0){
							totalLen += sprintf(cursor," set wlan stop service at %d:%d:%d %s %s %s %s %s %s %s %s\n",(WLAN[i]->StopService.times)/3600,((WLAN[i]->StopService.times)%3600)/60,((WLAN[i]->StopService.times)%3600)%60,
							(WLAN[i]->StopService.is_once == 1)?"once":"cycle",(WLAN[i]->StopService.wday[1]== 1)?"mon":"",(WLAN[i]->StopService.wday[2]== 1)?"tue":"",(WLAN[i]->StopService.wday[3]== 1)?"wed":"", 
							(WLAN[i]->StopService.wday[4]== 1)?"thu":"",(WLAN[i]->StopService.wday[5]== 1)?"fri":"",(WLAN[i]->StopService.wday[6]== 1)?"sat":"",(WLAN[i]->StopService.wday[0]== 1)?"sun":"");
							cursor = showStr + totalLen;
							if(WLAN[i]->StopService.TimerState == 1){
								totalLen += sprintf(cursor," set wlan stoptimer enable\n");
								cursor = showStr + totalLen;
							}
						}
					}
					/* zhangshu add for set eap mac,2010-10-22 */
					if(WLAN[i]->eap_mac_switch == 1){
						totalLen += sprintf(cursor," set 1xServer switch enable based mac %s\n",WLAN[i]->eap_mac);
						cursor = showStr + totalLen;
					}
					//weichao add
					if(WLAN[i]->flow_check == 1){
						totalLen += sprintf(cursor," flow check enable\n");
						cursor = showStr + totalLen;
						if(WLAN[i]->no_flow_time != 900){
							totalLen += sprintf(cursor," set no flow time %d\n",WLAN[i]->no_flow_time);
							cursor = showStr + totalLen;
						}
						if(WLAN[i]->limit_flow != 10240){
							totalLen += sprintf(cursor," set limit min flow %d\n",WLAN[i]->limit_flow);
							cursor = showStr + totalLen;
						}
					}
					//mahz add nas_port_id
					if(WLAN[i]->nas_port_id[0] != 0){
						totalLen += sprintf(cursor," set wlan nas-port-id %s\n",WLAN[i]->nas_port_id);
						cursor = showStr + totalLen;
					}
					if(WLAN[i]->multi_user_optimize_switch != 0)
					{
							totalLen += sprintf(cursor,"set wlan all bss  multi_user switch  enable\n");
							cursor = showStr + totalLen;
					}
					if(WLAN[i]->hotspot_id != 0){
						totalLen += sprintf(cursor," set wlan hotspotid %d\n",WLAN[i]->hotspot_id);
						cursor = showStr + totalLen;
					}
					/* end */
					
					totalLen += sprintf(cursor,"exit\n");
					cursor = showStr + totalLen;
				}

			}
		}
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_STRING,
									 &showStr);	
	WID_FREE(showStr);
	showStr = NULL;
	return reply;


}
DBusMessage * wid_dbus_wlan_show_running_config_end(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusMessageIter  iter;
	unsigned char num=0;
	char *showStr = NULL,*cursor = NULL;
	int totalLen = 0;
	DBusError err;
	//int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	int i=0;
	WID_WLAN *WLAN[WLAN_NUM];
	while(i<WLAN_NUM){
		if(AC_WLAN[i] != NULL && AC_WLAN[i]->want_to_delete != 1)		/* Huangleilei check wlan operation */
		{
			WLAN[num] = AC_WLAN[i];
			num++;
		}
		i++;
	}
	
	if(num == 0){
		showStr = (char*)WID_MALLOC(1);		
		memset(showStr,0,1);
		//printf("no wlan config\n");
		wid_syslog_debug_debug(WID_DBUS,"no wlan config\n");
	}else{
		showStr = (char*)WID_MALLOC(num*1024);
	
		if(NULL == showStr) {
			//printf(("memory malloc error\n"));
			wid_syslog_crit("memory malloc error\n");
			//return NULL;
		}else{
			memset(showStr,0,num*1024);
			cursor = showStr;			
			//totalLen += sprintf(cursor,"*****wlan setting display*****\n");
			//cursor = showStr + totalLen;
			if(g_WLAN_TUNNEL_POLICY != CW_802_DOT_11_TUNNEL){
				if(g_WLAN_TUNNEL_POLICY == CW_802_DOT_3_TUNNEL){
					totalLen += sprintf(cursor," set wlan tunnel mode capwap802dot3\n");
					cursor = showStr + totalLen;
				}else if(g_WLAN_TUNNEL_POLICY == CW_802_IPIP_TUNNEL){
					totalLen += sprintf(cursor," set wlan tunnel mode ipip\n");
					cursor = showStr + totalLen;
				}
			}
			for(i=0; i<num; i++){				
				/*if(((int)WLAN[i]->SecurityID > 0)&&(WLAN[i]->Wlan_Ifi != NULL)&&(WLAN[i]->Status == 0)){*/
				if(WLAN[i] != NULL && WLAN[i]->want_to_delete != 1 && ((int)WLAN[i]->SecurityID > 0)){	/* Huang Leilei fix for AXSSZFI-1694,  */
					totalLen += sprintf(cursor,"config wlan %d\n",WLAN[i]->WlanID);
					cursor = showStr + totalLen;
					if((WLAN[i]->wlan_if_policy == WLAN_INTERFACE)&&(WLAN[i]->tunnel_wlan_vlan != NULL)){
						struct WID_TUNNEL_WLAN_VLAN *iflist;
						iflist = WLAN[i]->tunnel_wlan_vlan;							
						while(iflist != NULL){
							if(strlen(iflist->ifname) > 3)
							{
								totalLen += sprintf(cursor," set tunnel wlan-vlan uplink %s\n",iflist->ifname);
//								printf("set tunnel wlan-vlan uplink %s\n",iflist->ifname);
								cursor = showStr + totalLen;
								iflist = iflist->ifnext;
							}
						}

					}
					if(WLAN[i]->wlan_if_policy == WLAN_INTERFACE)
					{
						if(WLAN[i]->isolation_policy != 1)
						{
							totalLen += sprintf(cursor," set bridge_isolation disable\n");
							cursor = showStr + totalLen;
						}
						if(WLAN[i]->multicast_isolation_policy != 1)
						{
							totalLen += sprintf(cursor," set bridge_multicast_isolation disable\n");
							cursor = showStr + totalLen;
						}
						if(WLAN[i]->sameportswitch != 0)
						{
							totalLen += sprintf(cursor," set bridge sameportswitch enable\n");
							cursor = showStr + totalLen;
						}
						if(WLAN[i]->WLAN_TUNNEL_POLICY != g_WLAN_TUNNEL_POLICY){
							if(WLAN[i]->WLAN_TUNNEL_POLICY == CW_802_DOT_3_TUNNEL){
								totalLen += sprintf(cursor," set wlan tunnel mode capwap802dot3\n");
								cursor = showStr + totalLen;
							}else if(WLAN[i]->WLAN_TUNNEL_POLICY == CW_802_DOT_11_TUNNEL){
								totalLen += sprintf(cursor," set wlan tunnel mode capwap802dot11\n");
								cursor = showStr + totalLen;
							}else if(WLAN[i]->WLAN_TUNNEL_POLICY == CW_802_IPIP_TUNNEL){
								totalLen += sprintf(cursor," set wlan tunnel mode ipip\n");
								cursor = showStr + totalLen;
							}
						}
						if(WLAN[i]->bridge_ucast_solicit_stat != 1)
						{
							totalLen += sprintf(cursor," set bridge_ucast_solicit disable\n");
							cursor = showStr + totalLen;
						}
						if(WLAN[i]->bridge_mcast_solicit_stat != 1)
						{
							totalLen += sprintf(cursor," set bridge_mcast_solicit disable\n");
							cursor = showStr + totalLen;
						}
					}
					if(WLAN[i]->wlan_if_policy == BSS_INTERFACE)
					{
						totalLen += sprintf(cursor," set wlan forwarding mode tunnel\n");
						cursor = showStr + totalLen;
					}
					if(WLAN[i]->wlan_if_policy == BSS_INTERFACE_EBR)
					{
						totalLen += sprintf(cursor," set wlan forwarding mode tunnel ebr\n");
						cursor = showStr + totalLen;
					}
					if(WLAN[i]->Status == 0)
					{
						totalLen += sprintf(cursor," service enable\n");
						cursor = showStr + totalLen;
					}
					if(WLAN[i]->WDSStat)
					{	if(WLAN[i]->wds_mesh == 0){
							totalLen += sprintf(cursor," wds enable\n");
							cursor = showStr + totalLen;
						}
						else
						{
							totalLen += sprintf(cursor," mesh enable\n");
							cursor = showStr + totalLen;
						}
					}
					totalLen += sprintf(cursor,"exit\n");
					cursor = showStr + totalLen;
					
					if((WLAN[i]->uplinkState != 0)&&(WLAN[i]->uplink_addr != NULL))
					{
						totalLen += sprintf(cursor,"uplink %s %d enable\n",WLAN[i]->uplink_addr,WLAN[i]->uplinkWlanId);
						cursor = showStr + totalLen; 
					}

				}

			}
		}
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_STRING,
									 &showStr);	
	WID_FREE(showStr);
	showStr = NULL;
	return reply;

}
DBusMessage * wid_dbus_show_wtp_config(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage*		reply;	  
	DBusMessageIter 	iter= {0};
	DBusError			err;   		
	int wtpid = 0;
	int i = 0;
	int j = 0;
	int num = 0;
	int str_len = 0;
	int totalLen = 0;
	char *showStr = NULL,*cursor = NULL;
	char *showStr_new = NULL;
	WID_WTP **WTP;
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));



	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_INVALID))){
		printf("Unable to get input args\n");
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if((wtpid > 0)&&(wtpid < WTP_NUM)){
		//while(i<=WTP_NUM){
			if(AC_WTP[wtpid] != NULL)
			{
				WTP[wtpid] = AC_WTP[wtpid];
				num++;
				printf("while ,2num:%d  \n",num);
			}
		//	i++;
		//}

	}else if(wtpid == 0){
		while(i<WTP_NUM){
			if(AC_WTP[i] != NULL)
			{
				WTP[num] = AC_WTP[i];
				num++;
				
			}
			i++;
		}
	}
	str_len = WTP_NUM*1024;
	showStr = (char*)WID_MALLOC(str_len);
	if(NULL == showStr) {
		wid_syslog_debug_debug(WID_DBUS,"alloc memory fail when mirror show running-config\n");
		if(WTP){
			WID_FREE(WTP);
			WTP = NULL;
		}
		return NULL;
	}
	
	memset(showStr,0,str_len);
	cursor = showStr;
	//totalLen += sprintf(cursor,"hello show running wtp,wuwenlong.\n");
	//cursor = showStr + totalLen;

	
	if((wtpid > 0)&&(num > 0)){
		show_running_config_wtp(WTP,wtpid,cursor,&showStr,showStr_new,&totalLen,&str_len);
	}
	else if(wtpid == 0){
		for(j=0; j<num; j++){
			show_running_config_wtp(WTP,j,cursor,&showStr,showStr_new,&totalLen,&str_len);
		}
	}else{
		totalLen += sprintf(cursor,"no this wtp config.\n");
		cursor = showStr + totalLen;
	}

	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append (reply, &iter);	
	dbus_message_iter_append_basic (&iter,
								   DBUS_TYPE_STRING,
								   &showStr);
	
	WID_FREE(showStr);
	showStr = NULL;
	
	WID_FREE(WTP);
	WTP = NULL;
	return reply;
}

//fengwenchao add 20110126 for XJDEV-32  from 2.0
DBusMessage * wid_dbus_interface_set_ap_if_eth_mtu(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply;
	DBusMessageIter  iter;
	
	unsigned int wtpid = 0;
	unsigned char ifindex = 0;
	unsigned int mtu = 100;
	int i = 0; /*wcl add for globle variable*/
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_BYTE,&ifindex,
								DBUS_TYPE_UINT32,&mtu,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(wtpid == 0){
		gAPIFINFOETH_MTU[ifindex] = mtu;
		for(i=0;i<WTP_NUM;i++){
			if(AC_WTP[i] != NULL){
				if(ifindex >= AC_WTP[i]->apifinfo.eth_num){
					ret = ETH_NOT_EXIST;
				}else{
					AC_WTP[i]->apifinfo.eth[ifindex].eth_mtu = mtu;
					ret = wid_set_ap_eth_if_mtu(i,ifindex);
				}
			}
		}
	}/*wcl add for globle variable*/
	else if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(ifindex >= AC_WTP[wtpid]->apifinfo.eth_num)   //fengwenchao add 20110325
	{
		ret = ETH_NOT_EXIST;
	}
	else 
	{	
		AC_WTP[wtpid]->apifinfo.eth[ifindex].eth_mtu = mtu;
		ret = wid_set_ap_eth_if_mtu(wtpid,ifindex);
	}
	
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	return reply;
	
}
//fengwenchao add end
DBusMessage * wid_dbus_wtp_show_running_config_start(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusMessageIter  iter;
	unsigned int num=0;
	char *showStr = NULL,*cursor = NULL;
	char *showStr_new = NULL;	//ht add 090907
	int str_len = 0;
	int totalLen = 0;
//	int m = 0;
//	int circlecount = 0;
//	int modelcount = 0;
	char *logswtich = "OFF";
//	char radio_type[ACDBUS_RADOI_TYPE_LEN];	
	unsigned char channel_t[4] = {1,6,11,0};
	DBusError err;
	//int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	int i=0;
//	int s_id = 0;
//	int s_id2 = 0;
//	int s_state = 0;
	WID_WTP **WTP=NULL;
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));

	while(i<WTP_NUM){
		if(AC_WTP[i] != NULL)
		{
			WTP[num] = AC_WTP[i];
			num++;
		}
		i++;
	}
	if(num == 0){
		str_len = DEFAULT_LEN*1024;
		showStr = (char*)WID_MALLOC(str_len);		
		memset(showStr,0,str_len);
		cursor = showStr;

		if(pwhite_mac_list!=NULL){	// white list
			struct white_mac *wm;
			wm=pwhite_mac_list->list_mac;
			while(wm!=NULL){
				if(totalLen + 1024 > str_len) {
					str_len *= 2;
					showStr_new = (char*)realloc(showStr,str_len);
					if(showStr_new == NULL){
						wid_syslog_info("show running realloc failed\n");
						break;
					}else {
						showStr = showStr_new;
						memset(showStr+str_len/2,0,str_len/2);
						showStr_new = NULL;
					}
					wid_syslog_debug_debug(WID_DBUS,"show running totalLen %d realloc strlen %d\n",totalLen,str_len);
				}
				
				cursor = showStr + totalLen;
				totalLen += sprintf(cursor,"set mac %02X:%02X:%02X:%02X:%02X:%02X whitelist\n",
					wm->elem_mac[0],wm->elem_mac[1],wm->elem_mac[2],
					wm->elem_mac[3],wm->elem_mac[4],wm->elem_mac[5]);
				cursor = showStr + totalLen;
				wm=wm->next;
			}
		}
		
		struct oui_node * node;
		node=g_oui_list.oui_list;	//oui
		while(node!=NULL){
			if(totalLen + 1024 > str_len) {
				str_len *= 2;
				showStr_new = (char*)realloc(showStr,str_len);
				if(showStr_new == NULL){
					wid_syslog_info("show running realloc failed\n");
					break;
				}else {
					showStr = showStr_new;
					memset(showStr+str_len/2,0,str_len/2);
					showStr_new = NULL;
				}
				wid_syslog_debug_debug(WID_DBUS,"show running totalLen %d realloc strlen %d\n",totalLen,str_len);
			}
			
			cursor = showStr + totalLen;
			totalLen += sprintf(cursor,"add legal manufacturer %02X:%02X:%02X\n",node->oui[0],node->oui[1],node->oui[2]);
			cursor = showStr + totalLen;
			node=node->next;
		}
		
		struct essid_node * node1;			//essid
		node1=g_essid_list.essid_list;
		while(node1!=NULL){
			if(totalLen + 1024 > str_len) {
				str_len *= 2;
				showStr_new = (char*)realloc(showStr,str_len);
				if(showStr_new == NULL){
					wid_syslog_info("show running realloc failed\n");
					break;
				}else {
					showStr = showStr_new;
					memset(showStr+str_len/2,0,str_len/2);
					showStr_new = NULL;
				}
				wid_syslog_debug_debug(WID_DBUS,"show running totalLen %d realloc strlen %d\n",totalLen,str_len);
			}
			
			cursor = showStr + totalLen;
			if(node1->essid!=NULL){
				totalLen += sprintf(cursor,"add legal essid %s\n",node1->essid);
				cursor = showStr + totalLen;
			}
			node1=node1->next;
		}
		
		struct attack_mac_node * node3;
		node3=g_attack_mac_list.attack_mac_list;   //attack mac
		while(node3!=NULL){
			if(totalLen + 1024 > str_len) {
				str_len *= 2;
				showStr_new = (char*)realloc(showStr,str_len);
				if(showStr_new == NULL){
					wid_syslog_info("show running realloc failed\n");
					break;
				}else {
					showStr = showStr_new;
					memset(showStr+str_len/2,0,str_len/2);
					showStr_new = NULL;
				}
				wid_syslog_debug_debug(WID_DBUS,"show running totalLen %d realloc strlen %d\n",totalLen,str_len);
			}
			
			cursor = showStr + totalLen;
			totalLen += sprintf(cursor,"add attack ap mac %02X:%02X:%02X:%02X:%02X:%02X\n",
				node3->mac[0],node3->mac[1],node3->mac[2],
				node3->mac[3],node3->mac[4],node3->mac[5]);
			cursor = showStr + totalLen;
			node3=node3->next;
		}
		
		if((gMaxWTPs_from_sem >0)&&(gMaxWTPs != gMaxWTPs_from_sem))  //fengwenchao modify for read gMaxWTPs from /dbm/local_board/board_ap_max_counter
		{
			totalLen += sprintf(cursor,"set wireless-control max wtp %d\n",gMaxWTPs);
			cursor = showStr + totalLen; 
		}
		else if((gMaxWTPs_from_sem == 0)&&(gMaxWTPs != 1024))   //fengwenchao modify for read gMaxWTPs from /dbm/local_board/board_ap_max_counter
		{
			totalLen += sprintf(cursor,"set wireless-control max wtp %d\n",gMaxWTPs );
			cursor = showStr + totalLen; 
		}
		
		if((AP_SNR_MAX != gMAX_WEB_REPORT_SNR) || (AP_SNR_MIN != gMIN_WEB_REPORT_SNR))
		{
			totalLen += sprintf(cursor," set web-report ap-snr-range %d %d\n", gMAX_WEB_REPORT_SNR, gMIN_WEB_REPORT_SNR);
			cursor = showStr + totalLen;
		}

		wid_syslog_debug_debug(WID_DBUS,"no wtp config\n");
	}else{
		str_len = num*1024;
		showStr = (char*)WID_MALLOC(str_len);
	
		if(NULL == showStr) {
			wid_syslog_crit("memory malloc error\n");
			//return NULL;
		}else{
			memset(showStr,0,str_len);
			cursor = showStr;

			
			//totalLen += sprintf(cursor,"*****wtp setting display*****\n");
			// cursor = showStr + totalLen;
			
			if(pwhite_mac_list!=NULL){  // white list
				struct white_mac *wm;
				wm=pwhite_mac_list->list_mac;
				while(wm!=NULL){
					if(totalLen + 1024 > str_len) {
						str_len *= 2;
						showStr_new = (char*)realloc(showStr,str_len);
						if(showStr_new == NULL){
							wid_syslog_info("show running realloc failed\n");
							break;
						}else {
							showStr = showStr_new;
							memset(showStr+str_len/2,0,str_len/2);
							showStr_new = NULL;
						}
						wid_syslog_debug_debug(WID_DBUS,"show running totalLen %d realloc strlen %d\n",totalLen,str_len);
					}
					
					cursor = showStr + totalLen;
					totalLen += sprintf(cursor,"set mac %02X:%02X:%02X:%02X:%02X:%02X whitelist\n",
						wm->elem_mac[0],wm->elem_mac[1],wm->elem_mac[2],
						wm->elem_mac[3],wm->elem_mac[4],wm->elem_mac[5]);
					cursor = showStr + totalLen;
					wm=wm->next;
				}
			}
			
			struct oui_node * node;
			node=g_oui_list.oui_list;   //oui
			while(node!=NULL){
				if(totalLen + 1024 > str_len) {
					str_len *= 2;
					showStr_new = (char*)realloc(showStr,str_len);
					if(showStr_new == NULL){
						wid_syslog_info("show running realloc failed\n");
						break;
					}else {
						showStr = showStr_new;
						memset(showStr+str_len/2,0,str_len/2);
						showStr_new = NULL;
					}
					wid_syslog_debug_debug(WID_DBUS,"show running totalLen %d realloc strlen %d\n",totalLen,str_len);
				}
				
				cursor = showStr + totalLen;
				totalLen += sprintf(cursor,"add legal manufacturer %02X:%02X:%02X\n",node->oui[0],node->oui[1],node->oui[2]);
				cursor = showStr + totalLen;
				node=node->next;
			}

			struct essid_node * node1;			//essid
			node1=g_essid_list.essid_list;
			while(node1!=NULL){
				if(totalLen + 1024 > str_len) {
					str_len *= 2;
					showStr_new = (char*)realloc(showStr,str_len);
					if(showStr_new == NULL){
						wid_syslog_info("show running realloc failed\n");
						break;
					}else {
						showStr = showStr_new;
						memset(showStr+str_len/2,0,str_len/2);
						showStr_new = NULL;
					}
					wid_syslog_debug_debug(WID_DBUS,"show running totalLen %d realloc strlen %d\n",totalLen,str_len);
				}
				
				cursor = showStr + totalLen;
				if(node1->essid!=NULL){
					totalLen += sprintf(cursor,"add legal essid %s\n",node1->essid);
					cursor = showStr + totalLen;
				}
				node1=node1->next;
			}

			struct attack_mac_node * node3;
			node3=g_attack_mac_list.attack_mac_list;   //attack mac
			while(node3!=NULL){
				if(totalLen + 1024 > str_len) {
					str_len *= 2;
					showStr_new = (char*)realloc(showStr,str_len);
					if(showStr_new == NULL){
						wid_syslog_info("show running realloc failed\n");
						break;
					}else {
						showStr = showStr_new;
						memset(showStr+str_len/2,0,str_len/2);
						showStr_new = NULL;
					}
					wid_syslog_debug_debug(WID_DBUS,"show running totalLen %d realloc strlen %d\n",totalLen,str_len);
				}
				
				cursor = showStr + totalLen;
				totalLen += sprintf(cursor,"add attack ap mac %02X:%02X:%02X:%02X:%02X:%02X\n",
					node3->mac[0],node3->mac[1],node3->mac[2],
					node3->mac[3],node3->mac[4],node3->mac[5]);
				cursor = showStr + totalLen;
				node3=node3->next;
			}
			
			#if 0
			CWConfigVersionInfo *pnode = gConfigVersionInfo;

			while(pnode != NULL)
			{
				modelcount++;
				pnode = pnode->next;
			}
			pnode = gConfigVersionInfo;
			circlecount = modelcount- gModelCount;
			
			//for(m = 0; m<circlecount; m++)
			for(m = 0; m<modelcount; m++)
			{
				if(pnode->ismodelchanged == CW_TRUE)
				{
					// set model to new AQ 2010 to AW 3110
					totalLen += sprintf(cursor,"set model to new AQ%s to %s\n",pnode->str_ap_code,pnode->str_ap_model);
					cursor = showStr + totalLen; 
					
				}
				
				if (pnode->ischanged == CW_TRUE){
					totalLen += sprintf(cursor,"set ap img-path %s radio %d bss %d based %s version %s\n",pnode->str_ap_version_path,pnode->radio_num,pnode->bss_num,pnode->str_ap_model,pnode->str_ap_version_name);
					cursor = showStr + totalLen; 
					}
				pnode = pnode->next;
			}
			#endif
			if(img_now == 1){
				totalLen += sprintf(cursor,"old_ap_img_data open\n");
				cursor = showStr + totalLen; 
			}
			/////////////added version end////////////////	
			if(gCOUNTRYCODE != COUNTRY_CHINA_CN)/*wcl modify for OSDEVTDPB-31*/
			{
				char *countrycode;
				countrycode = (char *)WID_MALLOC(sizeof(char)*3);
				memset(countrycode,0,3);
				
				switch(gCOUNTRYCODE)
				{
					case COUNTRY_CHINA_CN : 
											strncpy(countrycode,"CN",2);
											break;
											
					case COUNTRY_EUROPE_EU : 
											strncpy(countrycode,"EU",2);
											break;
																			
					case COUNTRY_USA_US : 
											strncpy(countrycode,"US",2);
											break;
																			
					case COUNTRY_JAPAN_JP : 
											strncpy(countrycode,"JP",2);
											break;
																			
					case COUNTRY_FRANCE_FR : 
											strncpy(countrycode,"FR",2);
											break;
																			
					case COUNTRY_SPAIN_ES : 
											strncpy(countrycode,"ES",2);
											break;

					default : 
								strncpy(countrycode,"CN",2);
								break;
				}
				
//				printf("countrycode %s\n",countrycode);
				

				
				
				totalLen += sprintf(cursor,"country-code %s\n",countrycode);
				cursor = showStr + totalLen; 

				WID_FREE(countrycode);
				countrycode = NULL;
			}
			/*fengwenchao add for AUTELAN-2712,20111214*/
			int qosnum = 0;
			AC_QOS *QOS[QOS_NUM];
			char ack[] = "ack";
			char noack[] = "noack";
			i = 0;
			while(i<QOS_NUM)
			{
				if(WID_QOS[i] != NULL)
				{
					QOS[qosnum] = WID_QOS[i];
					qosnum++;
				}
				i++;
			}
			if(qosnum != 0)
			{
				for(i=0;i<qosnum;i++)
				{
					if(totalLen + 1024 > str_len) {
						str_len *= 2;
						showStr_new = (char*)realloc(showStr,str_len);
						if(showStr_new == NULL){
							wid_syslog_info("show running realloc failed\n");
							break;
						}else {
							showStr = showStr_new;
							memset(showStr+str_len/2,0,str_len/2);
							showStr_new = NULL;
						}
						wid_syslog_debug_debug(WID_DBUS,"show running totalLen %d realloc strlen %d\n",totalLen,str_len);
					}
					
					cursor = showStr + totalLen;
					if(QOS[i]->name != NULL)
					{
						totalLen += sprintf(cursor,"create wireless qos profile %d %s\n",QOS[i]->QosID,QOS[i]->name);
						cursor = showStr + totalLen; 
					}
					if(QOS[i]->name != NULL)
					{
						totalLen += sprintf(cursor,"config wireless qos %d\n",QOS[i]->QosID);
						cursor = showStr + totalLen; 
					}

					if((QOS[i]->radio_qos[0]->CWMin != 4)
						||(QOS[i]->radio_qos[0]->CWMax != 10)
						||(QOS[i]->radio_qos[0]->AIFS != 2)
						||(QOS[i]->radio_qos[0]->TXOPlimit != 2048)
						||(QOS[i]->radio_qos[0]->ACK != 1))
					{
						totalLen += sprintf(cursor," set radio besteffort cwmin %d cwmax %d aifs %d txoplimit %d %s\n",QOS[i]->radio_qos[0]->CWMin
																													,QOS[i]->radio_qos[0]->CWMax
																													,QOS[i]->radio_qos[0]->AIFS
																													,QOS[i]->radio_qos[0]->TXOPlimit
																													,(QOS[i]->radio_qos[0]->ACK == 1)?ack:noack);
						cursor = showStr + totalLen; 
					}
					if((QOS[i]->radio_qos[1]->CWMin != 4)
						||(QOS[i]->radio_qos[1]->CWMax != 10)
						||(QOS[i]->radio_qos[1]->AIFS != 7)
						||(QOS[i]->radio_qos[1]->TXOPlimit != 0)
						||(QOS[i]->radio_qos[1]->ACK != 1))
					{
						totalLen += sprintf(cursor," set radio background cwmin %d cwmax %d aifs %d txoplimit %d %s\n",QOS[i]->radio_qos[1]->CWMin
																													,QOS[i]->radio_qos[1]->CWMax
																													,QOS[i]->radio_qos[1]->AIFS
																													,QOS[i]->radio_qos[1]->TXOPlimit
																													,(QOS[i]->radio_qos[1]->ACK == 1)?ack:noack);
						cursor = showStr + totalLen; 
					}
					if((QOS[i]->radio_qos[2]->CWMin != 3)
						||(QOS[i]->radio_qos[2]->CWMax != 4)
						||(QOS[i]->radio_qos[2]->AIFS != 1)
						||(QOS[i]->radio_qos[2]->TXOPlimit != 3008)
						||(QOS[i]->radio_qos[2]->ACK != 1))
					{
						totalLen += sprintf(cursor," set radio video cwmin %d cwmax %d aifs %d txoplimit %d %s\n",QOS[i]->radio_qos[2]->CWMin
																													,QOS[i]->radio_qos[2]->CWMax
																													,QOS[i]->radio_qos[2]->AIFS
																													,QOS[i]->radio_qos[2]->TXOPlimit
																													,(QOS[i]->radio_qos[2]->ACK == 1)?ack:noack);
						cursor = showStr + totalLen; 
					}
					if((QOS[i]->radio_qos[3]->CWMin != 2)
						||(QOS[i]->radio_qos[3]->CWMax != 3)
						||(QOS[i]->radio_qos[3]->AIFS != 1)
						||(QOS[i]->radio_qos[3]->TXOPlimit != 1504)
						||(QOS[i]->radio_qos[3]->ACK != 1))
					{
						totalLen += sprintf(cursor," set radio voice cwmin %d cwmax %d aifs %d txoplimit %d %s\n",QOS[i]->radio_qos[3]->CWMin
																													,QOS[i]->radio_qos[3]->CWMax
																													,QOS[i]->radio_qos[3]->AIFS
																													,QOS[i]->radio_qos[3]->TXOPlimit
																													,(QOS[i]->radio_qos[3]->ACK == 1)?ack:noack);
						cursor = showStr + totalLen; 
					}
					if((QOS[i]->client_qos[0]->CWMin != 4)
						||(QOS[i]->client_qos[0]->CWMax != 10)
						||(QOS[i]->client_qos[0]->AIFS != 2)
						||(QOS[i]->client_qos[0]->TXOPlimit != 2048))
					{
						totalLen += sprintf(cursor," set client besteffort cwmin %d cwmax %d aifs %d txoplimit %d\n",QOS[i]->client_qos[0]->CWMin
																													,QOS[i]->client_qos[0]->CWMax
																													,QOS[i]->client_qos[0]->AIFS
																													,QOS[i]->client_qos[0]->TXOPlimit);
						cursor = showStr + totalLen;
					}
					if((QOS[i]->client_qos[1]->CWMin != 4)
						||(QOS[i]->client_qos[1]->CWMax != 10)
						||(QOS[i]->client_qos[1]->AIFS != 7)
						||(QOS[i]->client_qos[1]->TXOPlimit != 0))
					{
						totalLen += sprintf(cursor," set client background cwmin %d cwmax %d aifs %d txoplimit %d\n",QOS[i]->client_qos[1]->CWMin
																													,QOS[i]->client_qos[1]->CWMax
																													,QOS[i]->client_qos[1]->AIFS
																													,QOS[i]->client_qos[1]->TXOPlimit);
						cursor = showStr + totalLen;
					}
					if((QOS[i]->client_qos[2]->CWMin != 3)
						||(QOS[i]->client_qos[2]->CWMax != 4)
						||(QOS[i]->client_qos[2]->AIFS != 2)
						||(QOS[i]->client_qos[2]->TXOPlimit != 3008))
					{
						totalLen += sprintf(cursor," set client video cwmin %d cwmax %d aifs %d txoplimit %d\n",QOS[i]->client_qos[2]->CWMin
																													,QOS[i]->client_qos[2]->CWMax
																													,QOS[i]->client_qos[2]->AIFS
																													,QOS[i]->client_qos[2]->TXOPlimit);
						cursor = showStr + totalLen; 
					}
					if((QOS[i]->client_qos[3]->CWMin != 2)
						||(QOS[i]->client_qos[3]->CWMax != 3)
						||(QOS[i]->client_qos[3]->AIFS != 2)
						||(QOS[i]->client_qos[3]->TXOPlimit != 1504))
					{
						totalLen += sprintf(cursor," set client voice cwmin %d cwmax %d aifs %d txoplimit %d\n",QOS[i]->client_qos[3]->CWMin
																													,QOS[i]->client_qos[3]->CWMax
																													,QOS[i]->client_qos[3]->AIFS
																													,QOS[i]->client_qos[3]->TXOPlimit);
						cursor = showStr + totalLen; 
					}
					if((QOS[i]->radio_qos[0]->mapstate != 0)||
						(QOS[i]->radio_qos[1]->mapstate != 0)||
						(QOS[i]->radio_qos[2]->mapstate != 0)||
						(QOS[i]->radio_qos[3]->mapstate != 0))
					{
							totalLen += sprintf(cursor," set wmm map enable\n");
							cursor = showStr + totalLen;
					}
					int i2=0;
					for(i2=0;i2<4;i2++)
					{
						if(QOS[i]->radio_qos[i2]->mapstate != 0)
						{
							
							if(QOS[i]->radio_qos[i2]->wmm_map_dot1p != 0)
							{
								switch(i2)
								{
									case 0 : totalLen += sprintf(cursor," wmm besteffort map dot1p %d\n",QOS[i]->radio_qos[i2]->wmm_map_dot1p);
											cursor = showStr + totalLen;
											break;
									case 1 : totalLen += sprintf(cursor," wmm background map dot1p %d\n",QOS[i]->radio_qos[i2]->wmm_map_dot1p);
											cursor = showStr + totalLen;
											break;		
									case 2 : totalLen += sprintf(cursor," wmm video map dot1p %d\n",QOS[i]->radio_qos[i2]->wmm_map_dot1p);
											cursor = showStr + totalLen;
											break;
									case 3 : totalLen += sprintf(cursor," wmm voice map dot1p %d\n",QOS[i]->radio_qos[i2]->wmm_map_dot1p);
											cursor = showStr + totalLen;
											break;
									default : break;
								}
								
							}
							
							if(QOS[i]->radio_qos[i2]->dot1p_map_wmm_num != 0)
							{
								unsigned char dot1p[8];
								int mapnum =0;
								int mapnum2 = 0;
								for(mapnum=0;mapnum<(QOS[i]->radio_qos[i2]->dot1p_map_wmm_num);mapnum++)
								{
									if(QOS[i]->radio_qos[0]->dot1p_map_wmm[mapnum] != 0)
									{
										dot1p[mapnum2] = QOS[i]->radio_qos[i2]->dot1p_map_wmm[mapnum];
										mapnum2++;
									}
									
								}
								if(mapnum2 != 0)
								{
									char *mapstr = NULL,*mapmsg = NULL;
									mapstr = (char*)WID_MALLOC(16);		
									memset(mapstr,0,16);
									mapmsg = mapstr;
									int length = 0;
									int i1 = 0;
									for(i1=0;i1<mapnum2;i1++)
									{
										length += sprintf (mapmsg, "%d",dot1p[i1]);
										mapmsg = mapstr + length;
										if(i1 != (mapnum2-1))
										{
											length += sprintf (mapmsg, ",");
											mapmsg = mapstr + length;
										}
										else
										{
											
										}
		//								printf("%s\n",mapstr);
									}
		//							printf("%s\n",mapstr);
									switch(i2)
									{
										case 0 : totalLen += sprintf(cursor," dot1p %s map besteffort\n",mapstr);
												cursor = showStr + totalLen;
												break;
										case 1 : totalLen += sprintf(cursor," dot1p %s map background\n",mapstr);
												cursor = showStr + totalLen;
												break;		
										case 2 : totalLen += sprintf(cursor," dot1p %s map video\n",mapstr);
												cursor = showStr + totalLen;
												break;
										case 3 : totalLen += sprintf(cursor," dot1p %s map voice\n",mapstr);
												cursor = showStr + totalLen;
												break;
										default : break;
									}

									CW_FREE_OBJECT_WID(mapstr);
									
								}
							}
						}
					}
					
					if(QOS[i]->name != NULL)
					{
						totalLen += sprintf(cursor,"exit\n");
						cursor = showStr + totalLen; 
					}
				}
			}			
			/*fengwenchao add end*/
			/************wcl add for globle variable***************/
				if(cpu_mem_collect_time != 300)
				{
					totalLen += sprintf(cursor,"set ap cpu_collect_time %d\n",cpu_mem_collect_time);
					cursor = showStr + totalLen; 
				}
				if(gEchoRequestTimer != CW_ECHO_INTERVAL_DEFAULT)
				{
					totalLen += sprintf(cursor,"set ap echotimer %d\n",gEchoRequestTimer);
					cursor = showStr + totalLen; 
				}
				if(gWIFIEXTENSIONREPORTINTERVAL != 1800) 
				{
					totalLen += sprintf(cursor,"set ap extension infomation reportinterval %d\n",gWIFIEXTENSIONREPORTINTERVAL);
					cursor = showStr + totalLen;
				}

				if (g_wbs_cpe_switch != 0) {
					totalLen += sprintf(cursor,"set ap wbs-cpe switch enable\n");
					cursor = showStr + totalLen;
				}
				
				if(g_AC_ALL_EXTENTION_INFORMATION_SWITCH != 0)
				{
					totalLen += sprintf(cursor,"set ac extension infomation switch enable\n");
					cursor = showStr + totalLen; 
				}
				unsigned char jj=0;
				for(jj = 0;jj<AP_ETH_IF_NUM;jj++)
				{
					if(gAPIFINFOETH_MTU[jj] != 1500) 
					{
						totalLen += sprintf(cursor,"set ap interface eth%d mtu %d\n",jj,gAPIFINFOETH_MTU[jj]);
						cursor = showStr + totalLen;							
					}
					if(gAPIFINFOETH_RATE[jj] != 100) 
					{
						totalLen += sprintf(cursor,"set ap interface eth %d rate %d\n",jj,gAPIFINFOETH_RATE[jj]);
						cursor = showStr + totalLen;							
					}	
				}
				if(gINFOREPORTINTERVAL != 1800) 
				{
					totalLen += sprintf(cursor,"set ap interface infomation reportinterval %d\n",gINFOREPORTINTERVAL);
					cursor = showStr + totalLen;
				}
				if(gINFOREPORTSWITCH != 0) 
				{
					totalLen += sprintf(cursor,"set ap interface infomation report switch enable\n");
					cursor = showStr + totalLen;
				}
				if(gBANDWIDTH != 108)
				{
					totalLen += sprintf(cursor," set ap max throughout %d\n",gBANDWIDTH);
					cursor = showStr + totalLen;
				}
				if(gSTAREPORTINTERVAL != 1800)
				{
					totalLen += sprintf(cursor,"set ap sta infomation reportinterval %d\n",gSTAREPORTINTERVAL);
					cursor = showStr + totalLen;
				}
				if(gSTAREPORTSWITCH != 0)
				{
					totalLen += sprintf(cursor,"set ap sta infomation report switch enable\n");
					cursor = showStr + totalLen;
				}
				if(gAP_STA_WAPI_REPORT_INTERVAL != 1800)	
				{
					totalLen += sprintf(cursor,"set ap sta wapi info reportinterval %d\n",gAP_STA_WAPI_REPORT_INTERVAL);
					cursor = showStr + totalLen;
				}
				if(gAP_STA_WAPI_REPORT_SWITCH != 0)
				{			
					totalLen += sprintf(cursor,"set ap sta wapi info report switch enable\n"); 
					cursor = showStr + totalLen;
				}
				if(apstatisticsinterval != 1800)
				{
					totalLen += sprintf(cursor,"set ap statistics interval %d\n",apstatisticsinterval);
					cursor = showStr + totalLen;
				}
				if(gSTAINFOREPORT != 0) 
				{
					totalLen += sprintf(cursor," set wtp sta info report enable\n");
					cursor = showStr + totalLen;
				}
				if(gNTP_STATE != 1)
				{			
					if(gNTP_INTERVAL == 3600){
						totalLen += sprintf(cursor,"set ap ntp start\n");
						cursor = showStr + totalLen;
					}else{
						totalLen += sprintf(cursor,"set ap ntp start %d\n",gNTP_INTERVAL);
						cursor = showStr + totalLen;
					}
				}
			    if(gTER_DIS_INFOSTA_TRAP_COUNT != 2)
                {
                    totalLen += sprintf(cursor,"set ap terminal distrub infomation sta_num %d\n",gTER_DIS_INFOSTA_TRAP_COUNT);
					cursor = showStr + totalLen;
                }
			    if(gTER_DIS_INFOREPORTPKT != 0)
                {
                    totalLen += sprintf(cursor,"set ap terminal distrub infomation reportpkt %d\n",gTER_DIS_INFOREPORTPKT);
					cursor = showStr + totalLen;
                }
				if(gTER_DIS_INFOREPORTSWITCH != 0)
                {
                    totalLen += sprintf(cursor,"set ap terminal distrub infomation switch enable\n");
					cursor = showStr + totalLen;
                }
				if(gNEIGHBORCHANNELRSSITHOLD != -70)
				{
					totalLen += sprintf(cursor,"set wtp neighborchannelrssi threshold %d\n",gNEIGHBORCHANNELRSSITHOLD);
					cursor = showStr + totalLen;
				}
				if(gSAMECHANNELRSSITHOLD != -80)
				{
					totalLen += sprintf(cursor,"set wtp samechannelrssi threshold %d\n",gSAMECHANNELRSSITHOLD);
					cursor = showStr + totalLen;
				}
				if(gWTP_ROGUE_AP_THRESHOLD != 10)
				{
					totalLen += sprintf(cursor," set wtp rogueap threshold %d\n",gWTP_ROGUE_AP_THRESHOLD);
					cursor = showStr + totalLen;	
				}
				if(gWTP_ROGUE_TERMINAL_THRESHOLD != 1)
				{
					totalLen += sprintf(cursor," set wtp rogueterminal threshold %d\n",gWTP_ROGUE_TERMINAL_THRESHOLD);
					cursor = showStr + totalLen;	
				}
				if(gWTP_CPU_USE_THRESHOLD != 10)
				{
					totalLen += sprintf(cursor," set wtp cpu threshold %d\n",gWTP_CPU_USE_THRESHOLD);
					cursor = showStr + totalLen;	
				}
				if(gWTP_MEM_USE_THRESHOLD != 30)
				{
					totalLen += sprintf(cursor," set wtp memory threshold %d\n",gWTP_MEM_USE_THRESHOLD);
					cursor = showStr + totalLen;	
				}
				if(gDHCP_SNOOPING != 0)
				{
					totalLen += sprintf(cursor," set wtp dhcp snooping enable\n");
					cursor = showStr + totalLen;
				}
				if(gWTP_FLOW_TRIGER != 0)
				{
					totalLen += sprintf(cursor," set wtp flow triger %d\n",gWTP_FLOW_TRIGER);
					cursor = showStr + totalLen;
				} 
				if(gWTP_MAX_STA != 64)
				{
					totalLen += sprintf(cursor," set wtp max sta num %d\n",gWTP_MAX_STA);
					cursor = showStr + totalLen;
				}  						
				if(sta_deauth_message_reportswitch)
				{
					totalLen += sprintf(cursor," set sta deauth message report switch enable\n");
				 	cursor = showStr + totalLen;
				}
				if(sta_flow_information_reportswitch)
				{
					totalLen += sprintf(cursor," set ap report sta detail information switch enable\n");
					cursor = showStr + totalLen;
				}
				if(0 != g_radio_5g_sw){
					totalLen += sprintf(cursor," set ap 5g switch %s\n",(g_radio_5g_sw != 0) ?"enable":"disable");
					cursor = showStr + totalLen;
				}
			/************wcl add for globle variable***************/
			/*fengwenchao add 20120117 for onlinebug-96*/
			if(gwtpstate_mb  != 300){
				totalLen += sprintf(cursor,"set ac master_bak correct wtp state timer %d\n",gwtpstate_mb);
				cursor = showStr + totalLen; 
			}			
			/*fengwenchao add end*/
			if((gMaxWTPs_from_sem >0)&&(gMaxWTPs != gMaxWTPs_from_sem))  //fengwenchao modify for read gMaxWTPs from /dbm/local_board/board_ap_max_counter
			{
				totalLen += sprintf(cursor,"set wireless-control max wtp %d\n",gMaxWTPs);
				cursor = showStr + totalLen; 
			}
			else if((gMaxWTPs_from_sem == 0)&&(gMaxWTPs != 1024))	//fengwenchao modify for read gMaxWTPs from /dbm/local_board/board_ap_max_counter
			{
				totalLen += sprintf(cursor,"set wireless-control max wtp %d\n",gMaxWTPs );
				cursor = showStr + totalLen; 
			}
			if((AP_SNR_MAX != gMAX_WEB_REPORT_SNR) || (AP_SNR_MIN != gMIN_WEB_REPORT_SNR))
			{
				totalLen += sprintf(cursor," set web-report ap-snr-range %d %d\n", gMAX_WEB_REPORT_SNR, gMIN_WEB_REPORT_SNR);
				cursor = showStr + totalLen;
			}
			for(i=0; i<num; i++){
				show_running_config_wtp(WTP,i,cursor,&showStr,showStr_new,&totalLen,&str_len);
			}
		}
	}

	//add ap group configuration
	unsigned char j=0, group_len = 0;
	unsigned char temp_ap_group_id[1024], *t_buf;
	struct WTP_GROUP_MEMBER *wtp_next;
	for (j=0; j<WTP_GROUP_NUM; j++) {
		if (WTP_GROUP[j] && WTP_GROUP[j]->GID != 0) {
			wid_syslog_err("for ap-group %d\n", j);
			if(totalLen + 1024 > str_len) {
				str_len *= 2;
				showStr_new = (char*)realloc(showStr,str_len);
				if(showStr_new == NULL){
					wid_syslog_info("show running realloc failed\n");
					goto fail;
				}else {
					showStr = showStr_new;
					memset(showStr+str_len/2,0,str_len/2);
					showStr_new = NULL;
				}
				wid_syslog_debug_debug(WID_DBUS,"show running totalLen %d realloc strlen %d\n",totalLen,str_len);
			}
			cursor = showStr + totalLen;
			totalLen += sprintf(cursor," create ap-group %d %s\n", WTP_GROUP[j]->GID, WTP_GROUP[j]->GNAME);
			cursor = showStr + totalLen;
			if (WTP_GROUP[j]->WTP_COUNT != 0) {
				totalLen += sprintf(cursor," config ap-group %d\n", WTP_GROUP[j]->GID);
				cursor = showStr + totalLen;
				
				t_buf = temp_ap_group_id;
				memset(t_buf, 0, 1024);
				wtp_next = WTP_GROUP[j]->WTP_M;
				while(wtp_next) {
					group_len += sprintf((char *)t_buf, "%u", wtp_next->WTPID);
					t_buf = temp_ap_group_id+group_len;
					wtp_next = wtp_next->next;
					if(wtp_next) {
						group_len += sprintf((char *)t_buf, ",");
						t_buf = temp_ap_group_id+group_len;
					}
				}
				totalLen += sprintf(cursor," add ap-group member %s\n", temp_ap_group_id);
				cursor = showStr + totalLen;
				totalLen += sprintf(cursor," exit\n");
				cursor = showStr + totalLen;
			}
		}
	}
	
	if(totalLen + 1024 > str_len) {
		str_len *= 2;
		showStr_new = (char*)realloc(showStr,str_len);
		if(showStr_new == NULL){
			wid_syslog_info("show running realloc failed\n");
			goto fail;
		}else {
			showStr = showStr_new;
			memset(showStr+str_len/2,0,str_len/2);
			showStr_new = NULL;
		}
		wid_syslog_debug_debug(WID_DBUS,"show running totalLen %d realloc strlen %d\n",totalLen,str_len);
	}
	
	cursor = showStr + totalLen;
	////////added version/////////////////////
	/*if(gEchoRequestTimer != CW_ECHO_INTERVAL_DEFAULT)
	{
		totalLen += sprintf(cursor,"set ap echotimer %d\n",gEchoRequestTimer);
		cursor = showStr + totalLen; 
	}*//*wcl modify for globle variable*/
	if(gCheckRequestTimer != CW_ECHO_INTERVAL_DEFAULT)
	{
		totalLen += sprintf(cursor,"set ap checktimer %d\n",gCheckRequestTimer);
		cursor = showStr + totalLen; 
	}
	if(routine_report_interval!= 50)		/*xiaodawei add for ap routine_collect infomation_reportinterval, 20101210*/
	{
		totalLen += sprintf(cursor,"set ap routine_collect infomation_reportinterval %d\n",routine_report_interval);
		cursor = showStr + totalLen;
	}
	if(moment_report_interval!= 30)		/*xiaodawei add for ap moment_collect infomation_reportinterval, 20101210*/
	{
		totalLen += sprintf(cursor,"set ap moment_collect infomation_reportinterval %d\n",moment_report_interval);
		cursor = showStr + totalLen;
	}
	if(sample_infor_interval!= 30)		/*xiaodawei add for ap sample infomation_reportinterval, 20101210*/
	{
		totalLen += sprintf(cursor,"set ap sample infomation_reportinterval %d\n",sample_infor_interval);
		cursor = showStr + totalLen;
	}

	if(gCWImageDataPendingTimer != CW_IMAGE_INTERVAL_DEFAULT)
	{
		totalLen += sprintf(cursor,"set ap update img timer %d\n",gCWImageDataPendingTimer);
		cursor = showStr + totalLen; 
	}
/*	zhanglei change */

	if(gCWForceMTU != 500)
	{
		totalLen += sprintf(cursor,"set wireless-control max mtu %d\n",gCWForceMTU);
		cursor = showStr + totalLen; 
	}
	
	if(gEnabledLog != 1)
	{
		totalLen += sprintf(cursor,"set wireless-control log switch %s\n",logswtich);
		cursor = showStr + totalLen; 
	}
	
	if(gMaxLogFileSize != DEFAULT_LOG_SIZE)
	{
		totalLen += sprintf(cursor,"set wireless-control log size %d\n",gMaxLogFileSize);
		cursor = showStr + totalLen; 
	}
	if(gapscanset.opstate != 0)
	{
		totalLen += sprintf(cursor,"set radio resource management enable\n");
		cursor = showStr + totalLen; 
		if(channel_state == 1)
		{
			totalLen += sprintf(cursor,"open dynamic channel selection\n");
			cursor = showStr + totalLen; 
		}
		if(txpower_state == 1)
		{
			totalLen += sprintf(cursor,"open transmit power control\n");
			cursor = showStr + totalLen; 
		}
		if(neighborrogueapcount != 10){
			totalLen += sprintf(cursor,"set rogue ap trap threshold %d\n",neighborrogueapcount);
			cursor = showStr + totalLen; 
		}
	}
	if(memcmp(channelRange, channel_t, 4) != 0)
	{
		totalLen += sprintf(cursor,"set dynamic channel selection range %d %d %d %d\n",channelRange[0],channelRange[1],channelRange[2],channelRange[3]);
		cursor = showStr + totalLen; 
	}
	if(gapscanset.countermeasures_switch != 0)
	{
		totalLen += sprintf(cursor,"set radio resource management countermeasures enable\n");
		cursor = showStr + totalLen; 
	}	
	if(gWIDLOGLEVEL != WID_SYSLOG_DEFAULT)
	{
		if(gWIDLOGLEVEL == WID_ALL){
			totalLen += sprintf(cursor,"set wireless-control daemonlog all debug open\n");
			cursor = showStr + totalLen; 
		}else{
			if(gWIDLOGLEVEL & WID_DEFAULT){
				totalLen += sprintf(cursor,"set wireless-control daemonlog default debug open\n");
				cursor = showStr + totalLen; 
			}
			if(gWIDLOGLEVEL & WID_DBUS){
				totalLen += sprintf(cursor,"set wireless-control daemonlog dbus debug open\n");
				cursor = showStr + totalLen; 
			}
			if(gWIDLOGLEVEL & WID_WTPINFO){
				totalLen += sprintf(cursor,"set wireless-control daemonlog wtp debug open\n");
				cursor = showStr + totalLen; 
			}
			if(gWIDLOGLEVEL & WID_MB){
				totalLen += sprintf(cursor,"set wireless-control daemonlog mb debug open\n");
				cursor = showStr + totalLen; 
			}
		}
	}
	/*xiaodawei add for wireless detection prevention, 20110322*/
	if(gwids.flooding != 0)
	{
		totalLen += sprintf(cursor,"set ap wids flooding enable\n");
		cursor = showStr + totalLen; 
	}
	if(gwids.sproof != 0)
	{
		totalLen += sprintf(cursor,"set ap wids spoofing enable\n");
		cursor = showStr + totalLen; 
	}
	if(gwids.weakiv != 0)
	{
		totalLen += sprintf(cursor,"set ap wids weakiv enable\n");
		cursor = showStr + totalLen; 
	}
		if(gdhcp_flooding_status != 0)
		{
			totalLen += sprintf(cursor, "service dhcp-flooding enable\n");
			cursor = showStr + totalLen;
		}
	if(gtrapflag != 1)
	{
		totalLen += sprintf(cursor,"set wireless-control trap level %d\n",gtrapflag);
		cursor = showStr + totalLen; 
	}
	if(gtrap_ap_run_quit_trap_switch != 0)
	{
		totalLen += sprintf(cursor,"set wireless-control trap ap_run_quit switch enable\n");
		cursor = showStr + totalLen; 
	}
	if(gtrap_ap_cpu_trap_switch  != 0)
	{
		totalLen += sprintf(cursor,"set wireless-control trap ap_cpu_threshold switch enable\n");
		cursor = showStr + totalLen; 
	}
	if(gtrap_ap_mem_trap_switch  != 0)
	{
		totalLen += sprintf(cursor,"set wireless-control trap ap_mem_threshold switch enable\n");
		cursor = showStr + totalLen; 
	}
	if(gtrap_flash_write_fail_trap_switch  != 0)
	{
		totalLen += sprintf(cursor,"set wireless-control trap ap_update_fail switch enable\n");
		cursor = showStr + totalLen; 
	}
	if(gtrap_rrm_change_trap_switch  != 0)
	{
		totalLen += sprintf(cursor,"set wireless-control trap rrm_change switch enable\n");
		cursor = showStr + totalLen; 
	}
	if(gtrap_rogue_ap_threshold_switch != 0)
	{
		totalLen += sprintf(cursor,"set wireless-control trap rogue_ap_threshold switch enable\n");
		cursor = showStr + totalLen; 
	}
	if(gtrap_channel_terminal_interference_switch  != 0)
	{
		totalLen += sprintf(cursor,"set wireless-control trap rogue_terminal_threshold switch enable\n");
		cursor = showStr + totalLen; 
	}
	if(gtrap_channel_device_interference_switch  != 0)
	{
		totalLen += sprintf(cursor,"set wireless-control trap rogue_device switch enable\n");
		cursor = showStr + totalLen; 
	}
	if(gtrap_wireless_interface_down_switch  != 0)
	{
		totalLen += sprintf(cursor,"set wireless-control trap wireless_interface_down switch enable\n");
		cursor = showStr + totalLen; 
	}
	if(gtrap_channel_count_minor_switch  != 0)
	{
		totalLen += sprintf(cursor,"set wireless-control trap channel_count_minor switch enable\n");
		cursor = showStr + totalLen; 
	}
	if(gtrap_channel_change_switch  != 0)
	{
		totalLen += sprintf(cursor,"set wireless-control trap channel_change switch enable\n");
		cursor = showStr + totalLen; 
	}
	/*if(g_AC_ALL_EXTENTION_INFORMATION_SWITCH != 0)
	{
		totalLen += sprintf(cursor,"set ac extension infomation switch enable\n");
		cursor = showStr + totalLen; 
	}*//*wcl modify for globle variable*/
/*zhaoruijia,tranlate  neighbor_channel_interference to 1.3,start*/
	if(gtrap_channel_device_ap_switch  != 0)
		{
			totalLen += sprintf(cursor,"set wireless-control trap rogue_ap switch enable\n");
			cursor = showStr + totalLen; 
		}
	
	/*default code
	if(g_AUTO_AP_LOGIN_SAVE_CONFIG_SWITCH == 1)
	{
		if(g_AUTO_AP_LOGIN_SWITCH == 1)
		{
			if(g_AUTO_AP_LOGIN_BINDING_L3_INTERFACE != NULL)
				{
					if(g_AUTO_AP_LOGIN_BINDING_WLANID != 0)
					{
						totalLen += sprintf(cursor,"set auto_ap_login interface %s\n",g_AUTO_AP_LOGIN_BINDING_L3_INTERFACE);
						cursor = showStr + totalLen;
						totalLen += sprintf(cursor,"set auto_ap_login wlan %d\n",g_AUTO_AP_LOGIN_BINDING_WLANID);
						cursor = showStr + totalLen;
						totalLen += sprintf(cursor,"set auto_ap_login switch enable\n");
						cursor = showStr + totalLen;
						totalLen += sprintf(cursor,"set auto_ap_login save_config_switch enable\n");
						cursor = showStr + totalLen;
					}
				}
		}
	}*/
	//auto ap login area
	if((g_auto_ap_login.ifnum != 0)||(g_auto_ap_login.auto_ap_if != NULL))
	{
		int bss = 0;
		wid_auto_ap_if *iflist;
		iflist = g_auto_ap_login.auto_ap_if;
		while(iflist != NULL)
		{
			if(totalLen + 1024 > str_len) {
				str_len *= 2;
				showStr_new = (char*)realloc(showStr,str_len);
				if(showStr_new == NULL){
					wid_syslog_info("show running realloc failed\n");
					break;
				}else {
					showStr = showStr_new;
					memset(showStr+str_len/2,0,str_len/2);
					showStr_new = NULL;
				}
				wid_syslog_debug_debug(WID_DBUS,"show running totalLen %d realloc strlen %d\n",totalLen,str_len);
			}
			
			cursor = showStr + totalLen;
			totalLen += sprintf(cursor,"set auto_ap_login interface add %s\n",iflist->ifname);
			cursor = showStr + totalLen;
			if(iflist->wlannum != 0)
			{
				for(bss=0; bss<L_BSS_NUM; bss++)
				{
					if(iflist->wlanid[bss] != 0 && (AC_WLAN[iflist->wlanid[bss]] != NULL && AC_WLAN[iflist->wlanid[bss]]->want_to_delete != 1))		/* Huangleilei check wlan operation */
					{
						totalLen += sprintf(cursor,"set auto_ap_login wlan %d base interface %s\n",iflist->wlanid[bss],iflist->ifname);
						cursor = showStr + totalLen;
					}
				}
			}
			iflist = iflist->ifnext;
		}
	}
	if(g_auto_ap_login.save_switch == 0)
	{
		totalLen += sprintf(cursor,"set auto_ap_login save_config_switch disable\n");
		cursor = showStr + totalLen;
	}
	if(g_auto_ap_login.auto_ap_switch == 1)
	{
		totalLen += sprintf(cursor,"set auto_ap_login switch enable\n");
		cursor = showStr + totalLen;
	}
	if(tx_power_threshold != 30)
	{
		totalLen += sprintf(cursor,"set txpower threshold %d\n",tx_power_threshold);
		cursor = showStr + totalLen; 
	}
	if(coverage_threshold != 10)
	{
		totalLen += sprintf(cursor,"set coverage threshold %d\n",coverage_threshold);
		cursor = showStr + totalLen; 
	}
	if(wirelessdata_switch!= 0)
	{
		totalLen += sprintf(cursor,"set ap wireless_data revise enable\n");
		cursor = showStr + totalLen; 
	}
	if(wireddata_switch!= 0)
	{
		totalLen += sprintf(cursor,"set ap wired_data revise enable\n");
		cursor = showStr + totalLen; 
	}
	if(apstatistics != 0)
	{
		totalLen += sprintf(cursor,"set ap statistics enable\n");
		cursor = showStr + totalLen; 
	}	
	/* Huang Leilei add 2012-10-25 */
	if (BakCheckInterval != 3600)
	{
		totalLen += sprintf(cursor, "set bak_check_interval %d\n", BakCheckInterval);
		cursor = showStr + totalLen;
	}
	/* Huang Leilei add 2012-10-25*/
	if (LicBakReqInterval != 3600)
	{
		totalLen += sprintf(cursor, "set lic_bak_req_interval %d\n", LicBakReqInterval);
		cursor = showStr + totalLen;
	}
	if(aphotreboot != 0)
	{
		totalLen += sprintf(cursor,"set ap hotreboot enable\n");
		cursor = showStr + totalLen; 
	}		
	if((gapscanset.reportinterval != 0)&&(gapscanset.reportinterval != ROGUE_AP_REPORT_INT))
	{
		totalLen += sprintf(cursor,"set radio resource management report interval %d\n",gapscanset.reportinterval);
		cursor = showStr + totalLen; 
	}
	if(gCWNeighborDeadInterval != CW_NEIGHBORDEAD_INTERVAL_DEFAULT)
	{
		if(vrrid != 0){
			totalLen += sprintf(cursor," ");
			cursor = showStr + totalLen;
		}

		totalLen += sprintf(cursor,"set neighbordead interval %d\n",gCWNeighborDeadInterval);
		cursor = showStr + totalLen; 
	}
	/*zhaoruijia,20100916,ap auto service tftp*/
	if(g_ap_auto_update_service_tftp != 0)
	{
        totalLen += sprintf(cursor,"service tftp enable \n");
		cursor = showStr + totalLen; 
	}
	if(g_service_ftp_state != 0)
	{
        totalLen += sprintf(cursor,"service ftp enable \n");
		cursor = showStr + totalLen; 
	}
	int count = gListenningIF.count;
	unsigned ip = 0;
	if(Lic_ip.lic_active_ac_ip != 0){
        totalLen += sprintf(cursor," set ac state %s addr %d.%d.%d.%d\n",(Lic_ip.isActive == 1)?"master":"bakup",(Lic_ip.lic_active_ac_ip>>24)&0xFF,(Lic_ip.lic_active_ac_ip>>16)&0xFF,(Lic_ip.lic_active_ac_ip>>8)&0xFF,(Lic_ip.lic_active_ac_ip)&0xFF);
		cursor = showStr + totalLen; 
	}
	if((gListenningIF.interfaces != NULL)&&(count > 0)){
		struct CWMultiHomedInterface *p = gListenningIF.interfaces;
		while((p != NULL)&&(count > 0)){
			//totalLen += sprintf(cursor,"set wireless-control listen interface add %s\n",p->ifname);
			ip = ((struct sockaddr_in *)&(p->addr))->sin_addr.s_addr;
			if((p->lic_flag == DOWN_LINK_IP_TYPE)&&(ip != 0)){
				totalLen += sprintf(cursor," set wireless-control listen ip add %d.%d.%d.%d \n",(ip>>24)&0xFF,(ip>>16)&0xFF,(ip>>8)&0xFF,(ip)&0xFF);
			}else if(p->lic_flag == DOWN_LINK_IF_TYPE){
				totalLen += sprintf(cursor,"set wireless-control listen interface add %s\n",p->ifname);
			}
			cursor = showStr + totalLen; 
			p = p->if_next;
			count --;
		}
		p = NULL;
	}
#if 0	
	/*xiaodawei add, 20101115, for set license LIST binding*/
	unsigned int flag = 0;
	char *string = NULL;
	char ** LICE_LIST = NULL;
	string = (char *)WID_MALLOC(4);
	LICE_LIST = (char *)WID_MALLOC(glicensecount*sizeof(char *));
	for(i=0; i<glicensecount; i++){
		if(LICE_LIST[i])
			LICE_LIST[i] = NULL;
	}
	for(i=0; i<glicensecount; i++){
		flag = g_wtp_count[i]->flag;
		if(flag!=0){
			memset(string, 0, 4);
			sprintf(string, "%d", i+1);
			if(LICE_LIST[flag]==NULL){
				LICE_LIST[flag] = (char *)WID_MALLOC(2*glicensecount+1);
				memset(LICE_LIST[flag], 0, 2*glicensecount+1);
				strncat(LICE_LIST[flag],string,strlen(string));
			}
			else{
				strncat(LICE_LIST[flag],",",1);
				strncat(LICE_LIST[flag],string,strlen(string));	
			}
				
		}
	}
	for(i=0; i<glicensecount; i++){
		if(LICE_LIST[i]!=NULL){
			totalLen += sprintf(cursor,"set license %s binding\n",LICE_LIST[i]);
			cursor = showStr + totalLen;
		}
	}
	if(LICE_LIST!=NULL){
		WID_FREE(LICE_LIST);
		LICE_LIST = NULL;
	}
	if(string!=NULL){
		WID_FREE(string);
		string = NULL;
	}
	/*END*/
#endif	
	/* zhangshu add for save offline wtp status switch,2010-09-25 */
	if(hide_quit_wtp_in_showting != 0)
	{
	    totalLen += sprintf(cursor,"set offline wtp statistics disable\n");
		cursor = showStr + totalLen; 
	}
	/*int qosnum = 0;
	AC_QOS *QOS[QOS_NUM];
	char ack[] = "ack";
	char noack[] = "noack";
	i = 0;
	while(i<QOS_NUM)
	{
		if(WID_QOS[i] != NULL)
		{
			QOS[qosnum] = WID_QOS[i];
			qosnum++;
		}
		i++;
	}
	if(qosnum != 0)
	{
		for(i=0;i<qosnum;i++)
		{
			if(totalLen + 1024 > str_len) {
				str_len *= 2;
				showStr_new = (char*)realloc(showStr,str_len);
				if(showStr_new == NULL){
					wid_syslog_info("show running realloc failed\n");
					break;
				}else {
					showStr = showStr_new;
					memset(showStr+str_len/2,0,str_len/2);
					showStr_new = NULL;
				}
				wid_syslog_debug_debug(WID_DBUS,"show running totalLen %d realloc strlen %d\n",totalLen,str_len);
			}
			
			cursor = showStr + totalLen;
			if(QOS[i]->name != NULL)
			{
				totalLen += sprintf(cursor,"create wireless qos profile %d %s\n",QOS[i]->QosID,QOS[i]->name);
				cursor = showStr + totalLen; 
			}
			if(QOS[i]->name != NULL)
			{
				totalLen += sprintf(cursor,"config wireless qos %d\n",QOS[i]->QosID);
				cursor = showStr + totalLen; 
			}

			if((QOS[i]->radio_qos[0]->CWMin != 4)
				||(QOS[i]->radio_qos[0]->CWMax != 10)
				||(QOS[i]->radio_qos[0]->AIFS != 2)
				||(QOS[i]->radio_qos[0]->TXOPlimit != 2048)
				||(QOS[i]->radio_qos[0]->ACK != 1))
			{
				totalLen += sprintf(cursor," set radio besteffort cwmin %d cwmax %d aifs %d txoplimit %d %s\n",QOS[i]->radio_qos[0]->CWMin
																											,QOS[i]->radio_qos[0]->CWMax
																											,QOS[i]->radio_qos[0]->AIFS
																											,QOS[i]->radio_qos[0]->TXOPlimit
																											,(QOS[i]->radio_qos[0]->ACK == 1)?ack:noack);
				cursor = showStr + totalLen; 
			}
			if((QOS[i]->radio_qos[1]->CWMin != 4)
				||(QOS[i]->radio_qos[1]->CWMax != 10)
				||(QOS[i]->radio_qos[1]->AIFS != 7)
				||(QOS[i]->radio_qos[1]->TXOPlimit != 0)
				||(QOS[i]->radio_qos[1]->ACK != 1))
			{
				totalLen += sprintf(cursor," set radio background cwmin %d cwmax %d aifs %d txoplimit %d %s\n",QOS[i]->radio_qos[1]->CWMin
																											,QOS[i]->radio_qos[1]->CWMax
																											,QOS[i]->radio_qos[1]->AIFS
																											,QOS[i]->radio_qos[1]->TXOPlimit
																											,(QOS[i]->radio_qos[1]->ACK == 1)?ack:noack);
				cursor = showStr + totalLen; 
			}
			if((QOS[i]->radio_qos[2]->CWMin != 3)
				||(QOS[i]->radio_qos[2]->CWMax != 4)
				||(QOS[i]->radio_qos[2]->AIFS != 1)
				||(QOS[i]->radio_qos[2]->TXOPlimit != 3008)
				||(QOS[i]->radio_qos[2]->ACK != 1))
			{
				totalLen += sprintf(cursor," set radio video cwmin %d cwmax %d aifs %d txoplimit %d %s\n",QOS[i]->radio_qos[2]->CWMin
																											,QOS[i]->radio_qos[2]->CWMax
																											,QOS[i]->radio_qos[2]->AIFS
																											,QOS[i]->radio_qos[2]->TXOPlimit
																											,(QOS[i]->radio_qos[2]->ACK == 1)?ack:noack);
				cursor = showStr + totalLen; 
			}
			if((QOS[i]->radio_qos[3]->CWMin != 2)
				||(QOS[i]->radio_qos[3]->CWMax != 3)
				||(QOS[i]->radio_qos[3]->AIFS != 1)
				||(QOS[i]->radio_qos[3]->TXOPlimit != 1504)
				||(QOS[i]->radio_qos[3]->ACK != 1))
			{
				totalLen += sprintf(cursor," set radio voice cwmin %d cwmax %d aifs %d txoplimit %d %s\n",QOS[i]->radio_qos[3]->CWMin
																											,QOS[i]->radio_qos[3]->CWMax
																											,QOS[i]->radio_qos[3]->AIFS
																											,QOS[i]->radio_qos[3]->TXOPlimit
																											,(QOS[i]->radio_qos[3]->ACK == 1)?ack:noack);
				cursor = showStr + totalLen; 
			}
			if((QOS[i]->client_qos[0]->CWMin != 4)
				||(QOS[i]->client_qos[0]->CWMax != 10)
				||(QOS[i]->client_qos[0]->AIFS != 2)
				||(QOS[i]->client_qos[0]->TXOPlimit != 2048))
			{
				totalLen += sprintf(cursor," set client besteffort cwmin %d cwmax %d aifs %d txoplimit %d\n",QOS[i]->client_qos[0]->CWMin
																											,QOS[i]->client_qos[0]->CWMax
																											,QOS[i]->client_qos[0]->AIFS
																											,QOS[i]->client_qos[0]->TXOPlimit);
				cursor = showStr + totalLen;
			}
			if((QOS[i]->client_qos[1]->CWMin != 4)
				||(QOS[i]->client_qos[1]->CWMax != 10)
				||(QOS[i]->client_qos[1]->AIFS != 7)
				||(QOS[i]->client_qos[1]->TXOPlimit != 0))
			{
				totalLen += sprintf(cursor," set client background cwmin %d cwmax %d aifs %d txoplimit %d\n",QOS[i]->client_qos[1]->CWMin
																											,QOS[i]->client_qos[1]->CWMax
																											,QOS[i]->client_qos[1]->AIFS
																											,QOS[i]->client_qos[1]->TXOPlimit);
				cursor = showStr + totalLen;
			}
			if((QOS[i]->client_qos[2]->CWMin != 3)
				||(QOS[i]->client_qos[2]->CWMax != 4)
				||(QOS[i]->client_qos[2]->AIFS != 2)
				||(QOS[i]->client_qos[2]->TXOPlimit != 3008))
			{
				totalLen += sprintf(cursor," set client video cwmin %d cwmax %d aifs %d txoplimit %d\n",QOS[i]->client_qos[2]->CWMin
																											,QOS[i]->client_qos[2]->CWMax
																											,QOS[i]->client_qos[2]->AIFS
																											,QOS[i]->client_qos[2]->TXOPlimit);
				cursor = showStr + totalLen; 
			}
			if((QOS[i]->client_qos[3]->CWMin != 2)
				||(QOS[i]->client_qos[3]->CWMax != 3)
				||(QOS[i]->client_qos[3]->AIFS != 2)
				||(QOS[i]->client_qos[3]->TXOPlimit != 1504))
			{
				totalLen += sprintf(cursor," set client voice cwmin %d cwmax %d aifs %d txoplimit %d\n",QOS[i]->client_qos[3]->CWMin
																											,QOS[i]->client_qos[3]->CWMax
																											,QOS[i]->client_qos[3]->AIFS
																											,QOS[i]->client_qos[3]->TXOPlimit);
				cursor = showStr + totalLen; 
			}
			if((QOS[i]->radio_qos[0]->mapstate != 0)||
				(QOS[i]->radio_qos[1]->mapstate != 0)||
				(QOS[i]->radio_qos[2]->mapstate != 0)||
				(QOS[i]->radio_qos[3]->mapstate != 0))
			{
					totalLen += sprintf(cursor," set wmm map enable\n");
					cursor = showStr + totalLen;
			}
			int i2=0;
			for(i2=0;i2<4;i2++)
			{
				if(QOS[i]->radio_qos[i2]->mapstate != 0)
				{
					
					if(QOS[i]->radio_qos[i2]->wmm_map_dot1p != 0)
					{
						switch(i2)
						{
							case 0 : totalLen += sprintf(cursor," wmm besteffort map dot1p %d\n",QOS[i]->radio_qos[i2]->wmm_map_dot1p);
									cursor = showStr + totalLen;
									break;
							case 1 : totalLen += sprintf(cursor," wmm background map dot1p %d\n",QOS[i]->radio_qos[i2]->wmm_map_dot1p);
									cursor = showStr + totalLen;
									break;		
							case 2 : totalLen += sprintf(cursor," wmm video map dot1p %d\n",QOS[i]->radio_qos[i2]->wmm_map_dot1p);
									cursor = showStr + totalLen;
									break;
							case 3 : totalLen += sprintf(cursor," wmm voice map dot1p %d\n",QOS[i]->radio_qos[i2]->wmm_map_dot1p);
									cursor = showStr + totalLen;
									break;
							default : break;
						}
						
					}
					
					if(QOS[i]->radio_qos[i2]->dot1p_map_wmm_num != 0)
					{
						unsigned char dot1p[8];
						int mapnum =0;
						int mapnum2 = 0;
						for(mapnum=0;mapnum<(QOS[i]->radio_qos[i2]->dot1p_map_wmm_num);mapnum++)
						{
							if(QOS[i]->radio_qos[0]->dot1p_map_wmm[mapnum] != 0)
							{
								dot1p[mapnum2] = QOS[i]->radio_qos[i2]->dot1p_map_wmm[mapnum];
								mapnum2++;
							}
							
						}
						if(mapnum2 != 0)
						{
							char *mapstr = NULL,*mapmsg = NULL;
							mapstr = (char*)malloc(16);		
							memset(mapstr,0,16);
							mapmsg = mapstr;
							int length = 0;
							int i1 = 0;
							for(i1=0;i1<mapnum2;i1++)
							{
								length += sprintf (mapmsg, "%d",dot1p[i1]);
								mapmsg = mapstr + length;
								if(i1 != (mapnum2-1))
								{
									length += sprintf (mapmsg, ",");
									mapmsg = mapstr + length;
								}
								else
								{
									
								}
//								printf("%s\n",mapstr);
							}
//							printf("%s\n",mapstr);
							switch(i2)
							{
								case 0 : totalLen += sprintf(cursor," dot1p %s map besteffort\n",mapstr);
										cursor = showStr + totalLen;
										break;
								case 1 : totalLen += sprintf(cursor," dot1p %s map background\n",mapstr);
										cursor = showStr + totalLen;
										break;		
								case 2 : totalLen += sprintf(cursor," dot1p %s map video\n",mapstr);
										cursor = showStr + totalLen;
										break;
								case 3 : totalLen += sprintf(cursor," dot1p %s map voice\n",mapstr);
										cursor = showStr + totalLen;
										break;
								default : break;
							}

							CW_FREE_OBJECT(mapstr);
							
						}
					}
				}
			}
			
			if(QOS[i]->name != NULL)
			{
				totalLen += sprintf(cursor,"exit\n");
				cursor = showStr + totalLen; 
			}
		}
	}*/  //fengwenchao comment 20111214 for AUTELAN-2712

fail:
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_STRING,
									 &showStr);	
	WID_FREE(showStr);
	showStr = NULL;
	WID_FREE(WTP);
	WTP = NULL;
	return reply;


}

DBusMessage * wid_dbus_wtp_show_running_config_end(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusMessageIter  iter;
	unsigned int num=0;
	char *showStr = NULL,*cursor = NULL;
	char *showStr_new = NULL;
	int totalLen = 0;
	int str_len = 0;
	struct acl_config *conf=NULL;
	struct maclist *entry=NULL;
	unsigned int *bssid = NULL;
	unsigned int wlanid = 0 ; 
	unsigned int radio = 0 ; 
	DBusError err;
	//int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	int i=0;
	int j=0;
	int k=0;
	WID_WTP **WTP=NULL;	
	unsigned int bss_num = 0 ; 
	unsigned int command_num = 0;
	bssid = (unsigned int*)WID_MALLOC(BSS_NUM*sizeof(unsigned int));
	if(bssid == NULL){
		wid_syslog_err("%s :bssid malloc fail.\n",__func__);
		goto fail;		
	}
	WTP = WID_MALLOC(WTP_NUM*(sizeof(WID_WTP *)));
	if( WTP == NULL){
		wid_syslog_err("%s %d:WTP malloc fail.\n",__func__,__LINE__);
		goto fail;
	}
	memset(WTP,0,WTP_NUM*(sizeof(WID_WTP *)));
	while(i<WTP_NUM){
		if(AC_WTP[i] != NULL)
		{
			WTP[num] = AC_WTP[i];
			num++;
		}
		i++;
	}
	if(num == 0){	
		str_len = 1;
		showStr = (char*)WID_MALLOC(1);		
		memset(showStr,0,1);
		wid_syslog_debug_debug(WID_DBUS,"no wtp config\n");
	}else{
		showStr = (char*)WID_MALLOC(num*1024);
	
		if(NULL == showStr) {
			wid_syslog_crit("memory WID_MALLOC error\n");
			//return NULL;
		}else{
			str_len = num*1024;
			memset(showStr,0,num*1024);
			cursor = showStr;			
			//totalLen += sprintf(cursor,"*****wtp setting display*****\n");
			// = showStr + totalLen;
			for(i=0; i<num; i++){				
				if(totalLen + 1024 > str_len) {
					str_len *= 2;
					showStr_new = (char*)realloc(showStr,str_len);
					if(showStr_new == NULL){
						wid_syslog_info("show running realloc failed\n");
						break;
					}else {
						showStr = showStr_new;
						memset(showStr+str_len/2,0,str_len/2);
						showStr_new = NULL;
					}
					wid_syslog_info("show running totalLen %d realloc strlen %d\n",totalLen,str_len);
				}
				
				cursor = showStr + totalLen;
				//int rnum = WTP[i]->RadioCount;
				//int j = 0;
				if((WTP[i])&&(WTP[i]->isused == 1))  //fengwenchao modify 20111221
				{
					if((WTP[i]->wtp_login_mode == 1)&&(g_auto_ap_login.save_switch == 0))
					{
						wid_syslog_debug_debug(WID_DBUS,"wtp %d is auto ap,but wid do not allow save auto ap config\n",WTP[i]->WTPID);
						continue;	
					}
					else
					{
						totalLen += sprintf(cursor,"config wtp %d\n",WTP[i]->WTPID);
						cursor = showStr + totalLen;
						totalLen += sprintf(cursor," wtp used\n");
						cursor = showStr + totalLen;
						totalLen += sprintf(cursor,"exit\n");
						cursor = showStr + totalLen;
					}
				}
				for(j=0;j<L_RADIO_NUM;j++)
				{
					if(totalLen + 1024 > str_len) {
						str_len *= 2;
						showStr_new = (char*)realloc(showStr,str_len);
						if(showStr_new == NULL){
							wid_syslog_info("show running realloc failed\n");
							break;
						}else {
							showStr = showStr_new;
							memset(showStr+str_len/2,0,str_len/2);
							showStr_new = NULL;
						}
						wid_syslog_debug_debug(WID_DBUS,"show running totalLen %d realloc strlen %d\n",totalLen,str_len);
					}
					
					cursor = showStr + totalLen;
					/*if((WTP[i]->WTP_Radio[j] != NULL)&&(WTP[i]->WTP_Radio[j]->QOSstate != 0))
					{
						totalLen += sprintf(cursor,"config radio %d\n",WTP[i]->WTP_Radio[j]->Radio_G_ID);
						cursor = showStr + totalLen;
						totalLen += sprintf(cursor," radio apply qos %d\n",WTP[i]->WTP_Radio[j]->QOSID);
						cursor = showStr + totalLen;
						totalLen += sprintf(cursor,"exit\n");
						cursor = showStr + totalLen;
					}*/  //fengwenchao comment 20111214 for AUTELAN-2712
					
					if((WTP[i])&&(WTP[i]->WTP_Radio[j] != NULL))
					{
						totalLen += sprintf(cursor,"config radio %d-%d\n",WTP[i]->WTPID,WTP[i]->WTP_Radio[j]->Radio_L_ID);
						cursor = showStr + totalLen;
						for(k=0;k<L_BSS_NUM;k++)
						{
							if(WTP[i]->WTP_Radio[j]->BSS[k] != NULL && AC_WLAN[WTP[i]->WTP_Radio[j]->BSS[k]->WlanID] != NULL && AC_WLAN[WTP[i]->WTP_Radio[j]->BSS[k]->WlanID]->want_to_delete != 1)	/* Huangleilei check wlan operation */
							{
								
								if(WTP[i]->WTP_Radio[j]->BSS[k]->WDSStat == WDS_ANY)
								{
									if(WTP[i]->WTP_Radio[j]->BSS[k]->wds_mesh == 0){
										//totalLen += sprintf(cursor,"config radio %d\n",WTP[i]->WTP_Radio[j]->Radio_G_ID);
										totalLen += sprintf(cursor," wlan %d wds enable\n",WTP[i]->WTP_Radio[j]->BSS[k]->WlanID);
										cursor = showStr + totalLen;						
										//break;
									}
									else{
										totalLen += sprintf(cursor," wlan %d mesh enable\n",WTP[i]->WTP_Radio[j]->BSS[k]->WlanID);
										cursor = showStr + totalLen;						
										//break;
									}
								}
								wlanid = WTP[i]->WTP_Radio[j]->BSS[k]->WlanID;
								if((WTP[i]->WTP_Radio[j]->BSS[k]->BSS_IF_POLICY != NO_INTERFACE)\
									&&(AC_WLAN[wlanid] != NULL)
								&&(WTP[i]->WTP_Radio[j]->BSS[k]->BSS_TUNNEL_POLICY != AC_WLAN[wlanid]->WLAN_TUNNEL_POLICY)){
									if(WTP[i]->WTP_Radio[j]->BSS[k]->BSS_TUNNEL_POLICY == CW_802_DOT_3_TUNNEL){
										if(vrrid != 0){
											totalLen += sprintf(cursor," ");
											cursor = showStr + totalLen;
										}
										totalLen += sprintf(cursor," wlan %d tunnel mode capwap802dot3\n",WTP[i]->WTP_Radio[j]->BSS[k]->WlanID);
										cursor = showStr + totalLen;
									}else if(WTP[i]->WTP_Radio[j]->BSS[k]->BSS_TUNNEL_POLICY == CW_802_DOT_11_TUNNEL){
										if(vrrid != 0){
											totalLen += sprintf(cursor," ");
											cursor = showStr + totalLen;
										}
										totalLen += sprintf(cursor," wlan %d tunnel mode capwap802dot11\n",WTP[i]->WTP_Radio[j]->BSS[k]->WlanID);
										cursor = showStr + totalLen;
									}else if(WTP[i]->WTP_Radio[j]->BSS[k]->BSS_TUNNEL_POLICY == CW_802_IPIP_TUNNEL){
										if(vrrid != 0){
											totalLen += sprintf(cursor," ");
											cursor = showStr + totalLen;
										}
										totalLen += sprintf(cursor," wlan %d tunnel mode ipip\n",WTP[i]->WTP_Radio[j]->BSS[k]->WlanID);
										cursor = showStr + totalLen;
									}
								}
										
							}
						}
						totalLen += sprintf(cursor,"exit\n");
						cursor = showStr + totalLen;
					}
				}
				}
			while(i<BSS_NUM){
				if(AC_BSS[i]!=NULL){
					bssid[bss_num] = AC_BSS[i]->BSSIndex;
					bss_num++;
				}
				i++;
			}
			for (i=0; i<bss_num; i++) {
				if( (AC_BSS[bssid[i]] != NULL) &&(AC_BSS[bssid[i]]->acl_conf != NULL) ) {
					command_num += AC_BSS[bssid[i]]->acl_conf->num_accept_mac + 
						AC_BSS[bssid[i]]->acl_conf->num_deny_mac + 1;
				}
			}
			
			if(command_num == 0){
				wid_syslog_debug_debug(WID_DEFAULT,"no bss mac list profile\n"); 
			}else{
				showStr_new = (char*)realloc(showStr,totalLen+command_num*50);
				
				if(NULL == showStr_new){
					wid_syslog_crit("memory WID_MALLOC error\n");
					exit(1);
				} else {
					showStr = showStr_new;
					cursor = showStr + totalLen; 
					
					for(i=0; i<bss_num; i++){
						conf = AC_BSS[bssid[i]]->acl_conf;
						if( conf != NULL && AC_WLAN[AC_BSS[bssid[i]]->WlanID] != NULL && AC_WLAN[AC_BSS[bssid[i]]->WlanID]->want_to_delete != 1) {		/* Huangleilei check wlan operation */
							radio = AC_BSS[bssid[i]]->Radio_G_ID;
							wlanid = AC_BSS[bssid[i]]->WlanID;
							if( conf->macaddr_acl != 0 ) {
								totalLen += sprintf(cursor,"radio %d wlan %d use %s list \n",radio,wlanid,(conf->macaddr_acl==1)?"black":"white");
								cursor = showStr + totalLen;
							}
			
							for(entry=conf->accept_mac; entry; entry=entry->next) {
								totalLen += sprintf(cursor,"radio %d wlan %d add white list "MACSTR"\n",radio,wlanid,MAC2STR(entry->addr));
								cursor = showStr + totalLen;
							}
							
							for(entry=conf->deny_mac; entry; entry=entry->next) {
								totalLen += sprintf(cursor,"radio %d wlan %d add black list "MACSTR"\n",radio,wlanid,MAC2STR(entry->addr));
								cursor = showStr + totalLen;
							}
						}
						}
				}
				}
		}
	}
fail:
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_STRING,
									 &showStr);	
	WID_FREE(showStr);
	showStr = NULL;
	if(bssid){
		WID_FREE(bssid);
		bssid = NULL;
	}
	WID_FREE(WTP);
	WTP = NULL;
	return reply;


}
DBusMessage * wid_dbus_ebr_show_running_config_start(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusMessageIter  iter;
	unsigned int num=0;
	char *showStr = NULL,*cursor = NULL;
	int totalLen = 0;
	DBusError err;
	//int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	int i = 0;
	ETHEREAL_BRIDGE *EBR[EBR_NUM];
	while(i<EBR_NUM){
		if(WID_EBR[i] != NULL)
		{
			EBR[num] = WID_EBR[i];
			num++;
		}
		i++;
	}
	if(num == 0){		
		showStr = (char*)WID_MALLOC(1); 	
		memset(showStr,0,1);
		wid_syslog_debug_debug(WID_DBUS,"no ebr config\n");
	}else{
		showStr = (char*)WID_MALLOC(num*1024);
	
		if(NULL == showStr) {
			wid_syslog_crit("memory malloc error\n");
			//return NULL;
		}else{
			memset(showStr,0,num*1024);
			cursor = showStr;	
			
			for(i=0; i<num; i++)
			{				
				totalLen += sprintf(cursor,"create ebr %d %s\n",EBR[i]->EBRID,EBR[i]->name);
				cursor = showStr + totalLen;
				totalLen += sprintf(cursor,"config ebr %d\n",EBR[i]->EBRID);
				cursor = showStr + totalLen;
				totalLen += sprintf(cursor," service enable\n");
				cursor = showStr + totalLen;
				totalLen += sprintf(cursor,"exit\n");
				cursor = showStr + totalLen;
			}
		}
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_STRING,
									 &showStr);	
	WID_FREE(showStr);
	showStr = NULL;
	return reply;


}

DBusMessage * wid_dbus_ebr_show_running_config_end(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusMessageIter  iter;
	unsigned int num=0;
	unsigned int wtp_num = 0;
	char *showStr = NULL,*cursor = NULL;
	char *showStr_new = NULL;	//ht add 090907
	int str_len = 0;
	int totalLen = 0;
	DBusError err;
	//int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	int i=0;
	int j=0;
	ETHEREAL_BRIDGE *EBR[EBR_NUM];
	while(i<EBR_NUM){
		if(WID_EBR[i] != NULL)
		{
			EBR[num] = WID_EBR[i];
			num++;
		}
		i++;
	}

	while(j<WTP_NUM){
		if(AC_WTP[j] != NULL)
		{
			wtp_num++;
		}
		j++;
	}
	
	if(num == 0){		
		showStr = (char*)WID_MALLOC(1); 	
		memset(showStr,0,1);
		wid_syslog_debug_debug(WID_DBUS,"no ebr config\n");
	}else{
		if(wtp_num > num)
			str_len = wtp_num*1024;	
		else
			str_len = num*1024;
		showStr = (char*)WID_MALLOC(str_len);
	
		if(NULL == showStr) {
			wid_syslog_crit("memory malloc error\n");
			//return NULL;
		}else{
			memset(showStr,0,str_len);
			cursor = showStr;	
			
			for(i=0; i<num; i++)
			{				
				totalLen += sprintf(cursor,"config ebr %d\n",EBR[i]->EBRID);
				cursor = showStr + totalLen;
				totalLen += sprintf(cursor," service disable\n");
				cursor = showStr + totalLen;
				if(EBR[i]->isolation_policy != 1)
				{
					totalLen += sprintf(cursor," set bridge_isolation disable\n");
					cursor = showStr + totalLen;
				}
				if(EBR[i]->multicast_isolation_policy != 1)
				{
					totalLen += sprintf(cursor," set bridge_multicast_isolation disable\n");
					cursor = showStr + totalLen;
				}
				if(EBR[i]->bridge_ucast_solicit_stat != 1)
				{
					totalLen += sprintf(cursor," set bridge_ucast_solicit disable\n");
					cursor = showStr + totalLen;
				}
				if(EBR[i]->bridge_mcast_solicit_stat != 1)
				{
					totalLen += sprintf(cursor, " set bridge_mcast_solicit disable\n");
					cursor = showStr + totalLen;
				}
				if(EBR[i]->sameportswitch != 0)
				{
					totalLen += sprintf(cursor," set bridge sameportswitch enable\n");
					cursor = showStr + totalLen;
				}
				if(EBR[i]->multicast_fdb_learn != 1)
				{
					totalLen += sprintf(cursor," set ebr multicast fdb learn disable\n");
					cursor = showStr + totalLen;
				}
				if((EBR[i]->iflist != NULL))
				{
					EBR_IF_LIST *tmp;
					tmp = EBR[i]->iflist;							
					while(tmp != NULL)
					{	
						if(totalLen + 1024 > str_len) {
							str_len *= 2;
							showStr_new = (char*)realloc(showStr,str_len);
							if(showStr_new == NULL){
								wid_syslog_info("show running realloc failed\n");
								break;
							}else {
								showStr = showStr_new;
								memset(showStr+str_len/2,0,str_len/2);
								showStr_new = NULL;
							}
							wid_syslog_debug_debug(WID_DBUS,"show running totalLen %d realloc strlen %d\n",totalLen,str_len);
						}
						
						cursor = showStr + totalLen;
						totalLen += sprintf(cursor," set ebr add interface %s\n",tmp->ifname);
						cursor = showStr + totalLen;
						tmp = tmp->ifnext;
					}
				}

				if((EBR[i]->uplinklist != NULL))
				{
					EBR_IF_LIST *tmp2;
					tmp2 = EBR[i]->uplinklist;							
					while(tmp2 != NULL)
					{	
						if(totalLen + 1024 > str_len) {
							str_len *= 2;
							showStr_new = (char*)realloc(showStr,str_len);
							if(showStr_new == NULL){
								wid_syslog_info("show running realloc failed\n");
								break;
							}else {
								showStr = showStr_new;
								memset(showStr+str_len/2,0,str_len/2);
								showStr_new = NULL;
							}
							wid_syslog_debug_debug(WID_DBUS,"show running totalLen %d realloc strlen %d\n",totalLen,str_len);
						}
						
						cursor = showStr + totalLen;
						totalLen += sprintf(cursor," set ebr add uplink %s\n",tmp2->ifname);
						cursor = showStr + totalLen;
						tmp2 = tmp2->ifnext;
					}
				}

				
				if(EBR[i]->state == 1)
				{
					totalLen += sprintf(cursor," service enable\n");
					cursor = showStr + totalLen;
				}
				totalLen += sprintf(cursor,"exit\n");
				cursor = showStr + totalLen;
			}
		}
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_STRING,
									 &showStr); 
	WID_FREE(showStr);
	showStr = NULL;
	return reply;


}

DBusMessage * wid_dbus_ac_ip_list_show_running_config(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply;
	DBusMessageIter  iter;
	unsigned char num=0;
	char *showStr = NULL,*cursor = NULL;
	int totalLen = 0;
	DBusError err;
	//int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	int i = 0;
	wid_ac_ip_group *ACIPLIST[ACIPLIST_NUM];

	while(i<ACIPLIST_NUM){
		if(AC_IP_GROUP[i] != NULL)
		{
			ACIPLIST[num] = AC_IP_GROUP[i];
			num++;
		}
		i++;
	}
	if(num == 0){		
		showStr = (char*)WID_MALLOC(1); 	
		memset(showStr,0,1);
		wid_syslog_debug_debug(WID_DBUS,"no ac ip list config\n");
	}else{
		showStr = (char*)WID_MALLOC(num*1024);
	
		if(NULL == showStr) {
			wid_syslog_crit("memory malloc error\n");
			//return NULL;
		}else{
			memset(showStr,0,num*1024);
			cursor = showStr;	
			
			for(i=0; i<num; i++)
			{				
				totalLen += sprintf(cursor,"create ac-ip-list %d base %s\n",ACIPLIST[i]->GroupID, ACIPLIST[i]->ifname);
				cursor = showStr + totalLen;
				totalLen += sprintf(cursor,"config ac-ip-list %d\n",ACIPLIST[i]->GroupID);
				cursor = showStr + totalLen;
				if(ACIPLIST[i]->ip_list != NULL){
					struct wid_ac_ip *tmp = ACIPLIST[i]->ip_list;
					while(tmp != NULL){
						totalLen += sprintf(cursor," add ac ip %s priority %d\n",tmp->ip, tmp->priority);
						cursor = showStr + totalLen;
						tmp = tmp->next;
					}
				}
				totalLen += sprintf(cursor,"exit\n");
				cursor = showStr + totalLen;
			}
		}
	}
	reply = dbus_message_new_method_return(msg);
	
	dbus_message_iter_init_append (reply, &iter);
	
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_STRING,
									 &showStr);	
	WID_FREE(showStr);
	showStr = NULL;
	return reply;


}
DBusMessage * wid_dbus_interface_show_wlan_pkt_infomation(DBusConnection *conn, DBusMessage *msg, void *user_data)
{

	DBusMessage* reply;
	DBusMessageIter  iter;
	DBusError err;
	unsigned char wlanid = 0;
	int i = 0;
	int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else{
		for(i = 0; i < WTP_NUM; i++){
			if(AC_WLAN[wlanid]->S_WTP_BSS_List[i][0] != 0){
				if(AC_WTP[i] != NULL){
					AC_WLAN[wlanid]->wifi_extension_info.tx_packets += AC_WTP[i]->wifi_extension_info.tx_packets;
					AC_WLAN[wlanid]->wifi_extension_info.tx_errors += AC_WTP[i]->wifi_extension_info.tx_errors;
					AC_WLAN[wlanid]->wifi_extension_info.tx_unicast += AC_WTP[i]->wifi_extension_info.tx_unicast;
					AC_WLAN[wlanid]->wifi_extension_info.tx_broadcast += AC_WTP[i]->wifi_extension_info.tx_broadcast;
					AC_WLAN[wlanid]->wifi_extension_info.tx_drop += AC_WTP[i]->wifi_extension_info.tx_drop;
					AC_WLAN[wlanid]->wifi_extension_info.tx_bytes += (unsigned long long)AC_WTP[i]->apstatsinfo[0].tx_bytes;
					AC_WLAN[wlanid]->wifi_extension_info.rx_packets += AC_WTP[i]->apstatsinfo[0].rx_packets;
					AC_WLAN[wlanid]->wifi_extension_info.rx_errors += AC_WTP[i]->apstatsinfo[0].rx_errors;
					AC_WLAN[wlanid]->wifi_extension_info.rx_bytes += (unsigned long long)AC_WTP[i]->apstatsinfo[0].rx_bytes;
					AC_WLAN[wlanid]->wifi_extension_info.rx_unicast += AC_WTP[i]->wifi_extension_info.rx_unicast;
					AC_WLAN[wlanid]->wifi_extension_info.rx_broadcast += AC_WTP[i]->wifi_extension_info.rx_broadcast;
					AC_WLAN[wlanid]->wifi_extension_info.rx_drop += AC_WTP[i]->wifi_extension_info.rx_drop;
				}
			}
		}
	}		
	reply = dbus_message_new_method_return(msg);

	if(ret != WID_DBUS_SUCCESS)
	{
		dbus_message_iter_init_append(reply, &iter);
		
		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	}
	else
	{
		dbus_message_iter_init_append(reply, &iter);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WLAN[wlanid]->wifi_extension_info.tx_packets));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WLAN[wlanid]->wifi_extension_info.tx_errors));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WLAN[wlanid]->wifi_extension_info.tx_unicast));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WLAN[wlanid]->wifi_extension_info.tx_broadcast));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WLAN[wlanid]->wifi_extension_info.tx_drop));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WLAN[wlanid]->wifi_extension_info.tx_bytes));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WLAN[wlanid]->wifi_extension_info.rx_packets));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WLAN[wlanid]->wifi_extension_info.rx_errors));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WLAN[wlanid]->wifi_extension_info.rx_unicast));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WLAN[wlanid]->wifi_extension_info.rx_broadcast));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WLAN[wlanid]->wifi_extension_info.rx_drop));

		dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(AC_WLAN[wlanid]->wifi_extension_info.rx_bytes));

	}
	return reply;
	
}
/*zhaoruijia,20100916,add ap auto update service tftp,start*/

DBusMessage * wid_dbus_service_tftp_state(DBusConnection *conn, DBusMessage *msg, void *user_data){

    DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned char policy[6] = {0};
    char buff[128] = {0};
	int sysState=0;
	int sysErrorCode = 0;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
    unsigned int ap_auto_update_service_tftp = 0;
 
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&ap_auto_update_service_tftp,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
  
	if(ap_auto_update_service_tftp == 1){
		
        memcpy(policy,"start",5);
   	    ret = WID_DBUS_SUCCESS;
	}
	else if(ap_auto_update_service_tftp == 0){

        memcpy(policy,"stop",4);
	    ret = WID_DBUS_SUCCESS;
		
	}
	else{
		memcpy(policy,"stop",4);
		ret = WID_DBUS_ERROR;
	}
    wid_syslog_debug_debug(WID_DBUS,"service tftp %s\n",policy);

	sprintf(buff, "sudo /etc/init.d/tftpd-hpa %s &", policy);

    sysState = system(buff);
    sysErrorCode = WEXITSTATUS(sysState);
	if(0==sysErrorCode)
	{
        if(ap_auto_update_service_tftp == 1){
          g_ap_auto_update_service_tftp  = 1;
		}
		else if(ap_auto_update_service_tftp == 0){
          g_ap_auto_update_service_tftp  = 0;
		}
		else{
          g_ap_auto_update_service_tftp  = 0;
		}
	}
   else
	{
		
		wid_syslog_debug_debug(WID_DBUS,"System cmd error,error code %d\n",sysErrorCode);
		
	}

	if(sysState != 0 )
    {
		
        wid_syslog_debug_debug(WID_DBUS,"System sysState error,error code %d\n",sysState);
		
	}
   
	reply = dbus_message_new_method_return(msg);
			
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;	
}

/*zhaoruijia,20100916,add service tftp,end*/

/*zhaoruijia,20100916,add service ftp,end*/


DBusMessage * wid_dbus_service_ftp_state(DBusConnection *conn, DBusMessage *msg, void *user_data){

    DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned char policy[6] = {0};
    char buff[128] = {0};
	int sysState=0;
	int sysErrorCode = 0;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
    unsigned service_ftp_state  = 0;
 
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&service_ftp_state,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
  
	if(service_ftp_state == 1){
		
        memcpy(policy,"start",5);
   	    ret = WID_DBUS_SUCCESS;
	}
	else if(service_ftp_state == 0){

        memcpy(policy,"stop",4);
	    ret = WID_DBUS_SUCCESS;
		
	}
	else{
		memcpy(policy,"stop",4);
		ret = WID_DBUS_ERROR;
	}
    wid_syslog_debug_debug(WID_DBUS,"service ftp %s\n",policy);

	sprintf(buff, "sudo /etc/init.d/pure-ftpd %s &", policy);

    sysState = system(buff);
    sysErrorCode = WEXITSTATUS(sysState);
	if(0==sysErrorCode)
	{
        if(service_ftp_state == 1){
          g_service_ftp_state  = 1;
		}
		else if(service_ftp_state == 0){
          g_service_ftp_state  = 0;
		}
		else{
          g_service_ftp_state  = 0;
		}
	}
   else
	{
		
		wid_syslog_debug_debug(WID_DBUS,"System cmd error,error code %d\n",sysErrorCode);
		
	}

	if(sysState != 0 )
    {
		
        wid_syslog_debug_debug(WID_DBUS,"System sysState error,error code %d\n",sysState);
		
	}
   
	reply = dbus_message_new_method_return(msg);
			
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;	
}


DBusMessage * wid_dbus_show_service_tftp_state(DBusConnection *conn, DBusMessage *msg, void *user_data){
    DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;
	dbus_error_init(&err);	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
    dbus_message_iter_append_basic(&iter,DBUS_TYPE_UINT32,&g_ap_auto_update_service_tftp);

	return reply;

}

DBusMessage * wid_dbus_show_service_ftp_state(DBusConnection *conn, DBusMessage *msg, void *user_data){
    DBusMessage * reply;
	DBusMessageIter  iter;
	DBusError err;
	dbus_error_init(&err);	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
    dbus_message_iter_append_basic(&iter,DBUS_TYPE_UINT32,&g_service_ftp_state);

	return reply;

}

/*zhaoruijia,translate  neighbor_channel_interference to 1.3,start*/
DBusMessage *wid_dbus_set_neighbor_same_channelrssi_threshold(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply = NULL;	
	DBusMessageIter	 iter;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	unsigned int policy = 0;
	int value = 0;
	unsigned int wtpid = 0;
	unsigned int i = 0;
   dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wtpid,
								DBUS_TYPE_UINT32,&policy,
								DBUS_TYPE_UINT32,&value,
								DBUS_TYPE_INVALID))){
		printf("Unable to get input args\n");
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	
	if(wtpid == 0){
		if(policy == 1){
			gNEIGHBORCHANNELRSSITHOLD = value;
		}else if(policy == 2){
			gSAMECHANNELRSSITHOLD = value;
		}/*wcl add for globle variable*/
		for(i=0;i<WTP_NUM;i++){
			if(AC_WTP[i] != NULL){
				if(policy == 1)
				{
					AC_WTP[i]->neighborchannelrssithold = value;
				}
				else if(policy == 2)
				{
					AC_WTP[i]->samechannelrssithold = value; 
				}
				
				
			}
		}
	}
	else{
      if((wtpid<WTP_NUM)&&(AC_WTP[wtpid] != NULL)){
		if(policy == 1)
		{
			AC_WTP[wtpid]->neighborchannelrssithold = value;
		}
		else if(policy == 2)
		{
			AC_WTP[wtpid]->samechannelrssithold = value;
		}
		
		else
		{
			ret = WID_DBUS_ERROR;
		}
      }
	}
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_interface_set_neighbor_same_channelrssi_threshold policy %d trap_threshold %d",policy,value);
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append (reply, &iter);
	dbus_message_iter_append_basic (&iter,
									 DBUS_TYPE_UINT32,
									 &ret);
	return reply;	
}


/*zhaoruijia,20101103,for wid wsm error handle control,start*/
DBusMessage * wid_dbus_set_wid_error_handle_state(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply = NULL;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int wid_wsm_error_handle_state = 0;

	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;

	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&wid_wsm_error_handle_state,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
   }

	if(wid_wsm_error_handle_state == 1){
           g_wid_wsm_error_handle_state  = 1;
		}
	else if(wid_wsm_error_handle_state == 0){
           g_wid_wsm_error_handle_state  = 0;
		}
	else{
          g_wid_wsm_error_handle_state  = 0;
		  ret = WID_DBUS_ERROR;
	}

	wid_syslog_debug_debug(WID_DBUS,"Wid Error handle state %d\n",g_wid_wsm_error_handle_state);
  
    reply = dbus_message_new_method_return(msg);
			
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	
	return reply;	

}


DBusMessage * wid_dbus_add_black_white_oui_mac_to_xml(DBusConnection *conn, DBusMessage *msg, void *user_data){

	DBusMessage* reply = NULL;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned char oui_mac[OUI_LEN] = { 0 };
	unsigned int  ouiXmlType = 0;
	unsigned int ret = WID_DBUS_SUCCESS;
	int i = 0;
	CWOUIInfo *OuiInfoList = NULL;
	CWOUIInfo *OuiInfoList_tmp = NULL;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&ouiXmlType,
							    DBUS_TYPE_BYTE,&oui_mac[0],
								DBUS_TYPE_BYTE,&oui_mac[1],
								DBUS_TYPE_BYTE,&oui_mac[2],
								DBUS_TYPE_INVALID))){
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
	}

    switch(ouiXmlType){
      case 1:{//add black oui mac
         if(CWAddBlackOuiInfoToXml(oui_mac)) {
	            wid_syslog_debug_debug(WID_DBUS,"add BLACK_OUI_MAC:"OUIMACSTR" to blackouilist.xml Successfull \n",OUIMAC2STR(oui_mac));
	            CWThreadMutexLock(&(gOuiMacXmlMutex));	
				CWParseBlackOuiInfoXML(&OuiInfoList);
	            OuiInfoList_tmp = gBlackOuiInfoList;
				gBlackOuiInfoList = OuiInfoList;
				CWFreeOuiInfoList(&OuiInfoList_tmp);
				CWThreadMutexUnlock(&(gOuiMacXmlMutex));	
				if(gOuiListType == 1){//now ,use blackouilist
                   for(i=0;i<WTP_NUM;i++){
				   	   if((AC_WTP[i]!=NULL)&&
					   	   (AC_WTP[i]->WTPMAC!=NULL)&&
			   	           (AC_WTP[i]->WTPStat == 5)){
					   	   wid_syslog_debug_debug(WID_DBUS,"AC_WTP[%d]->MAC: "OUIMACSTR"\n",i,OUIMAC2STR(AC_WTP[i]->WTPMAC));
					   	   if(oui_mac_filters(AC_WTP[i]->WTPMAC)){
						   	    wid_syslog_debug_debug(WID_DBUS,"AC_WTP[%d]->MAC: "OUIMACSTR"Was filtered\n",i,OUIMAC2STR(AC_WTP[i]->WTPMAC));
                                wid_set_ap_reboot(i);       
				         }
                   	}
              	   }
				}
		 }
		 else{
              ret = WID_ADD_BLACK_WHITE_OUI_MAC_ERR;
		 }
      }
	  break;
	  case 2:{//add white oui mac
	     if(CWAddWhiteOuiInfoToXml(oui_mac)){
		 	 wid_syslog_debug_debug(WID_DBUS,"add WHITE_OUI_MAC:"OUIMACSTR" to whiteouilist.xml Successfull \n",OUIMAC2STR(oui_mac));
		 	 CWThreadMutexLock(&(gOuiMacXmlMutex));	
			 CWParseWhiteOuiInfoXML(&OuiInfoList);
	         OuiInfoList_tmp = gWhiteOuiInfoList;
			 gWhiteOuiInfoList = OuiInfoList;
			 CWFreeOuiInfoList(&OuiInfoList_tmp);
			 CWThreadMutexUnlock(&(gOuiMacXmlMutex));
	     }
		 else{
            ret = WID_ADD_BLACK_WHITE_OUI_MAC_ERR;
		 }
	  }
	  break;
	  default:
        break;
   }
    reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	return reply;
}
DBusMessage * wid_dbus_del_black_white_oui_mac_from_xml(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply = NULL;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned char oui_mac[OUI_LEN] = { 0 };
	unsigned int  ouiXmlType = 0;
	unsigned int ret = WID_DBUS_SUCCESS;
	int i = 0;
//	int delState = 0;
	CWOUIInfo *OuiInfoList = NULL;
	CWOUIInfo *OuiInfoList_tmp = NULL;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&ouiXmlType,
							    DBUS_TYPE_BYTE,&oui_mac[0],
								DBUS_TYPE_BYTE,&oui_mac[1],
								DBUS_TYPE_BYTE,&oui_mac[2],
								DBUS_TYPE_INVALID))){
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
	}
    switch(ouiXmlType){
      case 1:{//del black oui mac
	   if(1 == CWDelBlackOuiInfoFromXml(oui_mac)){
			 wid_syslog_debug_debug(WID_DBUS,"del BLACK_OUI_MAC:"OUIMACSTR" to blackouilist.xml Successfull \n",OUIMAC2STR(oui_mac));
             CWThreadMutexLock(&(gOuiMacXmlMutex));	
			 CWParseBlackOuiInfoXML(&OuiInfoList);
	         OuiInfoList_tmp = gBlackOuiInfoList;
			 gBlackOuiInfoList = OuiInfoList;
			 CWFreeOuiInfoList(&OuiInfoList_tmp);
			 CWThreadMutexUnlock(&(gOuiMacXmlMutex));
		}
		else{
              ret = WID_DEL_BLACK_WHITE_OUI_MAC_ERR;
		 }
      }
	  break;
	  case 2:{//del white oui mac
	     if(1 == CWDelWhiteOuiInfoFromXml(oui_mac)){
			 wid_syslog_debug_debug(WID_DBUS,"del WHITE_OUI_MAC:"OUIMACSTR" to blackouilist.xml Successfull \n",OUIMAC2STR(oui_mac));
             CWThreadMutexLock(&(gOuiMacXmlMutex));	
			 CWParseWhiteOuiInfoXML(&OuiInfoList);
	         OuiInfoList_tmp = gWhiteOuiInfoList;
			 gWhiteOuiInfoList = OuiInfoList;
			 CWFreeOuiInfoList(&OuiInfoList_tmp);
			 CWThreadMutexUnlock(&(gOuiMacXmlMutex));
             if(gOuiListType == 2 ){
				 for(i=0 ;i<WTP_NUM;i++){
				 	if((AC_WTP[i] != NULL)&&
						(AC_WTP[i]->WTPMAC!=NULL)&&
			   	        (AC_WTP[i]->WTPStat == 5)
					   ){
					   	   wid_syslog_debug_debug(WID_DBUS,"AC_WTP[%d]->MAC: "OUIMACSTR"\n",i,OUIMAC2STR(AC_WTP[i]->WTPMAC));
					   	   if(oui_mac_filters(AC_WTP[i]->WTPMAC)){
						   	    wid_syslog_debug_debug(WID_DBUS,"AC_WTP[%d]->MAC: "OUIMACSTR"Was filtered\n",i,OUIMAC2STR(AC_WTP[i]->WTPMAC));
                                wid_set_ap_reboot(i);       
				         }
                   	}
				 }
			 }
		}
		else{
              ret = WID_DEL_BLACK_WHITE_OUI_MAC_ERR;
		 }
	  }
	  break;
	  default:
        break;
   }
    reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	return reply;
}
DBusMessage * wid_dbus_show_black_white_oui_info_list(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply = NULL;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;
//	int i = 0;
	unsigned int  ouiXmlType = 0;
	unsigned int ret = WID_DBUS_SUCCESS;
	unsigned int oui_num = 0;
	CWOUIInfo *pnode = NULL;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&ouiXmlType,
							    DBUS_TYPE_INVALID))){
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
	}
    switch(ouiXmlType){
      case 1:{//show black oui info
         oui_num = gblackOuiNum;
		 pnode = gBlackOuiInfoList;
      }
	  break;
	  case 2:{//show white oui info
	     oui_num = gWhiteOuiNum;
	     pnode = gWhiteOuiInfoList;
	  }
	  break;
	  default:
        break;
   }
      wid_syslog_debug_debug(WID_DBUS,"%s num: %d",(ouiXmlType==1)?"black_oui_mac":"white_oui_mac",oui_num);
	  reply = dbus_message_new_method_return(msg);
	  dbus_message_iter_init_append (reply, &iter);
	  dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	  dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&oui_num);
	  dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
										    DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
											DBUS_TYPE_BYTE_AS_STRING
									DBUS_STRUCT_END_CHAR_AS_STRING,
		 						 &iter_array);
	   CWThreadMutexLock(&(gOuiMacXmlMutex));	
		while(pnode != NULL){
           DBusMessageIter iter_struct;
		   dbus_message_iter_open_container(&iter_array,DBUS_TYPE_STRUCT,NULL,&iter_struct);
		   dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(pnode->oui_mac[0]));
		   dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(pnode->oui_mac[1]));
		   dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_BYTE,&(pnode->oui_mac[2]));
           pnode = pnode->next;
           dbus_message_iter_close_container (&iter_array, &iter_struct);
        }
		CWThreadMutexUnlock(&(gOuiMacXmlMutex));	
		dbus_message_iter_close_container (&iter, &iter_array);
       return reply;
}
DBusMessage *wid_dbus_update_black_white_oui_info_list(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply = NULL;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int  ouiXmlType = 0;
	unsigned int ret = WID_DBUS_SUCCESS;
	int i = 0;
	CWOUIInfo *OuiInfoList = NULL;
	CWOUIInfo *OuiInfoList_tmp = NULL;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&ouiXmlType,
							    DBUS_TYPE_INVALID))){
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
	}
    switch(ouiXmlType){
      case 1:{//update black oui mac
			 CWThreadMutexLock(&(gOuiMacXmlMutex));	
			 CWParseBlackOuiInfoXML(&OuiInfoList);
	         OuiInfoList_tmp = gBlackOuiInfoList;
			 gBlackOuiInfoList = OuiInfoList;
			 CWFreeOuiInfoList(&OuiInfoList_tmp);
			 CWThreadMutexUnlock(&(gOuiMacXmlMutex));
	  }
	  break;
	  case 2:{//update white oui mac
			 CWThreadMutexLock(&(gOuiMacXmlMutex));	
			 CWParseWhiteOuiInfoXML(&OuiInfoList);
	         OuiInfoList_tmp = gWhiteOuiInfoList;
			 gWhiteOuiInfoList = OuiInfoList;
			 CWFreeOuiInfoList(&OuiInfoList_tmp);
			 CWThreadMutexUnlock(&(gOuiMacXmlMutex));
      }
	  break;
	  default:
        break;
   }
    if(gOuiListType == ouiXmlType){
          CWThreadMutexLock(&(gOuiMacXmlMutex));	
	      wid_syslog_debug_debug(WID_DBUS,"@@@@@@@@@gOuiListType :%s oui_typ:%s@@@@@@@@@@\n",(gOuiListType==1)?"black":"white",(ouiXmlType==1)?"black":"white");
		   for(i=0 ;i< WTP_NUM;i++){
		   	   if((AC_WTP[i]!=NULL)&&
			   	   (AC_WTP[i]->WTPMAC!=NULL)&&
			   	   (AC_WTP[i]->WTPStat == 5)){
			   	   wid_syslog_debug_debug(WID_DBUS,"AC_WTP[%d]->MAC: "OUIMACSTR"\n",i,OUIMAC2STR(AC_WTP[i]->WTPMAC));
			   	   if(oui_mac_filters(AC_WTP[i]->WTPMAC)){
				   	    wid_syslog_debug_debug(WID_DBUS,"AC_WTP[%d]->MAC: "OUIMACSTR"Was filtered\n",i,OUIMAC2STR(AC_WTP[i]->WTPMAC));
                        wid_set_ap_reboot(i);       
		       }
           	}
      	   }
		  CWThreadMutexUnlock(&(gOuiMacXmlMutex));	
         }
    reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	return reply;
}
DBusMessage *wid_dbus_use_black_white_none_oui_policy(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply = NULL;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int  ouiPolicyType = 0;
	unsigned int ret = WID_DBUS_SUCCESS;
	int          i= 0;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&ouiPolicyType,
							    DBUS_TYPE_INVALID))){
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
	}
    switch(ouiPolicyType){
	  case 0:{//use none policy 
          gOuiListType = ouiPolicyType;
	  }
	  break;
      case 1:
	  case 2:{//use black white oui policy
	      CWThreadMutexLock(&(gOuiMacXmlMutex));	
	       wid_syslog_debug_debug(WID_DBUS,"@@@@@@@@@gOuiListType :%s oui_typ:%s@@@@@@@@@@\n",(gOuiListType==1)?"black":"white",(ouiPolicyType==1)?"black":"white");
	       if(gOuiListType != ouiPolicyType){
            gOuiListType = ouiPolicyType;
	        for(i=0 ;i< WTP_NUM;i++){
		   	   if((AC_WTP[i]!=NULL)&&
			   	   (AC_WTP[i]->WTPMAC!=NULL)&&
			   	   (AC_WTP[i]->WTPStat == 5)){
			   	   wid_syslog_debug_debug(WID_DBUS,"AC_WTP[%d]->MAC: "OUIMACSTR"\n",i,OUIMAC2STR(AC_WTP[i]->WTPMAC));
			   	   if(oui_mac_filters(AC_WTP[i]->WTPMAC)){
				   	    wid_syslog_debug_debug(WID_DBUS,"AC_WTP[%d]->MAC: "OUIMACSTR"Was filtered\n",i,OUIMAC2STR(AC_WTP[i]->WTPMAC));
                        wid_set_ap_reboot(i);       
		       }
           	}
      	   }
         }
		CWThreadMutexUnlock(&(gOuiMacXmlMutex));	   
      }
	  break;
	  default:
        break;
   }
    reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	return reply;
}
DBusMessage *wid_dbus_show_oui_policy(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply = NULL;	
	DBusMessageIter	 iter;
	DBusError err;
//	unsigned int  ouiXmlType = 0;
	unsigned int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &gOuiListType);
	return reply;
}
DBusMessage *wid_dbus_checking_wireless(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply = NULL;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int ret = WID_DBUS_SUCCESS;
	dbus_error_init(&err);
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
	return reply;
}

/* book add for wsm deamon quit, 2011-5-23 */
DBusMessage *wid_dbus_method_quit(DBusConnection *conn, DBusMessage *msg, void *user_data){
	DBusMessage* reply = NULL;	
	DBusMessageIter	 iter;
	DBusError err;
	unsigned int ret = WID_DBUS_SUCCESS;
	int bssid = 0;
	int wlanid = 0;
	int radioid = 0;
	int wtpid = 0;
	dbus_error_init(&err);
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append(reply, &iter);
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
    wid_syslog_debug_debug(WID_DEFAULT,"exit wid deamon  ret = %d\n",ret);
    
    /* delete all interfaces */
    int i = 0;
    for(i = 1; i < (WTP_NUM*L_RADIO_NUM*L_BSS_NUM); i++){
        if((AC_BSS[i] != NULL) && (AC_BSS[i]->BSS_IF_POLICY != NO_INTERFACE)){
            wtpid = AC_BSS[i]->Radio_G_ID / L_RADIO_NUM;
            radioid = AC_BSS[i]->Radio_L_ID;
            wlanid = AC_BSS[i]->WlanID;
            bssid = (i%(L_RADIO_NUM*L_BSS_NUM))%L_BSS_NUM;
            wid_syslog_debug_debug(WID_DBUS,"wtpid %d,radioid %d,wlanid %d,bssid %d\n",wtpid,radioid,wlanid,bssid);
			AC_BSS[i]->State = 0;
			WID_BSS_L3IF_POLICY(wlanid,wtpid,radioid,bssid,0);
        }
    }
    wid_syslog_debug_debug(WID_DEFAULT,"free bss interface ok\n");
    for(i = 1; i < WLAN_NUM; i++){
        if((AC_WLAN[i] != NULL) && (AC_WLAN[i]->wlan_if_policy != NO_INTERFACE)){
			AC_WLAN[i]->Status = 1;
			WID_WLAN_L3IF_POLICY_BR(i, 0);
        }
    }
    wid_syslog_debug_debug(WID_DEFAULT,"free wlan interface ok\n");
    for(i = 1; i < EBR_NUM; i++){
        if(WID_EBR[i] != NULL){
            WID_DELETE_ETHEREAL_BRIDGE(i);
        }
    }
    wid_syslog_debug_debug(WID_DEFAULT,"free ebr interface ok\n");
    
	exit(2);
	
	return reply;
}


int check_dbus_uname(char * sender){
	int i = 0;
	int j = 0; 
	for(i = 0; i < DBUS_COUNT_NUM; i++){
		for(j = 0; j < dbus_count[i].num; j++){
			if(dbus_count[i].uname != NULL){
				printf("dbus_count[i].uname[j] %s\n",&(dbus_count[i].uname[j*SENDER_LEN]));
				printf("sender %s\n",sender);
				if(strcmp(&(dbus_count[i].uname[j*SENDER_LEN]),sender) == 0){
					dbus_count[i].count++;
					return 1;
				}
			}
		}
	}
	return 0;
}
int get_dbus_uname(int index){
	
	DBusMessage *reply;
	DBusMessage *method;
	DBusError error;
	char **list;
	int len, i;
	const char *name;

	reply = NULL;
	method = NULL;
	list = NULL;

	dbus_error_init (&error);

	method = dbus_message_new_method_call (DBUS_SERVICE_DBUS,
									 DBUS_PATH_DBUS,
									 DBUS_INTERFACE_DBUS,
									 "ListQueuedOwners");

	if (method == NULL)
	goto out;
	name = dbus_count[index].rname;
	if (!dbus_message_append_args (method,
							 DBUS_TYPE_STRING, &(name),
							 DBUS_TYPE_INVALID))
	{
	fprintf (stderr, "Error appending args\n") ;
	goto out;
	}

	reply = dbus_connection_send_with_reply_and_block (wid_dbus_connection2,
												 method,
												 -1,
												 &error);

	if (reply == NULL)
	{
	fprintf (stderr, "Error calling ListQueuedOwners: %s\n", error.message);
	dbus_error_free (&error);
	goto out;
	}



	if (!dbus_message_get_args (reply,
						  &error,
						  DBUS_TYPE_ARRAY, DBUS_TYPE_STRING,
						  &list, &len,
						  DBUS_TYPE_INVALID))
	{
	fprintf (stderr, "Error getting args: %s\n", error.message);
	dbus_error_free (&error);
	goto out;
	}
	if(len > 0){
		if(dbus_count[index].uname != NULL){
			WID_FREE(dbus_count[index].uname);
			dbus_count[index].uname = NULL;
			dbus_count[index].num = 0;
		}
		dbus_count[index].uname = WID_MALLOC(len*SENDER_LEN);
		memset(dbus_count[index].uname, 0, len*SENDER_LEN);
		dbus_count[index].num = len;
	}

	for (i = 0; i < len; i++)
	{
		strcpy(&(dbus_count[index].uname[i*SENDER_LEN]),list[i]);
		printf ("%s\n", list[i]);
	}
	dbus_message_unref (method);
	dbus_message_unref (reply);
	dbus_free_string_array (list);
	return TRUE;
	out:
	if (method != NULL)
	dbus_message_unref (method);
	if (reply != NULL)
	dbus_message_unref (reply);
	if (list != NULL)
	dbus_free_string_array (list);
	return FALSE;
}
int wid_static_dbus_op(char * sender){
	int i;
	if(!check_dbus_uname(sender)){
		for(i = 0; i < DBUS_COUNT_NUM; i++){
			get_dbus_uname(i);		
		}		
		if(!check_dbus_uname(sender))
			other_dbus_count++;
	}
	return 0;
}

DBusMessage *wid_dbus_show_wid_dbus_count(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(dbus_count[0].count));
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(dbus_count[1].count));
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(dbus_count[2].count));
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(dbus_count[3].count));
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(dbus_count[4].count));

	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(dbus_count[5].count));
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &(other_dbus_count));
		
	return reply;	

}


DBusMessage *wid_dbus_set_wid_dbus_count(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply;	
	DBusMessageIter	 iter;
	DBusError err;
	dbus_error_init(&err);
	int ret = WID_DBUS_SUCCESS;
	int type;
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&type,
								DBUS_TYPE_INVALID))){

				
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return NULL;
	}
	reply = dbus_message_new_method_return(msg);
	dbus_count_switch = type;
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);
		
	return reply;	

}

DBusMessage * wid_dbus_interface_multicast_listen(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 
	DBusMessageIter  iter;
//	DBusMessageIter  iter_array;
	DBusError err;
	dbus_error_init(&err);	
	int ret = WID_DBUS_SUCCESS;
	int state = 0;
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&state,
								DBUS_TYPE_INVALID))){

		printf("Unable to get input args\n");
				
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	if(multicast_listen_state != state){
		multicast_listen_state = state;
		if(state == 1){
			wid_multicast_listen_setting(&gACSocket, CW_CONTROL_PORT);
		}else if(state == 0){
			wid_multicast_listen_close(&gACSocket);
		}
	}
	reply = dbus_message_new_method_return(msg);
		
	dbus_message_iter_init_append(reply, &iter);
		
	dbus_message_iter_append_basic(&iter, DBUS_TYPE_UINT32, &ret);

	return reply;	

}


DBusMessage *wid_dbus_set_wlan_tunnel_mode_state_add_to_ebr(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 	
	DBusMessageIter  iter;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	unsigned char wlanid =0;	
	unsigned char state = 0;//1--enable, 0--disable
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&state,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_INVALID))){
	
				
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(AC_WLAN[wlanid] == NULL)  //fengwenchao add 20121203 for axsszfi-1283
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else
		ret = set_wlan_tunnel_mode(wlanid, state, 1);

	reply = dbus_message_new_method_return(msg);
			
	dbus_message_iter_init_append (reply, &iter);	

	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 

	return reply;	
}


DBusMessage *wid_dbus_set_wlan_tunnel_mode_state(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage* reply; 	
	DBusMessageIter  iter;
	DBusError err;
	int ret = WID_DBUS_SUCCESS;
	unsigned char wlanid =0;	
	unsigned char state = 0;//1--enable, 0--disable
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_BYTE,&state,
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_INVALID))){
	
				
		if (dbus_error_is_set(&err)) {
			dbus_error_free(&err);
		}
		return NULL;
	}

	if(AC_WLAN[wlanid] == NULL)  //fengwenchao add 20121203 for axsszfi-1283
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	else
	{
		if(state == 0)
		{
			delete_radioif_from_wlan_bridge(wlanid);
			wid_syslog_debug_debug(WID_DBUS,"delete radio intf from wlan br\n");
		}
		
		ret = set_wlan_tunnel_mode(wlanid, state, 0);

	}

	reply = dbus_message_new_method_return(msg);
			
	dbus_message_iter_init_append (reply, &iter);	

	dbus_message_iter_append_basic (&iter,
									DBUS_TYPE_UINT32,
									&ret); 

	return reply;	
}
DBusMessage * wid_dbus_interface_set_wsm_sta_info_reportinterval(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	DBusMessage * reply = NULL;
	DBusMessageIter  iter;
	DBusError err;
	unsigned int wtpid = 0;
	unsigned int radioid = 0;
	unsigned int l_radioid = 0;
	unsigned char wlanid = 0;
	unsigned int ret = WID_DBUS_SUCCESS;
	unsigned short interval = 0;
	dbus_error_init(&err);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,	
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_UINT16,&interval,
								DBUS_TYPE_INVALID))){
		printf("Unable to get input args\n");
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		return NULL;
	}
	wtpid = radioid/L_RADIO_NUM;
	l_radioid = radioid%L_RADIO_NUM;
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid]->isBinddingWlan == 0)
	{
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}	
	else if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	if(ret == WID_DBUS_SUCCESS)
	{
		int bssindex = AC_WLAN[wlanid]->S_WTP_BSS_List[wtpid][l_radioid];
		if((AC_BSS[bssindex] != NULL)&&(AC_BSS[bssindex]->WlanID == wlanid))
		{		
			if(AC_BSS[bssindex]->wsm_sta_info_reportinterval != interval)
			{
				AC_BSS[bssindex]->wsm_sta_info_reportinterval = interval;
				ret = wid_radio_wsm_sta_info_report(wtpid,l_radioid,radioid,bssindex);
			}
		}
	}
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append (reply, &iter);
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	return reply;	
}
DBusMessage * wid_dbus_interface_set_wsm_sta_info_reportswitch(DBusConnection *conn, DBusMessage *msg, void *user_data)
{
	wid_syslog_info("%s,%d\n",__func__,__LINE__);
	DBusMessage * reply = NULL;
	DBusMessageIter  iter;
	DBusError err;
	unsigned int wtpid = 0;
	unsigned int radioid = 0;
	unsigned int l_radioid = 0;
	unsigned char wlanid = 0;
	unsigned int ret = WID_DBUS_SUCCESS;
	char policy = 0;
	dbus_error_init(&err);
	wid_syslog_info("%s,%d\n",__func__,__LINE__);
	if (!(dbus_message_get_args ( msg, &err,
								DBUS_TYPE_UINT32,&radioid,	
								DBUS_TYPE_BYTE,&wlanid,
								DBUS_TYPE_BYTE,&policy,
								DBUS_TYPE_INVALID))){
		printf("Unable to get input args\n");
		if (dbus_error_is_set(&err)) {
			printf("%s raised: %s",err.name,err.message);
			dbus_error_free(&err);
		}
		wid_syslog_info("%s,%d\n",__func__,__LINE__);
		return NULL;
	}
	wtpid = radioid/L_RADIO_NUM;
	l_radioid = radioid%L_RADIO_NUM;
	printf("policy =  %d\n",policy);
	printf("wtpid =  %d\n",wtpid);
	printf("l_radioid =  %d\n",l_radioid);
	if(AC_WTP[wtpid] == NULL)
	{
		ret = WTP_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid] == NULL)
	{
		ret = RADIO_ID_NOT_EXIST;
	}
	else if(AC_RADIO[radioid]->isBinddingWlan == 0)
	{
		ret = WTP_IS_NOT_BINDING_WLAN_ID;
	}	
	else if(AC_WLAN[wlanid] == NULL)
	{
		ret = WLAN_ID_NOT_EXIST;
	}
	else if (AC_WLAN[wlanid]->want_to_delete == 1)		/* Huangleilei add for ASXXZFI-1622 */
	{
		ret = WID_WANT_TO_DELETE_WLAN;
	}
	if(ret == WID_DBUS_SUCCESS)
	{
		int bssindex = AC_WLAN[wlanid]->S_WTP_BSS_List[wtpid][l_radioid];
			printf("bssindex =  %d\n",bssindex);
		if((AC_BSS[bssindex] != NULL)&&(AC_BSS[bssindex]->WlanID == wlanid))
		{		
			printf("AC_BSS[%d]->wsm_sta_info_reportswitch  =%d \n",bssindex,AC_BSS[bssindex]->wsm_sta_info_reportswitch);
			printf("policy =  %d\n",policy);
			if(AC_BSS[bssindex]->wsm_sta_info_reportswitch != policy)
			{
				printf("222222222 \n");
				AC_BSS[bssindex]->wsm_sta_info_reportswitch = policy;
				ret = wid_radio_wsm_sta_info_report(wtpid,l_radioid,radioid,bssindex);
			}
		}
	}
	reply = dbus_message_new_method_return(msg);
	dbus_message_iter_init_append (reply, &iter);
	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&ret);
	return reply;		
}


int show_running_config_wtp(WID_WTP **WTP,int i,char *cursor,char **showStr2,char *showStr_new,int *totalLen_T,int *str_len_T){
	char radio_type[ACDBUS_RADOI_TYPE_LEN];	
	int s_id = 0;
	int s_state = 0;
	int s_id2 = 0;

	int totalLen = *totalLen_T;
	int str_len = *str_len_T;
	char *showStr = *showStr2;
	
	if(totalLen + 1024 > str_len) {
		str_len *= 2;
		showStr_new = (char*)realloc(showStr,str_len);
		if(showStr_new == NULL){
			wid_syslog_info("show running realloc failed\n");
			return -1;
		}else {
			showStr = showStr_new;
			*showStr2 = showStr;
			memset(showStr+str_len/2,0,str_len/2);
			showStr_new = NULL;
		}
		wid_syslog_debug_debug(WID_DBUS,"show running totalLen %d realloc strlen %d\n",totalLen,str_len);
	}
	cursor = showStr + totalLen;
				
	if((WTP[i]->wtp_login_mode == 1)&&(g_auto_ap_login.save_switch == 0))
	{
		wid_syslog_info("wtp %d is auto ap,but wid do not allow save auto ap config\n",WTP[i]->WTPID);
		return 0;	
	}
	else
	{
		//mac first				
		if((WTP[i]->WTPMAC[0] == 0)&&(WTP[i]->WTPMAC[1] == 0)&&(WTP[i]->WTPMAC[2] == 0)
			&&(WTP[i]->WTPMAC[3] == 0)&&(WTP[i]->WTPMAC[3] == 0)&&(WTP[i]->WTPMAC[5] == 0))
		{
			if(vrrid != 0){
				totalLen += sprintf(cursor," ");
				cursor = showStr + totalLen;
			}
			/* book modify */
			//if(WTP[i]->apcodeflag == 0)
			totalLen += sprintf(cursor,"create wtp %d %s model&sn %s sn %s\n",WTP[i]->WTPID,WTP[i]->WTPNAME,WTP[i]->WTPModel,WTP[i]->WTPSN);
			//else
			//	totalLen += sprintf(cursor,"create wtp %d %s model&sn %s sn %s flag %d\n",WTP[i]->WTPID,WTP[i]->WTPNAME,WTP[i]->WTPModel,WTP[i]->WTPSN,WTP[i]->apcodeflag);
			cursor = showStr + totalLen;	
		}
		else
		{
			if(vrrid != 0){
				totalLen += sprintf(cursor," ");
				cursor = showStr + totalLen;
			}
			//if(WTP[i]->apcodeflag == 0)
			totalLen += sprintf(cursor,"create wtp %d %s model&mac %s mac %02X:%02X:%02X:%02X:%02X:%02X\n",WTP[i]->WTPID,WTP[i]->WTPNAME,WTP[i]->WTPModel,\
			    WTP[i]->WTPMAC[0],WTP[i]->WTPMAC[1],WTP[i]->WTPMAC[2],WTP[i]->WTPMAC[3],WTP[i]->WTPMAC[4],WTP[i]->WTPMAC[5]);
			/*//else
			//	totalLen += sprintf(cursor,"create wtp %d %s model&mac %s mac %02X:%02X:%02X:%02X:%02X:%02X flag %d\n",WTP[i]->WTPID,WTP[i]->WTPNAME,WTP[i]->WTPModel,\
			//	WTP[i]->WTPMAC[0],WTP[i]->WTPMAC[1],WTP[i]->WTPMAC[2],WTP[i]->WTPMAC[3],WTP[i]->WTPMAC[4],WTP[i]->WTPMAC[5],WTP[i]->apcodeflag);*/
			cursor = showStr + totalLen;
		}
		
		int rnum = WTP[i]->RadioCount;
		int j = 0;
#ifdef _CheckBindingIf_
		if(WTP[i]->BindingSystemIndex != -1)
		{
#else
		{	
#endif
			if(vrrid != 0){
				totalLen += sprintf(cursor," ");
				cursor = showStr + totalLen;
			}
			totalLen += sprintf(cursor,"config wtp %d\n",WTP[i]->WTPID);
			cursor = showStr + totalLen;
			/*if(WTP[i]->isipv6addr == 1)
			{
				totalLen += sprintf(cursor,"wtp apply ipv6interface %s\n",WTP[i]->BindingIFName);
				cursor = showStr + totalLen;
			}
			else
			*/
			/*{  //fengwenchao comment 20111123
				if(vrrid != 0){
					totalLen += sprintf(cursor," ");
					cursor = showStr + totalLen;
				}
				totalLen += sprintf(cursor," wtp apply interface %s\n",WTP[i]->BindingIFName);
				cursor = showStr + totalLen;
			}*/
			/*wcl modify*/
			/*if(memcmp(WTP[i]->WTPSN, gdefaultsn,strlen(WTP[i]->WTPSN)) != 0)
			{
				if(vrrid != 0){
					totalLen += sprintf(cursor," ");
					cursor = showStr + totalLen;
				}
				totalLen += sprintf(cursor," set wtp sn %s\n",WTP[i]->WTPSN);
				cursor = showStr + totalLen;
			}*/
			/*end*/
			if(WTP[i]->location!=NULL){
				if(vrrid != 0){
					totalLen += sprintf(cursor," ");
					cursor = showStr + totalLen;
				}
				totalLen += sprintf(cursor," set wtp location %s\n",WTP[i]->location);
				cursor = showStr + totalLen;
			} /*wuwl  add*/ 
			/*to ap option60*/
			if(WTP[i]->option60_param !=NULL){
				if(vrrid != 0){
					totalLen += sprintf(cursor," ");
					cursor = showStr + totalLen;
				}
				totalLen += sprintf(cursor,"set ap option60 parameter %s\n",WTP[i]->option60_param);
				cursor = showStr + totalLen;
			} 
			//struct wlanid *Wlanid = WTP[i]->WTP_Radio[0]->Wlan_Id;
			struct wlanid *Wlanid = NULL;
			while(Wlanid != NULL){					
				if(vrrid != 0){
					totalLen += sprintf(cursor," ");
					cursor = showStr + totalLen;
				}
				totalLen += sprintf(cursor," wtp apply wlan %d\n",Wlanid->wlanid);
				cursor = showStr + totalLen;
				Wlanid = Wlanid->next;
			}

			if(WTP[i]->wtp_allowed_max_sta_num != gWTP_MAX_STA){/*wcl modfiy for globle variable*/
				if(vrrid != 0){
					totalLen += sprintf(cursor," ");
					cursor = showStr + totalLen;
				}
				totalLen += sprintf(cursor," set wtp max sta num %d\n",WTP[i]->wtp_allowed_max_sta_num);
				cursor = showStr + totalLen;
			}    //xm add 08/12/05

			if(WTP[i]->wtp_triger_num!=1){
				if(vrrid != 0){
					totalLen += sprintf(cursor," ");
					cursor = showStr + totalLen;
				}
				totalLen += sprintf(cursor," set wtp number triger %d\n",WTP[i]->wtp_triger_num);
				cursor = showStr + totalLen;
			}    //xm add 08/12/05
			
			if(WTP[i]->wtp_flow_triger != gWTP_FLOW_TRIGER){/*wcl modify for globle variable*/
				if(vrrid != 0){
					totalLen += sprintf(cursor," ");
					cursor = showStr + totalLen;
				}
				totalLen += sprintf(cursor," set wtp flow triger %d\n",WTP[i]->wtp_flow_triger);
				cursor = showStr + totalLen;
			}    //xm add 09/02/05
			if(WTP[i]->WTP_Radio[0]->bandwidth != gBANDWIDTH)/*wcl modify for globle variable*/
			{
				if(vrrid != 0){
					totalLen += sprintf(cursor," ");
					cursor = showStr + totalLen;
				}
				totalLen += sprintf(cursor," set ap max throughout %d\n",WTP[i]->WTP_Radio[0]->bandwidth);
				cursor = showStr + totalLen;
			}
			if((WTP[i]->updateversion != NULL)&&(WTP[i]->updatepath != NULL))
			{
				if(vrrid != 0){
					totalLen += sprintf(cursor," ");
					cursor = showStr + totalLen;
				}
				totalLen += sprintf(cursor," update ap img-file %s version %s later\n",WTP[i]->updatepath,WTP[i]->updateversion);
				cursor = showStr + totalLen;
			}
			if(WTP[i]->dhcp_snooping != gDHCP_SNOOPING){/*wcl modify for globle variable*/
				if(WTP[i]->dhcp_snooping != 0){
					if(vrrid != 0){
						totalLen += sprintf(cursor," ");
						cursor = showStr + totalLen;
					}
					totalLen += sprintf(cursor," set wtp dhcp snooping enable\n");
					cursor = showStr + totalLen;
				}else{
						if(vrrid != 0){
						totalLen += sprintf(cursor," ");
						cursor = showStr + totalLen;
					}
					totalLen += sprintf(cursor," set wtp dhcp snooping disable\n");
					cursor = showStr + totalLen;
				}
			}
			if(WTP[i]->sta_ip_report != gSTAINFOREPORT){ /*wcl modify for globle variable*/
				if(WTP[i]->sta_ip_report != 0)
				{
					if(vrrid != 0){
						totalLen += sprintf(cursor," ");
						cursor = showStr + totalLen;
					}
					totalLen += sprintf(cursor," set wtp sta info report enable\n");
					cursor = showStr + totalLen;
				}else{
					if(vrrid != 0){
						totalLen += sprintf(cursor," ");
						cursor = showStr + totalLen;
					}
					totalLen += sprintf(cursor," set wtp sta info report disable\n");
					cursor = showStr + totalLen;
				}
			}
			if(WTP[i]->wtp_rogue_ap_threshold != gWTP_ROGUE_AP_THRESHOLD)/*wcl modify for globle variable*/
			{
				if(vrrid != 0){
					totalLen += sprintf(cursor," ");
					cursor = showStr + totalLen;
				}
				totalLen += sprintf(cursor," set wtp rogueap threshold %d\n",WTP[i]->wtp_rogue_ap_threshold);
				cursor = showStr + totalLen;	
			}
			if(WTP[i]->wtp_rogue_terminal_threshold != gWTP_ROGUE_TERMINAL_THRESHOLD)/*wcl modify for globle variable*/
			{
				if(vrrid != 0){
					totalLen += sprintf(cursor," ");
					cursor = showStr + totalLen;
				}
				totalLen += sprintf(cursor," set wtp rogueterminal threshold %d\n",WTP[i]->wtp_rogue_terminal_threshold);
				cursor = showStr + totalLen;	
			}
			if(WTP[i]->wtp_cpu_use_threshold != gWTP_CPU_USE_THRESHOLD)/*wcl modify for globle variable*/
			{
				if(vrrid != 0){
					totalLen += sprintf(cursor," ");
					cursor = showStr + totalLen;
				}
				totalLen += sprintf(cursor," set wtp cpu threshold %d\n",WTP[i]->wtp_cpu_use_threshold);
				cursor = showStr + totalLen;	
			}
			if(WTP[i]->wtp_mem_use_threshold != gWTP_MEM_USE_THRESHOLD)/*wcl modify for globle variable*/
			{
				if(vrrid != 0){
					totalLen += sprintf(cursor," ");
					cursor = showStr + totalLen;
				}
				totalLen += sprintf(cursor," set wtp memory threshold %d\n",WTP[i]->wtp_mem_use_threshold);
				cursor = showStr + totalLen;	
			}
			if(WTP[i]->EchoTimer != gEchoRequestTimer)					/*xiaodawei add for echotimer show running,20101210*/
			{
				if(vrrid != 0){
					totalLen += sprintf(cursor," ");
					cursor = showStr + totalLen;
				}
				totalLen += sprintf(cursor,"set ap echotimer %d\n",WTP[i]->EchoTimer);
				cursor = showStr + totalLen;
			}
			if(WTP[i]->apstatisticsinterval != apstatisticsinterval)/*wcl modify for globle variable*/
			{
				if(vrrid != 0){
					totalLen += sprintf(cursor," ");
					cursor = showStr + totalLen;
				}
				totalLen += sprintf(cursor,"set ap statistics interval %d\n",WTP[i]->apstatisticsinterval);
				cursor = showStr + totalLen;
			}
			if(WTP[i]->ap_sta_wapi_report_interval!= gAP_STA_WAPI_REPORT_INTERVAL)		/*xiaodawei add for ap sta wapi info reportinterval, 20101210*/
			{
				if(vrrid != 0){
					totalLen += sprintf(cursor," ");
					cursor = showStr + totalLen;
				}
				totalLen += sprintf(cursor,"set ap sta wapi info reportinterval %d\n",WTP[i]->ap_sta_wapi_report_interval);
				cursor = showStr + totalLen;
			}
			if(WTP[i]->ap_sta_report_interval != gSTAREPORTINTERVAL) /*wcl modify for globle variable*/
			{
				if(vrrid != 0){
					totalLen += sprintf(cursor," ");
					cursor = showStr + totalLen;
				}
				totalLen += sprintf(cursor,"set ap sta infomation reportinterval %d\n",WTP[i]->ap_sta_report_interval);
				cursor = showStr + totalLen;
			}
			if(WTP[i]->collect_time!= cpu_mem_collect_time)		/*xiaodawei add for ap cpu collect time, 20101210*//*wcl modify for globle variable*/
			{
				if(vrrid != 0){
					totalLen += sprintf(cursor," ");
					cursor = showStr + totalLen;
				}
				totalLen += sprintf(cursor,"set ap cpu_collect_time %d\n",WTP[i]->collect_time);
				cursor = showStr + totalLen;
			}
			/*nl add 20100324*/
			if(WTP[i]->ap_sta_report_switch != gSTAREPORTSWITCH) /*wcl modify for globle variable*/
			{
				if(WTP[i]->ap_sta_report_switch != 0)
				{
					if(vrrid != 0){
						totalLen += sprintf(cursor," ");
						cursor = showStr + totalLen;
					}
					totalLen += sprintf(cursor,"set ap sta infomation report switch enable\n");/*wcl modify for globle variable*/
					cursor = showStr + totalLen;
				}else{
					if(vrrid != 0){
						totalLen += sprintf(cursor," ");
						cursor = showStr + totalLen;
					}
					totalLen += sprintf(cursor,"set ap sta infomation report switch disable\n");/*wcl modify for globle variable*/
					cursor = showStr + totalLen;
				}
			}
			if(WTP[i]->wifi_extension_reportinterval != gWIFIEXTENSIONREPORTINTERVAL)/*wcl modify for globle variable*/
			{
				if(vrrid != 0){
					totalLen += sprintf(cursor," ");
					cursor = showStr + totalLen;
				}
				totalLen += sprintf(cursor,"set ap extension infomation reportinterval %d\n",WTP[i]->wifi_extension_reportinterval);
				cursor = showStr + totalLen;
			}
			if(WTP[i]->wifi_extension_reportswitch != g_AC_ALL_EXTENTION_INFORMATION_SWITCH)/*wcl modify for globle variable*/
			{
				if(WTP[i]->wifi_extension_reportswitch != 0)
				{
					if(vrrid != 0){
						totalLen += sprintf(cursor," ");
						cursor = showStr + totalLen;
					}
					totalLen += sprintf(cursor,"set ap extension infomation switch enable\n");/*wcl modify for globle variable*/
					cursor = showStr + totalLen;
					}
				else{
					if(vrrid != 0){
					totalLen += sprintf(cursor," ");
					cursor = showStr + totalLen;
					}
					totalLen += sprintf(cursor,"set ap extension infomation switch disable\n");/*wcl modify for globle variable*/
					cursor = showStr + totalLen;
				}
			}
			//set wtp longitude and latitude
			if (strlen((char *)(WTP[i]->longitude)) != 0 || strlen((char *)(WTP[i]->latitude)) != 0) {
				if (vrrid != 0) {
					totalLen += sprintf(cursor, " ");
					cursor = showStr + totalLen;
				}
				totalLen += sprintf(cursor, "set ap longitude %s latitude %s\n", WTP[i]->longitude, WTP[i]->latitude);
				cursor = showStr + totalLen;
			}

			//set unauthorized mac report switch
			if (WTP[i]->unauthorized_mac_reportswitch == UNKNOWN_MAC_TRAP_SWITCH_ENABLE) {
				if (vrrid != 0) {
					totalLen += sprintf(cursor, " ");
					cursor = showStr + totalLen;
				}
				totalLen += sprintf(cursor, "set ap unauthorized mac switch enable\n");
				cursor = showStr + totalLen;
			}

			//set configure error report switch
			if (WTP[i]->wtp_configure_error_reportswitch == AP_CONFIG_FILE_ERR_TRAP_SWITCH_ENABLE) {
				if (vrrid != 0) {
					totalLen += sprintf(cursor, " ");
					cursor = showStr + totalLen;
				}
				totalLen += sprintf(cursor, "set ap configure file error switch enable\n");
				cursor = showStr + totalLen;
			}

			//set sta flow overlfow rx report switch
			if (WTP[i]->sta_flow_overflow_rx_reportswitch == STA_FLOW_OVERFLOW_TRAP_RX_SWITCH_ENABLE) {
				if (vrrid != 0) {
					totalLen += sprintf(cursor, " ");
					cursor = showStr + totalLen;
				}
				totalLen += sprintf(cursor, "set ap sta flow rx overflow report switch enable\n");
				cursor = showStr + totalLen;
			}

			//set sta flow overlfow tx report switch
			if (WTP[i]->sta_flow_overflow_tx_reportswitch == STA_FLOW_OVERFLOW_TRAP_RX_SWITCH_ENABLE) {
				if (vrrid != 0) {
					totalLen += sprintf(cursor, " ");
					cursor = showStr + totalLen;
				}
				totalLen += sprintf(cursor, "set ap sta flow tx overflow report switch enable\n");
				cursor = showStr + totalLen;
			}

			//set sta flow overlfow rx report threshold
			if (WTP[i]->sta_flow_overflow_rx_threshold != STA_FLOW_OVERFLOW_RX_THRESHOLD && WTP[i]->sta_flow_overflow_rx_threshold != 0) {
				if (vrrid != 0) {
					totalLen += sprintf(cursor, " ");
					cursor = showStr + totalLen;
				}
				totalLen += sprintf(cursor, "set ap sta flow rx overflow threshold %u\n", WTP[i]->sta_flow_overflow_rx_threshold);
				cursor = showStr + totalLen;
			}

			//set sta flow overlfow tx report threshold
			if (WTP[i]->sta_flow_overflow_tx_threshold != STA_FLOW_OVERFLOW_TX_THRESHOLD && WTP[i]->sta_flow_overflow_tx_threshold != 0) {
				if (vrrid != 0) {
					totalLen += sprintf(cursor, " ");
					cursor = showStr + totalLen;
				}
				totalLen += sprintf(cursor, "set ap sta flow tx overflow threshold %u\n", WTP[i]->sta_flow_overflow_tx_threshold);
				cursor = showStr + totalLen;
			}
			
			if(WTP[i]->apifinfo.report_interval != gINFOREPORTINTERVAL) /*wcl modify for globle variable*/
			{
				if(vrrid != 0){
					totalLen += sprintf(cursor," ");
					cursor = showStr + totalLen;
				}
				totalLen += sprintf(cursor,"set ap interface infomation reportinterval %d\n",WTP[i]->apifinfo.report_interval);
				cursor = showStr + totalLen;
			}
			if(WTP[i]->apifinfo.report_switch != gINFOREPORTSWITCH) /*wcl modify for globle modify*/
			{	
				if(WTP[i]->apifinfo.report_switch != 0)
				{
					if(vrrid != 0){
						totalLen += sprintf(cursor," ");
						cursor = showStr + totalLen;
					}
					totalLen += sprintf(cursor,"set ap interface infomation report switch enable\n");/*wcl modify for globle variable*/
					cursor = showStr + totalLen;
				}else{
					if(vrrid != 0){
						totalLen += sprintf(cursor," ");
						cursor = showStr + totalLen;
					}
					totalLen += sprintf(cursor,"set ap interface infomation report switch disable\n");/*wcl modify for globle variable*/
					cursor = showStr + totalLen;
				}
			}
			if(WTP[i]->ap_sta_wapi_report_switch != gAP_STA_WAPI_REPORT_SWITCH)/*wcl modify for globle variable*/
			{
				if(WTP[i]->ap_sta_wapi_report_switch != 0)
				{
					if(vrrid != 0){
						totalLen += sprintf(cursor," ");
						cursor = showStr + totalLen;
					}
					totalLen += sprintf(cursor,"set ap sta wapi info report switch enable\n"); /*wcl modify for globle variable*/
					cursor = showStr + totalLen;
				}else{
					if(vrrid != 0){
						totalLen += sprintf(cursor," ");
						cursor = showStr + totalLen;
					}
					totalLen += sprintf(cursor,"set ap sta wapi info report switch disable\n"); /*wcl modify for globle variable*/
					cursor = showStr + totalLen;
				}
			}
			if(WTP[i]->neighborchannelrssithold != gNEIGHBORCHANNELRSSITHOLD)/*wcl modify for globle variable*/
			{
				totalLen += sprintf(cursor,"set wtp neighborchannelrssi threshold %d\n",WTP[i]->neighborchannelrssithold);
				cursor = showStr + totalLen;
			}
			if(WTP[i]->samechannelrssithold != gSAMECHANNELRSSITHOLD)/*wcl modify for globle variable*/
			{
				totalLen += sprintf(cursor,"set wtp samechannelrssi threshold %d\n",WTP[i]->samechannelrssithold);
				cursor = showStr + totalLen;
			}
			
			/*zhaoruijia,20100904,transplant ACTIMESYNCHROFAILURE from 1.2omc to 1.3,start*/
			if((WTP[i]->ntp_state != gNTP_STATE)||(WTP[i]->ntp_interval != gNTP_INTERVAL))/*wcl modify for globle variable*/
			{
				if(WTP[i]->ntp_state != 1){
					if(WTP[i]->ntp_interval == gNTP_INTERVAL){
						totalLen += sprintf(cursor,"set ap ntp start\n");
						cursor = showStr + totalLen;
					}else{
						totalLen += sprintf(cursor,"set ap ntp start %d\n",WTP[i]->ntp_interval);
						cursor = showStr + totalLen;
					}
				}else{
					totalLen += sprintf(cursor,"set ap ntp stop\n");
					cursor = showStr + totalLen;
				}
			}/*wcl modify for globle variable*/
			
			/*zhaoruijia,20100904,transplant ACTIMESYNCHROFAILURE from 1.2omc to 1.3,end*/

			/* zhangshu add for terminal disturb info, 2010-10-08 */
            if(WTP[i]->ter_dis_info.sta_trap_count != gTER_DIS_INFOSTA_TRAP_COUNT)/*wcl modify for globle variable*/
            {
                totalLen += sprintf(cursor,"set ap terminal distrub infomation sta_num %d\n",WTP[i]->ter_dis_info.sta_trap_count);
				cursor = showStr + totalLen;
            }
            if(WTP[i]->ter_dis_info.reportpkt != gTER_DIS_INFOREPORTPKT)/*wcl modify for globle variable*/
            {
                totalLen += sprintf(cursor,"set ap terminal distrub infomation reportpkt %d\n",WTP[i]->ter_dis_info.reportpkt);
				cursor = showStr + totalLen;
            }
            if(WTP[i]->ter_dis_info.reportswitch != gTER_DIS_INFOREPORTSWITCH)/*wcl modify for globle variable*/
            {
            	if(WTP[i]->ter_dis_info.reportswitch != 0){
             		totalLen += sprintf(cursor,"set ap terminal distrub infomation switch enable\n");
					cursor = showStr + totalLen;
            	}else{
					totalLen += sprintf(cursor,"set ap terminal distrub infomation switch disable\n");
					cursor = showStr + totalLen;
				}
            }
			if(WTP[i]->sta_deauth_message_reportswitch != sta_deauth_message_reportswitch){
				totalLen += sprintf(cursor,"set sta deauth message report switch %s\n",WTP[i]->sta_deauth_message_reportswitch?"enable":"disable");
				cursor = showStr + totalLen;
			}
			if(WTP[i]->sta_flow_information_reportswitch != sta_flow_information_reportswitch){
				totalLen += sprintf(cursor,"set ap report sta detail information switch %s\n",WTP[i]->sta_flow_information_reportswitch?"enable":"disable");
				cursor = showStr + totalLen;
			}
            /* zhangshu add END,2010-10-08 */
			if(g_radio_5g_sw != WTP[i]->radio_5g_sw){
				if(WTP[i]->RadioCount >= 2){
					totalLen += sprintf(cursor," set ap 5g switch %s\n",(WTP[i]->radio_5g_sw == 1) ?"enable":"disable");
					cursor = showStr + totalLen;
				}
			}
			/*fengwenchao add 20110324*/
			unsigned char jj=0;
			for(jj = 0;jj<AP_ETH_IF_NUM;jj++)
			{
				if(WTP[i]->apifinfo.eth[jj].eth_mtu != gAPIFINFOETH_MTU[jj]) /*wcl modify for globle variable*/
				{
					totalLen += sprintf(cursor," set ap interface eth%d mtu %d\n",jj,WTP[i]->apifinfo.eth[jj].eth_mtu);
					cursor = showStr + totalLen;							
				}
				if(WTP[i]->apifinfo.eth[jj].eth_rate != gAPIFINFOETH_RATE[jj]) /*wcl modify for globle variable*/
				{
					totalLen += sprintf(cursor," set ap interface eth %d rate %d\n",jj,WTP[i]->apifinfo.eth[jj].eth_rate);
					cursor = showStr + totalLen;							
				}	
			}
			/*fengwenchao add end*/
            
			totalLen += sprintf(cursor,"exit\n");
			cursor = showStr + totalLen;
		}
		for(j = 0; j < rnum; j++){
			if(totalLen + 1024 > str_len) {
				str_len *= 2;
				showStr_new = (char*)realloc(showStr,str_len);
				if(showStr_new == NULL){
					wid_syslog_info("show running realloc failed\n");
					return -1;
				}else {
					showStr = showStr_new;
					*showStr2 = showStr;
					memset(showStr+str_len/2,0,str_len/2);
					showStr_new = NULL;
				}
				wid_syslog_debug_debug(WID_DBUS,"show running totalLen %d realloc strlen %d\n",totalLen,str_len);
			}
			cursor = showStr + totalLen;
			if((WTP[i]->WTP_Radio[j] != NULL)){// && ((WTP[i]->WTP_Radio[j]->Radio_Chan != 0)||(WTP[i]->WTP_Radio[j]->Radio_TXP != 20)||(WTP[i]->WTP_Radio[j]->Support_Rate_Count != 12)||(WTP[i]->WTP_Radio[j]->BeaconPeriod != 100)||(WTP[i]->WTP_Radio[j]->FragThreshold != 2346)||(WTP[i]->WTP_Radio[j]->IsShortPreamble != 1)||(WTP[i]->WTP_Radio[j]->rtsthreshold != 2347)||(WTP[i]->WTP_Radio[j]->ShortRetry != 7)||(WTP[i]->WTP_Radio[j]->LongRetry != 4)||(WTP[i]->WTP_Radio[j]->DTIMPeriod != 1)||(WTP[i]->WTP_Radio[j]->Radio_Type != 5)||((j>0)&&(WTP[i]->WTP_Radio[j]->Radio_Type != 2))||(WTP[i]->WTP_Radio[j]->Wlan_Id != NULL)||(WTP[i]->WTP_Radio[j]->auto_channel != 0)||(WTP[i]->WTP_Radio[j]->diversity != 0)||(WTP[i]->WTP_Radio[j]->txantenna != 1)||(WTP[i]->WTP_Radio[j]->REFlag == 1))){
				if(vrrid != 0){
					totalLen += sprintf(cursor," ");
					cursor = showStr + totalLen;
				}
				//totalLen += sprintf(cursor,"config radio %d\n",WTP[i]->WTP_Radio[j]->Radio_G_ID);
				totalLen += sprintf(cursor,"config radio %d-%d\n",WTP[i]->WTPID,WTP[i]->WTP_Radio[j]->Radio_L_ID);
				cursor = showStr + totalLen;	

				/*wcl add for OSDEVTDPB-31*/
		
				if(WTP[i]->WTP_Radio[j]->Radio_country_code != gCOUNTRYCODE)
				{
					char *countrycode;
					countrycode = (char *)WID_MALLOC(sizeof(char)*3);
					memset(countrycode,0,3);
									
					switch(WTP[i]->WTP_Radio[j]->Radio_country_code)
					{
						case COUNTRY_CHINA_CN : 
												strncpy(countrycode,"CN",2);
												break;
										
						case COUNTRY_EUROPE_EU : 
												strncpy(countrycode,"EU",2);
												break;
																		
						case COUNTRY_USA_US : 
												strncpy(countrycode,"US",2);
												break;
																		
						case COUNTRY_JAPAN_JP : 
												strncpy(countrycode,"JP",2);
												break;
																		
						case COUNTRY_FRANCE_FR : 
												strncpy(countrycode,"FR",2);
												break;
																		
						case COUNTRY_SPAIN_ES : 
												strncpy(countrycode,"ES",2);
												break;

						default : 
										strncpy(countrycode,"CN",2);
										break;
					}

					totalLen += sprintf(cursor,"country-code %s\n",countrycode);
					cursor = showStr + totalLen; 

					WID_FREE(countrycode);
					countrycode = NULL; 																			
				}
			/*end*/						
						struct wlanid *radioWlanid = WTP[i]->WTP_Radio[j]->Wlan_Id;
					/*	while(radioWlanid != NULL){					
							totalLen += sprintf(cursor,"radio apply wlan %d\n",radioWlanid->wlanid);
							cursor = showStr + totalLen;
							radioWlanid = radioWlanid->next;
						}*/
						while(radioWlanid != NULL)
						{					
							int l_bssid = 0;
							for(l_bssid=0;l_bssid<L_BSS_NUM;l_bssid++)
							{
								if(WTP[i]->WTP_Radio[j]->BSS[l_bssid] != NULL)
								{
									if((WTP[i]->WTP_Radio[j]->BSS[l_bssid]->WlanID == radioWlanid->wlanid)
										&&(AC_WLAN[radioWlanid->wlanid] != NULL)&& (AC_WLAN[radioWlanid->wlanid]->want_to_delete != 1))		/* HuangLeilei add for AXSSZFI-1622 */
									{
										if(WTP[i]->WTP_Radio[j]->BSS[l_bssid]->vlanid != 0)
										{
											if(vrrid != 0){
												totalLen += sprintf(cursor," ");
												cursor = showStr + totalLen;
											}
											totalLen += sprintf(cursor," radio apply wlan %d base vlan %d\n",radioWlanid->wlanid,WTP[i]->WTP_Radio[j]->BSS[l_bssid]->vlanid);
											cursor = showStr + totalLen;
										}

										if(WTP[i]->WTP_Radio[j]->BSS[l_bssid]->nas_port_id[0] != 0)
										{
											if(vrrid != 0){
												totalLen += sprintf(cursor," ");
												cursor = showStr + totalLen;
											}
											totalLen += sprintf(cursor," radio apply wlan %d base nas_port_id %s\n",radioWlanid->wlanid,WTP[i]->WTP_Radio[j]->BSS[l_bssid]->nas_port_id);
											cursor = showStr + totalLen;
										}
										if((AC_WLAN[radioWlanid->wlanid] != NULL)
											&&(WTP[i]->WTP_Radio[j]->BSS[l_bssid]->hotspot_id != AC_WLAN[radioWlanid->wlanid]->hotspot_id))
										{
											if(vrrid != 0){
												totalLen += sprintf(cursor," ");
												cursor = showStr + totalLen;
											}
											totalLen += sprintf(cursor," radio apply wlan %d base hotspot %d\n",radioWlanid->wlanid,WTP[i]->WTP_Radio[j]->BSS[l_bssid]->hotspot_id);
											cursor = showStr + totalLen;
										}
								else if((WTP[i]->WTP_Radio[j]->BSS[l_bssid]->vlanid == 0) && ((WTP[i]->WTP_Radio[j]->BSS[l_bssid]->nas_port_id[0] == 0)) && (radioWlanid->ESSID)\
									&& (strcmp(AC_WLAN[radioWlanid->wlanid]->ESSID,radioWlanid->ESSID) != 0))
								{
									if(vrrid != 0){
										totalLen += sprintf(cursor," ");
										cursor = showStr + totalLen;
									}
									totalLen += sprintf(cursor," radio apply wlan %d essid %s\n",radioWlanid->wlanid,radioWlanid->ESSID);
									cursor = showStr + totalLen;
								}
								else if((WTP[i]->WTP_Radio[j]->BSS[l_bssid]->vlanid == 0)&&(WTP[i]->WTP_Radio[j]->BSS[l_bssid]->nas_port_id[0] == 0))
								{
									if(vrrid != 0){
										totalLen += sprintf(cursor," ");
										cursor = showStr + totalLen;
									}
									totalLen += sprintf(cursor," radio apply wlan %d\n",radioWlanid->wlanid);
									cursor = showStr + totalLen;
								}
								if(( AC_WLAN[radioWlanid->wlanid] != NULL)&&
									(WTP[i]->WTP_Radio[j]->BSS[l_bssid]->multi_user_optimize_switch != AC_WLAN[radioWlanid->wlanid]->multi_user_optimize_switch))
								{
									if(vrrid != 0){
										totalLen += sprintf(cursor," ");
										cursor = showStr + totalLen;
									}
									totalLen += sprintf(cursor," set bss wlan %d multi_user switch %s\n",WTP[i]->WTP_Radio[j]->BSS[l_bssid]->WlanID,WTP[i]->WTP_Radio[j]->BSS[l_bssid]->multi_user_optimize_switch?"enable":"disable");
									cursor = showStr + totalLen;
								}

										if(WTP[i]->WTP_Radio[j]->BSS[l_bssid]->WDSStat == WDS_SOME){
											struct wds_bssid *wds = NULL;
											if(WTP[i]->WTP_Radio[j]->BSS[l_bssid]->wblwm == 0){
												wds = WTP[i]->WTP_Radio[j]->BSS[l_bssid]->wds_bss_list;
												while(wds != NULL){
													if(vrrid != 0){
														totalLen += sprintf(cursor," ");
														cursor = showStr + totalLen;
													}
													totalLen += sprintf(cursor," wlan %d add wds_bssid %02X:%02X:%02X:%02X:%02X:%02X\n",radioWlanid->wlanid,wds->BSSID[0],wds->BSSID[1],wds->BSSID[2],wds->BSSID[3],wds->BSSID[4],wds->BSSID[5]);
													cursor = showStr + totalLen;												
													wds = wds->next;
												}
											}
											else{
												wds = WTP[i]->WTP_Radio[j]->BSS[l_bssid]->wds_bss_list;
												while(wds != NULL){
													if(vrrid != 0){
														totalLen += sprintf(cursor," ");
														cursor = showStr + totalLen;
													}
													totalLen += sprintf(cursor," wlan %d add mesh_bssid %02X:%02X:%02X:%02X:%02X:%02X\n",radioWlanid->wlanid,wds->BSSID[0],wds->BSSID[1],wds->BSSID[2],wds->BSSID[3],wds->BSSID[4],wds->BSSID[5]);
													cursor = showStr + totalLen;												
													wds = wds->next;
											}												}
										}
										if(WTP[i]->WTP_Radio[j]->BSS[l_bssid]->wsm_sta_info_reportinterval != 1800)
										{
											if(vrrid != 0){
												totalLen += sprintf(cursor," ");
												cursor = showStr + totalLen;
											}
											totalLen += sprintf(cursor," set wlan %d wsm sta info reportinterval %d\n",WTP[i]->WTP_Radio[j]->BSS[l_bssid]->WlanID,WTP[i]->WTP_Radio[j]->BSS[l_bssid]->wsm_sta_info_reportinterval);
											cursor = showStr + totalLen;									
										}
										if(WTP[i]->WTP_Radio[j]->BSS[l_bssid]->wsm_sta_info_reportswitch == 1)
										{
											if(vrrid != 0){
												totalLen += sprintf(cursor," ");
												cursor = showStr + totalLen;
											}
											totalLen += sprintf(cursor," set wlan %d wsm sta info reportswitch enable\n",WTP[i]->WTP_Radio[j]->BSS[l_bssid]->WlanID);
											cursor = showStr + totalLen;									
										}

										break;
									}
								}
							}
							radioWlanid = radioWlanid->next;
						}

						int bind_wlan = 0;
						struct vlan_id * tmp = NULL;
						for(bind_wlan=0;bind_wlan<8;bind_wlan++)
						{
							if(WTP[i]->WTP_Radio[j]->cpe_intf[bind_wlan].wlanid != 0)
							{

								tmp = WTP[i]->WTP_Radio[j]->cpe_intf[bind_wlan].vlanid;
								while(tmp)
								{
									if(tmp->vlanId != 0)
									{
										if(vrrid != 0)
										{
												totalLen += sprintf(cursor," ");
												cursor = showStr + totalLen;
										}
										totalLen += sprintf(cursor," radio cpe channel apply wlan %d base vlan %d\n",WTP[i]->WTP_Radio[j]->cpe_intf[bind_wlan].wlanid,tmp->vlanId);
										cursor = showStr + totalLen;
									}
									tmp = tmp->next;
								}
							}
						}
						if(WTP[i]->WTP_Radio[j]->StartService.times != -1){
							if(WTP[i]->WTP_Radio[j]->StartService.is_once == 0){
								totalLen += sprintf(cursor," set radio start service at %d:%d:%d %s %s %s %s %s %s %s %s\n",(WTP[i]->WTP_Radio[j]->StartService.times)/3600,((WTP[i]->WTP_Radio[j]->StartService.times)%3600)/60,((WTP[i]->WTP_Radio[j]->StartService.times)%3600)%60,
								(WTP[i]->WTP_Radio[j]->StartService.is_once == 1)?"once":"cycle",(WTP[i]->WTP_Radio[j]->StartService.wday[1]== 1)?"mon":"",(WTP[i]->WTP_Radio[j]->StartService.wday[2]== 1)?"tue":"",(WTP[i]->WTP_Radio[j]->StartService.wday[3]== 1)?"wed":"", 
								(WTP[i]->WTP_Radio[j]->StartService.wday[4]== 1)?"thu":"",(WTP[i]->WTP_Radio[j]->StartService.wday[5]== 1)?"fri":"",(WTP[i]->WTP_Radio[j]->StartService.wday[6]== 1)?"sat":"",(WTP[i]->WTP_Radio[j]->StartService.wday[0]== 1)?"sun":"");
								cursor = showStr + totalLen;	
								if(WTP[i]->WTP_Radio[j]->StartService.TimerState == 1){
									totalLen += sprintf(cursor," set radio starttimer enable\n");
									cursor = showStr + totalLen;
								}
							}
						}
						if(WTP[i]->WTP_Radio[j]->StopService.times != -1){
							if(WTP[i]->WTP_Radio[j]->StopService.is_once == 0){
								totalLen += sprintf(cursor," set radio stop service at %d:%d:%d %s %s %s %s %s %s %s %s\n",(WTP[i]->WTP_Radio[j]->StopService.times)/3600,((WTP[i]->WTP_Radio[j]->StopService.times)%3600)/60,((WTP[i]->WTP_Radio[j]->StopService.times)%3600)%60,
								(WTP[i]->WTP_Radio[j]->StopService.is_once == 1)?"once":"cycle",(WTP[i]->WTP_Radio[j]->StopService.wday[1]== 1)?"mon":"",(WTP[i]->WTP_Radio[j]->StopService.wday[2]== 1)?"tue":"",(WTP[i]->WTP_Radio[j]->StopService.wday[3]== 1)?"wed":"", 
								(WTP[i]->WTP_Radio[j]->StopService.wday[4]== 1)?"thu":"",(WTP[i]->WTP_Radio[j]->StopService.wday[5]== 1)?"fri":"",(WTP[i]->WTP_Radio[j]->StopService.wday[6]== 1)?"sat":"",(WTP[i]->WTP_Radio[j]->StopService.wday[0]== 1)?"sun":"");
								cursor = showStr + totalLen;
								if(WTP[i]->WTP_Radio[j]->StopService.TimerState == 1){
									totalLen += sprintf(cursor," set radio stoptimer enable\n");
									cursor = showStr + totalLen;
								}
							}
						}

						//xm add 08/12/05
						////////////////////////////////////////////////////
						int mm=0;
						int wlanid =0;
						for(mm=0;mm<L_BSS_NUM;mm++){
							if(totalLen + 1024 > str_len) {
								str_len *= 2;
								showStr_new = (char*)realloc(showStr,str_len);
								if(showStr_new == NULL){
									wid_syslog_info("show running realloc failed\n");
									return -1;
								}else {
									showStr = showStr_new;
									*showStr2 = showStr;
									memset(showStr+str_len/2,0,str_len/2);
									showStr_new = NULL;
								}
								wid_syslog_debug_debug(WID_DBUS,"show running totalLen %d realloc strlen %d\n",totalLen,str_len);
							}
							cursor = showStr + totalLen;
							if(WTP[i]->WTP_Radio[j]->BSS[mm]!=NULL 
								&& AC_WLAN[WTP[i]->WTP_Radio[j]->BSS[mm]->WlanID] != NULL 
								&& AC_WLAN[WTP[i]->WTP_Radio[j]->BSS[mm]->WlanID]->want_to_delete != 1){		/* HuangLeilei add for AXSSZFI-1622 */
								wlanid = WTP[i]->WTP_Radio[j]->BSS[mm]->WlanID;
								if((AC_WLAN[wlanid] != NULL)&&(WTP[i]->WTP_Radio[j]->BSS[mm]->bss_max_allowed_sta_num != AC_WLAN[wlanid]->bss_allow_max_sta_num)){//fengwenchao modify 20120323
									if(vrrid != 0){
										totalLen += sprintf(cursor," ");
										cursor = showStr + totalLen;
									}
									totalLen += sprintf(cursor," set bss wlan %d max_sta_num %d\n",WTP[i]->WTP_Radio[j]->BSS[mm]->WlanID,WTP[i]->WTP_Radio[j]->BSS[mm]->bss_max_allowed_sta_num);  //fengwenchao modify 20110513
									cursor = showStr + totalLen;
								}

								//printf("0,mm %d WTP[i]->WTP_Radio[j]->BSS[mm]->ath_l2_isolation %d\n",mm,WTP[i]->WTP_Radio[j]->BSS[mm]->ath_l2_isolation);

								if((AC_WLAN[wlanid] != NULL)&&(WTP[i]->WTP_Radio[j]->BSS[mm]->ath_l2_isolation != AC_WLAN[wlanid]->wlan_ath_l2_isolation)) //fengwenchao modify 20120323
								{
									if(vrrid != 0){
										totalLen += sprintf(cursor," ");
										cursor = showStr + totalLen;
									}
									totalLen += sprintf(cursor," set wlan %d l2 isolation %s\n",
																WTP[i]->WTP_Radio[j]->BSS[mm]->WlanID,
																(WTP[i]->WTP_Radio[j]->BSS[mm]->ath_l2_isolation ==1)?"enable":"disable");//fengwenchao modify 20120323
									cursor = showStr + totalLen;
								}
								/*traffic limit*/
								if(WTP[i]->WTP_Radio[j]->BSS[mm]->traffic_limit_able == 1)
								{
									if(WTP[i]->WTP_Radio[j]->BSS[mm]->traffic_limit != 0)
									{
										if(vrrid != 0){
											totalLen += sprintf(cursor," ");
											cursor = showStr + totalLen;
										}
										totalLen += sprintf(cursor," wlan %d traffic limit value %d\n",WTP[i]->WTP_Radio[j]->BSS[mm]->WlanID,WTP[i]->WTP_Radio[j]->BSS[mm]->traffic_limit);
										cursor = showStr + totalLen;
									}
									if(WTP[i]->WTP_Radio[j]->BSS[mm]->average_rate != 0)
									{
										if(vrrid != 0){
											totalLen += sprintf(cursor," ");
											cursor = showStr + totalLen;
										}
										totalLen += sprintf(cursor," wlan %d traffic limit station average value %d\n",WTP[i]->WTP_Radio[j]->BSS[mm]->WlanID,WTP[i]->WTP_Radio[j]->BSS[mm]->average_rate);
										cursor = showStr + totalLen;
									}
									if(WTP[i]->WTP_Radio[j]->BSS[mm]->send_traffic_limit != 0)
									{
										if(vrrid != 0){
											totalLen += sprintf(cursor," ");
											cursor = showStr + totalLen;
										}
										totalLen += sprintf(cursor," wlan %d traffic limit send value %d\n",WTP[i]->WTP_Radio[j]->BSS[mm]->WlanID,WTP[i]->WTP_Radio[j]->BSS[mm]->send_traffic_limit);
										cursor = showStr + totalLen;
									}
									if(WTP[i]->WTP_Radio[j]->BSS[mm]->send_average_rate != 0)
									{
										if(vrrid != 0){
											totalLen += sprintf(cursor," ");
											cursor = showStr + totalLen;
										}
										totalLen += sprintf(cursor," wlan %d traffic limit station average send value %d\n",WTP[i]->WTP_Radio[j]->BSS[mm]->WlanID,WTP[i]->WTP_Radio[j]->BSS[mm]->send_average_rate);
										cursor = showStr + totalLen;
									}
								}
								if((AC_WLAN[wlanid] != NULL)&&(WTP[i]->WTP_Radio[j]->BSS[mm]->ip_mac_binding != AC_WLAN[wlanid]->sta_ip_mac_bind))//fengwenchao modify 20120323
								{
									if(vrrid != 0){
										totalLen += sprintf(cursor," ");
										cursor = showStr + totalLen;
									}
									totalLen += sprintf(cursor," wlan %d sta ip_mac binding %s\n",WTP[i]->WTP_Radio[j]->BSS[mm]->WlanID,(WTP[i]->WTP_Radio[j]->BSS[mm]->ip_mac_binding == 1)?"enable":"disable");//fengwenchao modify 20120323
									cursor = showStr + totalLen;
								}
								if((AC_WLAN[wlanid] != NULL)&&((WTP[i]->WTP_Radio[j]->BSS[mm]->sta_static_arp_policy != AC_WLAN[wlanid]->wlan_sta_static_arp_policy)||(strcmp(WTP[i]->WTP_Radio[j]->BSS[mm]->arp_ifname,AC_WLAN[wlanid]->wlan_arp_ifname) != 0))){//fengwenchao modify 20120323
									if(vrrid != 0){
										totalLen += sprintf(cursor," ");
										cursor = showStr + totalLen;
									}
									totalLen += sprintf(cursor," set wlan %d sta_static_arp %s base %s\n",WTP[i]->WTP_Radio[j]->BSS[mm]->WlanID,(WTP[i]->WTP_Radio[j]->BSS[mm]->sta_static_arp_policy == 1)?"enable":"disable",WTP[i]->WTP_Radio[j]->BSS[mm]->arp_ifname);
									cursor = showStr + totalLen;
								}
								if(WTP[i]->WTP_Radio[j]->BSS[mm]->ip_mac_binding == 1)
								{
									if(vrrid != 0){
										totalLen += sprintf(cursor," ");
										cursor = showStr + totalLen;
									}
									totalLen += sprintf(cursor," wlan %d sta ip_mac binding enable\n",WTP[i]->WTP_Radio[j]->BSS[mm]->WlanID);
									cursor = showStr + totalLen;
								}
								/*fengwenchao add 20120222 for RDIR-25*/
								if((AC_WLAN[wlanid] != NULL)&&(WTP[i]->WTP_Radio[j]->BSS[mm]->limit_sta_rssi != AC_WLAN[wlanid]->wlan_limit_sta_rssi)){
									if(vrrid != 0){
										totalLen += sprintf(cursor," ");
										cursor = showStr + totalLen;
									}
									totalLen += sprintf(cursor," set radio wlan %d access sta limit rssi %d\n",WTP[i]->WTP_Radio[j]->BSS[mm]->WlanID,WTP[i]->WTP_Radio[j]->BSS[mm]->limit_sta_rssi);
									cursor = showStr + totalLen;
								}								
								/*fengwenchao add end*/
								if((AC_WLAN[wlanid] != NULL)&&((WTP[i]->WTP_Radio[j]->BSS[mm]->muti_bro_cast_sw != AC_WLAN[wlanid]->wlan_muti_bro_cast_sw) 
									||(WTP[i]->WTP_Radio[j]->BSS[mm]->unicast_sw != AC_WLAN[wlanid]->wlan_unicast_sw)
									||(WTP[i]->WTP_Radio[j]->BSS[mm]->muti_rate != AC_WLAN[wlanid]->wlan_muti_rate)
									||(WTP[i]->WTP_Radio[j]->BSS[mm]->wifi_sw != AC_WLAN[wlanid]->wlan_wifi_sw))){ /*fengwenchao modify 20120323*/
									if((WTP[i]->WTP_Radio[j]->BSS[mm]->unicast_sw != AC_WLAN[wlanid]->wlan_unicast_sw)
										&&(WTP[i]->WTP_Radio[j]->BSS[mm]->muti_bro_cast_sw != AC_WLAN[wlanid]->wlan_muti_bro_cast_sw)
										&&(WTP[i]->WTP_Radio[j]->BSS[mm]->unicast_sw == WTP[i]->WTP_Radio[j]->BSS[mm]->muti_bro_cast_sw)){
										if(vrrid != 0){
											totalLen += sprintf(cursor," ");
											cursor = showStr + totalLen;
										}
										totalLen += sprintf(cursor," wlan %d unicast_and_multicast_broadcast isolation %s\n",WTP[i]->WTP_Radio[j]->BSS[mm]->WlanID,(WTP[i]->WTP_Radio[j]->BSS[mm]->muti_bro_cast_sw == 1)?"enable":"disable");
										cursor = showStr + totalLen;
									}else if(WTP[i]->WTP_Radio[j]->BSS[mm]->unicast_sw != AC_WLAN[wlanid]->wlan_unicast_sw){
										if(vrrid != 0){
											totalLen += sprintf(cursor," ");
											cursor = showStr + totalLen;
										}
										totalLen += sprintf(cursor," wlan %d unicast isolation %s\n",WTP[i]->WTP_Radio[j]->BSS[mm]->WlanID,(WTP[i]->WTP_Radio[j]->BSS[mm]->unicast_sw == 1)?"enable":"disable");
										cursor = showStr + totalLen;
									}else if(WTP[i]->WTP_Radio[j]->BSS[mm]->muti_bro_cast_sw != AC_WLAN[wlanid]->wlan_muti_bro_cast_sw){
										if(vrrid != 0){
											totalLen += sprintf(cursor," ");
											cursor = showStr + totalLen;
										}
										totalLen += sprintf(cursor," wlan %d multicast_broadcast isolation %s\n",WTP[i]->WTP_Radio[j]->BSS[mm]->WlanID,(WTP[i]->WTP_Radio[j]->BSS[mm]->muti_bro_cast_sw == 1)?"enable":"disable");
										cursor = showStr + totalLen;
									}
									if(WTP[i]->WTP_Radio[j]->BSS[mm]->wifi_sw != AC_WLAN[wlanid]->wlan_wifi_sw){
										if(vrrid != 0){
											totalLen += sprintf(cursor," ");
											cursor = showStr + totalLen;
										}
										totalLen += sprintf(cursor," wlan %d wifi isolation %s\n",WTP[i]->WTP_Radio[j]->BSS[mm]->WlanID,(WTP[i]->WTP_Radio[j]->BSS[mm]->wifi_sw == 1)?"enable":"disable");
										cursor = showStr + totalLen;
									}
									if(WTP[i]->WTP_Radio[j]->BSS[mm]->muti_rate != AC_WLAN[wlanid]->wlan_muti_rate){
										if(vrrid != 0){
											totalLen += sprintf(cursor," ");
											cursor = showStr + totalLen;
										}
										totalLen += sprintf(cursor," wlan %d multicast_broadcast_rate %d\n",WTP[i]->WTP_Radio[j]->BSS[mm]->WlanID,WTP[i]->WTP_Radio[j]->BSS[mm]->muti_rate);
										cursor = showStr + totalLen;
									}
									
								}
								/*fengwenchao add 20120331*/
								if((AC_WLAN[wlanid] != NULL)&&(WTP[i]->WTP_Radio[j]->BSS[mm]->noResToStaProReqSW != AC_WLAN[wlanid]->wlan_noResToStaProReqSW))
								{
									if(vrrid != 0){
										totalLen += sprintf(cursor," ");
										cursor = showStr + totalLen;
									}
									totalLen += sprintf(cursor," wlan %d no response to sta probe request %s\n",WTP[i]->WTP_Radio[j]->BSS[mm]->WlanID,(WTP[i]->WTP_Radio[j]->BSS[mm]->noResToStaProReqSW == 1)?"enable":"disable");
									cursor = showStr + totalLen;
								}		
								/*fengwenchao add end*/
								if(WTP[i]->WTP_Radio[j]->BSS[mm]->sta_static_arp_policy == 1){
									if(vrrid != 0){
										totalLen += sprintf(cursor," ");
										cursor = showStr + totalLen;
									}
									totalLen += sprintf(cursor," set wlan %d sta_static_arp enable base %s\n",WTP[i]->WTP_Radio[j]->BSS[mm]->WlanID,WTP[i]->WTP_Radio[j]->BSS[mm]->arp_ifname);
									cursor = showStr + totalLen;
								}
							}
							
						}
						if((WTP[i]->WTP_Radio[j]->txpowerautostate == 0)&&(WTP[i]->WTP_Radio[j]->Radio_TXP == 100))
						{
							if(vrrid != 0){
								totalLen += sprintf(cursor," ");
								cursor = showStr + totalLen;
							}
							totalLen += sprintf(cursor," txpower auto\n");
							cursor = showStr + totalLen;
						}
						/*wcl modify*/
						else if(WTP[i]->WTP_Radio[j]->txpowerautostate == 1){
							if(WTP[i]->WTP_Radio[j]->ishighpower == 1)
						{
								if((WTP[i]->WTP_Radio[j]->Radio_TXP != 27)&&(WTP[i]->WTP_Radio[j]->Radio_TXP != 100))
							{
								if(vrrid != 0){
									totalLen += sprintf(cursor," ");
									cursor = showStr + totalLen;
								}
								totalLen += sprintf(cursor," txpower %d\n",WTP[i]->WTP_Radio[j]->Radio_TXP);
								cursor = showStr + totalLen;
							}	
								}else{
									if((WTP[i]->WTP_Radio[j]->Radio_TXP != 20)&&(WTP[i]->WTP_Radio[j]->Radio_TXP != 100))
								{
									if(vrrid != 0){
										totalLen += sprintf(cursor," ");
										cursor = showStr + totalLen;
									}
									totalLen += sprintf(cursor," txpower %d\n",WTP[i]->WTP_Radio[j]->Radio_TXP);
									cursor = showStr + totalLen;
									}	
								}
						}
						/*end*/

						if((WTP[i]->WTP_Radio[j]->Radio_TXPOF != 0)){
							if(vrrid != 0){
								totalLen += sprintf(cursor," ");
								cursor = showStr + totalLen;
							}
							totalLen += sprintf(cursor," txpoweroffset %d\n",WTP[i]->WTP_Radio[j]->Radio_TXPOF);
							cursor = showStr + totalLen;
						}						
                       /*zhaoruijia,20100917,add*/
						if((WTP[i]->WTP_Radio[j]->txpowerstep!= 1)){
							if(vrrid != 0){
								totalLen += sprintf(cursor," ");
								cursor = showStr + totalLen;
							}
							totalLen += sprintf(cursor," txpowerstep %d\n",WTP[i]->WTP_Radio[j]->txpowerstep);
							cursor = showStr + totalLen;
						}	
						/*fengwenchao modfiy 20120203 for autelan-2821*/
						if(((WTP[i]->WTP_Radio[j]->Radio_Type & IEEE80211_11N) == IEEE80211_11N)&&(WTP[i]->WTP_Radio[j]->BeaconPeriod != 400))
						{
							if(vrrid != 0){
								totalLen += sprintf(cursor," ");
								cursor = showStr + totalLen;
							}
							totalLen += sprintf(cursor," beaconinterval %d\n",WTP[i]->WTP_Radio[j]->BeaconPeriod);
							cursor = showStr + totalLen;
						}
						else if(((WTP[i]->WTP_Radio[j]->Radio_Type & IEEE80211_11N) != IEEE80211_11N)&&(WTP[i]->WTP_Radio[j]->BeaconPeriod != 100))
						{
							if(vrrid != 0){
								totalLen += sprintf(cursor," ");
								cursor = showStr + totalLen;
							}
							totalLen += sprintf(cursor," beaconinterval %d\n",WTP[i]->WTP_Radio[j]->BeaconPeriod);
							cursor = showStr + totalLen;
						}
						/*fengwenchao modify end*/
						if(WTP[i]->WTP_Radio[j]->FragThreshold != 2346)
						{
							if(vrrid != 0){
								totalLen += sprintf(cursor," ");
								cursor = showStr + totalLen;
							}
							totalLen += sprintf(cursor," fragmentation %d\n",WTP[i]->WTP_Radio[j]->FragThreshold);
							cursor = showStr + totalLen;
						}
						if(WTP[i]->WTP_Radio[j]->IsShortPreamble != 1)
						{
							if(vrrid != 0){
								totalLen += sprintf(cursor," ");
								cursor = showStr + totalLen;
							}
							totalLen += sprintf(cursor," preamble long\n");
							cursor = showStr + totalLen;
						}

						if(WTP[i]->WTP_Radio[j]->Radio_Type != WTP[i]->WTP_Radio[j]->Radio_Type_Bank)
						{
						//	
    						switch(WTP[i]->WTP_Radio[j]->Radio_Type)
    							{
    							case 1: 
    								strcpy(radio_type, "11b");
    								if(vrrid != 0){
    									totalLen += sprintf(cursor," ");
    									cursor = showStr + totalLen;
    								}
    								totalLen += sprintf(cursor," mode %s\n",radio_type);
    								break;
    							case 2: 
    								//if(j == 0)
    								{
    									strcpy(radio_type, "11a");
    									if(vrrid != 0){
    										totalLen += sprintf(cursor," ");
    										cursor = showStr + totalLen;
    									}
    									totalLen += sprintf(cursor,"mode %s\n",radio_type);
    								}
    								break;
    							case 4:  
    								strcpy(radio_type, "11g");
    								if(vrrid != 0){
    									totalLen += sprintf(cursor," ");
    									cursor = showStr + totalLen;
    								}
    								totalLen += sprintf(cursor," mode %s\n",radio_type);
    								break;
    							case 5: 
    								//if(j > 0)
    								{
    								if(vrrid != 0){
    									totalLen += sprintf(cursor," ");
    									cursor = showStr + totalLen;
    								}
    									strcpy(radio_type, "11b/g");
    									totalLen += sprintf(cursor," mode %s\n",radio_type);
    								}
    								break;
    							case 8: 
    								if(vrrid != 0){
    									totalLen += sprintf(cursor," ");
    									cursor = showStr + totalLen;
    								}
    								strcpy(radio_type, "11n");
    								totalLen += sprintf(cursor," mode %s\n",radio_type);
    								break;	
    							case 10: 
    								if(vrrid != 0){
    									totalLen += sprintf(cursor," ");
    									cursor = showStr + totalLen;
    								}
    								strcpy(radio_type, "11a/n");
    								totalLen += sprintf(cursor," mode %s\n",radio_type);
    								break;	
    							case 13: 
    								if(vrrid != 0){
    									totalLen += sprintf(cursor," ");
    									cursor = showStr + totalLen;
    								}
    								strcpy(radio_type, "11b/g/n");
    								totalLen += sprintf(cursor," mode %s\n",radio_type);
    								break;
							/*fengwenchao add 20111109 for GM*/
							 case 26: 
    								if(vrrid != 0){
    									totalLen += sprintf(cursor," ");
    									cursor = showStr + totalLen;
    								}
    								strcpy(radio_type, "11a/an");
    								totalLen += sprintf(cursor," mode %s\n",radio_type);
    								break;
							 case 12: 
    								if(vrrid != 0){
    									totalLen += sprintf(cursor," ");
    									cursor = showStr + totalLen;
    								}
    								strcpy(radio_type, "11gn");
    								totalLen += sprintf(cursor," mode %s\n",radio_type);
    								break;
							 case 44: 
    								if(vrrid != 0){
    									totalLen += sprintf(cursor," ");
    									cursor = showStr + totalLen;
    								}
    								strcpy(radio_type, "11g/gn");
    								totalLen += sprintf(cursor," mode %s\n",radio_type);
    								break;								
							/*fengwenchao add end*/
    							default : strcpy(radio_type, "unknown");break;
    							}
							//totalLen += sprintf(cursor,"mode %d\n",WTP[i]->WTP_Radio[j]->Radio_Type);
							//printf("mode %s\n",radio_type);
						    cursor = showStr + totalLen;
						}
						//#endif
						if(((WTP[i]->WTP_Radio[j]->Radio_Type&IEEE80211_11N) == 0)&&(WTP[i]->WTP_Radio[j]->Support_Rate_Count != 12))//sz change ratelist
						{
							//////
							int m = 0;
							int derate[12] = {10,20,55,60,90,110,120,180,240,360,480,540};
							int rate[20];
							int count = 0;
							count = WTP[i]->WTP_Radio[j]->Support_Rate_Count;
							//check whether the max rate 
							if (WTP[i]->WTP_Radio[j]->Radio_Rate->Rate == derate[count - 1])
							{
								//printf("max mode\n");
								if(vrrid != 0){
									totalLen += sprintf(cursor," ");
									cursor = showStr + totalLen;
								}

								totalLen += sprintf(cursor," set max rate %d\n",derate[count - 1]);
								cursor = showStr + totalLen;
							}

							//rate list mode
							else
							{
								//printf("list mode\n");
								
								struct Support_Rate_List *ptr = NULL;
								ptr = WTP[i]->WTP_Radio[j]->Radio_Rate;
								
								char *ratelist = NULL;
								ratelist = (char *)WID_MALLOC(sizeof(char)*128);
								int k = 0;
								memset(ratelist,0,128);
								
								for (m=0;m<count;m++)
								{
									rate[m] = ptr->Rate;
								
									switch(rate[m])
									{
										case 540 : strcpy(ratelist+k, "540");k=k+3;break;
										case 480 : strcpy(ratelist+k, "480");k=k+3;break;
										case 360 : strcpy(ratelist+k, "360");k=k+3;break;
										case 240 : strcpy(ratelist+k, "240");k=k+3;break;
										case 180 : strcpy(ratelist+k, "180");k=k+3;break;
										case 120 : strcpy(ratelist+k, "120");k=k+3;break;
										case 110 : strcpy(ratelist+k, "110");k=k+3;break;
										case 90 : strcpy(ratelist+k, "90");k=k+2;break;
										case 60 : strcpy(ratelist+k, "60");k=k+2;break;
										case 55 : strcpy(ratelist+k, "55");k=k+2;break;
										case 20 : strcpy(ratelist+k, "20");k=k+2;break;
										case 10 : strcpy(ratelist+k, "10");k=k+2;break;
										default : break;
									}
									if(m != (count-1))
									{
										strcpy(ratelist+k, ",");
										k=k+1;
									}
									else
									{
										
									}
									ptr = ptr->next;
								}
								if(vrrid != 0){
									totalLen += sprintf(cursor," ");
									cursor = showStr + totalLen;
								}

						totalLen += sprintf(cursor," set support ratelist %s\n",ratelist);
						
						cursor = showStr + totalLen;

								WID_FREE(ratelist);
								ratelist = NULL;
								//totalLen += sprintf(cursor,"rate %d\n",WTP[i]->WTP_Radio[j]->Radio_Rate);
								//cursor = showStr + totalLen;
							}
						}
						if((WTP[i]->WTP_Radio[j]->Radio_Chan != 0)&&(WTP[i]->WTP_Radio[j]->auto_channel_cont != 0)){//sz1121 change 1 to 0
							if(vrrid != 0){
								totalLen += sprintf(cursor," ");
								cursor = showStr + totalLen;
							}
							totalLen += sprintf(cursor," channel %d\n",WTP[i]->WTP_Radio[j]->Radio_Chan);
							cursor = showStr + totalLen;
						}						
						if(WTP[i]->WTP_Radio[j]->rtsthreshold != 2346)//zhangshu modify rtsthreshold to 2347,2010-10-28, Huang Leilei change it for AXSSZFI-1406, 2012-01-09
						{
							if(vrrid != 0){
								totalLen += sprintf(cursor," ");
								cursor = showStr + totalLen;
							}
							totalLen += sprintf(cursor," rtsthreshold %d\n",WTP[i]->WTP_Radio[j]->rtsthreshold);
							cursor = showStr + totalLen;
						}
						if(WTP[i]->WTP_Radio[j]->DTIMPeriod != 1)
						{
							if(vrrid != 0){
								totalLen += sprintf(cursor," ");
								cursor = showStr + totalLen;
							}
							totalLen += sprintf(cursor," dtim %d\n",WTP[i]->WTP_Radio[j]->DTIMPeriod);
							cursor = showStr + totalLen;
						}
						if(WTP[i]->WTP_Radio[j]->ShortRetry != 7)
						{
							if(vrrid != 0){
								totalLen += sprintf(cursor," ");
								cursor = showStr + totalLen;
							}
							totalLen += sprintf(cursor," shortretry %d\n",WTP[i]->WTP_Radio[j]->ShortRetry);
							cursor = showStr + totalLen;
						}
						if(WTP[i]->WTP_Radio[j]->LongRetry != 4)
						{
							if(vrrid != 0){
								totalLen += sprintf(cursor," ");
								cursor = showStr + totalLen;
							}
							totalLen += sprintf(cursor," longretry %d\n",WTP[i]->WTP_Radio[j]->LongRetry);
							cursor = showStr + totalLen;
						}
						if(WTP[i]->WTP_Radio[j]->auto_channel != 0)
						{
							if(vrrid != 0){
								totalLen += sprintf(cursor," ");
								cursor = showStr + totalLen;
							}
							totalLen += sprintf(cursor," set radio auto channel enable\n");
							cursor = showStr + totalLen;
						}
						/*fengwenchao modify 20120203 for autelan-2821 begin*/
						if(((WTP[i]->WTP_Radio[j]->Radio_Type & IEEE80211_11N) != IEEE80211_11N)&&(WTP[i]->WTP_Radio[j]->diversity != 0)&&(((WTP[i]->APCode != NULL)&&(WTP[i]->APCode[strlen(WTP[i]->APCode)-1] != 'H'))&&(WTP[i]->WTP_Radio[j]->ishighpower  != 1)))   //fengwenchao modify 20110428
						{
							if(vrrid != 0){
								totalLen += sprintf(cursor," ");
								cursor = showStr + totalLen;
							}
							totalLen += sprintf(cursor," set radio diversity enable\n");
							cursor = showStr + totalLen;
						}
						else if(((WTP[i]->WTP_Radio[j]->Radio_Type & IEEE80211_11N) == IEEE80211_11N)&&(WTP[i]->WTP_Radio[j]->diversity != 1)&&(((WTP[i]->APCode != NULL)&&(WTP[i]->APCode[strlen(WTP[i]->APCode)-1] != 'H'))&&(WTP[i]->WTP_Radio[j]->ishighpower  != 1)))
						{
							if(vrrid != 0){
								totalLen += sprintf(cursor," ");
								cursor = showStr + totalLen;
							}
							totalLen += sprintf(cursor," set radio diversity disable\n");
							cursor = showStr + totalLen;
						}

						if(((WTP[i]->WTP_Radio[j]->Radio_Type & IEEE80211_11N) != IEEE80211_11N)&&(WTP[i]->WTP_Radio[j]->txantenna == 0))
						{
							if(vrrid != 0){
								totalLen += sprintf(cursor," ");
								cursor = showStr + totalLen;
							}
							totalLen += sprintf(cursor," set radio txantenna auto\n");
							cursor = showStr + totalLen;
						}
						else if(((WTP[i]->WTP_Radio[j]->Radio_Type & IEEE80211_11N) == IEEE80211_11N)&&(WTP[i]->WTP_Radio[j]->txantenna == 1))
						{
							if(vrrid != 0){
								totalLen += sprintf(cursor," ");
								cursor = showStr + totalLen;
							}
							totalLen += sprintf(cursor," set radio txantenna main\n");
							cursor = showStr + totalLen;
						}
						/*fengwenchao modify end*/
						else if(WTP[i]->WTP_Radio[j]->txantenna == 2)
						{
							if(vrrid != 0){
								totalLen += sprintf(cursor," ");
								cursor = showStr + totalLen;
							}
							totalLen += sprintf(cursor," set radio txantenna vice\n");
							cursor = showStr + totalLen;
						}

                        /* zhangshu add for save 11n paras, 2010-11-25 */
                        if((WTP[i]->WTP_Radio[j]->Radio_Type & IEEE80211_11N) == IEEE80211_11N){
						
    						if(WTP[i]->WTP_Radio[j]->Ampdu.AmpduLimit != 65535)
    						{
    							if(vrrid != 0){
    								totalLen += sprintf(cursor," ");
    								cursor = showStr + totalLen;
    							}
    							totalLen += sprintf(cursor," 11n ampdu limit %d\n",WTP[i]->WTP_Radio[j]->Ampdu.AmpduLimit);
    							cursor = showStr + totalLen;
    						}
    						if(WTP[i]->WTP_Radio[j]->Ampdu.subframe != 32)
    						{
    							if(vrrid != 0){
    								totalLen += sprintf(cursor," ");
    								cursor = showStr + totalLen;
    							}
    							totalLen += sprintf(cursor," 11n ampdu subframe %d\n",WTP[i]->WTP_Radio[j]->Ampdu.subframe);
    							cursor = showStr + totalLen;
    						}
    						if(WTP[i]->WTP_Radio[j]->Ampdu.Able != 1)
    						{
    							if(vrrid != 0){
    								totalLen += sprintf(cursor," ");
    								cursor = showStr + totalLen;
    							}
    							totalLen += sprintf(cursor," 11n ampdu disable\n");
    							cursor = showStr + totalLen;
    						}
    						if(WTP[i]->WTP_Radio[j]->Amsdu.AmsduLimit != 4000)
    						{
    							if(vrrid != 0){
    								totalLen += sprintf(cursor," ");
    								cursor = showStr + totalLen;
    							}
    							totalLen += sprintf(cursor," 11n amsdu limit %d\n",WTP[i]->WTP_Radio[j]->Amsdu.AmsduLimit);
    							cursor = showStr + totalLen;
    						}
    						if(WTP[i]->WTP_Radio[j]->Amsdu.subframe != 32)
    						{
    							if(vrrid != 0){
    								totalLen += sprintf(cursor," ");
    								cursor = showStr + totalLen;
    							}
    							totalLen += sprintf(cursor," 11n amsdu subframe %d\n",WTP[i]->WTP_Radio[j]->Amsdu.subframe);
    							cursor = showStr + totalLen;
    						}
    						if(WTP[i]->WTP_Radio[j]->Amsdu.Able != 0)
    						{
    							if(vrrid != 0){
    								totalLen += sprintf(cursor," ");
    								cursor = showStr + totalLen;
    							}
    							totalLen += sprintf(cursor," 11n amsdu enable\n");
    							cursor = showStr + totalLen;
    						}
    						
    						if(WTP[i]->WTP_Radio[j]->channel_offset == 1)/*wuwl default value is 0*/
    						{
    							if(vrrid != 0){
    								totalLen += sprintf(cursor," ");
    								cursor = showStr + totalLen;
    							}
    							totalLen += sprintf(cursor," channel offset up\n");
    							cursor = showStr + totalLen;
    						}
    						else if(WTP[i]->WTP_Radio[j]->channel_offset == -1)
    						{
    							if(vrrid != 0){
    								totalLen += sprintf(cursor," ");
    								cursor = showStr + totalLen;
    							}
    							totalLen += sprintf(cursor," channel offset down\n");
    							cursor = showStr + totalLen;
    						}
    						if((WTP[i]->WTP_Radio[j]->MixedGreenfield.Mixed_Greenfield != 0)
						&& (WTP[i]->WTP_Radio[j]->MixedGreenfield.WlanID != 0)		/* HuangLeilei add for AXSSZFI-1622 */
						&&((WTP[i]->WTP_Radio[j]->Radio_Type != 10)&&(WTP[i]->WTP_Radio[j]->Radio_Type !=12))) // fengwenchao modify 20120716 for autelan-3057
    						{
							if ((AC_WLAN[WTP[i]->WTP_Radio[j]->MixedGreenfield.WlanID] != NULL))
								if ( (AC_WLAN[WTP[i]->WTP_Radio[j]->MixedGreenfield.WlanID]->want_to_delete != 1))
    							if(vrrid != 0){
    								totalLen += sprintf(cursor," ");
    								cursor = showStr + totalLen;
    							}
    							totalLen += sprintf(cursor," wlan %d workmode puren\n",WTP[i]->WTP_Radio[j]->MixedGreenfield.WlanID);
    							cursor = showStr + totalLen;
    						}
    						/* zhangshu modify for chainmask config, 2010-11-24 */
    						if(((WTP[i]->WTP_Radio[j]->chainmask_num == 1) \
    						&& (WTP[i]->WTP_Radio[j]->tx_chainmask_state_value != 1)) || 
    						((WTP[i]->WTP_Radio[j]->chainmask_num == 2) \
    						&& (WTP[i]->WTP_Radio[j]->tx_chainmask_state_value != 3)) ||
    						((WTP[i]->WTP_Radio[j]->chainmask_num == 3) \
    						&& (WTP[i]->WTP_Radio[j]->tx_chainmask_state_value != 7)))
    						{
    							if(WTP[i]->WTP_Radio[j]->tx_chainmask_state_value == 1){
    								if(vrrid != 0){
    									totalLen += sprintf(cursor," ");
    									cursor = showStr + totalLen;
    								}
    								totalLen += sprintf(cursor," tx_chainmask 0.0.1\n");
    								cursor = showStr + totalLen;
    							}
    							else if(WTP[i]->WTP_Radio[j]->tx_chainmask_state_value == 2){
    								if(vrrid != 0){
    									totalLen += sprintf(cursor," ");
    									cursor = showStr + totalLen;
    								}
    								totalLen += sprintf(cursor," tx_chainmask 0.1.0\n");
    								cursor = showStr + totalLen;
    							}
    							else if(WTP[i]->WTP_Radio[j]->tx_chainmask_state_value == 3){
    								if(vrrid != 0){
    									totalLen += sprintf(cursor," ");
    									cursor = showStr + totalLen;
    								}
    								totalLen += sprintf(cursor," tx_chainmask 0.1.1\n");
    								cursor = showStr + totalLen;
    							}
    							else if(WTP[i]->WTP_Radio[j]->tx_chainmask_state_value == 4){
    								if(vrrid != 0){
    									totalLen += sprintf(cursor," ");
    									cursor = showStr + totalLen;
    								}
    								totalLen += sprintf(cursor," tx_chainmask 1.0.0\n");
    								cursor = showStr + totalLen;
    							}
    							else if(WTP[i]->WTP_Radio[j]->tx_chainmask_state_value == 5){
    								if(vrrid != 0){
    									totalLen += sprintf(cursor," ");
    									cursor = showStr + totalLen;
    								}
    								totalLen += sprintf(cursor," tx_chainmask 1.0.1\n");
    								cursor = showStr + totalLen;
    							}
    							else if(WTP[i]->WTP_Radio[j]->tx_chainmask_state_value == 6){
    								if(vrrid != 0){
    									totalLen += sprintf(cursor," ");
    									cursor = showStr + totalLen;
    								}
    								totalLen += sprintf(cursor," tx_chainmask 1.1.0\n");
    								cursor = showStr + totalLen;
    							}
    							else if(WTP[i]->WTP_Radio[j]->tx_chainmask_state_value == 7){
    								if(vrrid != 0){
    									totalLen += sprintf(cursor," ");
    									cursor = showStr + totalLen;
    								}
    								totalLen += sprintf(cursor," tx_chainmask 1.1.1\n");
    								cursor = showStr + totalLen;
    							}
    						}
    						
    						if(((WTP[i]->WTP_Radio[j]->chainmask_num == 1) \
    						&& (WTP[i]->WTP_Radio[j]->rx_chainmask_state_value != 1)) || 
    						((WTP[i]->WTP_Radio[j]->chainmask_num == 2) \
    						&& (WTP[i]->WTP_Radio[j]->rx_chainmask_state_value != 3)) ||
    						((WTP[i]->WTP_Radio[j]->chainmask_num == 3) \
    						&& (WTP[i]->WTP_Radio[j]->rx_chainmask_state_value != 7)))
    						{
    							if(WTP[i]->WTP_Radio[j]->rx_chainmask_state_value == 1){
    								if(vrrid != 0){
    									totalLen += sprintf(cursor," ");
    									cursor = showStr + totalLen;
    								}
    								totalLen += sprintf(cursor," rx_chainmask 0.0.1\n");
    								cursor = showStr + totalLen;
    							}
    							else if(WTP[i]->WTP_Radio[j]->rx_chainmask_state_value == 2){
    								if(vrrid != 0){
    									totalLen += sprintf(cursor," ");
    									cursor = showStr + totalLen;
    								}
    								totalLen += sprintf(cursor," rx_chainmask 0.1.0\n");
    								cursor = showStr + totalLen;
    							}
    							else if(WTP[i]->WTP_Radio[j]->rx_chainmask_state_value == 3){
    								if(vrrid != 0){
    									totalLen += sprintf(cursor," ");
    									cursor = showStr + totalLen;
    								}
    								totalLen += sprintf(cursor," rx_chainmask 0.1.1\n");
    								cursor = showStr + totalLen;
    							}
    							else if(WTP[i]->WTP_Radio[j]->rx_chainmask_state_value == 4){
    								if(vrrid != 0){
    									totalLen += sprintf(cursor," ");
    									cursor = showStr + totalLen;
    								}
    								totalLen += sprintf(cursor," rx_chainmask 1.0.0\n");
    								cursor = showStr + totalLen;
    							}
    							else if(WTP[i]->WTP_Radio[j]->rx_chainmask_state_value == 5){
    								if(vrrid != 0){
    									totalLen += sprintf(cursor," ");
    									cursor = showStr + totalLen;
    								}
    								totalLen += sprintf(cursor," rx_chainmask 1.0.1\n");
    								cursor = showStr + totalLen;
    							}
    							else if(WTP[i]->WTP_Radio[j]->rx_chainmask_state_value == 6){
    								if(vrrid != 0){
    									totalLen += sprintf(cursor," ");
    									cursor = showStr + totalLen;
    								}
    								totalLen += sprintf(cursor," rx_chainmask 1.1.0\n");
    								cursor = showStr + totalLen;
    							}
    							else if(WTP[i]->WTP_Radio[j]->rx_chainmask_state_value == 7){
    								if(vrrid != 0){
    									totalLen += sprintf(cursor," ");
    									cursor = showStr + totalLen;
    								}
    								totalLen += sprintf(cursor," rx_chainmask 1.1.1\n");
    								cursor = showStr + totalLen;
    							}
    						}
						    /* zhangshu add for chainmask config END */
    																							
						if(WTP[i]->WTP_Radio[j]->guardinterval != 1){
							if(vrrid != 0){
								totalLen += sprintf(cursor," ");
								cursor = showStr + totalLen;
							}
							totalLen += sprintf(cursor," 11n guard interval 800\n");
							cursor = showStr + totalLen;
						}
						if(WTP[i]->WTP_Radio[j]->cwmode != 0){
							if(WTP[i]->WTP_Radio[j]->cwmode == 1){
								if(vrrid != 0){
									totalLen += sprintf(cursor," ");
									cursor = showStr + totalLen;
								}
								totalLen += sprintf(cursor," 11n cwmode ht20/40\n");
								cursor = showStr + totalLen;
							}else if(WTP[i]->WTP_Radio[j]->cwmode == 2){
								if(vrrid != 0){
									totalLen += sprintf(cursor," ");
									cursor = showStr + totalLen;
								}
								totalLen += sprintf(cursor," 11n cwmode ht40\n");
								cursor = showStr + totalLen;
							}
						}
					/*	if(WTP[i]->WTP_Radio[j]->mcs != 0){
							if(vrrid != 0){
								totalLen += sprintf(cursor," ");
								cursor = showStr + totalLen;
							}
							totalLen += sprintf(cursor," 11n mcs %d\n",WTP[i]->WTP_Radio[j]->mcs);
							cursor = showStr + totalLen;
						}*/
						/*fengwenchao add 20120314 for requirements-407*/
						if(check_ac_whether_or_not_set_mcs_list(WTP[i]->WTPID,j) == 1)
						{
							int q = 0;
							if(vrrid != 0){
								totalLen += sprintf(cursor," ");
								cursor = showStr + totalLen;
							}
							totalLen += sprintf(cursor," 11n mcs ");
							cursor = showStr + totalLen;
							for(q = 0; q < WTP[i]->WTP_Radio[j]->mcs_count;q++)
							{
								if(q == (WTP[i]->WTP_Radio[j]->mcs_count-1))
								{
									totalLen += sprintf(cursor,"%d\n",WTP[i]->WTP_Radio[j]->mcs_list[q]);
									cursor = showStr + totalLen;
									break;
								}
								totalLen += sprintf(cursor,"%d,",WTP[i]->WTP_Radio[j]->mcs_list[q]);
								cursor = showStr + totalLen;
							}
							
						}
						/*fengwenchao add end*/
					}
					 /* zhangshu add for 11n  END */
						/*A8 set begin*/
						if(WTP[i]->WTP_Radio[j]->REFlag == 1)
							{
							struct wds_rbmac *tmp = WTP[i]->WTP_Radio[j]->rbmac_list;
							if(WTP[i]->WTP_Radio[j]->distance != 0){
								if(vrrid != 0){
									totalLen += sprintf(cursor," ");
									cursor = showStr + totalLen;
								}
								totalLen += sprintf(cursor," set wds bridge distance %d\n",WTP[i]->WTP_Radio[j]->distance);
								cursor = showStr + totalLen;
							}							
							if(WTP[i]->WTP_Radio[j]->cipherType != 0){
								if(vrrid != 0){
									totalLen += sprintf(cursor," ");
									cursor = showStr + totalLen;
								}
								totalLen += sprintf(cursor," set wds encrption type %s\n",(WTP[i]->WTP_Radio[j]->cipherType==1)?"wep":"aes");
								cursor = showStr + totalLen;
								if(WTP[i]->WTP_Radio[j]->cipherType == 1){
									if(vrrid != 0){
										totalLen += sprintf(cursor," ");
										cursor = showStr + totalLen;
									}
									totalLen += sprintf(cursor," set wds wep key %s\n",WTP[i]->WTP_Radio[j]->wepkey);
									cursor = showStr + totalLen;
								}
							}
							while(tmp != NULL){
								if(vrrid != 0){
									totalLen += sprintf(cursor," ");
									cursor = showStr + totalLen;
								}
								totalLen += sprintf(cursor," add wds remote brmac %02x:%02x:%02x:%02x:%02x:%02x\n",tmp->mac[0],tmp->mac[1],tmp->mac[2],tmp->mac[3],tmp->mac[4],tmp->mac[5]);
								cursor = showStr + totalLen;
								if(WTP[i]->WTP_Radio[j]->cipherType == 2){
									if(vrrid != 0){
										totalLen += sprintf(cursor," ");
										cursor = showStr + totalLen;
									}
									totalLen += sprintf(cursor," set wds brmac %02x:%02x:%02x:%02x:%02x:%02x aes key %s\n",tmp->mac[0],tmp->mac[1],tmp->mac[2],tmp->mac[3],tmp->mac[4],tmp->mac[5],tmp->key);
									cursor = showStr + totalLen;
								}
								tmp = tmp->next;
							}
							if(WTP[i]->WTP_Radio[j]->supper_g.supper_g_type & 0x1){
								if(vrrid != 0){
									totalLen += sprintf(cursor," ");
									cursor = showStr + totalLen;
								}
								totalLen += sprintf(cursor," set bursting enable\n");
								cursor = showStr + totalLen;								
							}							
							if(WTP[i]->WTP_Radio[j]->supper_g.supper_g_type & 0x2){
								if(vrrid != 0){
									totalLen += sprintf(cursor," ");
									cursor = showStr + totalLen;
								}
								totalLen += sprintf(cursor," set fastFrame enable\n");
								cursor = showStr + totalLen;								
							}
							if(WTP[i]->WTP_Radio[j]->supper_g.supper_g_type & 0x4){
								if(vrrid != 0){
									totalLen += sprintf(cursor," ");
									cursor = showStr + totalLen;
								}
								totalLen += sprintf(cursor," set compression enable\n");
								cursor = showStr + totalLen;								
							}
							char *S_LIST = NULL;
							int state_value = 0;
							S_LIST = (char *)WID_MALLOC(7+1);					
							memset(S_LIST,0,7+1);
							state_value = (int)(WTP[i]->WTP_Radio[j]->sector_state_value);
							if(WTP[i]->WTP_Radio[j]->sector_state_value != 0){
								if(state_value & 0x1)
								{
									strncat(S_LIST,"0",1);
								}
								if(state_value & 0x2)
								{
									strncat(S_LIST,",1",2);
								}
								if(state_value & 0x4)
								{
									strncat(S_LIST,",2",2);
								}
								if(state_value & 0x8)
								{   
									strncat(S_LIST,",3",2);
								}
								if(vrrid != 0){
									totalLen += sprintf(cursor," ");
									cursor = showStr + totalLen;
								}
								totalLen += sprintf(cursor," set radio sector %s enable\n",S_LIST);
								cursor = showStr + totalLen;								
							}
							if(S_LIST){
								WID_FREE(S_LIST);
								S_LIST = NULL;
							}
							/*"set radio sectorid (0|1|2|3|all) power VALUE"*/
							for(s_id=0;s_id<SECTOR_NUM;s_id++){
								s_state += WTP[i]->WTP_Radio[j]->sector[s_id]->state;
							}
							if(s_state == 4){
								if(vrrid != 0){
									totalLen += sprintf(cursor," ");
									cursor = showStr + totalLen;
								}
								totalLen += sprintf(cursor," set radio sectorid all power %d\n",WTP[i]->WTP_Radio[j]->sector[0]->tx_power);
								cursor = showStr + totalLen;		
							}else if(s_state < 4){
								//s_id=0;
								for(s_id2=0;s_id2<SECTOR_NUM;s_id2++){
									if(vrrid != 0){
										totalLen += sprintf(cursor," ");
										cursor = showStr + totalLen;
									}
									if((WTP[i]->WTP_Radio[j]->sector[s_id2]->state == 1)&&(WTP[i]->WTP_Radio[j]->sector[s_id2]->tx_power != 0)){
										totalLen += sprintf(cursor," set radio sectorid %d power %d\n",s_id2,WTP[i]->WTP_Radio[j]->sector[s_id2]->tx_power);
										cursor = showStr + totalLen;
									}	
								}	
							}
							/*countr code for a8*/
							if(gCOUNTRYCODE == COUNTRY_USA_US){
								if(vrrid != 0){
									totalLen += sprintf(cursor," ");
									cursor = showStr + totalLen;
								}
								totalLen += sprintf(cursor," country-code US\n");
								cursor = showStr + totalLen; 
							}
							else if(gCOUNTRYCODE == COUNTRY_EUROPE_EU){
								if(vrrid != 0){
									totalLen += sprintf(cursor," ");
									cursor = showStr + totalLen;
								}
								totalLen += sprintf(cursor," country-code EU\n");
								cursor = showStr + totalLen; 
							}
							else {
								if(vrrid != 0){
									totalLen += sprintf(cursor," ");
									cursor = showStr + totalLen;
								}
								totalLen += sprintf(cursor," country-code CN\n");/*in extern command actually send: set regdmn RoW*/
								cursor = showStr + totalLen;								
							}
							
							if(WTP[i]->WTP_Radio[j]->inter_vap_able == 1){
								if(vrrid != 0){
									totalLen += sprintf(cursor," ");
									cursor = showStr + totalLen;
								}
								totalLen += sprintf(cursor," set inter-VAP-forwarding enable\n");
								cursor = showStr + totalLen;								
							}
							if(WTP[i]->WTP_Radio[j]->intra_vap_able == 1){
								if(vrrid != 0){
									totalLen += sprintf(cursor," ");
									cursor = showStr + totalLen;
								}
								totalLen += sprintf(cursor," set intra-VAP-forwarding enable\n");
								cursor = showStr + totalLen;								
							}
							if(WTP[i]->WTP_Radio[j]->keep_alive_period != 3600){
								if(vrrid != 0){
									totalLen += sprintf(cursor," ");
									cursor = showStr + totalLen;
								}
								totalLen += sprintf(cursor," set radio keep_alive_period %d\n",WTP[i]->WTP_Radio[j]->keep_alive_period);
								cursor = showStr + totalLen;								
							}
							if(WTP[i]->WTP_Radio[j]->keep_alive_idle_time != 3600){
								if(vrrid != 0){
									totalLen += sprintf(cursor," ");
									cursor = showStr + totalLen;
								}
								totalLen += sprintf(cursor," set radio keep_alive_idle_time %d\n",WTP[i]->WTP_Radio[j]->keep_alive_idle_time);
								cursor = showStr + totalLen;								
							}
							if(WTP[i]->WTP_Radio[j]->congestion_avoidance == 1){
								if(vrrid != 0){
									totalLen += sprintf(cursor," ");
									cursor = showStr + totalLen;
								}
								totalLen += sprintf(cursor," set radio congestion_avoidance tail-drop\n");
								cursor = showStr + totalLen;								
							}
							else if(WTP[i]->WTP_Radio[j]->congestion_avoidance == 2){
								if(vrrid != 0){
									totalLen += sprintf(cursor," ");
									cursor = showStr + totalLen;
								}
								totalLen += sprintf(cursor," set radio congestion_avoidance red\n");
								cursor = showStr + totalLen;								
							}
							else if(WTP[i]->WTP_Radio[j]->congestion_avoidance == 3){
								if(vrrid != 0){
									totalLen += sprintf(cursor," ");
									cursor = showStr + totalLen;
								}
								totalLen += sprintf(cursor," set radio congestion_avoidance fwred\n");
								cursor = showStr + totalLen;								
							}
						}
						if(WTP[i]->WTP_Radio[j]->ack.distance != 0){
							if(vrrid != 0){
								totalLen += sprintf(cursor," ");
								cursor = showStr + totalLen;
							}
							totalLen += sprintf(cursor," acktimeout radio set distance %d\n",WTP[i]->WTP_Radio[j]->ack.distance);
							cursor = showStr + totalLen;
						}					/*wcl add for RDIR-33*/	
						/*fengwenchao add 20111214 for AUTELAN-2712*/
						if((WTP[i]->WTP_Radio[j] != NULL)&&(WTP[i]->WTP_Radio[j]->QOSstate != 0))
						{
							if(vrrid != 0){
								totalLen += sprintf(cursor," ");
								cursor = showStr + totalLen;
							}
							totalLen += sprintf(cursor," radio apply qos %d\n",WTP[i]->WTP_Radio[j]->QOSID);
							cursor = showStr + totalLen;
						}			
						/*fengwenchao add end*/
						/*fengwenchao add 20110921 for radio disable*/
						if(WTP[i]->WTP_Radio[j]->radio_disable_flag == 1)
						{
							if(vrrid != 0){
								totalLen += sprintf(cursor," ");
								cursor = showStr + totalLen;
							}
							totalLen += sprintf(cursor," radio disable\n");
							cursor = showStr + totalLen;							
						}
						/*fengwenchao add end*/

						
						/*A8 set end*/
						if(vrrid != 0){
							totalLen += sprintf(cursor," ");
							cursor = showStr + totalLen;
						}

						totalLen += sprintf(cursor,"exit\n");
						cursor = showStr + totalLen;
					}
					
					}
				}
				*totalLen_T = totalLen;
				*str_len_T = str_len;
	return 0;
}


static DBusHandlerResult wid_dbus_message_handler (DBusConnection *connection, DBusMessage *message, void *user_data){

	DBusMessage		*reply = NULL;
	char sender[20];

//	printf("enter wid handler\n");
	if(message == NULL);
//		printf("message is NULL\n");
	wid_syslog_debug_debug(WID_DBUS,"message path %s\n",dbus_message_get_path(message));
	wid_syslog_debug_debug(WID_DBUS,"message interface %s\n",dbus_message_get_interface(message));
	wid_syslog_debug_debug(WID_DBUS,"message member %s\n",dbus_message_get_member(message));
	wid_syslog_debug_debug(WID_DBUS,"message destination %s\n",dbus_message_get_destination(message));	
	wid_syslog_debug_debug(WID_DBUS,"message type %d\n",dbus_message_get_type(message));

	if	(strcmp(dbus_message_get_path(message),WID_DBUS_OBJPATH) == 0)	{
		//printf("wid obj path: %s", WID_DBUS_OBJPATH);
//		printf("config\n");
		if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WLAN)) {
//			printf("wlan exist?\n");
			reply = wid_dbus_interface_wlan(connection,message,user_data);
		}

		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WTP)) {
//			printf("wtp exist?\n");
			reply = wid_dbus_interface_wtp(connection,message,user_data);
		}		
		
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_RADIO)) {
		//	printf("radio exist?\n");
			reply = wid_dbus_interface_radio(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOWWLAN)) {
//			printf("config show wlan\n");
			reply = wid_dbus_interface_show_wlanconf(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOWWLAN_OF_ALL)){
			reply = wid_dbus_interface_show_wlanconf_of_all(connection,message,user_data);     //fengwenchao add 20101223
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WLANLIST)) {
//			printf("config show wlan list\n");
			reply = wid_dbus_interface_show_wlanlist(connection,message,user_data);
		}

		
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST)) {
//			printf("config show wtp list\n");
			reply = wid_dbus_interface_show_wtplist(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST_BYMAC)) {
			//printf("config show wtp list\n");
			reply = wid_dbus_interface_show_wtplist_bymac(connection,message,user_data);
		}
		/*xdw add for show ap network information of all wtp, 20101215*/
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_ALL_WTP_NETWORK_INFO)) {
			reply = wid_dbus_interface_show_all_wtp_network_info(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST_NEW)) {
			//printf("config show wtp list\n");
			reply = wid_dbus_interface_show_wtplist_new(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST_NEW_BYINTERFACE)) {
			//printf("config show wtp list\n");
			reply = wid_dbus_interface_show_wtplist_byinterface(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOWWTP_BYMODEL)) {
			reply = wid_dbus_interface_show_wtplist_bymodel(connection,message,user_data);     /*fengwenchao add 20110226*/
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOWWTP_BYVERSION)) {
			reply = wid_dbus_interface_show_wtplist_byversion(connection,message,user_data);   /*fengwenchao add 20110314*/
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST_UPDATE)) {
			reply = wid_dbus_interface_show_wtplist_update(connection,message,user_data);
		}	
		
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST_UPDATE_FAIL_LIST)) {
			reply = wid_dbus_interface_show_wtplist_update_fail(connection,message,user_data);
		}				
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ACVERSION)) {
			reply = wid_dbus_interface_show_acversion(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ECHOTIMER)) {
			reply = wid_dbus_interface_show_ap_echotimer(connection,message,user_data);
		}

		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOWWTP)) {
//			printf("config show wtp\n");
			reply = wid_dbus_interface_show_wtpconf(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_CONFIG_WTP)) {
			reply = wid_dbus_interface_show_wtpconf_allwtp(connection,message,user_data);    //fengwenchao add 20101223
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WTPLIST_BYWLANID)) {
			reply = wid_dbus_interface_show_wtpconf_bywlanid(connection,message,user_data);
		}			
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOWRADIO)) {
//			printf("config show radio\n");
			reply = wid_dbus_interface_show_radioconf(connection,message,user_data);
		}
		
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_RADIOLIST)) {
		
			reply = wid_dbus_interface_show_radiolist(connection,message,user_data);
		}
				
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ADD_DEL_WLAN)) {
//			printf("config ad wlan\n");
			reply = wid_dbus_interface_wlan_add_del(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ADD_DEL_WLAN_EBR)) {
			reply = wid_dbus_interface_wlan_ebr_add_del(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_AUTO_ADD_RADIO_EBR_SWITCH)) {
			reply = wid_dbus_interface_set_radio_auto_add_to_ebr_switch(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_AUTO_ADD_RADIO_EBR_SWITCH)) {
			reply = wid_dbus_interface_show_radio_auto_add_to_ebr_switch(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ADD_DEL_WLAN_CN)) {
			reply = wid_dbus_interface_wlan_add_del_CN(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ADD_DEL_WTP)) {
//			printf("config ad wtp\n");
			reply = wid_dbus_interface_wtp_add_del(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ADD_DEL_WTP_BY_MAC)) {
			reply = wid_dbus_interface_wtp_add_del_by_mac(connection,message,user_data);
		}

		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_WEB_REPORT_SNR_RANGE)) {
			reply = wid_dbus_interface_set_web_report_snr_range(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WLAN_SHOW_RUNNING_CONFIG_START)) {
			reply = wid_dbus_wlan_show_running_config_start(connection,message,user_data);
		}

		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WLAN_SHOW_RUNNING_CONFIG_END)) {
			reply = wid_dbus_wlan_show_running_config_end(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WTP_RUNNING_CONFIG)){
			reply = wid_dbus_show_wtp_config(connection,message,user_data);
		}			
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WTP_SHOW_RUNNING_CONFIG_START)) {
			reply = wid_dbus_wtp_show_running_config_start(connection,message,user_data);
		}
		
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WTP_SHOW_RUNNING_CONFIG_END)) {
			reply = wid_dbus_wtp_show_running_config_end(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_EBR_SHOW_RUNNING_CONFIG_START)) {
			reply = wid_dbus_ebr_show_running_config_start(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_EBR_SHOW_RUNNING_CONFIG_END)) {
			reply = wid_dbus_ebr_show_running_config_end(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WIDCONFIG)) {
			reply = wid_dbus_interface_show_wid_config(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_AC_NAME)) {
			reply = wid_dbus_interface_set_wid_name(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SW_VERSION)) {
			reply = wid_dbus_interface_set_wid_sw_version(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_HW_VERSION)) {
			reply = wid_dbus_interface_set_wid_hw_version(connection,message,user_data);
		}

		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SECURITY_TYPE)) {
			reply = wid_dbus_interface_set_wid_security_type(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_LEV3_PROTOCOL)) {
			reply = wid_dbus_interface_set_wid_lev3_protocol(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_MAX_WTP)) {
			reply = wid_dbus_interface_set_wid_max_wtp(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_MAX_MTU)) {
			reply = wid_dbus_interface_set_wid_max_mtu(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_LOG_SWITCH)) {
			reply = wid_dbus_interface_set_wid_log_switch(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_LOG_SIZE)) {
			reply = wid_dbus_interface_set_wid_log_size(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_LOG_LEVEL)) {
			reply = wid_dbus_interface_set_wid_syslog_debug_level(connection,message,user_data);
		}//sz20080917
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_DAEMONLOG_DEBUG_OPEN)) {
			reply = wid_dbus_interface_set_wid_daemonlog_level(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_HNLOG_SWITCH_ACTIVATED)){
			reply = wid_dbus_interface_set_wid_log_hn_enable(connection,message,user_data);//qiuchen add it for Henan mobile 2013.02.21
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONFIG_METHOD_SET_LOG_STATISTICS_INTERVAL)){
			reply = wid_dbus_interface_set_log_statistics_interval(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_AC_MANAGEMENT_IP)){
			reply = wid_dbus_interface_set_ac_management_ip(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_TRAP_DEBUG_OPEN)) {
			reply = wid_dbus_interface_set_wid_trap_debug(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_TRAP_SWITCH_ABLE)) {
			reply = wid_dbus_interface_set_wid_trap_switch_able(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_TRAP_SWITCH_SHOW)) {
			reply = wid_dbus_interface_show_wid_trap_switch_state(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_AP_SCANNING)) {
			reply = wid_dbus_interface_set_ap_scanning(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_AP_SCANNING_REPORT_INTERVAL)) {
			reply = wid_dbus_interface_set_ap_scanning_report_interval(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_AP_COUNTERMEASURES)) {
			reply = wid_dbus_interface_set_ap_countermeasures(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_AP_COUNTERMEASURES_MODE)) {
			reply = wid_dbus_interface_set_ap_countermeasures_mode(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_UPDATE_AP_SCANNING_INFO)) {
			reply = wid_dbus_interface_update_ap_scanning_info(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WHITELIST)) {
			reply = wid_dbus_interface_set_wireless_control_whitelist(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_CHANGE_WHITELIST)) {
			reply = wid_dbus_interface_change_wireless_control_whitelist(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_CHANGE_BLACKLIST)) {
			reply = wid_dbus_interface_change_wireless_control_blacklist(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ACCESS_WTP_VENDOR_COUNT_SHOW)) {
			reply = wid_dbus_interface_show_access_wtpvendor_count(connection,message,user_data);
		}		
		else if(dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_LICENSE_BINDING)) {
			reply = wid_dbus_interface_set_license_bind(connection,message,user_data);
		}
		//xiaodawei add for iperf, 20110311		
		else if(dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_IPERF_WTPIP)) {
			reply = wid_dbus_interface_iperf_wtpip(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ADD_OUI)) {
			reply = wid_dbus_interface_add_oui(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_DEL_OUI)) {
			reply = wid_dbus_interface_del_oui(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_DEL_ESSID)) {
			reply = wid_dbus_interface_del_essid(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ADD_ESSID)) {
			reply = wid_dbus_interface_add_essid(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_MODIFY_ESSID)) {
			reply = wid_dbus_interface_modify_essid(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_MAC_WHITELIST_SWITCH)) {
			reply = wid_dbus_interface_set_wid_mac_whitelist_switch(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_ESSID_WHITELIST_SWITCH)) {
			reply = wid_dbus_interface_set_wid_essid_whitelist_switch(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ADD_ATTACK_MAC)) {
			reply = wid_dbus_interface_add_attack_ap_mac(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ADD_WID_MAC)) {
			reply = wid_dbus_interface_add_wids_mac(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_DEL_WID_MAC)) {
			reply = wid_dbus_interface_del_wids_mac(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_DEL_ATTACK_MAC)) {
			reply = wid_dbus_interface_del_attack_ap_mac(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_BLACKLIST)) {
			reply = wid_dbus_interface_set_wireless_control_blacklist(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WHITELIST_DELETE)) {
			reply = wid_dbus_interface_delete_wireless_control_whitelist(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_BLACKLIST_DELETE)) {
			reply = wid_dbus_interface_delete_wireless_control_blacklist(connection,message,user_data);
		}

		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ROGUE_AP_LIST)) {
			reply = wid_dbus_interface_show_rogue_ap_list(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ROGUE_AP_THRESHOLD)) {
			reply = wid_dbus_interface_show_rogue_ap_threshold(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ROGUE_AP_LIST_V1)) {
			reply = wid_dbus_interface_show_rogue_ap_list_v1(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ROGUE_AP_LIST_BYWTPID)) {
			reply = wid_dbus_interface_show_rogue_ap_list_bywtpid(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_DYNAMIC_CHANNEL_SELECTION)){
			reply = wid_dbus_interface_dynamic_channel_selection(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_DYNAMIC_CHANNEL_SELECTION_RANGE)){
			reply = wid_dbus_interface_dynamic_channel_selection_range(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_TRANSMIT_POWER_CONTROL)){
			reply = wid_dbus_interface_transmit_power_control(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_TXPOWER_THRESHOLD)){
			reply = wid_dbus_interface_txpower_threshold(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ROGUE_AP_TRAP_THRESHOLD)){
			reply = wid_dbus_interface_rogue_ap_trap_threshold(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_COVERAGE_THRESHOLD)){
			reply = wid_dbus_interface_coverage_threshold(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_CONTROL_SCOPE)){
			reply = wid_dbus_interface_control_scope(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_NEIGHBOR_RSSI_INFO)){
			reply = wid_dbus_interface_show_neighbor_rssi(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_NEIGHBOR_AP_LIST_BYWTPID)) {
			reply = wid_dbus_interface_show_neighbor_ap_list_bywtpid(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_NEIGHBOR_AP_LIST)) {
			reply = wid_dbus_interface_show_neighbor_ap_list(connection,message,user_data);	    //fengwenchao add 20101223
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_NEIGHBOR_AP_LIST_BYWTPID2)) {
			reply = wid_dbus_interface_show_neighbor_ap_list_bywtpid2(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WIDS_STATISTICS_LIST_BYWTPID)) {
			reply = wid_dbus_interface_show_wids_statistics_list_bywtpid(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_CLEAR_WIDS_STATISTICS_LIST_BYWTPID)) {
			reply = wid_dbus_interface_clear_wids_statistics_list_bywtpid(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WIDS_STATISTICS_LIST)) {
			reply = wid_dbus_interface_show_wids_statistics_list(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_CLEAR_WIDS_STATISTICS_LIST)) {
			reply = wid_dbus_interface_clear_wids_statistics_list(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WIDS_DEVICE_LIST_BYWTPID)) {
			reply = wid_dbus_interface_show_wids_device_list_bywtpid(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_CLEAR_WIDS_DEVICE_LIST_BYWTPID)) {
			reply = wid_dbus_interface_clear_wids_device_list_bywtpid(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WIDS_DEVICE_LIST)) {
			reply = wid_dbus_interface_show_wids_device_list(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WIDS_DEVICE_OF_ALL)){
			reply = wid_dbus_interface_show_wids_device_of_all(connection,message,user_data);  //fengwenchao add 20101227
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_CLEAR_WIDS_DEVICE_LIST)) {
			reply = wid_dbus_interface_clear_wids_device_list(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WHITELIST_SHOW)) {
			reply = wid_dbus_interface_show_wireless_control_whitelist(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE, WID_DBUS_CONF_METHOD_ATTACK_MAC_SHOW )) {
			reply = wid_dbus_interface_show_attack_mac_list(connection,message,user_data);
		}
		
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE, WID_DBUS_CONF_METHOD_WIDS_MAC_SHOW )) {
			reply = wid_dbus_interface_show_wids_mac_list(connection,message,user_data);
		}			
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_OUI_SHOW)) {
			reply = wid_dbus_interface_show_oui_list(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ESSID_SHOW )) {
			reply = wid_dbus_interface_show_essid_list(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_BLACKLIST_SHOW)) {
			reply = wid_dbus_interface_show_wireless_control_blacklist(connection,message,user_data);
		}
		//country code area
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_COUNTRY_CODE)) {
			reply = wid_dbus_interface_set_country_code(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_UNDO_COUNTRY_CODE)) {
			reply = wid_dbus_interface_undo_country_code(connection,message,user_data);
		}
		//auto ap area
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_DYNAMIC_AP_LOGIN_SWITCH)) {
			reply = wid_dbus_interface_set_wid_auto_ap_login_switch(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_MEMORY_TRACE_SWITCH)) {
			reply = wid_dbus_interface_set_wid_memory_trace_switch(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_DYNAMIC_AP_LOGIN_L3_INTERFACE)) {
			reply = wid_dbus_interface_set_wid_auto_ap_login_binding_l3_interface(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_LISTEN_L3_INTERFACE)) {
			reply = wid_dbus_interface_set_wid_listen_l3_interface(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_LISTEN_IP)) {
			reply = wid_dbus_interface_set_wid_listen_ip(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WID_LISTEN_L3_INTERFACE)) {
			reply = wid_dbus_show_wid_listen_l3_interface(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_DYNAMIC_AP_LOGIN_WLANID)) {
			reply = wid_dbus_interface_set_wid_auto_ap_login_binding_wlan(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_DEL_WID_DYNAMIC_AP_LOGIN_WLANID)) {
			reply = wid_dbus_interface_del_wid_auto_ap_login_binding_wlan(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_DYNAMIC_AP_LOGIN_SAVE_CONFIG_SWITCH)) {
			reply = wid_dbus_interface_set_wid_auto_ap_login_save_config_switch(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WID_DYNAMIC_AP_LOGIN_SAVE_CONFIG)) {
			reply = wid_dbus_interface_show_wid_auto_ap_login_config(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_CLEAR_WID_DYNAMIC_AP_LOGIN_CONFIG)) {
			reply = wid_dbus_interface_clear_wid_auto_ap_login_config(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_AP_DATA_EXCLUDE_MULTICAST)) {
			reply = wid_dbus_interface_set_ap_data_exclude_multicast(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_AP_STATISTICS)) {
			reply = wid_dbus_interface_set_ap_statistics(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_AP_STATISTICS_INTERVAL)) {
			reply = wid_dbus_interface_set_ap_statistics_interval(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_AP_HOTREBOOT)) {
			reply = wid_dbus_interface_set_ap_hotreboot(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_AP_SHOW_STATISTICS_LIST)) {
			reply = wid_dbus_interface_show_ap_statistics(connection,message,user_data);
		}

		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_AP_SHOW_IPADDR)) {
			reply = wid_dbus_interface_show_ap_ipaddr(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_AP_SHOW_NETWORK)) {
			reply = wid_dbus_interface_show_ap_network(connection,message,user_data);
		}
		
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_AC_LOAD_BALANCE)) {
			reply = wid_dbus_interface_ac_load_balance(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_AC_LOAD_BALANCE_PARA)) {
			reply = wid_dbus_interface_set_ac_load_balance_para(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_AC_EXTENTION_INFOR_ENABLE)) {
			reply = wid_dbus_interface_set_ac_extension_infomation_enable(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_AC_BALANCE_CONFIGURATION)) {
			reply = wid_dbus_interface_show_ac_balance_configuration(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_AP_TIMESTAMP)) {
			reply = wid_dbus_interface_set_ap_timestamp(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_AP_SHOW_MODEL_INFOMATION)) {
			reply = wid_dbus_interface_show_ap_model_infomation(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_AP_SHOW_MODEL_CODE_INFOMATION)) {
			reply = wid_dbus_interface_show_ap_model_code_infomation(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_AP_SHOW_WTP_TXPOWER_CONTROL)) {
			reply = wid_dbus_interface_show_wtp_txpower_control_infomation(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_RECEIVER_SIGNAL_LEVEL)) {
			reply = wid_dbus_interface_set_receiver_signal_level(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_RECEIVER_SIGNAL_LEVEL)) {
			reply = wid_dbus_interface_show_receiver_signal_level(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_MONITOR_TIME)) {
			reply = wid_dbus_interface_set_wid_monitor_time(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_SAMPLE_TIME)) {
			reply = wid_dbus_interface_set_wid_sample_time(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WID_SAMPLE_INFO)) {
			reply = wid_dbus_interface_show_wid_sample_infomation(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_SAMPLE_ENABLE)) {
			reply = wid_dbus_interface_set_wid_sample_enable(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_MONITOR_ENABLE)) {
			reply = wid_dbus_interface_set_wid_monitor_enable(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_IPFWD)) {
			reply = wid_dbus_interface_set_wid_ipfwd(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WID_IPFWD)) {
			reply = wid_dbus_interface_show_wid_ipfwd(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_MODEL_LIST)) {
			reply = wid_dbus_interface_show_model_list(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_MODEL)) {
			reply = wid_dbus_interface_show_model(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_MODEL)) {
			reply = wid_dbus_interface_set_model(connection,message,user_data);
		}
			else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_AP_CM_THRESHOLD)) {
			reply = wid_dbus_interface_set_ap_cm_threshold(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_WTP_ROGUEAP_ROGUETERMINAL_CPU_MEM_TRAP_THRESHOLD)) {
			reply = wid_dbus_interface_set_wtp_rogueap_rogue_terminal_cpu_mem_trap_threshold(connection,message,user_data);
		}
		
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_WTP_COLLECT_TIME)) {
			reply = wid_dbus_interface_set_wtp_trap_collect_time(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_AP_CM_THRESHOLD)) {
			reply = wid_dbus_interface_show_ap_cm_threshold(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_AP_TRAP_ROGUE_AP_TERMINAL_CPU_MEM_THRESHOLD)) {
			reply = wid_dbus_interface_show_wtp_rogueap_terminal_cpu_mem_trap_threshold(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_WTP_TRAP_SWITCH)) {
			reply = wid_dbus_interface_set_wtp_trap_switch(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_WTP_SEQNUM_SWITCH)) {  /*wcl add*/
			reply = wid_dbus_interface_set_wtp_seqnum_switch(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHD_SET_WID_ROGUE_DANGER_UNSAFE_ATTACK_TRAP_STATE)){ /*fengwenchao add 20110221*/
			reply = wid_dbus_interface_set_wid_rogue_danger_unsafe_attack_trap_state(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_RRM_CONFIG)) {
			reply = wid_dbus_interface_show_rrm_config(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_RADIO_METHOD_SHOW_RADIO_QOS)) {
			reply = wid_dbus_interface_show_radio_qos(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_UPDATE_WTP_COUNT)) {
			reply = wid_dbus_interface_update_wtp_count(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_WIDS_SET)) {
			reply = wid_dbus_interface_set_wtp_wids_item(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_WTP_METHOD_SHOW_WTP_WIDS_SET)) {
			reply = wid_dbus_interface_show_wtp_wids_item(connection,message,user_data);
		}
			else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_WTP_METHOD_SHOW_DHCP_FLOODING_STATUS_SET)) {
				reply = wid_dbus_interface_show_dhcp_flooding_status(connection, message, user_data);
			}
			else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE, WID_DBUS_WTP_METHOD_SET_DHCP_FLOODING_STATUS_SET)) {
				reply = wid_dbus_interface_set_dhcp_flooding_status(connection, message, user_data);
			}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_NEIGHBORDEAD_INTERVAL)) {
			reply = wid_dbus_interface_set_neighbordead_interval(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_NEIGHBORDEAD_INTERVAL)) {
			reply = wid_dbus_interface_show_neighbordead_interval(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_WIDS_INTERVAL)) {
			reply = wid_dbus_interface_set_wtp_wids_interval(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_WIDS_POLICY)) {
			reply = wid_dbus_interface_set_wtp_wids_policy(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_WIDS_THRESHOLD)) {
			reply = wid_dbus_interface_set_wtp_wids_threshold(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_WIDS_LASTTIME_IN_BLACK)) {
			reply = wid_dbus_interface_set_wtp_wids_lasttime_in_black(connection,message,user_data);
		}
		/*fengwenchao add 20120117 for onlinebug-96*/
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_WTP_METHOD_SET_AC_MASTER_BAK_CORRECT_WTP_STATE_TIMER)){
			reply = wid_dbus_interface_set_ac_master_bak_correct_wtp_state_timer(connection,message,user_data);	
		}
		/*fengwenchao add end*/
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_WTP_METHOD_SET_AC_ACTIVE_BAK_STATE)){
			reply = wid_dbus_interface_set_ac_state_ip(connection,message,user_data);	
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_WTP_METHOD_SHOW_WTP_MODEL_CODE_VERSION)) {
			reply = wid_dbus_interface_show_wtp_model_code_version(connection,message,user_data);
		}	
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_WTP_METHOD_UPDATE_WTP_IMG)) {
			reply = wid_dbus_interface_update_wtp_img_version(connection,message,user_data);
		}	
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_WTP_METHOD_CLEAR_UPDATE_WTP_IMG)) {
			reply = wid_dbus_interface_clear_update_wtp_img_version(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_AP_UPDATE_TIMER)) {
			reply = wid_dbus_interface_set_ap_update_timer(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_AP_UPDATE_FAIL_COUNT)) {
			reply = wid_dbus_interface_set_ap_update_fail_count(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_AP_UPDATE_FAIL_COUNT)) {
			reply = wid_dbus_interface_show_ap_update_fail_count(connection,message,user_data);
		}				
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_AP_UPDATE_TIMER)) {
			reply = wid_dbus_interface_show_ap_update_timer(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_WTP_METHOD_UPDATE_WTP_IMG_LIST)) {
			reply = wid_dbus_interface_update_wtp_img_version_list(connection,message,user_data);
		}	
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_WTP_METHOD_CLEAR_UPDATE_WTP_IMG_LIST)) {
			reply = wid_dbus_interface_clear_update_wtp_img_version_list(connection,message,user_data);
		}	
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_WTP_METHOD_CLEAR_UPDATE_FAIL_WTP_LIST)) {
			reply = wid_dbus_interface_clear_update_fail_wtp_list(connection,message,user_data);
		}			
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_AC_ACCESS_WTPLIST)) {
			reply = wid_dbus_interface_show_ac_access_wtplist(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_CLEAN_AC_ACCESS_WTPLIST)) {
			reply = wid_dbus_interface_clean_ac_access_wtplist(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_OLD_AP_IMG)) {
			reply = wid_dbus_interface_old_ap_img(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_UPDATE_WTPCOMPATIBLE)) {
			reply = wid_dbus_interface_update_wtpcompatible(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_OLD_AP_IMG)) {
			reply = wid_dbus_interface_show_old_ap_img(connection,message,user_data);
		}
		 /*for showing wtp informaition for mib by nl*/
		 /*------------------------------------BEGIN----------------------------------------*/
		 else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_ALL_WTP_BASIC_INFORMATION)) {
			 reply = wid_dbus_interface_show_wtp_basic_information(connection,message,user_data);
		 }
		 else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_ALL_WTP_COLLECT_INFORMATION)) {
			 reply = wid_dbus_interface_show_wtp_collect_information(connection,message,user_data);
		 }
		 else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_ALL_WTP_PARA_INFORMATION)) {
			 reply = wid_dbus_interface_show_wtp_para_information(connection,message,user_data);
		 }
		 else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_ALL_WTP_WIRELESS_IFSTATS_INFORMATION)) {
			 reply = wid_dbus_interface_show_wtp_wireless_ifstats_information(connection,message,user_data);
		 }
		 //mahz add 2011.1.21
		 else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_RADIO_INFO_BYWTPID_WID)) {
			 reply = wid_dbus_interface_show_radio_info_bywtpid_wid(connection,message,user_data);
		 }
		 //mahz add 2011.5.12
		 else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_BSS_ADD_MAC_LIST)) {
			 reply = wid_dbus_interface_bss_add_mac_list(connection,message,user_data);
		 }
		 else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_BSS_DEL_MAC_LIST)) {
			 reply = wid_dbus_interface_bss_del_mac_list(connection,message,user_data);
		 }
		 else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_BSS_USE_MAC_LIST)) {
			 reply = wid_dbus_interface_bss_use_mac_list(connection,message,user_data);
		 }
		 else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_BSS_MAC_LIST)) {
			 reply = wid_dbus_interface_dbus_show_bss_mac_list(connection,message,user_data);
		 }
		 //
		 else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_ALL_WTP_DEVICE_INFORMATION)) {
			 reply = wid_dbus_interface_show_wtp_device_information(connection,message,user_data);
		 }
		 else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_ALL_WTP_DATA_PKTS_INFORMATION)) {
			 reply = wid_dbus_interface_show_wtp_datapkts_information(connection,message,user_data);
		 }
		 else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_ALL_WTP_STATS_INFORMATION)) {
			 reply = wid_dbus_interface_show_wtp_stats_information(connection,message,user_data);
		 }
		 else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_ALL_WLAN_STATS_INFORMATION)) {
			 reply = wid_dbus_interface_show_wlan_stats_information(connection,message,user_data);
		 }
		 else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_ALL_WLAN_SSID_STATS_INFORMATION)) {
			 reply = wid_dbus_interface_show_wlan_ssid_stats_information(connection,message,user_data);
		 }
		 else if(dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_ALL_WTP_INFORMATION)) {   /*fengwenchao add 20110617*/
			 reply = wid_dbus_interface_show_conjunction_info_of_all_wtp(connection,message,user_data);
		 }
		 else if  (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_INFO_BYWLANID)) {   /*fengwenchao add 20110617*/
		 	reply = wid_dbus_interface_show_info_bywlanid(connection,message,user_data);	
		 }
		else if  (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WD_DBUS_CONF_METHOD_SHOW_INFO_ALLWLAN)) {   /*fengwenchao add 20110617*/
			reply = wid_dbus_interface_show_info_allwlan(connection,message,user_data);	
		}
		  else if  (dbus_message_is_method_call(message,WID_DBUS_INTERFACE, WID_DBUS_CONF_METHOD_SHOW_INFO_BYWTPID)) {    /*fengwenchao add 20110617*/
		  	reply = wid_dbus_interface_show_info_bywtpid(connection,message,user_data);					
		  }
		 else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_ALL_WTP_IFNAME_INFORMATION)) {
			 reply = wid_dbus_interface_show_wtp_ifname_information(connection,message,user_data);
		 }
		 else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_ALL_WTP_WLAN_DATA_PKTS_INFORMATION)) {
			 reply = wid_dbus_interface_show_wtp_wlan_data_pkts_information(connection,message,user_data);
		}
		 else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_ALL_WTP_RADIO_PARA_INFOR_INFORMATION)) {
			 reply = wid_dbus_interface_show_wtp_radio_para_information(connection,message,user_data);
		 }
		 else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_ALL_WTP_ETH_PORT_INFORMATION)) {
			 reply = wid_dbus_interface_show_wtp_eth_port_information(connection,message,user_data);
		 }
		 else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_ALL_WTP_RADIO_STATS_INFORMATION)) {
			 reply = wid_dbus_interface_show_wtp_radio_stats_information(connection,message,user_data);
		}
		  else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_ALL_WTP_RADIO_CONFIG_INFORMATION)) {
			 reply = wid_dbus_interface_show_wtp_radio_config_information(connection,message,user_data);
		}
		   else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_ALL_WTP_NEW_WTPWIRELESS_IF_INFORMATION)) {
			 reply = wid_dbus_interface_show_new_wireless_ifstats_information(connection,message,user_data);
		}
		 else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_ALL_NEW_WTP_WIRELESS_IFSTATS_INFORMATION)) {
			 reply = wid_dbus_interface_show_new_wtp_wireless_ifstats_information(connection,message,user_data);
		 }
		  else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_ALL_ROGUE_WTP_INFORMATION)) {
			 reply = wid_dbus_interface_show_all_rogue_ap_information(connection,message,user_data); 
		 }
		  else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_ALL_WTP_WIRED_STATS_INFORMATION)) {
			 reply = wid_dbus_interface_show_wtp_wired_if_stats_information(connection,message,user_data);
		 }
		   else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_ALL_WTP_WIRELESS_STATS_INFORMATION)) {
			 reply = wid_dbus_interface_show_wtp_wireless_if_stats_information(connection,message,user_data);
		 }  
		   else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_ALL_WTP_ATH_STATISTICS_INFOMATION)) {
			 reply = wid_dbus_interface_show_all_wtp_ath_statistics_information(connection,message,user_data);
		 }
		    else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_STATISTICS_INFOMATION_OF_ALL_WTP_WHOLE)) {
			 reply = wid_dbus_show_statistics_information_of_all_wtp_whole(connection,message,user_data);	/*fengwenchao add 20110329*/
		 }
		 else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_STA_METHOD_SHOW_TERMINAL_INFO_OF_ALL_WTP)) {
			 reply = wid_dbus_show_terminal_info_of_all_wtp(connection,message,user_data);
		 }		   
		/*
		  else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_ALL_WTP_WLAN_DATA_PKTS_INFORMATION)) {
			 reply = wid_dbus_interface_show_wtp_wlan_data_pkts_information(connection,message,user_data);
		 }
		  */
		  else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_HIDE_QUIT_WTP_INFOR_IN_MIB_SHOWING)) {
			reply = wid_dbus_interface_set_hide_quit_wtp_infor_showwing(connection,message,user_data);
		}
		/* zhangshu append 2010-08-21 */
		 else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_HIDE_QUIT_WTP_INFOR_IN_MIB_SHOWING)) {
		 	 reply = wid_dbus_interface_show_wtp_hide_quit(connection,message,user_data);
		 }
		 /* zhangshu append 2010-08-24 */
		 else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_WTP_TRAP_IGNORE_PERCENT)) {
		    reply = set_wtp_trap_ignore_percent(connection,message,user_data);
		 }
		 
		 /*-----------------------------------END----------------------------------------*/
		
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_WATCH_DOG)) {
			reply = wid_dbus_interface_set_wid_watch_dog(connection,message,user_data);
		}else if(dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_DBUS_COUNT)){
			reply = wid_dbus_show_wid_dbus_count(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_DBUS_COUNT)){
			reply = wid_dbus_set_wid_dbus_count(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_AP_ACCESS_THROUGH_NAT)) {
			reply = wid_dbus_interface_set_ap_access_through_nat(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_WTP_LIST_METHOD_SET_DHCP_SNOOPING)) {
			reply = wid_dbus_interface_wtp_list_dhcp_snooping(connection,message,user_data);
		}			
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_WTP_METHOD_SET_DHCP_SNOOPING)) {
			reply = wid_dbus_interface_wtp_dhcp_snooping(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_WTP_LIST_METHOD_STA_INFO_REPORT)) {
			reply = wid_dbus_interface_wtp_list_sta_info_report(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_WTP_METHOD_STA_INFO_REPORT)) {
			reply = wid_dbus_interface_wtp_sta_info_report(connection,message,user_data);
		}		
		else if(dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_WTP_LINK_DETECT)){
			reply = wid_dbus_set_wtp_link_detect(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_WSM_SWITCH)){
			reply = wid_dbus_set_wsm_switch(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_VLAN_SWITCH)){
			reply = wid_dbus_set_vlan_switch(connection,message,user_data);
		}		
		else if(dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_DHCP_OPTION82_SWITCH)){
			reply = wid_dbus_set_dhcp_option82_switch(connection,message,user_data);
		}
       /*	zhaoruijia,20100913,translate set neighbor_same_channelrssithreshold to 1.3*/	

		else if(dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_NEIGHBOR_SAME_CHANNELRSSI_THRESHOLD)){
			reply = wid_dbus_set_neighbor_same_channelrssi_threshold(connection,message,user_data);
		}
	  /*	zhaoruijia,20100913,translate set neighbor_same_channelrssithreshold to 1.3*/	
		 /*zhaoruijia,20100916,add service tftp,start*/
		else if(dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SERVICE_TFTP_SWITCH)){
            
			reply = wid_dbus_service_tftp_state(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_SERVICE_TFTP_SWITCH)){
            reply = wid_dbus_show_service_tftp_state(connection,message,user_data);
		}
	   /*zhaoruijia,20100916,add service tftp,end*/

	   /*zhaoruijia,20100921,add  service ftp,start*/
	   else if(dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SERVICE_FTP_SWITCH)){
            
			reply = wid_dbus_service_ftp_state(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_SERVICE_FTP_SWITCH)){
            reply = wid_dbus_show_service_ftp_state(connection,message,user_data);
		}

	  /*zhaoruijia,20100921,add  service ftp,end*/

		else if(dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WLAN_RADIO_INFORMATION)){
            reply = wid_dbus_interface_show_wlan_radio_information(connection,message,user_data);
		}

		/*zhaoruijia,20101103,for wid wsm error handle control,start*/
		else if(dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_CONFLICT_WTP_LIST)){
            reply = wid_dbus_interface_show_conflict_wtp_list(connection,message,user_data);
		}
        else if(dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_ERROR_HANDLE_STATE)){
             reply = wid_dbus_set_wid_error_handle_state(connection,message,user_data);
			
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_ADD_BLACK_WHITE_OUI_MAC)){
             reply = wid_dbus_add_black_white_oui_mac_to_xml(connection,message,user_data);
        }
		else if(dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_DEL_BLACK_WHITE_OUI_MAC)){
             reply = wid_dbus_del_black_white_oui_mac_from_xml(connection,message,user_data);
        }
        else if(dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_BLACK_WHITE_OUI_INFO)){
             reply = wid_dbus_show_black_white_oui_info_list(connection,message,user_data);
        }
		else if(dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_UPDATE_BLACK_WHITE_OUI_INFO_LIST)){
             reply = wid_dbus_update_black_white_oui_info_list(connection,message,user_data);
        }
		else if(dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_USE_BLACK_WHITE_NONE_OUI_POLICY)){
             reply = wid_dbus_use_black_white_none_oui_policy(connection,message,user_data);
        }
		else if(dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_OUI_POLICY)){
             reply = wid_dbus_show_oui_policy(connection,message,user_data);
        }
		else if(dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_CHECKING)){
			 reply = wid_dbus_checking_wireless(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_QUIT)){
			 reply = wid_dbus_method_quit(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WIDS_JUDGE_POLICY)) {
			reply = wid_dbus_interface_set_wids_judge_policy(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WIDS_JUDGE_POLICY_SHOW)) {
			reply = wid_dbus_interface_show_wids_judge_policy(connection,message,user_data);
		}	
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WIDS_MONITOR_MODE)) {
			reply = wid_dbus_interface_set_wids_monitor_mode(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WIDS_SCANNING_MODE)) {
			reply = wid_dbus_interface_set_wids_mode(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WIDS_SCANNING_CHANNEL)) {
			reply = wid_dbus_interface_set_wids_channel(connection,message,user_data);
		}	
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_WIDS_SCANNING_MODE_CHANNEL_SHOW)) {
			reply = wid_dbus_interface_show_wids_mode_channel(connection,message,user_data);
		}		
		else if(dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_MULTICAST_LISTEN_SETTING)) {
			reply = wid_dbus_interface_multicast_listen(connection,message,user_data);
		}
		/* Huang Leilei 2012-10-24 add */
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_BAK_CHECK_INTERVAL))
		{
			reply = wid_dbus_interface_set_bak_check_interval(connection,message,user_data);
		}
		/* Huang Leilei 2012-10-23 add */
		else if (dbus_message_is_method_call(message,WID_DBUS_INTERFACE,WID_DBUS_CONF_METHOD_BAK_CHECK_INTERVAL_SHOW)) 
		{
			reply = wid_dbus_interface_show_bak_check_interval(connection,message,user_data);
		}	
		/* Huang Leilei 2012-10-25 add */
		else if (dbus_message_is_method_call(message, WID_DBUS_INTERFACE, WID_DBUS_CONF_METHOD_LIC_BAK_REQ_INTERVAL))
		{
			reply = wid_dbus_interface_set_lic_bak_req_interval(connection, message, user_data);
		}
		/* Huang Leilei 2012-10-25 add */
		else if (dbus_message_is_method_call(message, WID_DBUS_INTERFACE, WID_DBUS_CONF_METHOD_LIC_BAK_REQ_INTERVAL_SHOW))
		{
			reply = wid_dbus_interface_show_lic_bak_req_interval(connection, message, user_data);
		}
	}	
	else if	(strcmp(dbus_message_get_path(message),WID_DBUS_WLAN_OBJPATH) == 0) {
//		printf("wid obj path: %s", WID_DBUS_WLAN_OBJPATH);
		
		if (dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_ENABLE)) {
			reply = wid_dbus_interface_wlan_enable(connection,message,user_data);
		}
		 else if (dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_ALL_WLAN_SSID_CONFIG_INFORMATION)) {
			 reply = wid_dbus_show_ssid_config_information_of_all_wlan(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WDS_METHOD_ENABLE)) {
			reply = wid_dbus_interface_wds_enable(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_APPLY_IF)) {
			reply = wid_dbus_interface_wlan_apply_if(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_APPAY_WLAN_IFNAME)) {
			reply = wid_dbus_interface_wlan_apply_ifname(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_APPAY_WLAN_IFNAME_IPV6)) {
			reply = wid_dbus_interface_wlan_apply_ifname_ipv6(connection,message,user_data);
		}
		/*fengwenchao add 20120323*/
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_WLAN_MAX_STA_NEW)){
			reply = wid_dbus_interface_wlan_max_sta_new(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_WLAN_L2_ISOLATION)){
			reply = wid_dbus_interface_wlan_l2_isolation_new(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_WLAN_STA_STATIC_ARP)){
			reply = wid_dbus_interface_wlan_sta_static_arp(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_WLAN_ACCESS_STA_LIMIT_RSSI)){
			reply = wid_dbus_interface_wlan_access_sta_limit_rssi(connection,message,user_data);
		}
		/*fengwenchao add end*/		
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_APPAY_WLAN_MAX_STA)) {
			reply = wid_dbus_interface_wlan_max_sta(connection,message,user_data);
		}  //xm add 08/12/04
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_APPAY_WLAN_BALANCE_PARA)) {
			reply = wid_dbus_interface_wlan_balance_para(connection,message,user_data);
		}  //xm add 08/12/29
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_APPAY_WLAN_FLOW_BALANCE_PARA)) {
			reply = wid_dbus_interface_wlan_flow_balance_para(connection,message,user_data);
		}  //xm add 08/12/29	
		//weichao add 2011.10.28
		else if (dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_FLOW_CHECK)) {
			reply = wid_dbus_interface_wlan_flow_check(connection,message,user_data);
		}
		//weichao add 2011.10.31
		else if (dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_NO_FLOW_TIME)) {
			reply = wid_dbus_interface_wlan_no_flow_time(connection,message,user_data);
		}
		
		//weichao add 2011.10.31
		else if (dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_LIMIT_MIN_FLOW)) {
			reply = wid_dbus_interface_wlan_limit_min_flow(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_APPAY_WLAN_BALANCE_SWITCH)) {
			reply = wid_dbus_interface_wlan_balance_switch(connection,message,user_data);
		}  //xm add 09/02/05
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DEBUS_WLAN_METHOD_SET_EAP_MAC)) {
			reply = wid_dbus_interface_wlan_set_eap_mac(connection,message,user_data);
		}  //zhangshu add, 2010-10-22
        
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_DELETE_IF)) {
			reply = wid_dbus_interface_wlan_delete_ifname(connection,message,user_data);
		}		
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_HIDE_ESSID)) {
		 reply = wid_dbus_interface_wlan_hide_essid(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_L3IF_POLICY)) {
		 reply = wid_dbus_interface_wlan_l3if_policy(connection,message,user_data);
		}//ifname = wlan2
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_L3IF_POLICY2)) {
		 reply = wid_dbus_interface_wlan_l3if_policy2(connection,message,user_data);
		}//ifname = radio3-1.7
		//wlan for br area
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_L3IF_POLICY_BR)) {
		 reply = wid_dbus_interface_wlan_l3if_policy_br(connection,message,user_data);
		}//ifname = wlan2
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_L3IF_POLICY2_BR)) {
		 reply = wid_dbus_interface_wlan_l3if_policy2_br(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_FORMARD_MODE)) {
		 reply = wid_dbus_interface_wlan_forward_mode(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_TUNNEL_MODE)) {
		 reply = wid_dbus_interface_wlan_tunnel_mode(connection,message,user_data);
		}

		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_SET_NAS_IDENTIFIER)) {
			reply = wid_dbus_interface_set_nas_id(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_REMOVE_NAS_IDENTIFIER)) {
			reply = wid_dbus_interface_remove_nas_id(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_ROAMING_POLICY)) {
			reply = wid_dbus_interface_set_roaming_policy(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_SET_WLAN_VLANID)) {
			reply = wid_dbus_interface_set_wlan_vlanid(connection,message,user_data);
		}
		//mahz add 2011.5.25
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_SET_NAS_PORT_ID)) {
			reply = wid_dbus_interface_set_nas_port_id(connection,message,user_data);
		}//
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_SET_WLAN_HOTSPOTID)) {
			reply = wid_dbus_interface_set_wlan_hotspotid(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_CLEAN_WLAN_HOTSPOTID)) {
			reply = wid_dbus_interface_clean_wlan_hotspotid(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_SET_WLAN_VLAN_PRIORITY)) {
			reply = wid_dbus_interface_set_wlan_vlan_priority(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_UNDO_WLAN_VLANID)) {
			reply = wid_dbus_interface_undo_wlan_vlanid(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_SHOW_WLAN_VLAN_INFO)) {
			reply = wid_dbus_interface_show_wlan_vlan_info(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_SET_BRIDGE_ISOLATION)) {
			reply = wid_dbus_interface_set_wlan_br_isolation(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_SET_BRIDGE_MULTICAST_ISOLATION)) {
			reply = wid_dbus_interface_set_wlan_br_multicast_isolation(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_SHOW_BRIDGE_ISOLATION)) {
			reply = wid_dbus_interface_show_wlan_br_isolation_info(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_SET_TUNNEL_WLAN_VLAN)) {
			reply = wid_dbus_interface_set_tunnel_wlan_vlan(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_SHOW_TUNNEL_WLAN_VLAN)) {
			reply = wid_dbus_interface_show_tunnel_wlan_vlan(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_SET_BRIDGE_SAMEPORTSWICTH)) {
			reply = wid_dbus_interface_set_wlan_br_sameportswitch(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_SET_ESSID)) {
			reply = wid_dbus_interface_set_wlan_essid(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_SET_ASCII_ESSID)) {
			reply = wid_dbus_interface_set_wlan_ascii_essid(connection,message,user_data);     //fengwenchao add 20110307
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_STA_IP_MAC_BINDING)) {
			reply = wid_dbus_interface_wlan_sta_ip_mac_binding(connection,message,user_data);
		}		
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_SERVICE_CONTROL_TIMER)) {
			reply = wid_dbus_interface_wlan_service_control_timer(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_TIMER_ABLE)) {
			reply = wid_dbus_interface_wlan_timer_able(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_SHOW_WLAN_PTK_INFO)) {
			reply = wid_dbus_interface_show_wlan_pkt_infomation(connection,message,user_data);
		}
		/*nl add 20100318*/
		else if (dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_WHOLE_WLAN_TRAFFIC_LIMIT_VALUE)) {
			reply = wid_dbus_interface_set_whole_wlan_traffic_limit_value(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_WHOLE_WLAN_SEND_TRAFFIC_LIMIT_VALUE)) {
			reply = wid_dbus_interface_set_whole_wlan_send_traffic_limit_value(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_WHOLE_WLAN_STA_AVERAGE_TRAFFIC_LIMIT_VALUE)) {
			reply = wid_dbus_interface_set_whole_wlan_station_average_traffic_limit_value(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_WHOLE_WLAN_STA_AVERAGE_SEND_TRAFFIC_LIMIT_VALUE)) {
			reply = wid_dbus_interface_set_whole_wlan_station_average_send_traffic_limit_value(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_CONF_METHOD_WLAN_NO_RESPONSE_TO_STA_PROBLE_REQUEST)) {
			reply = wid_dbus_interface_set_wlan_no_response_to_sta_proble_request(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_CONF_METHOD_WLAN_UNI_MUTI_BR_CAST_ISOLATION_SW_AND_RATE_SET)) {
			reply = wid_dbus_interface_set_wlan_uni_muti_bro_cast_isolation_sw_and_rate_set(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_CONF_METHOD_WLAN_MUTI_BR_CAST_RATE_SET)) {
			reply = wid_dbus_interface_set_wlan_muti_bro_cast_rate_set(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_WHOLE_WLAN_BSS_MULTI_USER_OPTIMIZE_SWITCH)) {
			reply = wid_dbus_interface_set_whole_wlan_bss_multi_user_optimize_switch(connection,message,user_data);
		}else if (dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_TUNNEL_NODE_SETTING)) {
			reply = wid_dbus_set_wlan_tunnel_mode_state(connection,message,user_data);
		}else if (dbus_message_is_method_call(message,WID_DBUS_WLAN_INTERFACE,WID_DBUS_WLAN_METHOD_TUNNEL_NODE_SETTING_AND_ADD_TO_EBR)) {
			reply = wid_dbus_set_wlan_tunnel_mode_state_add_to_ebr(connection,message,user_data);
		}
	}
	else if	(strcmp(dbus_message_get_path(message),WID_DBUS_WTP_OBJPATH) == 0) {
//		printf("wid obj path: %s", WID_DBUS_WTP_OBJPATH);
	  if(dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_IFNAME)) {
		reply = wid_dbus_interface_wtp_apply_ifname(connection,message,user_data);
	  }
	  else  if(dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_IFNAME_IPV6)) {
		reply = wid_dbus_interface_wtp_apply_ifname_ipv6(connection,message,user_data);
	  }
	  else if(dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_WLANID)) {
		//printf("******wid_dbus_interface_wtp_apply_wlanid start************\n");
		reply = wid_dbus_interface_wtp_apply_wlanid(connection,message,user_data);
		//printf("******wid_dbus_interface_wtp_apply_wlanid end************\n");
	  }	 	
	  else if(dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_MAX_STA)) {
	
		reply = wid_dbus_interface_wtp_max_sta(connection,message,user_data);

	 }
	  else if(dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_INTERFACE_CHECK_WTP_STA)) {
	
		reply = wid_dbus_interface_check_wtp_sta(connection,message,user_data);

	 }
	 else if(dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_INTERFACE_ETH_MTU)){
			reply = wid_dbus_interface_set_ap_if_eth_mtu(connection,message,user_data);                 //fengwenchao add 20110126 for XJDEX-32 from 2.0
	}
	 else if(dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_CHECK_WLANID)) {
	
		reply = wid_dbus_interface_wtp_check_wlanid(connection,message,user_data);

	 }
	 else if(dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_TRIGER)) {
		  
		reply = wid_dbus_interface_wtp_triger(connection,message,user_data);
		  
	 }
	 else if(dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_APPAY_WTP_FLOW_TRIGER)) {
			  
		reply = wid_dbus_interface_wtp_flow_triger(connection,message,user_data);
			  
	}


	  else if(dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_WTP_USED)) {
	  		//intf("******* wid_dbus_interface_wtp_used start  *****\n");
			reply = wid_dbus_interface_wtp_used(connection,message,user_data);
			//intf("******* wid_dbus_interface_wtp_used end  *****\n");
		}
	  else if(dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_DELETE_WLAN_ID)) {
		reply = wid_dbus_interface_wtp_delete_wlanid(connection,message,user_data);
	  }		
	  else if(dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_DISABLE_WLAN_ID)) {
		reply = wid_dbus_interface_wtp_disable_wlanid(connection,message,user_data);
	  }	
	  
	  else if(dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_ENABLE_WLAN_ID)) {
		reply = wid_dbus_interface_wtp_enable_wlanid(connection,message,user_data);
	  }	
	  else if(dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_VERSION_PATH)) {
		reply = wid_dbus_interface_wtp_set_ap_version_path(connection,message,user_data);
	  }	
	 /* else if(dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_UPDATE_PATH)) {
		reply = wid_dbus_interface_wtp_set_ap_update_path(connection,message,user_data);
	  }*/		
	  /*mahz add for ap upgrade automatically*/
	  else if(dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_BIND_MODEL_WITH_FILE)) {
		reply = wid_dbus_interface_wtp_bind_model_with_file(connection,message,user_data);
	  }		
	  else if(dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_AP_UPDATE_BASE_MODEL)) {
		reply = wid_dbus_interface_wtp_set_ap_update_base_model(connection,message,user_data);
	  }		
	  else if(dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SHOW_MODEL_BIND_INFO)) {
		reply = wid_dbus_interface_show_model_bind_info(connection,message,user_data);
	  } 	
	  else if(dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_DELETE_MODEL_BIND_INFO)) {
		reply = wid_dbus_interface_delete_model_bind_info(connection,message,user_data);
	  } 	
	  else if(dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_CLEAR_ONE_MODEL_UPDATE_CONFIG)) {
		reply = wid_dbus_interface_wtp_clear_ap_one_model_update_path(connection,message,user_data);
	  }			  
	  else if(dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SHOW_DETAIL_MODEL_BIND_INFO)) {
		reply = wid_dbus_interface_show_model_detail_bind_info(connection,message,user_data);
	  } 	
	  else if(dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_UPDATE_CONFIG)) {
		reply = wid_dbus_interface_wtp_show_ap_update_path(connection,message,user_data);
	  }	
	  else if(dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_CLEAR_UPDATE_CONFIG)) {
		reply = wid_dbus_interface_wtp_clear_ap_update_path(connection,message,user_data);
	  }			  
	  else if(dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_AP_UPDATE_COUNT_ONETIME)) {
		reply = wid_dbus_interface_wtp_set_ap_update_count_onetime(connection,message,user_data);
	  } 		  
	  else if(dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_AP_UPDATE_CONTROL)) {
		reply = wid_dbus_interface_wtp_set_ap_update_control(connection,message,user_data);
	  } 		  
	  else if(dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SHOW_AP_UPGRADE_RESULT_INFO)) {
		reply = wid_dbus_interface_wtp_show_ap_upgrade_result(connection,message,user_data);
	  } 		  
	  else if(dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_DELETE_AP_MODEL)) {
		reply = wid_dbus_interface_wtp_delete_ap_model(connection,message,user_data);
	  }	
	  else if(dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_AP_TIMER)) {
		reply = wid_dbus_interface_wtp_set_ap_echotimer(connection,message,user_data);
	  }	
	  else if(dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_AP_CHECKTIMER)) {
		reply = wid_dbus_interface_wtp_set_ap_checktimer(connection,message,user_data);
	  }	
	  else if(dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_AP_COLLECT_TIME)) {
		reply = wid_dbus_interface_wtp_set_ap_collect_time(connection,message,user_data);
	  }	
	
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_AP_MAX_THROUGHOUT)) {
			reply = wid_dbus_interface_set_ap_max_throughout(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_AP_EXTENSION_COMMAND)) {
			reply = wid_dbus_interface_set_ap_extension_command(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_AP_LONGITUDE_LATITUDE_COMMAND)) {
			reply = wid_dbus_interface_set_ap_longitude_latitude_command(connection, message, user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_AP_OPTION60_PARAMETER)) {
			reply = wid_dbus_interface_set_ap_option60_parameter(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_TCPDUMP_AP_EXTENSION_COMMAND)) {
           
			reply = wid_dbus_tcpdump_command(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_AP_IP_GATEWAY)) {
			reply = wid_dbus_interface_set_ap_ip_gateway(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_AP_IP_GATEWAY_DNS)) {
			reply = wid_dbus_interface_set_ap_ip_gateway_dns(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WID_WTP_RUNTIME)) {
			reply = wid_dbus_interface_show_wtp_runtime(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_WTP_LOCATION)) {
			reply = wid_dbus_interface_set_wtp_location(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WID_WTP_LOCATION)) {
			reply = wid_dbus_interface_show_wtp_location(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_AP_CHANNEL_DISTURB_TRAP)) {
			reply = wid_dbus_interface_wtp_channel_disturb_trap(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SET_WID_WTP_NETID)) {
			reply = wid_dbus_interface_set_wtp_netid(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WID_WTP_NETID)) {
			reply = wid_dbus_interface_show_wtp_netid(connection,message,user_data);
		}
		//else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_AP_SHOW_WTP_EXTENSION_INFOMATION)) {
		//	reply = wid_dbus_interface_show_wtp_extension_infomation(connection,message,user_data);
		//}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WID_WTP_SAMPLE_THROUGHPUT_INFO)) {
			reply = wid_dbus_interface_show_wtp_sample_throughput_infomation(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTPNAME)) {
			reply = wid_dbus_interface_set_wtpname(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WID_WTP_WLAN_VLAN_INFO)) {
			reply = wid_dbus_interface_show_wtp_wlan_vlan_infomation(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_EXTENSION_INFOMATION_SWITCH)) {
			reply = wid_dbus_interface_set_wtp_extension_infomation_enable(connection,message,user_data);
		}
		/*fengwenchao add for GM-3, 20111130*/
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_METHOD_SET_AP_HEART_STATISTICS_SWITCH)){
			reply = wid_dbus_interface_set_ap_heart_statistics_switch(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_METHOD_SET_AP_HEART_STATISTICS_COLLECT_TIME)){
			reply = wid_dbus_interface_set_ap_heart_statistics_collect_time(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_USERNAME_PASSWORD)){
			reply = wid_dbus_interface_set_ap_username_password(connection,message,user_data);	
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_STA_DEAUTH_MESSAGE_REPORT_SWITCH)) {
			reply = wid_dbus_interface_set_sta_deauth_message_report_enable(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_STA_ALL_FLOW_INFORMATION_REPORT_SWITCH)) {
			reply = wid_dbus_interface_set_sta_all_flow_information_report_enable(connection,message,user_data);
		}
		/*fengwenchao add end*/
		/**************for sample value by nl*************/
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_MOMENT_INFOMATION_SWITCH)) {
			reply = wid_dbus_interface_set_wtp_moment_infomation_enable(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_MOMENT_INFOMATION_REPORTINTERVAL)) {
			reply = wid_dbus_interface_set_wtp_moment_infomation_interval(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_SAMPLE_INFOMATION_REPORTINTERVAL)) {
			reply = wid_dbus_interface_set_wtp_sample_infomation_interval(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SHOW_WTP_ROUTINE_INFOMATION_REPORTINTERVAL)) {
			reply = wid_dbus_interface_set_wtp_routine_infomation_interval(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SHOW_WTP_MOMENT_INFOMATION_REPORTINTERVAL)) {
			reply = wid_dbus_interface_show_wtp_moment_infomation(connection,message,user_data);
		}
		/***************for sample value  end *******************/
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_EXTENSION_INFOMATION_REPORTINTERVAL)) {
			reply = wid_dbus_interface_set_wtp_extension_infomation_interval(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_UNAUTHORIZED_MAC_REPORTINTERVAL)) {
			reply = wid_dbus_interface_set_wtp_unauthorized_mac_interval(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_UNAUTHORIZED_MAC_REPORT_SWITCH)) {
			reply = wid_dbus_interface_set_wtp_unauthorized_mac_switch(connection, message, user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WBS_CPE_SWITCH)) {
			reply = wid_dbus_interface_set_wtp_wbs_cpe_switch(connection, message, user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_CONFIGURE_ERR_REPORTINTERVAL)) {
			reply = wid_dbus_interface_set_wtp_configure_error_interval(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_CONFIGURE_ERR_REPORTSWITCH)) {
			reply = wid_dbus_interface_set_wtp_configure_error_switch(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_ONLINE_STA_FULL_REPORTEINTERVAL)) {
			reply = wid_dbus_interface_set_wtp_online_sta_full_interval(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_ONLINE_STA_FULL_REPORTE_SWITCH)) {
			reply = wid_dbus_interface_set_wtp_online_sta_full_switch(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_STA_FLOW_RX_TX_OVERLFOW_THRESHOLD)) {
			reply = wid_dbus_interface_set_wtp_sta_flow_rx_tx_overflow_threshold(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_STA_FLOW_RX_TX_OVERLFOW_REPORTINTERVAL)) {
			reply = wid_dbus_interface_set_wtp_sta_flow_rx_tx_overflow_interval(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_STA_FLOW_RX_TX_OVERLFOW_REPORT_SWITCH)) {
			reply = wid_dbus_interface_set_wtp_sta_flow_rx_tx_overflow_switch(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_STA_FLOW_RX_TX_OVERLFOW_TRAP_SWITCH)) {
			reply = wid_dbus_interface_set_wtp_sta_flow_rx_tx_trap_switch(connection,message,user_data);
		}
		#if 0
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_STA_FLOW_TX_OVERLFOW_REPORTINTERVAL)) {
			reply = wid_dbus_interface_set_wtp_sta_flow_tx_overflow_interval(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_STA_FLOW_TX_OVERLFOW_REPORT_SWITCH)) {
			reply = wid_dbus_interface_set_wtp_sta_flow_tx_overflow_switch(connection,message,user_data);
		}
		#endif
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_STA_INFOMATION_SWITCH)) {
			reply = wid_dbus_interface_set_wtp_sta_infomation_enable(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_STA_INFOMATION_REPORTINTERVAL)) {
			reply = wid_dbus_interface_set_wtp_sta_infomation_interval(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_STA_WAPI_INFO_SWITCH)) {
			reply = wid_dbus_interface_set_wtp_sta_wapi_info_enable(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_STA_WAPI_INFO_REPORTINTERVAL)) {
			reply = wid_dbus_interface_set_wtp_sta_wapi_info_interval(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_IF_INFO_SWITCH)) {
			reply = wid_dbus_interface_set_wtp_if_info_report_enable(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_IF_INFO_REPORTINTERVAL)) {
			reply = wid_dbus_interface_set_wtp_if_info_report_interval(connection,message,user_data);
		}
		//else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_AP_SHOW_WTP_EXTENSION_INFOMATION_V2)) {
		//	reply = wid_dbus_interface_show_wtp_extension_infomation_v2(connection,message,user_data);
		//}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_AP_SHOW_WTP_EXTENSION_INFOMATION_V3)) {
			reply = wid_dbus_interface_show_wtp_extension_infomation_v3(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_AP_SHOW_WTP_EXTENSION_INFOMATION_V4)) {
			reply = wid_dbus_interface_show_wtp_extension_infomation_v4(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_WID_WTP_ETH_IF_INFO)) {
			reply = wid_dbus_interface_show_wtp_eth_if_infomation(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SET_AP_L2_ISOLATION_ABLE)) {
			reply = wid_dbus_interface_set_ap_l2_siolation(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SET_AP_PREVENT_DOS_ATTACK)) {
			reply = wid_dbus_interface_set_ap_dos_def(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SET_AP_IGMP_SNOOPING)) {
			reply = wid_dbus_interface_set_ap_igmp_snoop(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_AP_MIB_INFO)) {
			reply = wid_dbus_interface_show_ap_mib_info(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_SHOW_AP_CM_STATISTICS)) {
			reply = wid_dbus_interface_show_ap_cm_statistics(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_INTERFACE_UPDOWN)) {
			reply = wid_dbus_interface_set_ap_if_updown(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_INTERFACE_ETH_RATE)) {
			reply = wid_dbus_interface_set_ap_if_eth_rate(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SHOW_WTP_IF_INFO)) {
			reply = wid_dbus_interface_show_ap_if_info(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_GET_WTP_BSS_PKT_INFO)) {
			reply = wid_dbus_interface_get_wtp_bss_pkt_info(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SHOW_WTP_BSS_PKT_INFO)) {
			reply = wid_dbus_interface_show_wtp_bss_pkt_info(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SHOW_WTP_RADIO_PKT_INFO)) {
			reply = wid_dbus_interface_show_wtp_radio_pkt_info(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SHOW_WTP_RADIO_PKT_INFO_TUNNEL)) {
			reply = wid_dbus_interface_show_wtp_radio_pkt_info_tunnel(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SHOW_WTP_ETH_PKT_INFO)) {
			reply = wid_dbus_interface_show_wtp_eth_pkt_info(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SHOW_WTP_WIFI_SNR_INFO)) {
			reply = wid_dbus_interface_show_wtp_wifi_snr_info(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_NTPCLIENT)) {
			reply = wid_dbus_interface_set_wtp_ntp(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_UPDATE_WTP_CONFIG)) {
			reply = wid_dbus_interface_update_ap_config(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_AP_SHOW_WTP_MAX_POWER)) {
			reply = wid_dbus_interface_show_ap_max_txpower(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_REBOOT)) {
			reply = wid_dbus_interface_set_ap_reboot(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_REBOOT_ALL)) {
			reply = wid_dbus_interface_set_ap_reboot_all(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_REBOOT_BY_WLANID)) {
			reply = wid_dbus_interface_set_ap_reboot_by_wlanid(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_REBOOT_BY_INTERFACE)) {
			reply = wid_dbus_interface_set_ap_reboot_by_interface(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_REBOOT_BY_MODEL)) {
			reply = wid_dbus_interface_set_ap_reboot_by_model(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_REBOOT_BY_LIST)) {
			reply = wid_dbus_interface_set_ap_reboot_by_list(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTPSN)) {
			reply = wid_dbus_interface_set_wtpsn(connection,message,user_data);
		}
		/* zhangshu add ,2010-10-08 */
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_TERMINAL_DISTRUB_INFOMATION_SWITCH)) {
			reply = wid_dbus_interface_set_wtp_terminal_disturb_info_switch(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_TERMINAL_DISTRUB_INFOMATION_PKT)) {
			reply = wid_dbus_interface_set_wtp_terminal_disturb_info_pkt(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_SET_WTP_TERMINAL_DISTRUB_INFOMATION_STA_NUM)) {
			reply = wid_dbus_interface_set_wtp_terminal_disturb_info_sta_num(connection,message,user_data);
		}
		/* --zhangshu add END--,2010-10-08 */
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_NO_RESPONSE_TO_STA_PROBLE_REQUEST)) {
			reply = wid_dbus_interface_set_wtp_no_response_to_sta_proble_request(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_UNI_MUTI_BR_CAST_ISOLATION_SW_AND_RATE_SET)) {
			reply = wid_dbus_interface_set_wtp_uni_muti_bro_cast_isolation_sw_and_rate_set(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_CONF_METHOD_MUTI_BR_CAST_RATE_SET)) {
			reply = wid_dbus_interface_set_wtp_muti_bro_cast_rate_set(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_WTP_INTERFACE,WID_DBUS_WTP_METHOD_5G_SWITH)) 
		{
			reply = wid_dbus_interface_wtp_5g_switch(connection,message,user_data);
		}
	}
	else if	(strcmp(dbus_message_get_path(message),WID_DBUS_RADIO_OBJPATH) == 0) {
//		printf("wid obj path: %s", WID_DBUS_RADIO_OBJPATH);

		if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_TXP)) {
			reply = wid_dbus_interface_radio_set_txp(connection,message,user_data);
		}
		if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_TXPOF)) {
			reply = wid_dbus_interface_radio_set_txpof(connection,message,user_data);
		}
		
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_CHAN)) {
			reply = wid_dbus_interface_radio_set_chan(connection,message,user_data);
		}
		
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_APPLY_WLAN)) {
			reply = wid_dbus_interface_radio_apply_wlan(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_DELETE_WLAN)) {
			reply = wid_dbus_interface_radio_delete_wlan(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_APPLY_WLAN_BASE_ESSID)) {
			reply = wid_dbus_interface_radio_apply_wlan_base_essid(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_DELETE_WLAN_BASE_ESSID)) {
			reply = wid_dbus_interface_radio_delete_wlan_base_essid(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_ENABLE_WLAN)) {
			reply = wid_dbus_interface_radio_enable_wlan(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_DISABLE_WLAN)) {
			reply = wid_dbus_interface_radio_disable_wlan(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_REVOVER_DEFAULT_CONFIG)) {
			reply = wid_dbus_interface_radio_recover_default_config(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_MAX_THROUGHOUT)) {
			reply = wid_dbus_interface_radio_set_max_throughout(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_WDS_WLAN_SET)) {
			reply = wid_dbus_radio_wlan_wds_mac_op(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SHOW_WDS_BSSID_INFO)) {
			reply = wid_dbus_interface_show_wds_bssid_list(connection,message,user_data);
		}
		
		//added by weiay 20080714
		//else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_RATE)) {
		//	reply = wid_dbus_interface_radio_set_rate(connection,message,user_data);
		//}
		/////
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_SUPPORT_RATELIST)) {
			reply = wid_dbus_interface_radio_set_support_ratelist(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_MAX_RATE)) {
			reply = wid_dbus_interface_radio_set_max_rate(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUG_RADIO_METHOD_SET_11N_RATE_PARAS)) {
			reply = wid_dbus_interface_radio_set_11n_rate_paras(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_BSS_L3_POLICY)) {
			reply = wid_dbus_interface_radio_set_bss_l3_policy(connection,message,user_data);
		}
		//else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_BSS_L3_IF_WLAN_BR)) {
		//	reply = wid_dbus_interface_radio_set_bss_l3_policy_br(connection,message,user_data);
		//}
		/////
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_MODE)) {
			reply = wid_dbus_interface_radio_set_mode(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_BEACON)) 
		{
			reply = wid_dbus_interface_radio_set_beacon(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_FRAGMENTATION)) 
		{
			reply = wid_dbus_interface_radio_set_fragmentation(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_DTIM)) 
		{
			reply = wid_dbus_interface_radio_set_dtim(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_RTSTHROLD)) 
		{
			reply = wid_dbus_interface_radio_set_rtsthreshold(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_GUARD_INTERVAL)) 
		{
			reply = wid_dbus_interface_radio_set_guardinterval(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_ACKTIMEOUT_DISTANCE)) 
		{
			reply = wid_dbus_interface_radio_set_acktimeout_distance(connection,message,user_data);
		}/*wcl add for RDIR-33*/
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_AMPDU_ABLE)) 
		{
			reply = wid_dbus_interface_radio_set_ampdu_able(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_AMPDU_LIMIT)) 
		{
			reply = wid_dbus_interface_radio_set_ampdu_limit(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_AMPDU_SUBFRAME)) 
		{
			reply = wid_dbus_interface_radio_set_ampdu_subframe(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_MIXED_PURE_N)) 
		{
			reply = wid_dbus_interface_radio_set_mixed_puren_switch(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_CHANNEL_OFFSET)) {
			reply = wid_dbus_interface_radio_set_channel_offset(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_MCS)) 
		{
			reply = wid_dbus_interface_radio_set_mcs(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_CMMODE)) 
		{
			reply = wid_dbus_interface_radio_set_cmmode(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_SECTOR_SET_CMD)) {
			reply = wid_dbus_interface_set_radio_sector_value(connection,message,user_data);
		}	
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_TX_CHAINMASK_SET_CMD)) {
			reply = wid_dbus_interface_set_radio_tx_chainmask_value(connection,message,user_data);
		}
		#if 0
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_TX_CHAINMASK_SET_CMD_V2)) {
			reply = wid_dbus_interface_set_radio_tx_chainmask_value_v2(connection,message,user_data);
		}
		#endif
	    else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_TX_CHAINMASK_SET_CMD_V2)) {
			reply = wid_dbus_interface_set_radio_chainmask_value(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_SECTOR_POWER_SET_CMD)) {
			reply = wid_dbus_interface_set_radio_tx_power_sector_value(connection,message,user_data);
		}	
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_NETGEAR_G_SET_CMD)) {
			reply = wid_dbus_interface_set_radio_supper_g_type_state(connection,message,user_data);
		}	
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_STATUS)) 
		{
			reply = wid_dbus_interface_radio_set_status(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_WDS_STATUS)) 
		{
			reply = wid_dbus_interface_radio_set_wds_status(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_PREAMBLE)) 
		{
			reply = wid_dbus_interface_radio_set_preamble(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_SHORTRETRY)) 
		{
			reply = wid_dbus_interface_radio_set_shortretry(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_LONGRETRY)) 
		{
			reply = wid_dbus_interface_radio_set_longretry(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_BSS_MAX_STA)) 
		{
			reply = wid_dbus_interface_radio_set_bss_max_sta(connection,message,user_data);
		}//xm add 08/12/04
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_APPLY_QOS)) 
		{
			reply = wid_dbus_interface_radio_apply_qos(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_DELETE_QOS)) 
		{
			reply = wid_dbus_interface_radio_delete_qos(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_BSS_MAX_THROUGHPUT)) 
		{
			reply = wid_dbus_interface_radio_set_bss_max_throughput(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SHOW_BSS_MAX_THROUGHPUT)) 
		{
			reply = wid_dbus_interface_radio_show_bss_max_throughput(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SHOW_CHANNEL_CHANGE)) 
		{
			reply = wid_dbus_interface_radio_show_channel_change_info(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_RADIO_APPLY_WLANID_BASE_VLANID)) 
		{
			reply = wid_dbus_interface_radio_apply_wlanid_base_vlanid(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_RADIO_CPE_CHANNEL_APPLY_WLANID_BASE_VLANID)) 
		{
			reply = wid_dbus_interface_radio_cpe_channel_apply_wlanid_base_vlanid(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_RADIO_CPE_CHANNEL_APPLY_WLANID_CLEAN_VLANID)) 
		{
			reply = wid_dbus_interface_radio_cpe_channel_apply_wlanid_clean_vlanid(connection,message,user_data);
		}
		//mahz add 2011.5.30
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_RADIO_APPLY_WLANID_BASE_NAS_PORT_ID)) 
		{
			reply = wid_dbus_interface_radio_apply_wlanid_base_nas_port_id(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_RADIO_APPLY_WLANID_CLEAN_NAS_PORT_ID)) 
		{
			reply = wid_dbus_interface_radio_apply_wlanid_clean_nas_port_id(connection,message,user_data);
		}//
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_RADIO_APPLY_WLANID_CLEAN_VLANID)) 
		{
			reply = wid_dbus_interface_radio_apply_wlanid_clean_vlanid(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_RADIO_APPLY_WLANID_BASE_HOTSPOT_ID)) 
		{
			reply = wid_dbus_interface_radio_apply_wlanid_base_hotspotid(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_RADIO_APPLY_WLANID_CLEAN_HOTSPOT_ID)) 
		{
			reply = wid_dbus_interface_radio_apply_wlanid_clean_hotspotid(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_RADIO_CHECK_RADIO_MEMBER))
		{
			reply = wid_dbus_interface_check_radio_member(connection,message,user_data);
		}	
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_RADIO_RX_DATA_DEAD_TIME)) 
		{
			reply = wid_dbus_interface_radio_receive_data_dead_time(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_RADIO_RX_DATA_DEAD_TIME_SHOW)) 
		{
			reply = wid_dbus_interface_radio_receive_data_dead_time_show(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SHOW_BSS_LIST)) 
		{
			reply = wid_dbus_interface_radio_show_bss_list(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_RADIO_L2_ISOLATION_ABLE)) 
		{
			reply = wid_dbus_interface_set_radio_l2_siolation(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_11N_SET_RADIO_CWMMODE)) 
		{
			reply = wid_dbus_interface_set_radio_11n_cwmmode(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_WTP_RADIO_AUTO_CHANNEL)) {
			reply = wid_dbus_interface_set_radio_auto_channel_able(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_WTP_RADIO_AUTO_CHANNEL_CONT)) {
			reply = wid_dbus_interface_set_radio_auto_channel_cont_able(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_WTP_RADIO_DIVERSITY)) {
			reply = wid_dbus_interface_set_radio_diversity_able(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_WTP_RADIO_TXANTENNA)) {
			reply = wid_dbus_interface_set_radio_txantenna_able(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_TRAFFIC_LIMIT_ABLE)) {
			reply = wid_dbus_interface_set_radio_wlan_traffic_limit_able(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_TRAFFIC_LIMIT_VALUE)) {
			reply = wid_dbus_interface_set_radio_wlan_traffic_limit_value(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_TRAFFIC_LIMIT_AVERAGE_VALUE)) {
			reply = wid_dbus_interface_set_radio_wlan_traffic_limit_average_value(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_TRAFFIC_LIMIT_CANCEL_AVERAGE_VALUE)){//fengwenchao add 20130416 for AXSSZFI-1374
			reply = wid_dbus_interface_set_radio_wlan_traffic_limit_cancel_average_value(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_TRAFFIC_LIMIT_CANCEL_AVERAGE_SEND_VALUE)){//fengwenchao add 20130416 for AXSSZFI-1374
			reply = wid_dbus_interface_set_radio_wlan_traffic_limit_cancel_average_send_value(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_TRAFFIC_LIMIT_STA_VALUE)) {
			reply = wid_dbus_interface_set_radio_wlan_traffic_limit_sta_value(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_TRAFFIC_LIMIT_CANCEL_STA_VALUE)) {
			reply = wid_dbus_interface_set_radio_wlan_traffic_limit_cancel_sta_value(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_TRAFFIC_LIMIT_SEND_VALUE)) {
			reply = wid_dbus_interface_set_radio_wlan_traffic_limit_send_value(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_TRAFFIC_LIMIT_AVERAGE_SEND_VALUE)) {
			reply = wid_dbus_interface_set_radio_wlan_traffic_limit_average_send_value(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_TRAFFIC_LIMIT_STA_SEND_VALUE)) {
			reply = wid_dbus_interface_set_radio_wlan_traffic_limit_sta_send_value(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_TRAFFIC_LIMIT_CANCEL_STA_SEND_VALUE)) {
			reply = wid_dbus_interface_set_radio_wlan_traffic_limit_cancel_sta_send_value(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_SET_STA_VLANID)) {
			reply = wid_dbus_interface_set_radio_wlan_sta_vlanid(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_SET_STA_DHCP_BEFORE_AUTHERIZED)) {
			reply = wid_dbus_interface_set_radio_wlan_sta_dhcp_before_autherized(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_WLAN_SET_STA_IP_MAC_BINDING)) {
			reply = wid_dbus_interface_set_radio_wlan_sta_ip_mac_binding(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_WDS_DISTANCE)) 
		{
			reply = wid_dbus_interface_radio_set_wds_distance(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_WDS_REMOTE_BRMAC)) 
		{
			reply = wid_dbus_interface_radio_set_wds_remote_brmac(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_WDS_WEP_KEY)) 
		{
			reply = wid_dbus_interface_radio_set_wds_wep_key(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_WDS_ENCRYPTION_TYPE)) 
		{
			reply = wid_dbus_interface_radio_set_wds_encryption_type(connection,message,user_data);
		}	
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_WDS_AES_KEY)) 
		{
			reply = wid_dbus_interface_radio_set_wds_aes_key(connection,message,user_data);
		}	
		//nl add 20100120
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_INTER_VAP_FORVARDING_ABLE)) {
			reply = wid_dbus_interface_set_radio_inter_vap_forwarding_able(connection,message,user_data);
		}	

		//nl add 20100120
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_INTRA_VAP_FORVARDING_ABLE)) {
			reply = wid_dbus_interface_set_radio_intra_vap_forwarding_able(connection,message,user_data);
		}	
		//nl add 20100128
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_KEEP_ALIVE_PERIOD)) {
			reply = wid_dbus_interface_set_radio_keep_alive_period_value(connection,message,user_data);
		}	
		//nl add 20100129
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_KEEP_ALIVE_IDLE_TIME)) {
			reply = wid_dbus_interface_set_radio_keep_alive_idle_time_value(connection,message,user_data);
		}	
		//nl add 20100130
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_CONGESTION_AVOID_STATE)) {
			reply = wid_dbus_interface_set_radio_congestion_avoid_state(connection,message,user_data);
		}	
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_WLAN_WTP_LIST_METHOD_STA_STATIC_ARP)) 
		{
			reply = wid_dbus_interface_wlan_wtp_list_sta_static_arp(connection,message,user_data);
		}	
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_WLAN_WTP_METHOD_STA_STATIC_ARP)) 
		{
			reply = wid_dbus_interface_wlan_wtp_sta_static_arp(connection,message,user_data);
		}	
       //zhaoruijia,20100917,add radio txpower step
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_TXPOWER_STEP)) 
		{
			reply = wid_dbus_interface_radio_set_txpower_step(connection,message,user_data);
		}
		//fengwenchao add 20120222 for RDIR-25
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SET_RADIO_WLAN_LIMIT_RSSI_ACCESS_STA))
		{
			reply = wid_dbus_interface_radio_set_radio_wlan_limit_rssi_access_sta(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_SERVICE_CONTROL_TIMER)) {
			reply = wid_dbus_interface_radio_service_control_timer(connection,message,user_data);
		}
		else if(dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_TIMER_ABLE)) {
			reply = wid_dbus_interface_radio_timer_able(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_MOLTI_USER_OPTIMIZE_SWITH)) 
		{
			reply = wid_dbus_interface_radio_multi_user_optimize_switch(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_WSM_STA_INFO_REPORTSWITCH))
		{
			reply = wid_dbus_interface_set_wsm_sta_info_reportswitch(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_RADIO_INTERFACE,WID_DBUS_RADIO_METHOD_WSM_STA_INFO_REPORTINTERVAL))
	  	{
	  		reply = wid_dbus_interface_set_wsm_sta_info_reportinterval(connection,message,user_data);
	  	}
	}
	else if	(strcmp(dbus_message_get_path(message),WID_DBUS_QOS_OBJPATH) == 0) {

		if (dbus_message_is_method_call(message,WID_DBUS_QOS_INTERFACE,WID_DBUS_QOS_METHOD_ADD_DEL_QOS)) {
			reply = wid_dbus_interface_qos_add_del_qos(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_QOS_INTERFACE,WID_DBUS_CONF_METHOD_DELETE_RADIO_WITH_QOS_PROFILE)) {  //fengwenchao add 20110427
			reply = wid_dbus_interface_delete_radio_with_qos_profile(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_QOS_INTERFACE,WID_DBUS_QOS_METHOD_SHOW_QOS)) {
			reply = wid_dbus_interface_qos_show_qos(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_QOS_INTERFACE,WID_DBUS_QOS_METHOD_SHOW_RADIO_QOS_INFO)) {
			reply = wid_dbus_interface_show_radio_apply_qos(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_QOS_INTERFACE,WID_DBUS_QOS_METHOD_CONFIG_QOS)) {
			reply = wid_dbus_interface_qos(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_QOS_INTERFACE,WID_DBUS_QOS_METHOD_SET_QOS_INFO)) {
			reply = wid_dbus_interface_qos_set_qos_info(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_QOS_INTERFACE,WID_DBUS_QOS_METHOD_SET_QOS_INFO_CLIENT)) {
			reply = wid_dbus_interface_qos_set_qos_info_client(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_QOS_INTERFACE,WID_DBUS_QOS_METHOD_SET_QOS_MAP)) {
			reply = wid_dbus_interface_qos_set_qos_map(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_QOS_INTERFACE,WID_DBUS_QOS_METHOD_SET_QOS_WMM_MAP_DOT1P)) {
			reply = wid_dbus_interface_qos_set_qos_wmm_map_dot1p(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_QOS_INTERFACE,WID_DBUS_QOS_METHOD_SET_QOS_DOT1P_MAP_WMM)) {
			reply = wid_dbus_interface_qos_set_qos_dot1p_map_wmm(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_QOS_INTERFACE,WID_DBUS_QOS_METHOD_SHOW_QOS_LIST)) {
			reply = wid_dbus_interface_show_qos_list(connection,message,user_data);
		}
		//set wireless qos info for mib
		else if (dbus_message_is_method_call(message,WID_DBUS_QOS_INTERFACE,WID_DBUS_QOS_METHOD_SHOW_QOS_EXTENSION_INFO)) {
			reply = wid_dbus_interface_qos_show_qos_extension_info(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_QOS_INTERFACE,WID_DBUS_QOS_METHOD_SET_QOS_TOTAL_BANDWIDTH)) {
			reply = wid_dbus_interface_set_qos_total_bandwidth(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_QOS_INTERFACE,WID_DBUS_QOS_METHOD_SET_QOS_FLOW_PARAMETER)) {
			reply = wid_dbus_interface_set_qos_flow_parameter_value(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_QOS_INTERFACE,WID_DBUS_QOS_METHOD_SET_QOS_FLOW_PARAMETER_V2)) {
			reply = wid_dbus_interface_set_qos_flow_parameter_value_v2(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_QOS_INTERFACE,WID_DBUS_QOS_METHOD_SET_QOS_FLOW_ABLE)) {
			reply = wid_dbus_interface_set_qos_flow_able_value(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_QOS_INTERFACE,WID_DBUS_QOS_METHOD_SET_QOS_FLOW_ABLE_V2)) {
			reply = wid_dbus_interface_set_qos_flow_able_value_v2(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_QOS_INTERFACE,WID_DBUS_QOS_METHOD_SET_QOS_PARAMETER)) {
			reply = wid_dbus_interface_set_qos_parameter_value(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_QOS_INTERFACE,WID_DBUS_QOS_METHOD_SET_QOS_POLICY)) {
			reply = wid_dbus_interface_set_qos_policy_used(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_QOS_INTERFACE,WID_DBUS_QOS_METHOD_SET_QOS_POLICY_NAME)) {
			reply = wid_dbus_interface_set_qos_policy_name(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_QOS_INTERFACE,WID_DBUS_QOS_METHOD_SET_QOS_MANAGE_ARITHMETIC_NAME)) {
			reply = wid_dbus_interface_set_qos_manage_arithmetic_name(connection,message,user_data);
		}
	}
	else if	(strcmp(dbus_message_get_path(message),WID_DBUS_EBR_OBJPATH) == 0) {

		if (dbus_message_is_method_call(message,WID_DBUS_EBR_INTERFACE,WID_DBUS_EBR_METHOD_ADD_DEL_EBR)) {
			reply = wid_dbus_interface_ebr_add_del_ebr(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_EBR_INTERFACE,WID_DBUS_EBR_METHOD_SHOW_EBR)) {
			reply = wid_dbus_interface_ebr_show_ebr(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_EBR_INTERFACE,WID_DBUS_EBR_METHOD_CONFIG_EBR)) {
			reply = wid_dbus_interface_ebr(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_EBR_INTERFACE,WID_DBUS_EBR_METHOD_SHOW_EBR_LIST)) {
			reply = wid_dbus_interface_show_ebr_list(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_EBR_INTERFACE,WID_DBUS_EBR_METHOD_CONFIG_EBR_ENABLE)) {
			reply = wid_dbus_interface_set_ebr_enable(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_EBR_INTERFACE,WID_DBUS_EBR_METHOD_SET_BRIDGE_ISOLATION)) {
			reply = wid_dbus_interface_set_ebr_isolation(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_EBR_INTERFACE,WID_DBUS_EBR_METHOD_SET_BRIDGE_MULTICAST_ISOLATION)) {
			reply = wid_dbus_interface_set_ebr_multicast_isolation(connection,message,user_data);
		}






		/* Huang Leilei add, 2012-11-12 9:55 */
		else if (dbus_message_is_method_call(message, WID_DBUS_EBR_INTERFACE, WID_DBUS_EBR_METHOD_SET_BRIDGE_UCAST_SOLICT))
		{
			reply = wid_dbus_interface_set_wlan_ebr_br_ucast_solicit(connection, message, user_data);
		}
		else if (dbus_message_is_method_call(message, WID_DBUS_EBR_INTERFACE, WID_DBUS_EBR_METHOD_SET_BRIDGE_MCAST_SOLICT))
		{
			reply = wid_dbus_interface_set_wlan_ebr_br_mcast_solicit(connection, message, user_data);
		}









		
		else if (dbus_message_is_method_call(message,WID_DBUS_EBR_INTERFACE,WID_DBUS_EBR_METHOD_SET_EBR_ADD_DEL_IF)) {
			reply = wid_dbus_interface_set_ebr_add_del_if(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_EBR_INTERFACE,WID_DBUS_EBR_METHOD_SET_EBR_ADD_DEL_UPLINK)) {
			reply = wid_dbus_interface_set_ebr_add_del_uplink(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_EBR_INTERFACE,WID_DBUS_EBR_METHOD_SHOW_FDB_SUMMARY_DETAIL)) {
			reply = wid_dbus_interface_show_fdb_summary_detail(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_EBR_INTERFACE,WID_DBUS_EBR_METHOD_SET_BRIDGE_SAMEPORTSWITCH)) {
			reply = wid_dbus_interface_set_ebr_sameportswitch(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_EBR_INTERFACE,WID_DBUS_EBR_METHOD_EBR_INTERFACE_EBR)) {
			reply = wid_dbus_interface_ebr_check_interface(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_EBR_INTERFACE,WID_DBUS_EBR_METHOD_SET_MULTICAST_FDB_LEARN)) {
			reply = wid_dbus_interface_set_ebr_multicast_fdb_learn(connection,message,user_data);
		}
	}
	else if(strcmp(dbus_message_get_path(message),WID_BAK_OBJPATH) == 0){
		printf("WID_BAK_OBJPATH\n");
		if (dbus_message_is_method_call(message,WID_BAK_INTERFACE,WID_DBUS_WTP_METHOD_MASTER_BAK_SET)) {
			reply = wid_dbus_set_ac_as_secondary(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_BAK_INTERFACE,WID_DBUS_CONF_METHOD_LOCAL_HASNI_STATE_CHANGE)) {
			reply = wid_dbus_set_local_hansi_state(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_BAK_INTERFACE,WID_DBUS_AC_METHOD_UPDATE_BAK_INFO)) {
			reply = wid_dbus_update_bak_ac_info(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_BAK_INTERFACE,WID_DBUS_AC_METHOD_SYNCHRONIZE_INFO)) {
			reply = wid_dbus_synchronize_wsm_info(connection,message,user_data);
		}	
		else if (dbus_message_is_method_call(message,WID_BAK_INTERFACE,WID_DBUS_AC_METHOD_ASD_SYNCHRONIZE_INFO)) {
			reply = wid_dbus_synchronize_asd_info(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_BAK_INTERFACE,WID_DBUS_AC_METHOD_NOTICE_INFO)) {
			reply = wid_dbus_notice_vrrp(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_BAK_INTERFACE,WID_DBUS_AC_METHOD_VRRP_INFO)) {
			reply = wid_dbus_vrrp_info(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_BAK_INTERFACE,WID_DBUS_AC_METHOD_VRRP_SOCK_INFO)) {
			reply = wid_dbus_interface_show_vrrp_sock_list(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_BAK_INTERFACE,WID_DBUS_AC_METHOD_SET_INTERFACE_VMAC)) {
			reply = wid_dbus_set_wireless_interface_vmac(connection,message,user_data);
		}		
	}
	else if(strcmp(dbus_message_get_path(message),WID_DBUS_ACIPLIST_OBJPATH) == 0){
		printf("WID_DBUS_ACIPLIST_OBJPATH\n");
		if (dbus_message_is_method_call(message,WID_DBUS_ACIPLIST_INTERFACE,WID_DBUS_ACIPLIST_METHOD_ADD_AC_IP_LIST_GROUP)) {
			reply = wid_dbus_add_ac_ip_list_group(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_ACIPLIST_INTERFACE,WID_DBUS_ACIPLIST_METHOD_DEL_AC_IP_LIST_GROUP)) {
			reply = wid_dbus_del_ac_ip_list_group(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_ACIPLIST_INTERFACE,WID_DBUS_ACIPLIST_METHOD_ADD_AC_IP)) {
			reply = wid_dbus_add_ac_ip(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_ACIPLIST_INTERFACE,WID_DBUS_ACIPLIST_METHOD_DEL_AC_IP)) {
			reply = wid_dbus_del_ac_ip(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_ACIPLIST_INTERFACE,WID_DBUS_ACIPLIST_METHOD_SET_AC_IP_PRIORITY)) {
			reply = wid_dbus_set_ac_ip_priority(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_ACIPLIST_INTERFACE,WID_DBUS_ACIPLIST_METHOD_SET_AC_IP_BANLANCE_FLAG)) {
			reply = wid_dbus_set_ac_ip_load_banlance(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_ACIPLIST_INTERFACE,WID_DBUS_ACIPLIST_METHOD_SET_AC_IP_DIFF_BANLANCE)) {
			reply = wid_dbus_set_ac_ip_diff_banlance(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_ACIPLIST_INTERFACE,WID_DBUS_ACIPLIST_METHOD_SET_AC_IP_THRESHOLD)) {
			reply = wid_dbus_set_ac_ip_threshold(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_ACIPLIST_INTERFACE,WID_DBUS_ACIPLIST_METHOD_CONFIG)) {
			reply = wid_dbus_ac_ip_list_group_config(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_ACIPLIST_INTERFACE,WID_DBUS_ACIPLIST_METHOD_SHOW_AC_IP_LIST_ONE)) {
			reply = wid_dbus_interface_show_ac_ip_list_one(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_ACIPLIST_INTERFACE,WID_DBUS_ACIPLIST_METHOD_SHOW_AC_IP_LIST)) {
			reply = wid_dbus_interface_show_ac_ip_list(connection,message,user_data);
		}		
		else if (dbus_message_is_method_call(message,WID_DBUS_ACIPLIST_INTERFACE,WID_DBUS_ACIPLIST_METHOD_SHOW_RUNNING_CONFIG)) {
			reply = wid_dbus_ac_ip_list_show_running_config(connection,message,user_data);
		}		
	}
	else if(strcmp(dbus_message_get_path(message),WID_DBUS_AP_GROUP_OBJPATH) == 0){
		if (dbus_message_is_method_call(message,WID_DBUS_AP_GROUP_INTERFACE,WID_DBUS_AP_GROUP_METHOD_CREATE)) {
			reply = wid_dbus_add_ap_group(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_AP_GROUP_INTERFACE,WID_DBUS_AP_GROUP_METHOD_DEL)) {
			reply = wid_dbus_del_ap_group(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_AP_GROUP_INTERFACE,WID_DBUS_AP_GROUP_METHOD_SHOW_ALL)) {
			reply = wid_dbus_show_ap_group_all(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_AP_GROUP_INTERFACE,WID_DBUS_AP_GROUP_METHOD_SHOW_ALL_AP_GROUP_MEMBERS)){
			reply = wid_dbus_show_ap_group_members_all(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_AP_GROUP_INTERFACE,WID_DBUS_AP_GROUP_METHOD_ADD_DEL_MEMBER)) {
			reply = wid_dbus_add_del_ap_group_member(connection,message,user_data);
		}	
		else if (dbus_message_is_method_call(message,WID_DBUS_AP_GROUP_INTERFACE,WID_DBUS_AP_GROUP_METHOD_SHOW_MEMBER)) {
			reply = wid_dbus_show_ap_group_member(connection,message,user_data);
		}
		else if (dbus_message_is_method_call(message,WID_DBUS_AP_GROUP_INTERFACE,WID_DBUS_AP_GROUP_METHOD_CONFIG)) {
			reply = wid_dbus_ap_group_config(connection,message,user_data);
		}		

	}	
	if (reply) {
		wid_syslog_debug_debug(WID_DBUS,"reply destination %s\n",dbus_message_get_destination(reply));
		memset(sender,0, 20);
		strcpy(sender,dbus_message_get_destination(reply));
		dbus_connection_send (connection, reply, NULL);
		dbus_connection_flush(connection); // TODO    Maybe we should let main loop process the flush
		dbus_message_unref (reply);
		if(dbus_count_switch)
			wid_static_dbus_op(sender);
	}

//	dbus_message_unref(message); //TODO who should unref the incoming message? 
	return DBUS_HANDLER_RESULT_HANDLED ;
}


/** Message handler for Signals
 *  or normally there should be no signals except dbus-daemon related.
 *
 *  @param  connection          D-BUS connection
 *  @param  message             Message
 *  @param  user_data           User data
 *  @return                     What to do with the message
 */
DBusHandlerResult
wid_dbus_filter_function (DBusConnection * connection,
					   DBusMessage * message, void *user_data)
{
//	printf("entering filter.\n");
	if (dbus_message_is_signal (message, DBUS_INTERFACE_LOCAL, "Disconnected") &&
		   strcmp (dbus_message_get_path (message), DBUS_PATH_LOCAL) == 0) {

		/* this is a local message; e.g. from libdbus in this process */

		wid_syslog_err("Got disconnected from the system message bus; "
				"retrying to reconnect every 3000 ms\n");
		//dbus_connection_close (wid_dbus_connection);
		wid_dbus_connection = NULL;
		CWThread thread_dbus; 
		if(!CWErr(CWCreateThread(&thread_dbus, wid_dbus_thread_restart, NULL,0))) {
			wid_syslog_crit("Error starting Dbus Thread");
			exit(1);
		}

		//g_timeout_add (3000, reinit_dbus, NULL);

	} else if (dbus_message_is_signal (message,
			      DBUS_INTERFACE_DBUS,
			      "NameOwnerChanged")) {

		//if (services_with_locks != NULL)  service_deleted (message);
	} else
		return TRUE;
		//return hald_dbus_filter_handle_methods (connection, message, user_data, FALSE);

	return DBUS_HANDLER_RESULT_HANDLED;
}

int wid_dbus_reinit(void)
{	
	int i = 0;
	DBusError dbus_error;
	dbus_threads_init_default();
	
	DBusObjectPathVTable	wid_vtable = {NULL, &wid_dbus_message_handler, NULL, NULL, NULL, NULL};	

//	printf("npd dbus init\n");

	dbus_connection_set_change_sigpipe (TRUE);

	dbus_error_init (&dbus_error);
	wid_dbus_connection = dbus_bus_get_private (DBUS_BUS_SYSTEM, &dbus_error);
	if (wid_dbus_connection == NULL) {
		wid_syslog_err("dbus_bus_get(): %s\n", dbus_error.message);
		return FALSE;
	}

	// Use npd to handle subsection of NPD_DBUS_OBJPATH including slots
	if (!dbus_connection_register_fallback (wid_dbus_connection, WID_DBUS_OBJPATH, &wid_vtable, NULL)) {
		wid_syslog_err("can't register D-BUS handlers (fallback NPD). cannot continue.\n");
		return FALSE;
		
	}
	
	
	i = dbus_bus_request_name (wid_dbus_connection, WID_DBUS_BUSNAME,
			       0, &dbus_error);
	i = dbus_bus_request_name (wid_dbus_connection2, "aw.widtrap",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[0], "aw.widtrap0",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[1], "aw.widtrap1",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[2], "aw.widtrap2",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[3], "aw.widtrap3",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[4], "aw.widtrap4",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[5], "aw.widtrap5",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[6], "aw.widtrap6",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[7], "aw.widtrap7",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[8], "aw.widtrap8",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[9], "aw.widtrap9",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[10], "aw.widtrap10",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[11], "aw.widtrap11",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[12], "aw.widtrap12",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[13], "aw.widtrap13",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[14], "aw.widtrap14",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[15], "aw.widtrap15",
			       0, &dbus_error);
	
	wid_syslog_debug_debug(WID_DBUS,"dbus_bus_request_name:%d",i);
	
	if (dbus_error_is_set (&dbus_error)) {
		wid_syslog_debug_debug(WID_DBUS,"dbus_bus_request_name(): %s",
			    dbus_error.message);
		return FALSE;
	}

	dbus_connection_add_filter (wid_dbus_connection, wid_dbus_filter_function, NULL, NULL);

	dbus_bus_add_match (wid_dbus_connection,
			    "type='signal'"
					    ",interface='"DBUS_INTERFACE_DBUS"'"
					    ",sender='"DBUS_SERVICE_DBUS"'"
					    ",member='NameOwnerChanged'",
			    NULL);
	
//	printf("init finished\n");
	return TRUE;
  
}

int wid_dbus_init(void)
{	
	int i = 0;
	DBusError dbus_error;
	dbus_threads_init_default();
	
	DBusObjectPathVTable	wid_vtable = {NULL, &wid_dbus_message_handler, NULL, NULL, NULL, NULL};	

//	printf("npd dbus init\n");

	dbus_connection_set_change_sigpipe (TRUE);

	dbus_error_init (&dbus_error);
	wid_dbus_connection = dbus_bus_get_private (DBUS_BUS_SYSTEM, &dbus_error);
	wid_dbus_connection2 = dbus_bus_get_private (DBUS_BUS_SYSTEM, &dbus_error);
	for(i = 0; i < THREAD_NUM; i++){
		wid_dbus_connection_t[i] = dbus_bus_get_private (DBUS_BUS_SYSTEM, &dbus_error); 
		if (wid_dbus_connection_t[i] == NULL) {
			wid_syslog_err("dbus_bus_get(): %s\n", dbus_error.message);
			return FALSE;
		}
	}
	if (wid_dbus_connection == NULL) {
		wid_syslog_err("dbus_bus_get(): %s\n", dbus_error.message);
		return FALSE;
	}

	// Use npd to handle subsection of NPD_DBUS_OBJPATH including slots
	if (!dbus_connection_register_fallback (wid_dbus_connection, WID_DBUS_OBJPATH, &wid_vtable, NULL)) {
		wid_syslog_err("can't register D-BUS handlers (fallback NPD). cannot continue.\n");
		return FALSE;
		
	}
	
	
	i = dbus_bus_request_name (wid_dbus_connection, WID_DBUS_BUSNAME,
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection2, "aw.widtrap",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[0], "aw.widtrap0",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[1], "aw.widtrap1",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[2], "aw.widtrap2",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[3], "aw.widtrap3",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[4], "aw.widtrap4",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[5], "aw.widtrap5",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[6], "aw.widtrap6",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[7], "aw.widtrap7",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[8], "aw.widtrap8",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[9], "aw.widtrap9",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[10], "aw.widtrap10",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[11], "aw.widtrap11",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[12], "aw.widtrap12",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[13], "aw.widtrap13",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[14], "aw.widtrap14",
			       0, &dbus_error);
	
	i = dbus_bus_request_name (wid_dbus_connection_t[15], "aw.widtrap15",
			       0, &dbus_error);
	
	wid_syslog_debug_debug(WID_DBUS,"dbus_bus_request_name:%d",i);
	
	if (dbus_error_is_set (&dbus_error)) {
		wid_syslog_debug_debug(WID_DBUS,"dbus_bus_request_name(): %s",
			    dbus_error.message);
		return FALSE;
	}

	dbus_connection_add_filter (wid_dbus_connection, wid_dbus_filter_function, NULL, NULL);

	dbus_bus_add_match (wid_dbus_connection,
			    "type='signal'"
					    ",interface='"DBUS_INTERFACE_DBUS"'"
					    ",sender='"DBUS_SERVICE_DBUS"'"
					    ",member='NameOwnerChanged'",
			    NULL);
	
//	printf("init finished\n");
	return TRUE;
  
}
//when channel of a radio changed,send this trap
int wid_dbus_trap_wtp_channel_change(unsigned char chan_past,unsigned char chan_curr,unsigned int radioid)
{
	DBusMessage *query;	
	DBusError err;
	unsigned wtpindex = radioid/4;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_wtp_channel_change tid %d\n",TID);
	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}	
    
	/* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_CHANNEL_CHANGE);
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&radioid,
						DBUS_TYPE_BYTE,&chan_past,
						DBUS_TYPE_BYTE,&chan_curr,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send (wid_dbus_connection_t[TID],query,NULL);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;
}
//when a wtp enter imagedata state,send this trap
int wid_dbus_trap_wtp_enter_imagedata_state(int wtpindex)
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_wtp_enter_imagedata_state tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}
	/* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_ENTER_IMAGEDATA_STATE);
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,	 
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;
}
//when a wtp enter imagedata state,send this trap
int wid_dbus_trap_wtp_tranfer_file(int wtpindex)
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_wtp_tranfer_file tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}

	/* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_TRANFER_FILE);
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;
}

//fengwenchao add 20110216 ap update successful
int wid_dbus_trap_wtp_update_successful(int wtpindex)
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_wtp_update_successful tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}

	/* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_UPDATE_SUCCESSFUL);
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;	
}
//fengwenchao add end

//fengwenchao add 20110216 ap update fail
int wid_dbus_trap_wtp_update_fail(int wtpindex)
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_wtp_update_fail tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}

	/* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_UPDATE_FAIL);
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;	
}
//fengwenchao add end

//when a wlan encryption type changed,send this trap
int wid_dbus_trap_wlan_encryption_type_change(int Wlanid)
{
	DBusMessage *query;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;
	if(AC_WLAN[Wlanid] == NULL) return 0;
	//search to find wtpindex and sn
	int i = 0;
	int j = 0;
	int num = 0;
	unsigned int *wtpid;	
	wtpid = (unsigned int *)WID_MALLOC(WTP_NUM*(sizeof(unsigned int)));
	memset(wtpid,0,WTP_NUM);
	for (i=0;i<WTP_NUM;i++)
	{
		if (AC_WTP[i] != NULL)
		{
			if(AC_WTP[i]->WTP_Radio[0]->isBinddingWlan == 1)
			{
				
				struct wlanid *wlan_id = AC_WTP[i]->WTP_Radio[0]->Wlan_Id;
				while(wlan_id != NULL)
				{	
					if(wlan_id->wlanid == Wlanid)
					{
						wtpid[j] = i;
						
						j++;
						num = j;
						break;
					}
					wlan_id = wlan_id->next;
				}
				if(wlan_id == NULL)
				{
					continue;
				}
			
			}
		}
	}
	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);	

	unsigned char securityid = AC_WLAN[Wlanid]->SecurityID; /*ht change char to unsigned char*/
	unsigned int encryptionType = AC_WLAN[Wlanid]->EncryptionType;

	unsigned int vrrp_id = vrrid;  //zhangshu add for vrrid,2010-10-19
	unsigned int local_id = local; //fengwenchao add 20111111
	//printf("num %d\n",num);
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WLAN_ENCRYPTION_TYPE_CHANGE);
	
	dbus_error_init(&err);

	dbus_message_iter_init_append (query, &iter);

	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&Wlanid);

	dbus_message_iter_append_basic (&iter,DBUS_TYPE_BYTE,&securityid);

	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&encryptionType);

	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&num);
	
    dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&vrrp_id); //zhangshu add for vrrid,2010-10-19

	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&local_id);  //fengwenchao add 20111111

	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_STRING_AS_STRING //zhangshu add for netid
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for (i = 0; i < num; i++) 
	{
	    /* zhangshu add for netid & vrrpid, 2010-10-19 */
        char *netid = NULL;
        
    	if((AC_WTP[i] != NULL)&&(AC_WTP[i]->netid != NULL))
    	{
    	    netid = (char *)WID_MALLOC(strlen(AC_WTP[i]->netid)+1);
    	    memset(netid,0,(strlen(AC_WTP[i]->netid)+1));
    		memcpy(netid,AC_WTP[i]->netid,strlen(AC_WTP[i]->netid));
    	}
    	else
    	{
    	    netid = (char *)WID_MALLOC(sizeof(char)*12);
    	    memset(netid,0,12);
    		memcpy(netid,"defaultcode",11);
    	}
    	/* zhangshu add end */
    	
		DBusMessageIter iter_struct;
			
		dbus_message_iter_open_container (&iter_array,
									DBUS_TYPE_STRUCT,
									NULL,
									&iter_struct);
	
	
		dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_UINT32,
									  &(wtpid[i]));

		memset(sn,0,NAS_IDENTIFIER_NAME);
		memcpy(sn,AC_WTP[(wtpid[i])]->WTPSN,strlen(AC_WTP[(wtpid[i])]->WTPSN));

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&sn);

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&netid);

		dbus_message_iter_close_container (&iter_array, &iter_struct);
		
        CW_FREE_OBJECT_WID(netid);
	}					

	dbus_message_iter_close_container (&iter, &iter_array);	

	dbus_connection_send(wid_dbus_connection2,query,NULL);

	
	dbus_message_unref(query);
	WID_FREE(wtpid);
	CW_FREE_OBJECT_WID(sn);
	return 0;
	
}
//when a wlan preshared key changed,send this trap
int wid_dbus_trap_wlan_preshared_key_change(int Wlanid,char *key)
{
	DBusMessage *query;	
	DBusMessageIter	 iter;
	DBusMessageIter	 iter_array;
	DBusError err;
	if(AC_WLAN[Wlanid] == NULL) return 0;
	//search to find wtpindex and sn
	int i = 0;
	int j = 0;
	int num = 0;
	unsigned int *wtpid;	
	wtpid = (unsigned int *)WID_MALLOC(WTP_NUM*(sizeof(unsigned int)));
	memset(wtpid,0,WTP_NUM);
	for (i=0;i<WTP_NUM;i++)
	{
		if (AC_WTP[i] != NULL)
		{
			if(AC_WTP[i]->WTP_Radio[0]->isBinddingWlan == 1)
			{
				
				struct wlanid *wlan_id = AC_WTP[i]->WTP_Radio[0]->Wlan_Id;
				while(wlan_id != NULL)
				{	
					if(wlan_id->wlanid == Wlanid)
					{
						wtpid[j] = i;
						
						j++;
						num = j;
						break;
					}
					wlan_id = wlan_id->next;
				}
				if(wlan_id == NULL)
				{
					continue;
				}
			
			}
		}
	}
	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);	

	unsigned char securityid = AC_WLAN[Wlanid]->SecurityID; /*ht change char to unsigned char*/

	unsigned int vrrp_id = vrrid;  //zhangshu add for vrrid,2010-10-19
	unsigned int local_id = local; //fengwenchao add 20111111
	//printf("num %d\n",num);
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WLAN_PRESHARED_KEY_CHANGE);
	
	dbus_error_init(&err);
	
	dbus_message_iter_init_append (query, &iter);

	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&Wlanid);

	dbus_message_iter_append_basic (&iter,DBUS_TYPE_BYTE,&securityid);

	dbus_message_iter_append_basic (&iter,DBUS_TYPE_STRING,&key);

	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&num);

	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&vrrp_id);

	dbus_message_iter_append_basic (&iter,DBUS_TYPE_UINT32,&local_id);	//fengwenchao add 20111111

	dbus_message_iter_open_container (&iter,
									DBUS_TYPE_ARRAY,
									DBUS_STRUCT_BEGIN_CHAR_AS_STRING
											DBUS_TYPE_UINT32_AS_STRING
											DBUS_TYPE_STRING_AS_STRING
											DBUS_TYPE_STRING_AS_STRING //zhangshu add for netid
									DBUS_STRUCT_END_CHAR_AS_STRING,
									&iter_array);

	for (i = 0; i < num; i++) 
	{
	    /* zhangshu add for netid & vrrpid, 2010-10-19 */
        char *netid = NULL;
        
    	if((AC_WTP[i] != NULL)&&(AC_WTP[i]->netid != NULL))
    	{
    	    netid = (char *)WID_MALLOC(strlen(AC_WTP[i]->netid)+1);
    	    memset(netid,0,(strlen(AC_WTP[i]->netid)+1));
    		memcpy(netid,AC_WTP[i]->netid,strlen(AC_WTP[i]->netid));
    	}
    	else
    	{
    	    netid = (char *)WID_MALLOC(sizeof(char)*12);
    	    memset(netid,0,12);
    		memcpy(netid,"defaultcode",11);
    	}
    	/* zhangshu add end */
    	
		DBusMessageIter iter_struct;
			
		dbus_message_iter_open_container (&iter_array,
									DBUS_TYPE_STRUCT,
									NULL,
									&iter_struct);
	
	
		dbus_message_iter_append_basic(&iter_struct,
									  DBUS_TYPE_UINT32,
									  &(wtpid[i]));
		
		
		memset(sn,0,NAS_IDENTIFIER_NAME);
		memcpy(sn,AC_WTP[(wtpid[i])]->WTPSN,strlen(AC_WTP[(wtpid[i])]->WTPSN));
		
		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&sn);

		dbus_message_iter_append_basic(&iter_struct,DBUS_TYPE_STRING,&netid);//zhangshu add for netid, 2010-10-19
		
		dbus_message_iter_close_container (&iter_array, &iter_struct);
		
        CW_FREE_OBJECT_WID(netid);
	}					

	dbus_message_iter_close_container (&iter, &iter_array);	

	dbus_connection_send(wid_dbus_connection2,query,NULL);
	
	dbus_message_unref(query);
	WID_FREE(wtpid);
	CW_FREE_OBJECT_WID(sn);
	return 0;
}



int wid_dbus_trap_wtp_code_start(int wtpindex)
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_wtp_code_start tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}
    /* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_CODE_START);
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,	 
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;

}

int wid_dbus_trap_wtp_electrify_register_circle(int wtpindex, int registertimer)
{
	DBusMessage *query;	
	DBusError err;
	
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_wtp_electrify_register_circle tid %d\n",TID);
	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}

	/* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_ELECTRIFY_REGISTER_CIRCLE);
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_UINT32,&registertimer,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;

}

int wid_dbus_trap_sta_online_full(int wtpindex, unsigned int sta_max_support_by_ap) {
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_configure_error tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	if (!mac) {
		wid_syslog_err("malloc for wtp mac failed\n");
		return 1;
	}
	memset(mac,0,MAC_LEN+1);

	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}


	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	if (!sn) {
		wid_syslog_err("malloc for wtp sn failed\n");
		WID_FREE(mac);
		return 1;
	}
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}

    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
		if (!netid) {
			wid_syslog_err("malloc for wtp netid failed1\n");
			WID_FREE(mac);
			WID_FREE(sn);
			return 1;
		}
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
		if (!netid) {
			wid_syslog_err("malloc for wtp netid failed2\n");
			WID_FREE(mac);
			WID_FREE(sn);
			return 1;
		}
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;

	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_STA_ONLINE_FULL);
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid,
						DBUS_TYPE_UINT32,&vrrp_id,
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_UINT32,&sta_max_support_by_ap,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;	
}

/*
 *is_rx_tx:1 rx trap ; 0 tx trap
 *
 */
int wid_dbus_trap_sta_overflow(int wtpindex, unsigned char *sta_mac, unsigned char is_rx_tx, unsigned long sta_flow) {
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_configure_error tid %d\n",TID);

	if (!sta_mac) {
		wid_syslog_err("sta_mac is null\n");
		return 1;
	}
	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	if (!mac) {
		wid_syslog_err("malloc for wtp mac failed\n");
		return 1;
	}
	memset(mac,0,MAC_LEN+1);

	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}


	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	if (!sn) {
		wid_syslog_err("malloc for wtp sn failed\n");
		WID_FREE(mac);
		return 1;
	}
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}

    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
		if (!netid) {
			wid_syslog_err("malloc for wtp netid failed1\n");
			WID_FREE(mac);
			WID_FREE(sn);
			return 1;
		}
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
		if (!netid) {
			wid_syslog_err("malloc for wtp netid failed2\n");
			WID_FREE(mac);
			WID_FREE(sn);
			return 1;
		}
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;

	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_STA_FLOW_RX_TX_OVERFLOW);

	dbus_error_init(&err);

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid,
						DBUS_TYPE_UINT32,&vrrp_id,
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_BYTE,&sta_mac[0],
						DBUS_TYPE_BYTE,&sta_mac[1],
						DBUS_TYPE_BYTE,&sta_mac[2],
						DBUS_TYPE_BYTE,&sta_mac[3],
						DBUS_TYPE_BYTE,&sta_mac[4],
						DBUS_TYPE_BYTE,&sta_mac[5],
						DBUS_TYPE_BYTE,&is_rx_tx,
						DBUS_TYPE_UINT64,&sta_flow,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;	
}

int wid_dbus_trap_configure_error(int wtpindex, unsigned char err_code) {
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_configure_error tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	if (!mac) {
		wid_syslog_err("malloc for wtp mac failed\n");
		return 1;
	}
	memset(mac,0,MAC_LEN+1);

	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}


	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	if (!sn) {
		wid_syslog_err("malloc for wtp sn failed\n");
		WID_FREE(mac);
		return 1;
	}
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}

    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
		if (!netid) {
			wid_syslog_err("malloc for wtp netid failed1\n");
			WID_FREE(mac);
			WID_FREE(sn);
			return 1;
		}
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
		if (!netid) {
			wid_syslog_err("malloc for wtp netid failed2\n");
			WID_FREE(mac);
			WID_FREE(sn);
			return 1;
		}
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;

	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_CONFIGURE_ERROR);
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid,
						DBUS_TYPE_UINT32,&vrrp_id,
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_BYTE,&err_code,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;

}

int wid_dbus_trap_sta_unauthorized_mac(int wtpindex, int mac_count, unsigned char *mac_str)
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_sta_unauthorized_mac tid %d\n",TID);

	unsigned char *temp_macs;
	//unsigned char *temp_offset;
	int i, j;

	if (mac_count <= 0) {
		wid_syslog_err("mac count is 0, no need send trap for wtp %d\n", wtpindex);
	}
	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	if (!mac) {
		wid_syslog_err("malloc for wtp mac failed\n");
		return 1;
	}
	memset(mac,0,MAC_LEN+1);

	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}
	
	temp_macs = WID_MALLOC(mac_count*18);//for mac and ,and :
	if (!temp_macs) {
		wid_syslog_err("malloc for sta macs failed\n");
		WID_FREE(mac);
		return 1;
	}
	memset(temp_macs, '\0', mac_count*18);

	for (i=0; i<mac_count; i++) {
		for (j=0; j<6; j++) {
			if (j<5) {
				sprintf((char *)temp_macs+(i*3*6+j*3), "%02X:", (unsigned char)(*(mac_str+i*6+j)));
			} else {
				sprintf((char *)temp_macs+(i*3*6+j*3), "%02X", (unsigned char)(*(mac_str+i*6+j)));
			}
		}
		
		if (i<(mac_count-1)) {
			sprintf((char *)temp_macs+(i*3*6+j*3-1), "%c", ',');
		}
	}
	
	wid_syslog_debug_debug(WID_DBUS,"mac str is :%s\n", temp_macs);

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	if (!sn) {
		wid_syslog_err("malloc for wtp sn failed\n");
		WID_FREE(mac);
		WID_FREE(temp_macs);
		return 1;
	}
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}

    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
		if (!netid) {
			wid_syslog_err("malloc for wtp netid failed1\n");
			WID_FREE(mac);
			WID_FREE(temp_macs);
			WID_FREE(sn);
			return 1;
		}
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
		if (!netid) {
			wid_syslog_err("malloc for wtp netid failed2\n");
			WID_FREE(mac);
			WID_FREE(temp_macs);
			WID_FREE(sn);
			return 1;
		}
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;

	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_STA_UNAUTHORIZED_MAC);
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid,
						DBUS_TYPE_UINT32,&vrrp_id,
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_STRING,&temp_macs,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	CW_FREE_OBJECT_WID(temp_macs);
	return 0;

}


int wid_dbus_trap_wtp_ap_power_off(int wtpindex)
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_wtp_ap_power_off tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}
	/* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_AP_DOWN);
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;

}

int wid_dbus_trap_wtp_ap_reboot(int wtpindex)
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_wtp_ap_reboot tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}
	/* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_AP_REBOOT);
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;

}
/*zhaoruijia,transplant ACTIMESYNCHROFAILURE from 1.2omc to 1.3*/
int wid_dbus_trap_wtp_ap_ACTimeSynchroFailure(int wtpindex,unsigned char flag)

	{
		DBusMessage *query; 
		DBusError err;
		unsigned int TID = wtpindex%THREAD_NUM;
		wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_wtp_ap_ACTimeSynchroFailure tid %d flag %d\n",TID,flag);
	
		/*store sn&mac of ap*/
		unsigned char *mac = NULL;
		mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
		memset(mac,0,MAC_LEN+1);
		if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
		{
			memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
		}
	
		char *sn = NULL;
		sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
		memset(sn,0,NAS_IDENTIFIER_NAME);
		if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
		{
			memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
		}

		/* zhangshu add for netid & vrrpid, 2010-10-19 */
        char *netid = NULL;
        
    	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
    	{
    	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
    	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
    		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
    	}
    	else
    	{
    	    netid = (char *)WID_MALLOC(sizeof(char)*12);
    	    memset(netid,0,12);
    		memcpy(netid,"defaultcode",11);
    	}
	unsigned int local_id = local;
    	unsigned int vrrp_id = vrrid;
    	/* zhangshu add end */
	
		query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
					WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_ACTIMESYNCHROFAILURE);
		
		dbus_error_init(&err);
	
		dbus_message_append_args(query,
							DBUS_TYPE_UINT32,&wtpindex,
							DBUS_TYPE_STRING,&sn,
							DBUS_TYPE_BYTE,&mac[0],
							DBUS_TYPE_BYTE,&mac[1],
							DBUS_TYPE_BYTE,&mac[2],
							DBUS_TYPE_BYTE,&mac[3],
							DBUS_TYPE_BYTE,&mac[4],
							DBUS_TYPE_BYTE,&mac[5],
							DBUS_TYPE_BYTE,&flag,//trap--0,clear --1
							DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-19
						   	DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-19
						    	DBUS_TYPE_UINT32,&local_id,
							DBUS_TYPE_INVALID);
	
		dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
		
		dbus_message_unref(query);
		
		CW_FREE_OBJECT_WID(sn);
		CW_FREE_OBJECT_WID(mac);
		CW_FREE_OBJECT_WID(netid);
		return 0;
	
	}



int wid_dbus_trap_wtp_ip_change_alarm(int wtpindex)
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_wtp_ip_change_alarm tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}
	/* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_IP_CHANGE_ALARM);
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;

}
int wid_dbus_trap_wtp_device_interference(int wtpindex)
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_wtp_device_interference tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;	
	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}
	
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_DEVICE_INTERFERENCE_DETECTED);
	
	dbus_error_init(&err);

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	return 0;

}
int wid_dbus_trap_show_wtp_runtime(unsigned int wtpindex)
{
	DBusMessage *query;	
	DBusError err;
	time_t time;
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;	
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_show_wtp_runtime tid %d\n",TID);
	
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_SHOW_RUNTIME);
	
	dbus_error_init(&err);
	if((AC_WTP[wtpindex] == NULL)||(AC_WTP[wtpindex]->add_time == NULL))
	{
		time = 0;
	}
	else
	{
		time = *AC_WTP[wtpindex]->add_time;
	}

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_UINT32,&time,
						DBUS_TYPE_UINT32,&vrrp_id, 
						DBUS_TYPE_UINT32,&local_id,						
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	wid_syslog_debug_debug(WID_DBUS,"wtp %d Access Time:	%s",wtpindex,ctime(&time));
	
	dbus_message_unref(query);
	return 0;

}
int wid_dbus_trap_set_wtp_remote_restart(unsigned int wtpindex)
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_set_wtp_remote_restart tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}
	
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_REMOTE_RESTART);
	
	dbus_error_init(&err);
	

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_UINT32,&vrrp_id, 
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	wid_syslog_debug_debug(WID_DBUS,"wtp %d remote restart",wtpindex);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	return 0;

}
int wid_dbus_trap_wtp_divorce_networwok(unsigned int wtpindex)
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_wtp_divorce_networwok tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}
    /* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_DIVORCE_NETWORK);
	
	dbus_error_init(&err);
	

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	wid_syslog_debug_debug(WID_DBUS,"wtp %d divorce network",wtpindex);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;

}



int wid_dbus_trap_wtp_channel_device_interference(int wtpindex,char chchannel,unsigned char mac[6])
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_wtp_channel_device_interference tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *wtpmac = NULL;
	wtpmac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(wtpmac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(wtpmac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}
	/* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_CHANNEL_DEVICE_INTERFERENCE);
	
	dbus_error_init(&err);
	
	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_BYTE,&chchannel,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&wtpmac[0],
						DBUS_TYPE_BYTE,&wtpmac[1],
						DBUS_TYPE_BYTE,&wtpmac[2],
						DBUS_TYPE_BYTE,&wtpmac[3],
						DBUS_TYPE_BYTE,&wtpmac[4],
						DBUS_TYPE_BYTE,&wtpmac[5],
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);
	
	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	wid_syslog_debug_debug(WID_DBUS,"wtp %d channel %d device interference",wtpindex,chchannel);
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(wtpmac);
	CW_FREE_OBJECT_WID(netid);
	return 0;

}
int wid_dbus_trap_wtp_channel_ap_interference(int wtpindex,char chchannel,unsigned char mac[6])
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_wtp_channel_ap_interference tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *wtpmac = NULL;
	wtpmac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(wtpmac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(wtpmac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}
	/* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_CHANNEL_AP_INTERFERENCE);
	
	dbus_error_init(&err);
	

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_BYTE,&chchannel,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&wtpmac[0],
						DBUS_TYPE_BYTE,&wtpmac[1],
						DBUS_TYPE_BYTE,&wtpmac[2],
						DBUS_TYPE_BYTE,&wtpmac[3],
						DBUS_TYPE_BYTE,&wtpmac[4],
						DBUS_TYPE_BYTE,&wtpmac[5],
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	wid_syslog_debug_debug(WID_DBUS,"wtp %d channel %d ap interference",wtpindex,chchannel);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(wtpmac);
	CW_FREE_OBJECT_WID(netid);
	return 0;

}

/* zhaoruijia,20100913,translate set neighbor_same_channelrssithreshold to 1.3*/   

int wid_dbus_trap_wtp_neighbor_channel_ap_interference(int wtpindex,char chchannel,unsigned char mac[6],unsigned char flag)
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_wtp_neighbor_channel_ap_interference tid %d,flag %d\n",TID,flag);

	/*store sn&mac of ap*/
	unsigned char *wtpmac = NULL;
	wtpmac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(wtpmac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(wtpmac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}
	/* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_NEIGHBOR_CHANNEL_AP_INTERFERENCE);
	
	dbus_error_init(&err);
	

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_BYTE,&chchannel,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&wtpmac[0],
						DBUS_TYPE_BYTE,&wtpmac[1],
						DBUS_TYPE_BYTE,&wtpmac[2],
						DBUS_TYPE_BYTE,&wtpmac[3],
						DBUS_TYPE_BYTE,&wtpmac[4],
						DBUS_TYPE_BYTE,&wtpmac[5],
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_BYTE,&flag,//0--trap,1---clear
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						//DBUS_TYPE_STRING,&netid,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	wid_syslog_debug_debug(WID_DBUS,"wtp %d channel %d ap interference",wtpindex,chchannel);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(wtpmac);
	CW_FREE_OBJECT_WID(netid);
	//CW_FREE_OBJECT(netid);
	return 0;

}

int wid_dbus_trap_wtp_channel_terminal_interference(int wtpindex,unsigned char radio_id, char chchannel,unsigned char mac[6])
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_wtp_channel_terminal_interference tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *wtpmac = NULL;
	wtpmac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(wtpmac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(wtpmac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}
	/* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_CHANNEL_TERMINAL_INTERFERENCE);
	
	dbus_error_init(&err);
	

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_BYTE,&chchannel,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&wtpmac[0],
						DBUS_TYPE_BYTE,&wtpmac[1],
						DBUS_TYPE_BYTE,&wtpmac[2],
						DBUS_TYPE_BYTE,&wtpmac[3],
						DBUS_TYPE_BYTE,&wtpmac[4],
						DBUS_TYPE_BYTE,&wtpmac[5],
						DBUS_TYPE_BYTE,&radio_id,// zhangshu add 2010-10-08
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	wid_syslog_debug_debug(WID_DBUS,"wtp %d channel %d terminal interference",wtpindex,chchannel);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(wtpmac);
	CW_FREE_OBJECT_WID(netid);
	return 0;

}
int wid_dbus_trap_wtp_channel_count_minor(int wtpindex)
{
	DBusMessage *query;	
	DBusError err;
	
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_wtp_channel_count_minor tid %d\n",TID);
	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}
	/* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_CHANNEL_COUNT_MINOR);
	
	dbus_error_init(&err);
	

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	wid_syslog_debug_debug(WID_DBUS,"wtp %d channel count minor",wtpindex);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;

}

int wid_dbus_trap_wtp_ap_flash_write_failed(unsigned int wtpindex)
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_wtp_ap_flash_write_failed tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}
	/* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_AP_FLASH_WRITE_FAIL);
	
	dbus_error_init(&err);
	

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	wid_syslog_debug_debug(WID_DBUS,"wtp %d flash write fail",wtpindex);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;

}

int wid_dbus_trap_wtp_ac_discovery_danger_ap(unsigned int wtpindex,struct Neighbor_AP_ELE *p_rssi)   //fengwenchao modify 20110509
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_wtp_ac_discovery_danger_ap tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}
	/* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	/*fengwenchao add 20110511*/
	char *essid = NULL;
	if((p_rssi != NULL)&&(p_rssi->ESSID != NULL))
	{
		essid = (char *)WID_MALLOC(strlen((char*)(p_rssi->ESSID))+1);
		memset(essid,0,(strlen((char*)p_rssi->ESSID)+1));
		memcpy(essid,p_rssi->ESSID,strlen((char*)p_rssi->ESSID));
	}
	else
	{
		essid = (char *)WID_MALLOC(sizeof(char)*5);
		memset(essid,0,5);
		memcpy(essid,"none",4);		
	}
	/*fengwenchao add end*/	
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_AC_DISCOVERY_DANGER_AP);
	
	dbus_error_init(&err);
	

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_BYTE,&p_rssi->BSSID[0],     //fengwenchao add 20110509
						DBUS_TYPE_BYTE,&p_rssi->BSSID[1],     //fengwenchao add 20110509
						DBUS_TYPE_BYTE,&p_rssi->BSSID[2],     //fengwenchao add 20110509
						DBUS_TYPE_BYTE,&p_rssi->BSSID[3],     //fengwenchao add 20110509
						DBUS_TYPE_BYTE,&p_rssi->BSSID[4],     //fengwenchao add 20110509
						DBUS_TYPE_BYTE,&p_rssi->BSSID[5],     //fengwenchao add 20110509
						DBUS_TYPE_UINT16,&p_rssi->Rate,          //fengwenchao add 20110509
						DBUS_TYPE_BYTE,&p_rssi->Channel,      //fengwenchao add 20110509
						DBUS_TYPE_BYTE,&p_rssi->RSSI,            //fengwenchao add 20110509
						DBUS_TYPE_STRING,&essid,      //fengwenchao add 20110509
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	wid_syslog_debug_debug(WID_DBUS,"wtp %d discovery danger ap",wtpindex);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	CW_FREE_OBJECT_WID(essid);     //fengwenchao add 20110511
	return 0;

}

int wid_dbus_trap_wtp_ac_discovery_cover_hole(unsigned int wtpindex)
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_wtp_ac_discovery_cover_hole tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}
	/* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_AC_DISCOVERY_COVER_HOLE);
	
	dbus_error_init(&err);
	

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	wid_syslog_debug_debug(WID_DBUS,"wtp %d discovery cover hole",wtpindex);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;

}
int wid_dbus_trap_ap_cpu_threshold(unsigned int wtpindex,unsigned char flag)
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_ap_cpu_threshold tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}

	unsigned int cpu = 0;
	if(AC_WTP[wtpindex] != NULL)
	{
		cpu = AC_WTP[wtpindex]->wifi_extension_info.cpu;
	}
	unsigned int cpu_threshold = g_ap_cpu_threshold;
	/* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_AP_CPU_THRESHOLD);
	
	dbus_error_init(&err);
	
	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_UINT32,&cpu,
						DBUS_TYPE_UINT32,&cpu_threshold,
						DBUS_TYPE_BYTE,&flag,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
//	wid_syslog_debug_debug("wtp %d cpu threshold cpu %d cpu threshold %d flag %d",wtpindex,AC_WTP[wtpindex]->wifi_extension_info.cpu,g_ap_cpu_threshold,flag);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;

}
int wid_dbus_trap_ap_mem_threshold(unsigned int wtpindex,unsigned char flag)
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_ap_mem_threshold tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}

	unsigned char memuse = 0;
	if(AC_WTP[wtpindex] != NULL)
	{
		memuse = AC_WTP[wtpindex]->wifi_extension_info.memoryuse;
	}
	unsigned int memuse_threshold = g_ap_memuse_threshold;
    /* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_AP_MEM_THRESHOLD);
	
	dbus_error_init(&err);
	
	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&memuse,
						DBUS_TYPE_UINT32,&memuse_threshold,
						DBUS_TYPE_BYTE,&flag,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	//wid_syslog_debug_debug("wtp %d mem threshold mem %d mem threshold %d flag %d",wtpindex,AC_WTP[wtpindex]->wifi_extension_info.memoryuse,g_ap_memuse_threshold,flag);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;

}

int wid_dbus_trap_ap_temp_threshold(unsigned int wtpindex,unsigned char flag)
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_ap_temp_threshold tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}

	
	unsigned char temperature = 0;
	if(AC_WTP[wtpindex] != NULL)
	{
		temperature = AC_WTP[wtpindex]->wifi_extension_info.temperature;
	}
	unsigned int temp_threshold = g_ap_temp_threshold;
    /* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_AP_TEMP_THRESHOLD);
	
	dbus_error_init(&err);
	
	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&temperature,
						DBUS_TYPE_UINT32,&temp_threshold,
						DBUS_TYPE_BYTE,&flag,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	//wid_syslog_debug_debug("wtp %d  temp %d temp threshold %d flag %d",wtpindex,AC_WTP[wtpindex]->wifi_extension_info.temperature,g_ap_temp_threshold,flag);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;

}
int wid_dbus_trap_ap_rogue_threshold(unsigned int wtpindex,unsigned int count,unsigned char flag)
{
	//printf("this is in wid_dbus_trap_ap_rogue_threshold.");
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_ap_rogue_threshold tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}
	//printf("here is middle1 of wid_dbus_trap_ap_rogue_threshold\n");
	
	unsigned char curcount = count;
	
	unsigned int rogue_ap_threshold = neighborrogueapcount;
    
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_AP_ROGUE_THRESHOLD);
	
	dbus_error_init(&err);
	//printf("here is middle2 of wid_dbus_trap_ap_rogue_threshold\n");
	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&curcount,
						DBUS_TYPE_UINT32,&rogue_ap_threshold,
						DBUS_TYPE_BYTE,&flag,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_UINT32,&vrrp_id, 
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	//wid_syslog_debug_debug("wtp %d  temp %d temp threshold %d flag %d",wtpindex,AC_WTP[wtpindex]->wifi_extension_info.temperature,g_ap_temp_threshold,flag);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	//printf("here is end of wid_dbus_trap_ap_rogue_threshold\n");
	return 0;

}

int wid_dbus_trap_ap_wifi_if_error(unsigned int wtpindex,unsigned char ifindex,unsigned char flag)
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_ap_wifi_if_error tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}

	unsigned char state = 0;
	if(AC_WTP[wtpindex] != NULL)
	{
		state = AC_WTP[wtpindex]->wifi_extension_info.wifi_state[ifindex];
	}
    /* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_AP_WIFI_IF_ERROR);
	
	dbus_error_init(&err);
	
	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&ifindex,
						DBUS_TYPE_BYTE,&state,
						DBUS_TYPE_BYTE,&flag,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	//wid_syslog_debug_debug("wtp %d  wifi %d wifi state %d flag %d",wtpindex,ifindex,AC_WTP[wtpindex]->wifi_extension_info.wifi_state[ifindex],flag);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;

}
int wid_dbus_trap_ap_ath_error(unsigned int wtpindex,unsigned char radioid,unsigned char wlanid,unsigned char type,unsigned char flag)
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_ap_ath_error tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}
	/* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_AP_ATH_ERROR);
	
	dbus_error_init(&err);
	
	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&radioid,
						DBUS_TYPE_BYTE,&wlanid,
						DBUS_TYPE_BYTE,&type,// 1-manual  /2-auto
						DBUS_TYPE_BYTE,&flag,// 0-trap /1-distrap
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	wid_syslog_debug_debug(WID_DBUS,"wtp %d  radioid %d wlanid %d type %d flag %d",wtpindex,radioid,wlanid,type,flag);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;

}
int wid_dbus_trap_ap_rrm_state_change(unsigned int wtpindex,unsigned char state)
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_ap_rrm_state_change tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}
	/* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_AP_RRM_STATE_CHANGE);
	
	dbus_error_init(&err);
	
	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&state,// 0-disable /1-enable
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	wid_syslog_debug_debug(WID_DBUS,"wtp %d  wid_dbus_trap_ap_rrm_state_change state %d 0-disable /1-enable\n",wtpindex,state);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;

}
int wid_dbus_trap_ap_run_quit(unsigned int wtpindex,unsigned char state)
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_ap_run_quit tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}
	/* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_AP_RUN_QUIT);
	
	dbus_error_init(&err);
	
	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&state,// 0-quit /1-run
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	wid_syslog_debug_debug(WID_DBUS,"wtp %d  wid_dbus_trap_ap_run_quit state %d 0-quit /1-run\n",wtpindex,state);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;

}

/*
int signal_sta_leave(unsigned char mac[6],unsigned int wtpid,unsigned int g_bssindex,unsigned char wlanid){

	DBusMessage *query; 
	DBusError err;
	wid_syslog_debug_debug("sta leave start\n");


	char *wtpmac = NULL;
	wtpmac = (char *)malloc(MAC_LEN+1);
	memset(wtpmac,0,MAC_LEN+1);
	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPMAC != NULL))
	{
		memcpy(wtpmac,AC_WTP[wtpid]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)malloc(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpid]->WTPSN,strlen(AC_WTP[wtpid]->WTPSN));
	}
	
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,ASD_DBUS_SIG_STA_LEAVE);

	dbus_error_init(&err);

	dbus_message_append_args(query,
					
					DBUS_TYPE_BYTE,&mac[0],
					DBUS_TYPE_BYTE,&mac[1],
					DBUS_TYPE_BYTE,&mac[2],
					DBUS_TYPE_BYTE,&mac[3],
					DBUS_TYPE_BYTE,&mac[4],
					DBUS_TYPE_BYTE,&mac[5],
					DBUS_TYPE_UINT32,&wtpid,
					DBUS_TYPE_UINT32,&g_bssindex,
					DBUS_TYPE_BYTE,&wlanid,
					DBUS_TYPE_STRING,&sn,
					DBUS_TYPE_BYTE,&wtpmac[0],
					DBUS_TYPE_BYTE,&wtpmac[1],
					DBUS_TYPE_BYTE,&wtpmac[2],
					DBUS_TYPE_BYTE,&wtpmac[3],
					DBUS_TYPE_BYTE,&wtpmac[4],
					DBUS_TYPE_BYTE,&wtpmac[5],
					DBUS_TYPE_INVALID);

	dbus_connection_send (wid_dbus_connection2,query,NULL);

	dbus_message_unref(query);
	wid_syslog_debug_debug("sta leave end\n");
	CW_FREE_OBJECT(sn);
	CW_FREE_OBJECT(wtpmac);
	return 0;
}

int signal_sta_come(unsigned char mac[6],unsigned int wtpid,unsigned int g_bssindex,unsigned char wlanid){

	DBusMessage *query; 
	DBusError err;
	wid_syslog_debug_debug("sta come start\n");


	char *wtpmac = NULL;
	wtpmac = (char *)malloc(MAC_LEN+1);
	memset(wtpmac,0,MAC_LEN+1);
	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPMAC != NULL))
	{
		memcpy(wtpmac,AC_WTP[wtpid]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)malloc(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpid]->WTPSN,strlen(AC_WTP[wtpid]->WTPSN));
	}
	
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,ASD_DBUS_SIG_STA_COME);

	dbus_error_init(&err);

	dbus_message_append_args(query,
					
					DBUS_TYPE_BYTE,&mac[0],
					DBUS_TYPE_BYTE,&mac[1],
					DBUS_TYPE_BYTE,&mac[2],
					DBUS_TYPE_BYTE,&mac[3],
					DBUS_TYPE_BYTE,&mac[4],
					DBUS_TYPE_BYTE,&mac[5],
					DBUS_TYPE_UINT32,&wtpid,
					DBUS_TYPE_UINT32,&g_bssindex,
					DBUS_TYPE_BYTE,&wlanid,
					DBUS_TYPE_STRING,&sn,
					DBUS_TYPE_BYTE,&wtpmac[0],
					DBUS_TYPE_BYTE,&wtpmac[1],
					DBUS_TYPE_BYTE,&wtpmac[2],
					DBUS_TYPE_BYTE,&wtpmac[3],
					DBUS_TYPE_BYTE,&wtpmac[4],
					DBUS_TYPE_BYTE,&wtpmac[5],
					DBUS_TYPE_INVALID);

	dbus_connection_send (wid_dbus_connection2,query,NULL);

	dbus_message_unref(query);

	wid_syslog_debug_debug("sta come end\n");

	CW_FREE_OBJECT(sn);
	CW_FREE_OBJECT(wtpmac);
	return 0;
}
*/
/*
int signal_wtp_deny_sta(unsigned int wtpid){
	DBusMessage *query; 
	DBusError err;
	wid_syslog_debug_debug("wtp deny sta start\n");

	
	char *mac = NULL;
	mac = (char *)malloc(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpid]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)malloc(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpid]->WTPSN,strlen(AC_WTP[wtpid]->WTPSN));
	}
	
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,ASD_DBUS_SIG_WTP_DENY_STA);

	dbus_error_init(&err);

	dbus_message_append_args(query,
					
					DBUS_TYPE_UINT32,&wtpid,
					DBUS_TYPE_STRING,&sn,
					DBUS_TYPE_BYTE,&mac[0],
					DBUS_TYPE_BYTE,&mac[1],
					DBUS_TYPE_BYTE,&mac[2],
					DBUS_TYPE_BYTE,&mac[3],
					DBUS_TYPE_BYTE,&mac[4],
					DBUS_TYPE_BYTE,&mac[5],
					DBUS_TYPE_INVALID);

	dbus_connection_send (wid_dbus_connection2,query,NULL);

	dbus_message_unref(query);
	wid_syslog_debug_debug("wtp deny sta end\n");
	CW_FREE_OBJECT(sn);
	CW_FREE_OBJECT(mac);
	return 0;

}


int signal_de_wtp_deny_sta(unsigned int wtpid){
	DBusMessage *query; 
	DBusError err;
	wid_syslog_debug_debug(" de wtp deny sta start\n");
	
	
	char *mac = NULL;
	mac = (char *)malloc(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpid]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)malloc(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpid]->WTPSN,strlen(AC_WTP[wtpid]->WTPSN));
	}
	
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,ASD_DBUS_SIG_DE_WTP_DENY_STA);

	dbus_error_init(&err);

	dbus_message_append_args(query,
					
					DBUS_TYPE_UINT32,&wtpid,
					DBUS_TYPE_STRING,&sn,
					DBUS_TYPE_BYTE,&mac[0],
					DBUS_TYPE_BYTE,&mac[1],
					DBUS_TYPE_BYTE,&mac[2],
					DBUS_TYPE_BYTE,&mac[3],
					DBUS_TYPE_BYTE,&mac[4],
					DBUS_TYPE_BYTE,&mac[5],
					DBUS_TYPE_INVALID);

	dbus_connection_send (wid_dbus_connection2,query,NULL);

	dbus_message_unref(query);
	wid_syslog_debug_debug("de wtp deny sta end\n");
	CW_FREE_OBJECT(sn);
	CW_FREE_OBJECT(mac);
	return 0;

}

int signal_sta_verify(unsigned char mac[6],int wtpid){
	DBusMessage *query; 
	DBusError err;
	wid_syslog_debug_debug("signal_sta_verify\n");


	char *wtpmac = NULL;
	wtpmac = (char *)malloc(MAC_LEN+1);
	memset(wtpmac,0,MAC_LEN+1);
	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPMAC != NULL))
	{
		memcpy(wtpmac,AC_WTP[wtpid]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)malloc(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpid]->WTPSN,strlen(AC_WTP[wtpid]->WTPSN));
	}
	
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,ASD_DBUS_SIG_STA_VERIFY);

	dbus_error_init(&err);

	dbus_message_append_args(query,
					DBUS_TYPE_BYTE,&mac[0],
					DBUS_TYPE_BYTE,&mac[1],
					DBUS_TYPE_BYTE,&mac[2],
					DBUS_TYPE_BYTE,&mac[3],
					DBUS_TYPE_BYTE,&mac[4],
					DBUS_TYPE_BYTE,&mac[5],
					DBUS_TYPE_INT32,&wtpid,
					DBUS_TYPE_STRING,&sn,
					DBUS_TYPE_BYTE,&wtpmac[0],
					DBUS_TYPE_BYTE,&wtpmac[1],
					DBUS_TYPE_BYTE,&wtpmac[2],
					DBUS_TYPE_BYTE,&wtpmac[3],
					DBUS_TYPE_BYTE,&wtpmac[4],
					DBUS_TYPE_BYTE,&wtpmac[5],
					DBUS_TYPE_INVALID);

	dbus_connection_send (wid_dbus_connection2,query,NULL);

	dbus_message_unref(query);
	CW_FREE_OBJECT(sn);
	CW_FREE_OBJECT(wtpmac);
	return 0;

}


int signal_sta_verify_failed(unsigned char mac[6],int wtpid){
	DBusMessage *query; 
	DBusError err;
	wid_syslog_debug_debug("signal_sta_verify_failed\n");

	char *wtpmac = NULL;
	wtpmac = (char *)malloc(MAC_LEN+1);
	memset(wtpmac,0,MAC_LEN+1);
	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPMAC != NULL))
	{
		memcpy(wtpmac,AC_WTP[wtpid]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)malloc(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpid]->WTPSN,strlen(AC_WTP[wtpid]->WTPSN));
	}
	
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,ASD_DBUS_SIG_STA_VERIFY_FAILED);

	dbus_error_init(&err);

	dbus_message_append_args(query,
					DBUS_TYPE_BYTE,&mac[0],
					DBUS_TYPE_BYTE,&mac[1],
					DBUS_TYPE_BYTE,&mac[2],
					DBUS_TYPE_BYTE,&mac[3],
					DBUS_TYPE_BYTE,&mac[4],
					DBUS_TYPE_BYTE,&mac[5],
					DBUS_TYPE_INT32,&wtpid,
					DBUS_TYPE_STRING,&sn,
					DBUS_TYPE_BYTE,&wtpmac[0],
					DBUS_TYPE_BYTE,&wtpmac[1],
					DBUS_TYPE_BYTE,&wtpmac[2],
					DBUS_TYPE_BYTE,&wtpmac[3],
					DBUS_TYPE_BYTE,&wtpmac[4],
					DBUS_TYPE_BYTE,&wtpmac[5],
					DBUS_TYPE_INVALID);

	dbus_connection_send (wid_dbus_connection2,query,NULL);

	dbus_message_unref(query);
	CW_FREE_OBJECT(sn);
	CW_FREE_OBJECT(wtpmac);
	return 0;

}

int signal_sta_assoc_failed(unsigned char mac[6],int wtpid,unsigned short ret){
	DBusMessage *query; 
	DBusError err;
	wid_syslog_debug_debug("signal_sta_assoc_failed\n");

	char *wtpmac = NULL;
	wtpmac = (char *)malloc(MAC_LEN+1);
	memset(wtpmac,0,MAC_LEN+1);
	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPMAC != NULL))
	{
		memcpy(wtpmac,AC_WTP[wtpid]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)malloc(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpid]->WTPSN,strlen(AC_WTP[wtpid]->WTPSN));
	}
	
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,ASD_DBUS_SIG_STA_ASSOC_FAILED);

	dbus_error_init(&err);

	dbus_message_append_args(query,
					DBUS_TYPE_BYTE,&mac[0],
					DBUS_TYPE_BYTE,&mac[1],
					DBUS_TYPE_BYTE,&mac[2],
					DBUS_TYPE_BYTE,&mac[3],
					DBUS_TYPE_BYTE,&mac[4],
					DBUS_TYPE_BYTE,&mac[5],
					DBUS_TYPE_INT32,&wtpid,
					DBUS_TYPE_UINT16,&ret,
					DBUS_TYPE_STRING,&sn,
					DBUS_TYPE_BYTE,&wtpmac[0],
					DBUS_TYPE_BYTE,&wtpmac[1],
					DBUS_TYPE_BYTE,&wtpmac[2],
					DBUS_TYPE_BYTE,&wtpmac[3],
					DBUS_TYPE_BYTE,&wtpmac[4],
					DBUS_TYPE_BYTE,&wtpmac[5],
					DBUS_TYPE_INVALID);

	dbus_connection_send (wid_dbus_connection2,query,NULL);

	dbus_message_unref(query);
	CW_FREE_OBJECT(sn);
	CW_FREE_OBJECT(wtpmac);
	return 0;

}

int signal_sta_jianquan_failed(unsigned char mac[6],int wtpid,unsigned short ret){
	DBusMessage *query; 
	DBusError err;
	wid_syslog_debug_debug("signal_sta_jianquan_failed\n");

	char *wtpmac = NULL;
	wtpmac = (char *)malloc(MAC_LEN+1);
	memset(wtpmac,0,MAC_LEN+1);
	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPMAC != NULL))
	{
		memcpy(wtpmac,AC_WTP[wtpid]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)malloc(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpid]->WTPSN,strlen(AC_WTP[wtpid]->WTPSN));
	}
	
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,ASD_DBUS_SIG_STA_JIANQUAN_FAILED );

	dbus_error_init(&err);

	dbus_message_append_args(query,
					DBUS_TYPE_BYTE,&mac[0],
					DBUS_TYPE_BYTE,&mac[1],
					DBUS_TYPE_BYTE,&mac[2],
					DBUS_TYPE_BYTE,&mac[3],
					DBUS_TYPE_BYTE,&mac[4],
					DBUS_TYPE_BYTE,&mac[5],
					DBUS_TYPE_INT32,&wtpid,
					DBUS_TYPE_UINT16,&ret,
					DBUS_TYPE_STRING,&sn,
					DBUS_TYPE_BYTE,&wtpmac[0],
					DBUS_TYPE_BYTE,&wtpmac[1],
					DBUS_TYPE_BYTE,&wtpmac[2],
					DBUS_TYPE_BYTE,&wtpmac[3],
					DBUS_TYPE_BYTE,&wtpmac[4],
					DBUS_TYPE_BYTE,&wtpmac[5],
					DBUS_TYPE_INVALID);

	dbus_connection_send (wid_dbus_connection2,query,NULL);

	dbus_message_unref(query);
	CW_FREE_OBJECT(sn);
	CW_FREE_OBJECT(wtpmac);
	return 0;

}
*/
	
int wid_dbus_trap_wtp_wireless_interface_down(unsigned int wtpindex)
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_wtp_wireless_interface_down tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}
	/* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_WIRELESS_INTERFACE_DOWN);
	
	dbus_error_init(&err);
	

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	wid_syslog_debug_debug(WID_DBUS,"wtp %d wireless interface down",wtpindex);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
    CW_FREE_OBJECT_WID(netid);
	return 0;

}

int wid_dbus_trap_wtp_wireless_interface_down_clear(unsigned int wtpindex)
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DEFAULT,"wid_dbus_trap_wtp_wireless_interface_down_clear tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}
	/* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_WIRELESS_INTERFACE_DOWN_CLEAR);
	
	dbus_error_init(&err);
	

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	wid_syslog_debug_debug(WID_DEFAULT,"wtp %d wireless interface down clear",wtpindex);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;

}
int wid_dbus_trap_wtp_channel_device_interference_clear(int wtpindex,char chchannel)
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_wtp_channel_device_interference_clear tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}
	/* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_CHANNEL_DEVICE_INTERFERENCE_CLEAR);
	
	dbus_error_init(&err);
	

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_BYTE,&chchannel,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	wid_syslog_debug_debug(WID_DBUS,"wtp %d channel %d device interference clear",wtpindex,chchannel);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;

}
int wid_dbus_trap_wtp_channel_ap_interference_clear(int wtpindex,char chchannel)
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_wtp_channel_ap_interference_clear tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}
	/* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_CHANNEL_AP_INTERFERENCE_CLEAR);
	
	dbus_error_init(&err);
	

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_BYTE,&chchannel,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	wid_syslog_debug_debug(WID_DBUS,"wtp %d channel %d ap interference clear",wtpindex,chchannel);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;

}
int wid_dbus_trap_wtp_channel_terminal_interference_clear(int wtpindex,unsigned char radio_id, char chchannel,unsigned char mac[6])
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_wtp_channel_terminal_interference_clear tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *wtpmac = NULL;
	wtpmac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(wtpmac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(wtpmac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}
	/* zhangshu add for 11n,2010-10-11 */
	/*if(mac == NULL)
    {
        mac = (unsigned char*)malloc(MAC_LEN + 1);
        memset(mac, 0, MAC_LEN);
    }*/
    /* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_CHANNEL_TERMINAL_INTERFERENCE_CLEAR);
	
	dbus_error_init(&err);
	

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_BYTE,&chchannel,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&wtpmac[0],
						DBUS_TYPE_BYTE,&wtpmac[1],
						DBUS_TYPE_BYTE,&wtpmac[2],
						DBUS_TYPE_BYTE,&wtpmac[3],
						DBUS_TYPE_BYTE,&wtpmac[4],
						DBUS_TYPE_BYTE,&wtpmac[5],
						DBUS_TYPE_BYTE,&radio_id,// zhangshu add 2010-10-08
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	wid_syslog_debug_debug(WID_DBUS,"wtp %d channel %d terminal interference clear",wtpindex,chchannel);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	//CW_FREE_OBJECT(mac);
	CW_FREE_OBJECT_WID(wtpmac);
	CW_FREE_OBJECT_WID(netid);
	return 0;

}
int wid_dbus_trap_wtp_channel_count_minor_clear(int wtpindex)
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_wtp_channel_count_minor_clear tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}
	/* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_CHANNEL_COUNT_MINOR_CLEAR);
	
	dbus_error_init(&err);
	

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	wid_syslog_debug_debug(WID_DBUS,"wtp %d channel count minor clear",wtpindex);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;

}

int wid_dbus_trap_wtp_ac_discovery_cover_hole_clear(unsigned int wtpindex)
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_wtp_ac_discovery_cover_hole_clear tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}
	/* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_AC_DISCOVERY_COVER_HOLE_CLEAR);
	
	dbus_error_init(&err);
	

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	wid_syslog_debug_debug(WID_DBUS,"wtp %d discovery cover hole clear",wtpindex);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;

}
int wid_dbus_trap_wtp_find_unsafe_essid(unsigned int wtpindex,char *name)
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DBUS,"wid_dbus_trap_wtp_find_unsafe_essid tid %d\n",TID);

	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}
	/* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_FIND_UNSAFE_ESSID);
	
	dbus_error_init(&err);
	

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_STRING,&name,
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	wid_syslog_debug_debug(WID_DBUS,"wtp %d find unsafe essid %s\n",wtpindex,name);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;

}

int wid_dbus_trap_wtp_find_wids_attack(unsigned int wtpindex,struct tag_wids_device_ele *phead)    //fengwenchao modify 20110509
{
	DBusMessage *query;	
	DBusError err;
	unsigned int TID = wtpindex%THREAD_NUM;
	wid_syslog_debug_debug(WID_DEFAULT,"wid_dbus_trap_wtp_find_wids_attack tid %d\n",TID);
	/*store sn&mac of ap*/
	unsigned char *mac = NULL;
	mac = (unsigned char *)WID_MALLOC(MAC_LEN+1);
	memset(mac,0,MAC_LEN+1);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPMAC != NULL))
	{
		memcpy(mac,AC_WTP[wtpindex]->WTPMAC,MAC_LEN);
	}

	char *sn = NULL;
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpindex]->WTPSN,strlen(AC_WTP[wtpindex]->WTPSN));
	}
	/* zhangshu add for netid & vrrpid, 2010-10-13 */
    char *netid = NULL;
    
	if((AC_WTP[wtpindex] != NULL)&&(AC_WTP[wtpindex]->netid != NULL))
	{
	    netid = (char *)WID_MALLOC(strlen(AC_WTP[wtpindex]->netid)+1);
	    memset(netid,0,(strlen(AC_WTP[wtpindex]->netid)+1));
		memcpy(netid,AC_WTP[wtpindex]->netid,strlen(AC_WTP[wtpindex]->netid));
	}
	else
	{
	    netid = (char *)WID_MALLOC(sizeof(char)*12);
	    memset(netid,0,12);
		memcpy(netid,"defaultcode",11);
	}
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	/* zhangshu add end */
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_WTP_FIND_WIDS_ATTACK);
	
	dbus_error_init(&err);
	

	dbus_message_append_args(query,
						DBUS_TYPE_UINT32,&wtpindex,
						DBUS_TYPE_STRING,&sn,
						DBUS_TYPE_BYTE,&mac[0],
						DBUS_TYPE_BYTE,&mac[1],
						DBUS_TYPE_BYTE,&mac[2],
						DBUS_TYPE_BYTE,&mac[3],
						DBUS_TYPE_BYTE,&mac[4],
						DBUS_TYPE_BYTE,&mac[5],
						DBUS_TYPE_BYTE,&phead->bssid[0],  //fengwenchao modify 20110509
						DBUS_TYPE_BYTE,&phead->bssid[1],  //fengwenchao modify 20110509
						DBUS_TYPE_BYTE,&phead->bssid[2],  //fengwenchao modify 20110509
						DBUS_TYPE_BYTE,&phead->bssid[3],  //fengwenchao modify 20110509
						DBUS_TYPE_BYTE,&phead->bssid[4],  //fengwenchao modify 20110509
						DBUS_TYPE_BYTE,&phead->bssid[5],  //fengwenchao modify 20110509
						DBUS_TYPE_STRING,&netid, //zhangshu add 2010-10-13
						DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
						DBUS_TYPE_BYTE,&phead->attacktype,   	  //fengwenchao add 20110509
						DBUS_TYPE_BYTE,&phead->frametype,    	  //fengwenchao add 20110509
						DBUS_TYPE_UINT32,&phead->attackcount,    //fengwenchao add 20110509
						DBUS_TYPE_UINT32,&phead->fst_attack,       //fengwenchao add 20110509
						DBUS_TYPE_UINT32,&phead->lst_attack,       //fengwenchao add 20110509
						DBUS_TYPE_BYTE,&phead->channel,       	  //fengwenchao add 20110509
						DBUS_TYPE_BYTE,&phead->rssi,            	  //fengwenchao add 20110509
						DBUS_TYPE_UINT32,&local_id,
						DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);
	wid_syslog_debug_debug(WID_DEFAULT,"wtp %d find wids attack %02X:%02X:%02X:%02X:%02X:%02X \n",wtpindex,phead->bssid[0],\
		phead->bssid[1],phead->bssid[2],phead->bssid[3],phead->bssid[4],phead->bssid[5]);
	
	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(mac);
	CW_FREE_OBJECT_WID(netid);
	return 0;

}

int wid_dbug_trap_more_ssid_key_conflict(unsigned int RadioID,unsigned char wlan1, unsigned char wlan2,char *ESSID1,char *ESSID2)
{
	DBusMessage *query; 
	DBusError err;
	unsigned char mac[MAC_LEN]={0};
	unsigned char ssid1_len=0, ssid2_len=0;
	unsigned char *ssid1=NULL,*ssid2=NULL;
	char *sn = NULL;
	unsigned int wtpid = RadioID/L_RADIO_NUM;
	unsigned char radio_l_id = RadioID%L_RADIO_NUM;
	unsigned int TID = wtpid%THREAD_NUM;
	
	unsigned char traplevel=4;
	
	wid_syslog_debug_debug(WID_DBUS,"wid_dbug_trap_ssid_key_conflict wtpid %d\n",wtpid);
	if(gtrapflag<traplevel){
		return 0;
	}
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpid]->WTPSN,strlen(AC_WTP[wtpid]->WTPSN));
	}

	memcpy(mac,AC_WTP[wtpid]->WTPMAC,MAC_LEN);
	ssid1_len = strlen(ESSID1);
	ssid1 = (unsigned char *)WID_MALLOC(ssid1_len+1);
	memset(ssid1,0,ssid1_len+1);
	memcpy(ssid1,ESSID1,ssid1_len);
	ssid2_len = strlen(ESSID2);
	ssid2 = (unsigned char *)WID_MALLOC(ssid2_len+1);
	memset(ssid2,0,ssid2_len+1);
	memcpy(ssid2,ESSID2,ssid2_len);
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_SSID_KEY_CONFLICT);

	dbus_error_init(&err);

	dbus_message_append_args(query,
					DBUS_TYPE_UINT32,&wtpid,
					DBUS_TYPE_STRING,&sn,
					DBUS_TYPE_BYTE,&mac[0],
					DBUS_TYPE_BYTE,&mac[1],
					DBUS_TYPE_BYTE,&mac[2],
					DBUS_TYPE_BYTE,&mac[3],
					DBUS_TYPE_BYTE,&mac[4],
					DBUS_TYPE_BYTE,&mac[5],
					DBUS_TYPE_BYTE,&radio_l_id,
					DBUS_TYPE_STRING,&ssid1,
					DBUS_TYPE_STRING,&ssid2,
					DBUS_TYPE_BYTE,&(AC_WLAN[wlan1]->SecurityIndex),
					DBUS_TYPE_BYTE,&(AC_WLAN[wlan2]->SecurityIndex),
					DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
					DBUS_TYPE_UINT32,&local_id,
					DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);

	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(ssid1);
	CW_FREE_OBJECT_WID(ssid2);
	wid_syslog_debug_debug(WID_DBUS,"wid_dbug_trap_ssid_key_conflict end\n");

	return 0;
}


int wid_dbug_trap_ssid_key_conflict(unsigned int wtpid,unsigned char radio_l_id, unsigned char wlan1, unsigned char wlan2)
{
	DBusMessage *query; 
	DBusError err;
	unsigned char mac[MAC_LEN]={0};
	unsigned char ssid1_len=0, ssid2_len=0;
	unsigned char *ssid1=NULL,*ssid2=NULL;
	unsigned int TID = wtpid%THREAD_NUM;
	char *sn = NULL;

	unsigned char traplevel=4;
	
	wid_syslog_debug_debug(WID_DBUS,"wid_dbug_trap_ssid_key_conflict wtpid %d\n",wtpid);
	if(gtrapflag<traplevel){
		return 0;
	}
	sn = (char *)WID_MALLOC(NAS_IDENTIFIER_NAME);
	memset(sn,0,NAS_IDENTIFIER_NAME);
	if((AC_WTP[wtpid] != NULL)&&(AC_WTP[wtpid]->WTPSN != NULL))
	{
		memcpy(sn,AC_WTP[wtpid]->WTPSN,strlen(AC_WTP[wtpid]->WTPSN));
	}

	memcpy(mac,AC_WTP[wtpid]->WTPMAC,MAC_LEN);
	ssid1_len = strlen(AC_WLAN[wlan1]->ESSID);
	ssid1 = (unsigned char *)WID_MALLOC(ssid1_len+1);
	memset(ssid1,0,ssid1_len+1);
	memcpy(ssid1,AC_WLAN[wlan1]->ESSID,ssid1_len);
	ssid2_len = strlen(AC_WLAN[wlan2]->ESSID);
	ssid2 = (unsigned char *)WID_MALLOC(ssid2_len+1);
	memset(ssid2,0,ssid2_len+1);
	memcpy(ssid2,AC_WLAN[wlan2]->ESSID,ssid2_len);
	unsigned int local_id = local;
	unsigned int vrrp_id = vrrid;
	query = dbus_message_new_signal(WID_TRAP_OBJPATH,\
				WID_TRAP_INTERFACE,WID_DBUS_TRAP_WID_SSID_KEY_CONFLICT);

	dbus_error_init(&err);

	dbus_message_append_args(query,
					DBUS_TYPE_UINT32,&wtpid,
					DBUS_TYPE_STRING,&sn,
					DBUS_TYPE_BYTE,&mac[0],
					DBUS_TYPE_BYTE,&mac[1],
					DBUS_TYPE_BYTE,&mac[2],
					DBUS_TYPE_BYTE,&mac[3],
					DBUS_TYPE_BYTE,&mac[4],
					DBUS_TYPE_BYTE,&mac[5],
					DBUS_TYPE_BYTE,&radio_l_id,
					DBUS_TYPE_STRING,&ssid1,
					DBUS_TYPE_STRING,&ssid2,
					DBUS_TYPE_BYTE,&(AC_WLAN[wlan1]->SecurityIndex),
					DBUS_TYPE_BYTE,&(AC_WLAN[wlan2]->SecurityIndex),
					DBUS_TYPE_UINT32,&vrrp_id, //zhangshu add 2010-10-13
					DBUS_TYPE_UINT32,&local_id,
					DBUS_TYPE_INVALID);

	dbus_connection_send(wid_dbus_connection_t[TID],query,NULL);

	dbus_message_unref(query);
	CW_FREE_OBJECT_WID(sn);
	CW_FREE_OBJECT_WID(ssid1);
	CW_FREE_OBJECT_WID(ssid2);
	wid_syslog_debug_debug(WID_DBUS,"wid_dbug_trap_ssid_key_conflict end\n");

	return 0;
}

void *wid_dbus_thread()
{
	//int loop_count = 0;
	/*
	For all OAM method call, synchronous is necessary.
	Only signal/event could be asynchronous, it could be sent in other thread.
	*/
	//printf("begin\n");
	wid_pid_write_v2("wid_dbus_thread",0,vrrid);
	if(wid_dbus_init()&&
	   CWGetMsgQueue(&ACDBUS_MSGQ)
	){
		while (dbus_connection_read_write_dispatch(wid_dbus_connection,500)) {
			//wid_syslog_debug_debug("entering main loop.\n");
			//wid_syslog_debug_debug("loop %d.\n",loop_count++);
		}
	}
	wid_syslog_err("there is something wrong in dbus handler\n");	

	return 0;
}

void *wid_dbus_thread_restart()
{
	//int loop_count = 0;
	/*
	For all OAM method call, synchronous is necessary.
	Only signal/event could be asynchronous, it could be sent in other thread.
	*/
	//printf("begin\n");
	wid_pid_write_v2("wid_dbus_thread_restart",0,vrrid);
	if(wid_dbus_reinit()&&
	   CWGetMsgQueue(&ACDBUS_MSGQ)
	){
		while (dbus_connection_read_write_dispatch(wid_dbus_connection,500)) {
			//wid_syslog_debug_debug(WID_DBUS,"entering main loop.\n");
			//wid_syslog_debug_debug(WID_DBUS,"loop %d.\n",loop_count++);
		}
	}
	wid_syslog_err("there is something wrong in dbus handler\n");	
	return 0;
}


#ifdef __cplusplus
}
#endif







