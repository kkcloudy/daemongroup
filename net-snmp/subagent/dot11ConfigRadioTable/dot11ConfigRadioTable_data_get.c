/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.18.2.1 $ of : mfd-data-get.m2c,v $ 
 *
 * $Id:$
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "dot11ConfigRadioTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement dot11ConfigRadioTable get routines.
 * TODO:240:M: Implement dot11ConfigRadioTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table dot11ConfigRadioTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * dot11ConfigRadioTable is subid 3 of wtpRadio.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.31656.6.1.1.4.3, length: 12
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement dot11ConfigRadioTable data context functions.
 */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpInfoEntry.wtpMacAddr
 * wtpMacAddr is subid 1 of dot11WtpInfoEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.1.1.1.1
 * Description:
AP mac.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is Dot11BaseWtpIdTC (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max )
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpMacAddr.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpMacAddr_dot11ConfigRadioTable_map(char **mib_wtpMacAddr_val_ptr_ptr, size_t *mib_wtpMacAddr_val_ptr_len_ptr, char *raw_wtpMacAddr_val_ptr, size_t raw_wtpMacAddr_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_wtpMacAddr_val_ptr);
    netsnmp_assert((NULL != mib_wtpMacAddr_val_ptr_ptr) && (NULL != mib_wtpMacAddr_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:wtpMacAddr_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement wtpMacAddr non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_wtpMacAddr_val_ptr_len; /* assume equal */
    if((NULL == *mib_wtpMacAddr_val_ptr_ptr) || (*mib_wtpMacAddr_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_wtpMacAddr_val_ptr_ptr = realloc( *mib_wtpMacAddr_val_ptr_ptr, converted_len * sizeof(**mib_wtpMacAddr_val_ptr_ptr));
        if(NULL == *mib_wtpMacAddr_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_wtpMacAddr_val_ptr_len_ptr = converted_len;
    memcpy( *mib_wtpMacAddr_val_ptr_ptr, raw_wtpMacAddr_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* wtpMacAddr_map */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11WtpWirelessIfEntry.wtpWirelessIfIndex
 * wtpWirelessIfIndex is subid 1 of dot11WtpWirelessIfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.3.3.1.1
 * Description:
Wireless interface index.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-wtpWirelessIfIndex.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
wtpWirelessIfIndex_map(long *mib_wtpWirelessIfIndex_val_ptr, long raw_wtpWirelessIfIndex_val)
{
    netsnmp_assert(NULL != mib_wtpWirelessIfIndex_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:wtpWirelessIfIndex_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement wtpWirelessIfIndex mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_wtpWirelessIfIndex_val_ptr) = raw_wtpWirelessIfIndex_val;

    return MFD_SUCCESS;
} /* wtpWirelessIfIndex_map */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
dot11ConfigRadioTable_indexes_set_tbl_idx(dot11ConfigRadioTable_mib_index *tbl_idx, char *wtpMacAddr_val_ptr,  size_t wtpMacAddr_val_ptr_len, long wtpWirelessIfIndex_val)
{
    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:dot11ConfigRadioTable_indexes_set_tbl_idx","called\n"));

    /* wtpMacAddr(1)/Dot11BaseWtpIdTC/ASN_OCTET_STR/char(char)//L/A/w/e/r/d/h */
     tbl_idx->wtpMacAddr_len = sizeof(tbl_idx->wtpMacAddr);
    /*
     * make sure there is enough space for wtpMacAddr data
     */
    if ((NULL == tbl_idx->wtpMacAddr) ||
        (tbl_idx->wtpMacAddr_len < (wtpMacAddr_val_ptr_len * sizeof(tbl_idx->wtpMacAddr[0])))) {
        snmp_log(LOG_ERR,"not enough space for value\n");
        return MFD_ERROR;
    }
    tbl_idx->wtpMacAddr_len = wtpMacAddr_val_ptr_len * sizeof(tbl_idx->wtpMacAddr[0]);
    memcpy( tbl_idx->wtpMacAddr, wtpMacAddr_val_ptr, tbl_idx->wtpMacAddr_len );
    
    /* wtpWirelessIfIndex(1)/INTEGER/ASN_INTEGER/long(long)//l/A/w/e/r/d/h */
    tbl_idx->wtpWirelessIfIndex = wtpWirelessIfIndex_val;
    

    return MFD_SUCCESS;
} /* dot11ConfigRadioTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
dot11ConfigRadioTable_indexes_set(dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, char *wtpMacAddr_val_ptr,  size_t wtpMacAddr_val_ptr_len, long wtpWirelessIfIndex_val)
{
    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:dot11ConfigRadioTable_indexes_set","called\n"));

    if(MFD_SUCCESS != dot11ConfigRadioTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx
                                   , wtpMacAddr_val_ptr, wtpMacAddr_val_ptr_len
                                   , wtpWirelessIfIndex_val
           ))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if(0 != dot11ConfigRadioTable_index_to_oid(&rowreq_ctx->oid_idx,
                                    &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* dot11ConfigRadioTable_indexes_set */


/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConfigRadioEntry.radioChannel
 * radioChannel is subid 1 of dot11ConfigRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.4.3.1.1
 * Description:
Radio channel,the range is form 149 to 153 when radio type is 11a,the other type is range from 1 to 11.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-radioChannel.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
radioChannel_map(long *mib_radioChannel_val_ptr, long raw_radioChannel_val)
{
    netsnmp_assert(NULL != mib_radioChannel_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioChannel_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement radioChannel mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_radioChannel_val_ptr) = raw_radioChannel_val;

    return MFD_SUCCESS;
} /* radioChannel_map */

/**
 * Extract the current value of the radioChannel data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param radioChannel_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
radioChannel_get( dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, long * radioChannel_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != radioChannel_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioChannel_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the radioChannel data.
 * set (* radioChannel_val_ptr ) from rowreq_ctx->data
 */
    (* radioChannel_val_ptr ) = rowreq_ctx->data.radioChannel;

    return MFD_SUCCESS;
} /* radioChannel_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConfigRadioEntry.radioTxPower
 * radioTxPower is subid 2 of dot11ConfigRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.4.3.1.2
 * Description:
Transmission power(UNITS DB).
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  1 - 27;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-radioTxPower.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
radioTxPower_map(long *mib_radioTxPower_val_ptr, long raw_radioTxPower_val)
{
    netsnmp_assert(NULL != mib_radioTxPower_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioTxPower_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement radioTxPower mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_radioTxPower_val_ptr) = raw_radioTxPower_val;

    return MFD_SUCCESS;
} /* radioTxPower_map */

/**
 * Extract the current value of the radioTxPower data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param radioTxPower_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
radioTxPower_get( dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, long * radioTxPower_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != radioTxPower_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioTxPower_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the radioTxPower data.
 * set (* radioTxPower_val_ptr ) from rowreq_ctx->data
 */
    (* radioTxPower_val_ptr ) = rowreq_ctx->data.radioTxPower;

    return MFD_SUCCESS;
} /* radioTxPower_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConfigRadioEntry.radioType
 * radioType is subid 3 of dot11ConfigRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.4.3.1.3
 * Description:
Radio type.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 4/8. Values:  a(1), b(2), g(4), bg(6), bgn(18)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-radioType.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
radioType_map(u_long *mib_radioType_val_ptr, u_long raw_radioType_val)
{
    netsnmp_assert(NULL != mib_radioType_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioType_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement radioType enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_radioType_val) {
        case INTERNAL_RADIOTYPE_A:
             *mib_radioType_val_ptr = RADIOTYPE_A;
             break;

        case INTERNAL_RADIOTYPE_B:
             *mib_radioType_val_ptr = RADIOTYPE_B;
             break;

        case INTERNAL_RADIOTYPE_G:
             *mib_radioType_val_ptr = RADIOTYPE_G;
             break;

        case INTERNAL_RADIOTYPE_BG:
             *mib_radioType_val_ptr = RADIOTYPE_BG;
             break;

        case INTERNAL_RADIOTYPE_AN:
             *mib_radioType_val_ptr = RADIOTYPE_AN;
             break;

        case INTERNAL_RADIOTYPE_AAN:
            *mib_radioType_val_ptr = RADIOTYPE_AAN;
            break;

        case INTERNAL_RADIOTYPE_GN:
            *mib_radioType_val_ptr = RADIOTYPE_GN;
            break;

        case INTERNAL_RADIOTYPE_GGN:
            *mib_radioType_val_ptr = RADIOTYPE_GGN;
            break;

        case INTERNAL_RADIOTYPE_BGGN:
            *mib_radioType_val_ptr = RADIOTYPE_BGGN;
            break;
            
             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for radioType\n", raw_radioType_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* radioType_map */

/**
 * Extract the current value of the radioType data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param radioType_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
radioType_get( dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, u_long * radioType_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != radioType_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioType_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the radioType data.
 * set (* radioType_val_ptr ) from rowreq_ctx->data
 */
    (* radioType_val_ptr ) = rowreq_ctx->data.radioType;

    return MFD_SUCCESS;
} /* radioType_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConfigRadioEntry.radioSpeed
 * radioSpeed is subid 4 of dot11ConfigRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.4.3.1.4
 * Description:
Speed.(1,2,5.5,6,9,11,12,18,24,36,48,54M/bps)
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-radioSpeed.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
radioSpeed_map(long *mib_radioSpeed_val_ptr, long raw_radioSpeed_val)
{
    netsnmp_assert(NULL != mib_radioSpeed_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioSpeed_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement radioSpeed mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_radioSpeed_val_ptr) = raw_radioSpeed_val;

    return MFD_SUCCESS;
} /* radioSpeed_map */

/**
 * Extract the current value of the radioSpeed data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param radioSpeed_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
radioSpeed_get( dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, long * radioSpeed_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != radioSpeed_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioSpeed_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the radioSpeed data.
 * set (* radioSpeed_val_ptr ) from rowreq_ctx->data
 */
    (* radioSpeed_val_ptr ) = rowreq_ctx->data.radioSpeed;

    return MFD_SUCCESS;
} /* radioSpeed_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConfigRadioEntry.radioBeacon
 * radioBeacon is subid 5 of dot11ConfigRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.4.3.1.5
 * Description:
Beacon.(Units ms)
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  25 - 1000;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-radioBeacon.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
radioBeacon_map(long *mib_radioBeacon_val_ptr, long raw_radioBeacon_val)
{
    netsnmp_assert(NULL != mib_radioBeacon_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioBeacon_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement radioBeacon mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_radioBeacon_val_ptr) = raw_radioBeacon_val;

    return MFD_SUCCESS;
} /* radioBeacon_map */

/**
 * Extract the current value of the radioBeacon data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param radioBeacon_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
radioBeacon_get( dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, long * radioBeacon_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != radioBeacon_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioBeacon_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the radioBeacon data.
 * set (* radioBeacon_val_ptr ) from rowreq_ctx->data
 */
    (* radioBeacon_val_ptr ) = rowreq_ctx->data.radioBeacon;

    return MFD_SUCCESS;
} /* radioBeacon_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConfigRadioEntry.radioFragThreshold
 * radioFragThreshold is subid 6 of dot11ConfigRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.4.3.1.6
 * Description:
Beaf.(Units byte)
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  256 - 2346;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-radioFragThreshold.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
radioFragThreshold_map(long *mib_radioFragThreshold_val_ptr, long raw_radioFragThreshold_val)
{
    netsnmp_assert(NULL != mib_radioFragThreshold_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioFragThreshold_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement radioFragThreshold mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_radioFragThreshold_val_ptr) = raw_radioFragThreshold_val;

    return MFD_SUCCESS;
} /* radioFragThreshold_map */

/**
 * Extract the current value of the radioFragThreshold data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param radioFragThreshold_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
radioFragThreshold_get( dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, long * radioFragThreshold_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != radioFragThreshold_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioFragThreshold_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the radioFragThreshold data.
 * set (* radioFragThreshold_val_ptr ) from rowreq_ctx->data
 */
    (* radioFragThreshold_val_ptr ) = rowreq_ctx->data.radioFragThreshold;

    return MFD_SUCCESS;
} /* radioFragThreshold_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConfigRadioEntry.radioDtim
 * radioDtim is subid 7 of dot11ConfigRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.4.3.1.7
 * Description:
Dtim.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  1 - 15;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-radioDtim.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
radioDtim_map(long *mib_radioDtim_val_ptr, long raw_radioDtim_val)
{
    netsnmp_assert(NULL != mib_radioDtim_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioDtim_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement radioDtim mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_radioDtim_val_ptr) = raw_radioDtim_val;

    return MFD_SUCCESS;
} /* radioDtim_map */

/**
 * Extract the current value of the radioDtim data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param radioDtim_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
radioDtim_get( dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, long * radioDtim_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != radioDtim_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioDtim_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the radioDtim data.
 * set (* radioDtim_val_ptr ) from rowreq_ctx->data
 */
    (* radioDtim_val_ptr ) = rowreq_ctx->data.radioDtim;

    return MFD_SUCCESS;
} /* radioDtim_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConfigRadioEntry.radioRTS
 * radioRTS is subid 8 of dot11ConfigRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.4.3.1.8
 * Description:
RTS.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  256 - 2346;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-radioRTS.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
radioRTS_map(long *mib_radioRTS_val_ptr, long raw_radioRTS_val)
{
    netsnmp_assert(NULL != mib_radioRTS_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioRTS_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement radioRTS mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_radioRTS_val_ptr) = raw_radioRTS_val;

    return MFD_SUCCESS;
} /* radioRTS_map */

/**
 * Extract the current value of the radioRTS data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param radioRTS_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
radioRTS_get( dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, long * radioRTS_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != radioRTS_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioRTS_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the radioRTS data.
 * set (* radioRTS_val_ptr ) from rowreq_ctx->data
 */
    (* radioRTS_val_ptr ) = rowreq_ctx->data.radioRTS;

    return MFD_SUCCESS;
} /* radioRTS_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConfigRadioEntry.radioLeadCode
 * radioLeadCode is subid 9 of dot11ConfigRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.4.3.1.9
 * Description:
Lead code.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  short(1), long(2)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-radioLeadCode.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
radioLeadCode_map(u_long *mib_radioLeadCode_val_ptr, u_long raw_radioLeadCode_val)
{
    netsnmp_assert(NULL != mib_radioLeadCode_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioLeadCode_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement radioLeadCode enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_radioLeadCode_val) {
        case INTERNAL_RADIOLEADCODE_SHORT:
             *mib_radioLeadCode_val_ptr = RADIOLEADCODE_SHORT;
             break;

        case INTERNAL_RADIOLEADCODE_LONG:
             *mib_radioLeadCode_val_ptr = RADIOLEADCODE_LONG;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for radioLeadCode\n", raw_radioLeadCode_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* radioLeadCode_map */

/**
 * Extract the current value of the radioLeadCode data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param radioLeadCode_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
radioLeadCode_get( dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, u_long * radioLeadCode_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != radioLeadCode_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioLeadCode_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the radioLeadCode data.
 * set (* radioLeadCode_val_ptr ) from rowreq_ctx->data
 */
    (* radioLeadCode_val_ptr ) = rowreq_ctx->data.radioLeadCode;

    return MFD_SUCCESS;
} /* radioLeadCode_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConfigRadioEntry.radioShortRetry
 * radioShortRetry is subid 10 of dot11ConfigRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.4.3.1.10
 * Description:
Short retry.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  1 - 15;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-radioShortRetry.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
radioShortRetry_map(long *mib_radioShortRetry_val_ptr, long raw_radioShortRetry_val)
{
    netsnmp_assert(NULL != mib_radioShortRetry_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioShortRetry_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement radioShortRetry mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_radioShortRetry_val_ptr) = raw_radioShortRetry_val;

    return MFD_SUCCESS;
} /* radioShortRetry_map */

/**
 * Extract the current value of the radioShortRetry data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param radioShortRetry_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
radioShortRetry_get( dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, long * radioShortRetry_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != radioShortRetry_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioShortRetry_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the radioShortRetry data.
 * set (* radioShortRetry_val_ptr ) from rowreq_ctx->data
 */
    (* radioShortRetry_val_ptr ) = rowreq_ctx->data.radioShortRetry;

    return MFD_SUCCESS;
} /* radioShortRetry_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConfigRadioEntry.radioLongRetry
 * radioLongRetry is subid 11 of dot11ConfigRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.4.3.1.11
 * Description:
Long retry.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  1 - 15;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-radioLongRetry.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
radioLongRetry_map(long *mib_radioLongRetry_val_ptr, long raw_radioLongRetry_val)
{
    netsnmp_assert(NULL != mib_radioLongRetry_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioLongRetry_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement radioLongRetry mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_radioLongRetry_val_ptr) = raw_radioLongRetry_val;

    return MFD_SUCCESS;
} /* radioLongRetry_map */

/**
 * Extract the current value of the radioLongRetry data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param radioLongRetry_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
radioLongRetry_get( dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, long * radioLongRetry_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != radioLongRetry_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioLongRetry_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the radioLongRetry data.
 * set (* radioLongRetry_val_ptr ) from rowreq_ctx->data
 */
    (* radioLongRetry_val_ptr ) = rowreq_ctx->data.radioLongRetry;

    return MFD_SUCCESS;
} /* radioLongRetry_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConfigRadioEntry.radioService
 * radioService is subid 12 of dot11ConfigRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.4.3.1.12
 * Description:
Radio service.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  disable(1), enable(2)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-radioService.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
radioService_map(u_long *mib_radioService_val_ptr, u_long raw_radioService_val)
{
    netsnmp_assert(NULL != mib_radioService_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioService_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement radioService enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_radioService_val) {
        case INTERNAL_RADIOSERVICE_DISABLE:
             *mib_radioService_val_ptr = RADIOSERVICE_DISABLE;
             break;

        case INTERNAL_RADIOSERVICE_ENABLE:
             *mib_radioService_val_ptr = RADIOSERVICE_ENABLE;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for radioService\n", raw_radioService_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* radioService_map */

/**
 * Extract the current value of the radioService data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param radioService_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
radioService_get( dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, u_long * radioService_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != radioService_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioService_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the radioService data.
 * set (* radioService_val_ptr ) from rowreq_ctx->data
 */
    (* radioService_val_ptr ) = rowreq_ctx->data.radioService;

    return MFD_SUCCESS;
} /* radioService_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConfigRadioEntry.radioMaxSpeed
 * radioMaxSpeed is subid 13 of dot11ConfigRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.4.3.1.13
 * Description:
Max speed.(1,2,5.5,6,9,11,12,18,24,36,48,54M/bps)
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-radioMaxSpeed.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
radioMaxSpeed_map(long *mib_radioMaxSpeed_val_ptr, long raw_radioMaxSpeed_val)
{
    netsnmp_assert(NULL != mib_radioMaxSpeed_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioMaxSpeed_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement radioMaxSpeed mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_radioMaxSpeed_val_ptr) = raw_radioMaxSpeed_val;

    return MFD_SUCCESS;
} /* radioMaxSpeed_map */

/**
 * Extract the current value of the radioMaxSpeed data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param radioMaxSpeed_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
radioMaxSpeed_get( dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, long * radioMaxSpeed_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != radioMaxSpeed_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioMaxSpeed_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the radioMaxSpeed data.
 * set (* radioMaxSpeed_val_ptr ) from rowreq_ctx->data
 */
    (* radioMaxSpeed_val_ptr ) = rowreq_ctx->data.radioMaxSpeed;

    return MFD_SUCCESS;
} /* radioMaxSpeed_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConfigRadioEntry.radioMaxFlow
 * radioMaxFlow is subid 14 of dot11ConfigRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.4.3.1.14
 * Description:
Max flow.(Units M)
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  1 - 108;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-radioMaxFlow.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
radioMaxFlow_map(long *mib_radioMaxFlow_val_ptr, long raw_radioMaxFlow_val)
{
    netsnmp_assert(NULL != mib_radioMaxFlow_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioMaxFlow_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement radioMaxFlow mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_radioMaxFlow_val_ptr) = raw_radioMaxFlow_val;

    return MFD_SUCCESS;
} /* radioMaxFlow_map */

/**
 * Extract the current value of the radioMaxFlow data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param radioMaxFlow_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
radioMaxFlow_get( dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, long * radioMaxFlow_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != radioMaxFlow_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioMaxFlow_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the radioMaxFlow data.
 * set (* radioMaxFlow_val_ptr ) from rowreq_ctx->data
 */
    (* radioMaxFlow_val_ptr ) = rowreq_ctx->data.radioMaxFlow;

    return MFD_SUCCESS;
} /* radioMaxFlow_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConfigRadioEntry.radioBindWlan
 * radioBindWlan is subid 15 of dot11ConfigRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.4.3.1.15
 * Description:
Bind wlan.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-radioBindWlan.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
radioBindWlan_map(char **mib_radioBindWlan_val_ptr_ptr, size_t *mib_radioBindWlan_val_ptr_len_ptr, char *raw_radioBindWlan_val_ptr, size_t raw_radioBindWlan_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_radioBindWlan_val_ptr);
    netsnmp_assert((NULL != mib_radioBindWlan_val_ptr_ptr) && (NULL != mib_radioBindWlan_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioBindWlan_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement radioBindWlan non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_radioBindWlan_val_ptr_len; /* assume equal */
    if((NULL == *mib_radioBindWlan_val_ptr_ptr) || (*mib_radioBindWlan_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_radioBindWlan_val_ptr_ptr = realloc( *mib_radioBindWlan_val_ptr_ptr, converted_len * sizeof(**mib_radioBindWlan_val_ptr_ptr));
        if(NULL == *mib_radioBindWlan_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_radioBindWlan_val_ptr_len_ptr = converted_len;
    memcpy( *mib_radioBindWlan_val_ptr_ptr, raw_radioBindWlan_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* radioBindWlan_map */

/**
 * Extract the current value of the radioBindWlan data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param radioBindWlan_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param radioBindWlan_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by radioBindWlan.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*radioBindWlan_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update radioBindWlan_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
radioBindWlan_get( dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, char **radioBindWlan_val_ptr_ptr, size_t *radioBindWlan_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != radioBindWlan_val_ptr_ptr) && (NULL != *radioBindWlan_val_ptr_ptr));
   netsnmp_assert( NULL != radioBindWlan_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioBindWlan_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the radioBindWlan data.
 * set (* radioBindWlan_val_ptr_ptr ) and (* radioBindWlan_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for radioBindWlan data
     */
    if ((NULL == (* radioBindWlan_val_ptr_ptr )) ||
        ((* radioBindWlan_val_ptr_len_ptr ) < (rowreq_ctx->data.radioBindWlan_len * sizeof((* radioBindWlan_val_ptr_ptr )[0])))) {
        /*
         * allocate space for radioBindWlan data
         */
        (* radioBindWlan_val_ptr_ptr ) = malloc(rowreq_ctx->data.radioBindWlan_len * sizeof((* radioBindWlan_val_ptr_ptr )[0]));
        if(NULL == (* radioBindWlan_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* radioBindWlan_val_ptr_len_ptr ) = rowreq_ctx->data.radioBindWlan_len * sizeof((* radioBindWlan_val_ptr_ptr )[0]);
    memcpy( (* radioBindWlan_val_ptr_ptr ), rowreq_ctx->data.radioBindWlan, (* radioBindWlan_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* radioBindWlan_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConfigRadioEntry.radioDelbindWlan
 * radioDelbindWlan is subid 16 of dot11ConfigRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.4.3.1.16
 * Description:
Delete Binded wlan.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-radioDelbindWlan.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
radioDelbindWlan_map(char **mib_radioDelbindWlan_val_ptr_ptr, size_t *mib_radioDelbindWlan_val_ptr_len_ptr, char *raw_radioDelbindWlan_val_ptr, size_t raw_radioDelbindWlan_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_radioDelbindWlan_val_ptr);
    netsnmp_assert((NULL != mib_radioDelbindWlan_val_ptr_ptr) && (NULL != mib_radioDelbindWlan_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioDelbindWlan_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement radioDelbindWlan non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_radioDelbindWlan_val_ptr_len; /* assume equal */
    if((NULL == *mib_radioDelbindWlan_val_ptr_ptr) || (*mib_radioDelbindWlan_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_radioDelbindWlan_val_ptr_ptr = realloc( *mib_radioDelbindWlan_val_ptr_ptr, converted_len * sizeof(**mib_radioDelbindWlan_val_ptr_ptr));
        if(NULL == *mib_radioDelbindWlan_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_radioDelbindWlan_val_ptr_len_ptr = converted_len;
    memcpy( *mib_radioDelbindWlan_val_ptr_ptr, raw_radioDelbindWlan_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* radioDelbindWlan_map */

/**
 * Extract the current value of the radioDelbindWlan data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param radioDelbindWlan_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param radioDelbindWlan_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by radioDelbindWlan.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*radioDelbindWlan_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update radioDelbindWlan_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
radioDelbindWlan_get( dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, char **radioDelbindWlan_val_ptr_ptr, size_t *radioDelbindWlan_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != radioDelbindWlan_val_ptr_ptr) && (NULL != *radioDelbindWlan_val_ptr_ptr));
   netsnmp_assert( NULL != radioDelbindWlan_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioDelbindWlan_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the radioDelbindWlan data.
 * set (* radioDelbindWlan_val_ptr_ptr ) and (* radioDelbindWlan_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for radioDelbindWlan data
     */
    if ((NULL == (* radioDelbindWlan_val_ptr_ptr )) ||
        ((* radioDelbindWlan_val_ptr_len_ptr ) < (rowreq_ctx->data.radioDelbindWlan_len * sizeof((* radioDelbindWlan_val_ptr_ptr )[0])))) {
        /*
         * allocate space for radioDelbindWlan data
         */
        (* radioDelbindWlan_val_ptr_ptr ) = malloc(rowreq_ctx->data.radioDelbindWlan_len * sizeof((* radioDelbindWlan_val_ptr_ptr )[0]));
        if(NULL == (* radioDelbindWlan_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* radioDelbindWlan_val_ptr_len_ptr ) = rowreq_ctx->data.radioDelbindWlan_len * sizeof((* radioDelbindWlan_val_ptr_ptr )[0]);
    memcpy( (* radioDelbindWlan_val_ptr_ptr ), rowreq_ctx->data.radioDelbindWlan, (* radioDelbindWlan_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* radioDelbindWlan_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConfigRadioEntry.radioBindQos
 * radioBindQos is subid 17 of dot11ConfigRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.4.3.1.17
 * Description:
Bind Qos.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-radioBindQos.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
radioBindQos_map(char **mib_radioBindQos_val_ptr_ptr, size_t *mib_radioBindQos_val_ptr_len_ptr, char *raw_radioBindQos_val_ptr, size_t raw_radioBindQos_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_radioBindQos_val_ptr);
    netsnmp_assert((NULL != mib_radioBindQos_val_ptr_ptr) && (NULL != mib_radioBindQos_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioBindQos_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement radioBindQos non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_radioBindQos_val_ptr_len; /* assume equal */
    if((NULL == *mib_radioBindQos_val_ptr_ptr) || (*mib_radioBindQos_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_radioBindQos_val_ptr_ptr = realloc( *mib_radioBindQos_val_ptr_ptr, converted_len * sizeof(**mib_radioBindQos_val_ptr_ptr));
        if(NULL == *mib_radioBindQos_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_radioBindQos_val_ptr_len_ptr = converted_len;
    memcpy( *mib_radioBindQos_val_ptr_ptr, raw_radioBindQos_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* radioBindQos_map */

/**
 * Extract the current value of the radioBindQos data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param radioBindQos_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param radioBindQos_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by radioBindQos.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*radioBindQos_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update radioBindQos_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
radioBindQos_get( dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, char **radioBindQos_val_ptr_ptr, size_t *radioBindQos_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != radioBindQos_val_ptr_ptr) && (NULL != *radioBindQos_val_ptr_ptr));
   netsnmp_assert( NULL != radioBindQos_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioBindQos_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the radioBindQos data.
 * set (* radioBindQos_val_ptr_ptr ) and (* radioBindQos_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for radioBindQos data
     */
    if ((NULL == (* radioBindQos_val_ptr_ptr )) ||
        ((* radioBindQos_val_ptr_len_ptr ) < (rowreq_ctx->data.radioBindQos_len * sizeof((* radioBindQos_val_ptr_ptr )[0])))) {
        /*
         * allocate space for radioBindQos data
         */
        (* radioBindQos_val_ptr_ptr ) = malloc(rowreq_ctx->data.radioBindQos_len * sizeof((* radioBindQos_val_ptr_ptr )[0]));
        if(NULL == (* radioBindQos_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* radioBindQos_val_ptr_len_ptr ) = rowreq_ctx->data.radioBindQos_len * sizeof((* radioBindQos_val_ptr_ptr )[0]);
    memcpy( (* radioBindQos_val_ptr_ptr ), rowreq_ctx->data.radioBindQos, (* radioBindQos_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* radioBindQos_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConfigRadioEntry.radioDelbindQos
 * radioDelbindQos is subid 18 of dot11ConfigRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.4.3.1.18
 * Description:
Delete Binded Qos.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-radioDelbindQos.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
radioDelbindQos_map(char **mib_radioDelbindQos_val_ptr_ptr, size_t *mib_radioDelbindQos_val_ptr_len_ptr, char *raw_radioDelbindQos_val_ptr, size_t raw_radioDelbindQos_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_radioDelbindQos_val_ptr);
    netsnmp_assert((NULL != mib_radioDelbindQos_val_ptr_ptr) && (NULL != mib_radioDelbindQos_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioDelbindQos_map","called\n"));
    
    /*
     * TODO:241:r: |-> Implement radioDelbindQos non-integer mapping
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
    converted_len = raw_radioDelbindQos_val_ptr_len; /* assume equal */
    if((NULL == *mib_radioDelbindQos_val_ptr_ptr) || (*mib_radioDelbindQos_val_ptr_len_ptr < converted_len)) {
        if(! allow_realloc) {
            snmp_log(LOG_ERR,"not enough space for value mapping\n");
            return SNMP_ERR_GENERR;
        }
        *mib_radioDelbindQos_val_ptr_ptr = realloc( *mib_radioDelbindQos_val_ptr_ptr, converted_len * sizeof(**mib_radioDelbindQos_val_ptr_ptr));
        if(NULL == *mib_radioDelbindQos_val_ptr_ptr) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return SNMP_ERR_GENERR;
        }
    }
    *mib_radioDelbindQos_val_ptr_len_ptr = converted_len;
    memcpy( *mib_radioDelbindQos_val_ptr_ptr, raw_radioDelbindQos_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* radioDelbindQos_map */

/**
 * Extract the current value of the radioDelbindQos data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param radioDelbindQos_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param radioDelbindQos_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by radioDelbindQos.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*radioDelbindQos_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update radioDelbindQos_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
radioDelbindQos_get( dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, char **radioDelbindQos_val_ptr_ptr, size_t *radioDelbindQos_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != radioDelbindQos_val_ptr_ptr) && (NULL != *radioDelbindQos_val_ptr_ptr));
   netsnmp_assert( NULL != radioDelbindQos_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioDelbindQos_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the radioDelbindQos data.
 * set (* radioDelbindQos_val_ptr_ptr ) and (* radioDelbindQos_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for radioDelbindQos data
     */
    if ((NULL == (* radioDelbindQos_val_ptr_ptr )) ||
        ((* radioDelbindQos_val_ptr_len_ptr ) < (rowreq_ctx->data.radioDelbindQos_len * sizeof((* radioDelbindQos_val_ptr_ptr )[0])))) {
        /*
         * allocate space for radioDelbindQos data
         */
        (* radioDelbindQos_val_ptr_ptr ) = malloc(rowreq_ctx->data.radioDelbindQos_len * sizeof((* radioDelbindQos_val_ptr_ptr )[0]));
        if(NULL == (* radioDelbindQos_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* radioDelbindQos_val_ptr_len_ptr ) = rowreq_ctx->data.radioDelbindQos_len * sizeof((* radioDelbindQos_val_ptr_ptr )[0]);
    memcpy( (* radioDelbindQos_val_ptr_ptr ), rowreq_ctx->data.radioDelbindQos, (* radioDelbindQos_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* radioDelbindQos_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConfigRadioEntry.radioAmpduSwitch
 * radioAmpduSwitch is subid 19 of dot11ConfigRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.33050.6.1.1.4.3.1.19
 * Description:
A-MPDU Switch.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  off(0), on(1)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-radioAmpduSwitch.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
radioAmpduSwitch_map(u_long *mib_radioAmpduSwitch_val_ptr, u_long raw_radioAmpduSwitch_val)
{
    netsnmp_assert(NULL != mib_radioAmpduSwitch_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioAmpduSwitch_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement radioAmpduSwitch enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_radioAmpduSwitch_val) {
        case INTERNAL_RADIOAMPDUSWITCH_OFF:
             *mib_radioAmpduSwitch_val_ptr = RADIOAMPDUSWITCH_OFF;
             break;

        case INTERNAL_RADIOAMPDUSWITCH_ON:
             *mib_radioAmpduSwitch_val_ptr = RADIOAMPDUSWITCH_ON;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for radioAmpduSwitch\n", raw_radioAmpduSwitch_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* radioAmpduSwitch_map */

/**
 * Extract the current value of the radioAmpduSwitch data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param radioAmpduSwitch_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
radioAmpduSwitch_get( dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, u_long * radioAmpduSwitch_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != radioAmpduSwitch_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioAmpduSwitch_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the radioAmpduSwitch data.
 * set (* radioAmpduSwitch_val_ptr ) from rowreq_ctx->data
 */
    (* radioAmpduSwitch_val_ptr ) = rowreq_ctx->data.radioAmpduSwitch;

    return MFD_SUCCESS;
} /* radioAmpduSwitch_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConfigRadioEntry.radioCwmode
 * radioCwmode is subid 20 of dot11ConfigRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.33050.6.1.1.4.3.1.20
 * Description:
Cwmode.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  ht20(0), ht20_ht40(1), ht40(2)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-radioCwmode.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
radioCwmode_map(u_long *mib_radioCwmode_val_ptr, u_long raw_radioCwmode_val)
{
    netsnmp_assert(NULL != mib_radioCwmode_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioCwmode_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement radioCwmode enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_radioCwmode_val) {
        case INTERNAL_RADIOCWMODE_HT20:
             *mib_radioCwmode_val_ptr = RADIOCWMODE_HT20;
             break;

        case INTERNAL_RADIOCWMODE_HT20_HT40:
             *mib_radioCwmode_val_ptr = RADIOCWMODE_HT20_HT40;
             break;

        case INTERNAL_RADIOCWMODE_HT40:
             *mib_radioCwmode_val_ptr = RADIOCWMODE_HT40;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for radioCwmode\n", raw_radioCwmode_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* radioCwmode_map */

/**
 * Extract the current value of the radioCwmode data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param radioCwmode_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
radioCwmode_get( dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, u_long * radioCwmode_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != radioCwmode_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioCwmode_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the radioCwmode data.
 * set (* radioCwmode_val_ptr ) from rowreq_ctx->data
 */
    (* radioCwmode_val_ptr ) = rowreq_ctx->data.radioCwmode;

    return MFD_SUCCESS;
} /* radioCwmode_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConfigRadioEntry.radioShortGISwitch
 * radioShortGISwitch is subid 21 of dot11ConfigRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.33050.6.1.1.4.3.1.21
 * Description:
Short GI Switch.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  off(0), on(1)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-radioShortGISwitch.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
radioShortGISwitch_map(u_long *mib_radioShortGISwitch_val_ptr, u_long raw_radioShortGISwitch_val)
{
    netsnmp_assert(NULL != mib_radioShortGISwitch_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioShortGISwitch_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement radioShortGISwitch enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_radioShortGISwitch_val) {
        case INTERNAL_RADIOSHORTGISWITCH_OFF:
             *mib_radioShortGISwitch_val_ptr = RADIOSHORTGISWITCH_OFF;
             break;

        case INTERNAL_RADIOSHORTGISWITCH_ON:
             *mib_radioShortGISwitch_val_ptr = RADIOSHORTGISWITCH_ON;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for radioShortGISwitch\n", raw_radioShortGISwitch_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* radioShortGISwitch_map */

/**
 * Extract the current value of the radioShortGISwitch data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param radioShortGISwitch_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
radioShortGISwitch_get( dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, u_long * radioShortGISwitch_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != radioShortGISwitch_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioShortGISwitch_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the radioShortGISwitch data.
 * set (* radioShortGISwitch_val_ptr ) from rowreq_ctx->data
 */
    (* radioShortGISwitch_val_ptr ) = rowreq_ctx->data.radioShortGISwitch;

    return MFD_SUCCESS;
} /* radioShortGISwitch_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConfigRadioEntry.radioAmsduSwitch
 * radioAmsduSwitch is subid 22 of dot11ConfigRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.4.3.1.22
 * Description:
A-MSDU Switch.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  off(0), on(1)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-radioAmsduSwitch.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
radioAmsduSwitch_map(u_long *mib_radioAmsduSwitch_val_ptr, u_long raw_radioAmsduSwitch_val)
{
    netsnmp_assert(NULL != mib_radioAmsduSwitch_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioAmsduSwitch_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement radioAmsduSwitch enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_radioAmsduSwitch_val) {
        case INTERNAL_RADIOAMSDUSWITCH_OFF:
             *mib_radioAmsduSwitch_val_ptr = RADIOAMSDUSWITCH_OFF;
             break;

        case INTERNAL_RADIOAMSDUSWITCH_ON:
             *mib_radioAmsduSwitch_val_ptr = RADIOAMSDUSWITCH_ON;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for radioAmsduSwitch\n", raw_radioAmsduSwitch_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* radioAmsduSwitch_map */

/**
 * Extract the current value of the radioAmsduSwitch data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param radioAmsduSwitch_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
radioAmsduSwitch_get( dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, u_long * radioAmsduSwitch_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != radioAmsduSwitch_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioAmsduSwitch_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the radioAmsduSwitch data.
 * set (* radioAmsduSwitch_val_ptr ) from rowreq_ctx->data
 */
    (* radioAmsduSwitch_val_ptr ) = rowreq_ctx->data.radioAmsduSwitch;

    return MFD_SUCCESS;
} /* radioAmsduSwitch_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConfigRadioEntry.radioMCS
 * radioMCS is subid 23 of dot11ConfigRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.4.3.1.23
 * Description:
Modulation and Coding Scheme.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-radioMCS.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
radioMCS_map(char **mib_radioMCS_val_ptr_ptr, size_t *mib_radioMCS_val_ptr_len_ptr, char *raw_radioMCS_val_ptr, size_t raw_radioMCS_val_ptr_len, int allow_realloc)
{
    int converted_len;

    netsnmp_assert(NULL != raw_radioMCS_val_ptr);
    netsnmp_assert((NULL != mib_radioMCS_val_ptr_ptr) && (NULL != mib_radioMCS_val_ptr_len_ptr));
    
    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioMCS_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement radioMCS non-integer mapping.
     * it is hard to autogenerate code for mapping types that are not simple
     * integers, so here is an idea of what you might need to do. It will
     * probably need some tweaking to get right.
     */
    /*
     * if the length of the raw data doesn't directly correspond with
     * the length of the mib data, set converted_len to the
     * space required.
     */
	converted_len = raw_radioMCS_val_ptr_len; /* assume equal */
	if((NULL == *mib_radioMCS_val_ptr_ptr) || (*mib_radioMCS_val_ptr_len_ptr < converted_len)) {
		if(! allow_realloc) {
			snmp_log(LOG_ERR,"not enough space for value mapping\n");
			return SNMP_ERR_GENERR;
		}
		*mib_radioMCS_val_ptr_ptr = realloc( *mib_radioMCS_val_ptr_ptr, converted_len * sizeof(**mib_radioMCS_val_ptr_ptr));
		if(NULL == *mib_radioMCS_val_ptr_ptr) {
			snmp_log(LOG_ERR,"could not allocate memory\n");
			return SNMP_ERR_GENERR;
		}
	}
	*mib_radioMCS_val_ptr_len_ptr = converted_len;
	memcpy( *mib_radioMCS_val_ptr_ptr, raw_radioMCS_val_ptr, converted_len );

    return MFD_SUCCESS;
} /* radioMCS_map */

/**
 * Extract the current value of the radioMCS data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param radioMCS_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param radioMCS_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by radioMCS.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*radioMCS_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update radioMCS_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */

int
radioMCS_get( dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, char **radioMCS_val_ptr_ptr, size_t *radioMCS_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != radioMCS_val_ptr_ptr) && (NULL != *radioMCS_val_ptr_ptr));
   netsnmp_assert( NULL != radioMCS_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioMCS_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the radioMCS data.
 * set (* radioMCS_val_ptr_ptr ) and (* radioMCS_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for radioMCS data
     */
    if ((NULL == (* radioMCS_val_ptr_ptr )) ||
        ((* radioMCS_val_ptr_len_ptr ) < (rowreq_ctx->data.radioMCS_len * sizeof((* radioMCS_val_ptr_ptr )[0])))) {
        /*
         * allocate space for radioMCS data
         */
        (* radioMCS_val_ptr_ptr ) = malloc(rowreq_ctx->data.radioMCS_len * sizeof((* radioMCS_val_ptr_ptr )[0]));
        if(NULL == (* radioMCS_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* radioMCS_val_ptr_len_ptr ) = rowreq_ctx->data.radioMCS_len * sizeof((* radioMCS_val_ptr_ptr )[0]);
    memcpy( (* radioMCS_val_ptr_ptr ), rowreq_ctx->data.radioMCS, (* radioMCS_val_ptr_len_ptr ) );

    return MFD_SUCCESS;
} /* radioMCS_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConfigRadioEntry.radio11nSwitch
 * radio11nSwitch is subid 24 of dot11ConfigRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.4.3.1.24
 * Description:
802.11n Switch.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  off(0), on(1)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-radio11nSwitch.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
radio11nSwitch_map(u_long *mib_radio11nSwitch_val_ptr, u_long raw_radio11nSwitch_val)
{
    netsnmp_assert(NULL != mib_radio11nSwitch_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radio11nSwitch_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement radio11nSwitch enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_radio11nSwitch_val) {
        case INTERNAL_RADIO11NSWITCH_OFF:
             *mib_radio11nSwitch_val_ptr = RADIO11NSWITCH_OFF;
             break;

        case INTERNAL_RADIO11NSWITCH_ON:
             *mib_radio11nSwitch_val_ptr = RADIO11NSWITCH_ON;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for radio11nSwitch\n", raw_radio11nSwitch_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* radio11nSwitch_map */

/**
 * Extract the current value of the radio11nSwitch data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param radio11nSwitch_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
radio11nSwitch_get( dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, u_long * radio11nSwitch_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != radio11nSwitch_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radio11nSwitch_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the radio11nSwitch data.
 * set (* radio11nSwitch_val_ptr ) from rowreq_ctx->data
 */
    (* radio11nSwitch_val_ptr ) = rowreq_ctx->data.radio11nSwitch;

    return MFD_SUCCESS;
} /* radio11nSwitch_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConfigRadioEntry.OnlyAllow11nStaAccess
 * OnlyAllow11nStaAccess is subid 25 of dot11ConfigRadioEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.31656.6.1.1.4.3.1.25
 * Description:
Whether only allows 11N terminal access.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-OnlyAllow11nStaAccess.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
OnlyAllow11nStaAccess_map(u_long *mib_OnlyAllow11nStaAccess_val_ptr, u_long raw_OnlyAllow11nStaAccess_val)
{
    netsnmp_assert(NULL != mib_OnlyAllow11nStaAccess_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:OnlyAllow11nStaAccess_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement OnlyAllow11nStaAccess enum mapping.
     * uses INTERNAL_* macros defined in the header files
     */
    switch(raw_OnlyAllow11nStaAccess_val) {
        case INTERNAL_ONLYALLOW11NSTAACCESS_TRUE:
             *mib_OnlyAllow11nStaAccess_val_ptr = TRUTHVALUE_TRUE;
             break;

        case INTERNAL_ONLYALLOW11NSTAACCESS_FALSE:
             *mib_OnlyAllow11nStaAccess_val_ptr = TRUTHVALUE_FALSE;
             break;

             default:
                 snmp_log(LOG_ERR, "couldn't map value %ld for OnlyAllow11nStaAccess\n", raw_OnlyAllow11nStaAccess_val );
                 return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* OnlyAllow11nStaAccess_map */

/**
 * Extract the current value of the OnlyAllow11nStaAccess data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param OnlyAllow11nStaAccess_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
OnlyAllow11nStaAccess_get( dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, u_long * OnlyAllow11nStaAccess_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != OnlyAllow11nStaAccess_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:OnlyAllow11nStaAccess_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the OnlyAllow11nStaAccess data.
 * set (* OnlyAllow11nStaAccess_val_ptr ) from rowreq_ctx->data
 */
    (* OnlyAllow11nStaAccess_val_ptr ) = rowreq_ctx->data.OnlyAllow11nStaAccess;

    return MFD_SUCCESS;
} /* OnlyAllow11nStaAccess_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConfigRadioEntry.radioRole
 * radioRole is subid 28 of dot11ConfigRadioEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.4.3.1.28
 * Description:
The work role of radio.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 4/8. Values:  Clint(1), Other(2), AP(6), Mesh(9)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the radioRole data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param radioRole_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
radioRole_get( dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, u_long * radioRole_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != radioRole_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioRole_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the radioRole data.
 * copy (* radioRole_val_ptr ) from rowreq_ctx->data
 */
    (* radioRole_val_ptr ) = rowreq_ctx->data.radioRole;

    return MFD_SUCCESS;
} /* radioRole_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConfigRadioEntry.radioChanelUsage
 * radioChanelUsage is subid 29 of dot11ConfigRadioEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.4.3.1.29
 * Description:
The usage percentage of radio channel.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the radioChanelUsage data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param radioChanelUsage_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
radioChanelUsage_get( dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, long * radioChanelUsage_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != radioChanelUsage_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioChanelUsage_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the radioChanelUsage data.
 * copy (* radioChanelUsage_val_ptr ) from rowreq_ctx->data
 */
    (* radioChanelUsage_val_ptr ) = rowreq_ctx->data.radioChanelUsage;

    return MFD_SUCCESS;
} /* radioChanelUsage_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConfigRadioEntry.radioChanelChangeNum
 * radioChanelChangeNum is subid 30 of dot11ConfigRadioEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.4.3.1.30
 * Description:
Channel change times.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the radioChanelChangeNum data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param radioChanelChangeNum_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
radioChanelChangeNum_get( dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, long * radioChanelChangeNum_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != radioChanelChangeNum_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioChanelChangeNum_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the radioChanelChangeNum data.
 * copy (* radioChanelChangeNum_val_ptr ) from rowreq_ctx->data
 */
    (* radioChanelChangeNum_val_ptr ) = rowreq_ctx->data.radioChanelChangeNum;

    return MFD_SUCCESS;
} /* radioChanelChangeNum_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConfigRadioEntry.radioChannelWidth
 * radioChannelWidth is subid 31 of dot11ConfigRadioEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.4.3.1.31
 * Description:
Channel width of radio.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the radioChannelWidth data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param radioChannelWidth_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
radioChannelWidth_get( dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, long * radioChannelWidth_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != radioChannelWidth_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioChannelWidth_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the radioChannelWidth data.
 * copy (* radioChannelWidth_val_ptr ) from rowreq_ctx->data
 */
    (* radioChannelWidth_val_ptr ) = rowreq_ctx->data.radioChannelWidth;

    return MFD_SUCCESS;
} /* radioChannelWidth_get */

/*---------------------------------------------------------------------
 * DOT11-WTP-MIB::dot11ConfigRadioEntry.radioNoiseFloor
 * radioNoiseFloor is subid 32 of dot11ConfigRadioEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.1.4.3.1.32
 * Description:
Noise floor of radio.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the radioNoiseFloor data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param radioNoiseFloor_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
radioNoiseFloor_get( dot11ConfigRadioTable_rowreq_ctx *rowreq_ctx, long * radioNoiseFloor_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != radioNoiseFloor_val_ptr );


    DEBUGMSGTL(("verbose:dot11ConfigRadioTable:radioNoiseFloor_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the radioNoiseFloor data.
 * copy (* radioNoiseFloor_val_ptr ) from rowreq_ctx->data
 */
    (* radioNoiseFloor_val_ptr ) = rowreq_ctx->data.radioNoiseFloor;

    return MFD_SUCCESS;
} /* radioNoiseFloor_get */



/** @} */
