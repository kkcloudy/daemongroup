/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.18.2.1 $ of : mfd-data-get.m2c,v $ 
 *
 * $Id:$
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "dot11AcIfCapabilityTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement dot11AcIfCapabilityTable get routines.
 * TODO:240:M: Implement dot11AcIfCapabilityTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table dot11AcIfCapabilityTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * dot11AcIfCapabilityTable is subid 3 of dot11AcInterface.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3, length: 12
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement dot11AcIfCapabilityTable data context functions.
 */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfEntry.ifIndex
 * ifIndex is subid 1 of dot11AcIfEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.2.1.1
 * Description:
Interface index.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-ifIndex.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
ifIndex_map(long *mib_ifIndex_val_ptr, long raw_ifIndex_val)
{
    netsnmp_assert(NULL != mib_ifIndex_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:ifIndex_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement ifIndex mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_ifIndex_val_ptr) = raw_ifIndex_val;

    return MFD_SUCCESS;
} /* ifIndex_map */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
dot11AcIfCapabilityTable_indexes_set_tbl_idx(dot11AcIfCapabilityTable_mib_index *tbl_idx, long ifIndex_val)
{
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:dot11AcIfCapabilityTable_indexes_set_tbl_idx","called\n"));

    /* ifIndex(1)/INTEGER/ASN_INTEGER/long(long)//l/A/w/e/r/d/h */
    tbl_idx->ifIndex = ifIndex_val;
    

    return MFD_SUCCESS;
} /* dot11AcIfCapabilityTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
dot11AcIfCapabilityTable_indexes_set(dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, long ifIndex_val)
{
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:dot11AcIfCapabilityTable_indexes_set","called\n"));

    if(MFD_SUCCESS != dot11AcIfCapabilityTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx
                                   , ifIndex_val
           ))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if(0 != dot11AcIfCapabilityTable_index_to_oid(&rowreq_ctx->oid_idx,
                                    &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* dot11AcIfCapabilityTable_indexes_set */


/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acIfInUcastPkts
 * acIfInUcastPkts is subid 1 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.1
 * Description:
The total number of unicast packets the interface received.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-acIfInUcastPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
acIfInUcastPkts_map(unsigned long long *mib_acIfInUcastPkts_val_ptr, unsigned long long raw_acIfInUcastPkts_val)
{
    netsnmp_assert(NULL != mib_acIfInUcastPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfInUcastPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acIfInUcastPkts_val_ptr) = raw_acIfInUcastPkts_val;

    return MFD_SUCCESS;
} /* acIfInUcastPkts_map */

/**
 * Extract the current value of the acIfInUcastPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acIfInUcastPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
acIfInUcastPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acIfInUcastPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acIfInUcastPkts_val_ptr );
   
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfInUcastPkts_get","called\n"));
   
   netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> copy acIfInUcastPkts data.
 * get (* acIfInUcastPkts_val_ptr ).low and (* acIfInUcastPkts_val_ptr ).high from rowreq_ctx->data
 */
    (* acIfInUcastPkts_val_ptr ) = rowreq_ctx->data.acIfInUcastPkts;


    return MFD_SUCCESS;
} /* acIfInUcastPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acIfInNUcastPkts
 * acIfInNUcastPkts is subid 2 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.2
 * Description:
The total number of non-unicast packets the interface received.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-acIfInNUcastPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
acIfInNUcastPkts_map(unsigned long long *mib_acIfInNUcastPkts_val_ptr, unsigned long long raw_acIfInNUcastPkts_val)
{
    netsnmp_assert(NULL != mib_acIfInNUcastPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfInNUcastPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInNUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acIfInNUcastPkts_val_ptr) = raw_acIfInNUcastPkts_val;

    return MFD_SUCCESS;
} /* acIfInNUcastPkts_map */

/**
 * Extract the current value of the acIfInNUcastPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acIfInNUcastPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
acIfInNUcastPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acIfInNUcastPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acIfInNUcastPkts_val_ptr );
   
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfInNUcastPkts_get","called\n"));
   
   netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> copy acIfInNUcastPkts data.
 * get (* acIfInNUcastPkts_val_ptr ).low and (* acIfInNUcastPkts_val_ptr ).high from rowreq_ctx->data
 */
    (* acIfInNUcastPkts_val_ptr ) = rowreq_ctx->data.acIfInNUcastPkts;


    return MFD_SUCCESS;
} /* acIfInNUcastPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acIfInOctets
 * acIfInOctets is subid 3 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.3
 * Description:
The total number of bytes the interface received.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-acIfInOctets.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
acIfInOctets_map(unsigned long long *mib_acIfInOctets_val_ptr, unsigned long long raw_acIfInOctets_val)
{
    netsnmp_assert(NULL != mib_acIfInOctets_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfInOctets_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInOctets mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acIfInOctets_val_ptr) = raw_acIfInOctets_val;

    return MFD_SUCCESS;
} /* acIfInOctets_map */

/**
 * Extract the current value of the acIfInOctets data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acIfInOctets_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
acIfInOctets_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acIfInOctets_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acIfInOctets_val_ptr );
   
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfInOctets_get","called\n"));
   
   netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> copy acIfInOctets data.
 * get (* acIfInOctets_val_ptr ).low and (* acIfInOctets_val_ptr ).high from rowreq_ctx->data
 */
    (* acIfInOctets_val_ptr ) = rowreq_ctx->data.acIfInOctets;


    return MFD_SUCCESS;
} /* acIfInOctets_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acIfInDiscardPkts
 * acIfInDiscardPkts is subid 4 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.4
 * Description:
The total number of  packets the interface received and discarded.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-acIfInDiscardPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
acIfInDiscardPkts_map(u_long *mib_acIfInDiscardPkts_val_ptr, u_long raw_acIfInDiscardPkts_val)
{
    netsnmp_assert(NULL != mib_acIfInDiscardPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfInDiscardPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInDiscardPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acIfInDiscardPkts_val_ptr) = raw_acIfInDiscardPkts_val;

    return MFD_SUCCESS;
} /* acIfInDiscardPkts_map */

/**
 * Extract the current value of the acIfInDiscardPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acIfInDiscardPkts_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
acIfInDiscardPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, u_long * acIfInDiscardPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acIfInDiscardPkts_val_ptr );


    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfInDiscardPkts_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the acIfInDiscardPkts data.
 * set (* acIfInDiscardPkts_val_ptr ) from rowreq_ctx->data
 */
    (* acIfInDiscardPkts_val_ptr ) = rowreq_ctx->data.acIfInDiscardPkts;

    return MFD_SUCCESS;
} /* acIfInDiscardPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acIfInErrors
 * acIfInErrors is subid 5 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.5
 * Description:
The total number of error packets the interface received.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-acIfInErrors.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
acIfInErrors_map(u_long *mib_acIfInErrors_val_ptr, u_long raw_acIfInErrors_val)
{
    netsnmp_assert(NULL != mib_acIfInErrors_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfInErrors_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInErrors mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acIfInErrors_val_ptr) = raw_acIfInErrors_val;

    return MFD_SUCCESS;
} /* acIfInErrors_map */

/**
 * Extract the current value of the acIfInErrors data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acIfInErrors_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
acIfInErrors_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, u_long * acIfInErrors_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acIfInErrors_val_ptr );


    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfInErrors_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the acIfInErrors data.
 * set (* acIfInErrors_val_ptr ) from rowreq_ctx->data
 */
    (* acIfInErrors_val_ptr ) = rowreq_ctx->data.acIfInErrors;

    return MFD_SUCCESS;
} /* acIfInErrors_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acIfOutUcastPkts
 * acIfOutUcastPkts is subid 6 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.6
 * Description:
The total number of unicast packets the interface transmited.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-acIfOutUcastPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
acIfOutUcastPkts_map(unsigned long long *mib_acIfOutUcastPkts_val_ptr, unsigned long long raw_acIfOutUcastPkts_val)
{
    netsnmp_assert(NULL != mib_acIfOutUcastPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfOutUcastPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfOutUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acIfOutUcastPkts_val_ptr) = raw_acIfOutUcastPkts_val;

    return MFD_SUCCESS;
} /* acIfOutUcastPkts_map */

/**
 * Extract the current value of the acIfOutUcastPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acIfOutUcastPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
acIfOutUcastPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acIfOutUcastPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acIfOutUcastPkts_val_ptr );
   
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfOutUcastPkts_get","called\n"));
   
   netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> copy acIfOutUcastPkts data.
 * get (* acIfOutUcastPkts_val_ptr ).low and (* acIfOutUcastPkts_val_ptr ).high from rowreq_ctx->data
 */
    (* acIfOutUcastPkts_val_ptr ) = rowreq_ctx->data.acIfOutUcastPkts;


    return MFD_SUCCESS;
} /* acIfOutUcastPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acIfOutNUcastPkts
 * acIfOutNUcastPkts is subid 7 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.7
 * Description:
The total number of non-unicast packets the interface transmited.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-acIfOutNUcastPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
acIfOutNUcastPkts_map(unsigned long long *mib_acIfOutNUcastPkts_val_ptr, unsigned long long raw_acIfOutNUcastPkts_val)
{
    netsnmp_assert(NULL != mib_acIfOutNUcastPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfOutNUcastPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfOutNUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acIfOutNUcastPkts_val_ptr) = raw_acIfOutNUcastPkts_val;

    return MFD_SUCCESS;
} /* acIfOutNUcastPkts_map */

/**
 * Extract the current value of the acIfOutNUcastPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acIfOutNUcastPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
acIfOutNUcastPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acIfOutNUcastPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acIfOutNUcastPkts_val_ptr );
   
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfOutNUcastPkts_get","called\n"));
   
   netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> copy acIfOutNUcastPkts data.
 * get (* acIfOutNUcastPkts_val_ptr ).low and (* acIfOutNUcastPkts_val_ptr ).high from rowreq_ctx->data
 */
    (* acIfOutNUcastPkts_val_ptr ) = rowreq_ctx->data.acIfOutNUcastPkts;


    return MFD_SUCCESS;
} /* acIfOutNUcastPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acIfOutOctets
 * acIfOutOctets is subid 8 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.8
 * Description:
The total number of bytes the interface transmited.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-acIfOutOctets.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
acIfOutOctets_map(unsigned long long *mib_acIfOutOctets_val_ptr, unsigned long long raw_acIfOutOctets_val)
{
    netsnmp_assert(NULL != mib_acIfOutOctets_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfOutOctets_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfOutOctets mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acIfOutOctets_val_ptr) = raw_acIfOutOctets_val;

    return MFD_SUCCESS;
} /* acIfOutOctets_map */

/**
 * Extract the current value of the acIfOutOctets data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acIfOutOctets_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
acIfOutOctets_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acIfOutOctets_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acIfOutOctets_val_ptr );
   
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfOutOctets_get","called\n"));
   
   netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> copy acIfOutOctets data.
 * get (* acIfOutOctets_val_ptr ).low and (* acIfOutOctets_val_ptr ).high from rowreq_ctx->data
 */
    (* acIfOutOctets_val_ptr ) = rowreq_ctx->data.acIfOutOctets;


    return MFD_SUCCESS;
} /* acIfOutOctets_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acIfOutDiscardPkts
 * acIfOutDiscardPkts is subid 9 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.9
 * Description:
The total number of  packets the interface transmited and discarded.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-acIfOutDiscardPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
acIfOutDiscardPkts_map(u_long *mib_acIfOutDiscardPkts_val_ptr, u_long raw_acIfOutDiscardPkts_val)
{
    netsnmp_assert(NULL != mib_acIfOutDiscardPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfOutDiscardPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfOutDiscardPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acIfOutDiscardPkts_val_ptr) = raw_acIfOutDiscardPkts_val;

    return MFD_SUCCESS;
} /* acIfOutDiscardPkts_map */

/**
 * Extract the current value of the acIfOutDiscardPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acIfOutDiscardPkts_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
acIfOutDiscardPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, u_long * acIfOutDiscardPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acIfOutDiscardPkts_val_ptr );


    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfOutDiscardPkts_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the acIfOutDiscardPkts data.
 * set (* acIfOutDiscardPkts_val_ptr ) from rowreq_ctx->data
 */
    (* acIfOutDiscardPkts_val_ptr ) = rowreq_ctx->data.acIfOutDiscardPkts;

    return MFD_SUCCESS;
} /* acIfOutDiscardPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acIfOutErrors
 * acIfOutErrors is subid 10 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.10
 * Description:
The total number of error packets the interface transmited.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-acIfOutErrors.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
acIfOutErrors_map(u_long *mib_acIfOutErrors_val_ptr, u_long raw_acIfOutErrors_val)
{
    netsnmp_assert(NULL != mib_acIfOutErrors_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfOutErrors_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfOutErrors mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acIfOutErrors_val_ptr) = raw_acIfOutErrors_val;

    return MFD_SUCCESS;
} /* acIfOutErrors_map */

/**
 * Extract the current value of the acIfOutErrors data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acIfOutErrors_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
acIfOutErrors_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, u_long * acIfOutErrors_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acIfOutErrors_val_ptr );


    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfOutErrors_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the acIfOutErrors data.
 * set (* acIfOutErrors_val_ptr ) from rowreq_ctx->data
 */
    (* acIfOutErrors_val_ptr ) = rowreq_ctx->data.acIfOutErrors;

    return MFD_SUCCESS;
} /* acIfOutErrors_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acIfUpDwnTimes
 * acIfUpDwnTimes is subid 11 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.11
 * Description:
The interface up-down times.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-acIfUpDwnTimes.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
acIfUpDwnTimes_map(u_long *mib_acIfUpDwnTimes_val_ptr, u_long raw_acIfUpDwnTimes_val)
{
    netsnmp_assert(NULL != mib_acIfUpDwnTimes_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfUpDwnTimes_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfUpDwnTimes mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acIfUpDwnTimes_val_ptr) = raw_acIfUpDwnTimes_val;

    return MFD_SUCCESS;
} /* acIfUpDwnTimes_map */

/**
 * Extract the current value of the acIfUpDwnTimes data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acIfUpDwnTimes_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
acIfUpDwnTimes_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, u_long * acIfUpDwnTimes_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acIfUpDwnTimes_val_ptr );


    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfUpDwnTimes_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the acIfUpDwnTimes data.
 * set (* acIfUpDwnTimes_val_ptr ) from rowreq_ctx->data
 */
    (* acIfUpDwnTimes_val_ptr ) = rowreq_ctx->data.acIfUpDwnTimes;

    return MFD_SUCCESS;
} /* acIfUpDwnTimes_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acIfInMulticastPkts
 * acIfInMulticastPkts is subid 12 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.12
 * Description:
Multicast packets received.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-acIfInMulticastPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
acIfInMulticastPkts_map(u_long *mib_acIfInMulticastPkts_val_ptr, u_long raw_acIfInMulticastPkts_val)
{
    netsnmp_assert(NULL != mib_acIfInMulticastPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfInMulticastPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInMulticastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acIfInMulticastPkts_val_ptr) = raw_acIfInMulticastPkts_val;

    return MFD_SUCCESS;
} /* acIfInMulticastPkts_map */

/**
 * Extract the current value of the acIfInMulticastPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acIfInMulticastPkts_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
acIfInMulticastPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, u_long * acIfInMulticastPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acIfInMulticastPkts_val_ptr );


    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfInMulticastPkts_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the acIfInMulticastPkts data.
 * set (* acIfInMulticastPkts_val_ptr ) from rowreq_ctx->data
 */
    (* acIfInMulticastPkts_val_ptr ) = rowreq_ctx->data.acIfInMulticastPkts;

    return MFD_SUCCESS;
} /* acIfInMulticastPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acIfOutMulticastPkts
 * acIfOutMulticastPkts is subid 13 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.13
 * Description:
Multicast packets sent.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-acIfOutMulticastPkts.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
acIfOutMulticastPkts_map(u_long *mib_acIfOutMulticastPkts_val_ptr, u_long raw_acIfOutMulticastPkts_val)
{
    netsnmp_assert(NULL != mib_acIfOutMulticastPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfOutMulticastPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfOutMulticastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acIfOutMulticastPkts_val_ptr) = raw_acIfOutMulticastPkts_val;

    return MFD_SUCCESS;
} /* acIfOutMulticastPkts_map */

/**
 * Extract the current value of the acIfOutMulticastPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acIfOutMulticastPkts_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
acIfOutMulticastPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, u_long * acIfOutMulticastPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acIfOutMulticastPkts_val_ptr );


    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfOutMulticastPkts_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the acIfOutMulticastPkts data.
 * set (* acIfOutMulticastPkts_val_ptr ) from rowreq_ctx->data
 */
    (* acIfOutMulticastPkts_val_ptr ) = rowreq_ctx->data.acIfOutMulticastPkts;

    return MFD_SUCCESS;
} /* acIfOutMulticastPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acUplinkRate
 * acUplinkRate is subid 14 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.14
 * Description:
The  ac uplink rate.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-acUplinkRate.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
acUplinkRate_map(unsigned long long *mib_acUplinkRate_val_ptr, unsigned long long raw_acUplinkRate_val)
{
    netsnmp_assert(NULL != mib_acUplinkRate_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acUplinkRate_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acUplinkRate mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acUplinkRate_val_ptr) = raw_acUplinkRate_val;

    return MFD_SUCCESS;
} /* acUplinkRate_map */

/**
 * Extract the current value of the acUplinkRate data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acUplinkRate_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
acUplinkRate_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acUplinkRate_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acUplinkRate_val_ptr );
   
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acUplinkRate_get","called\n"));
   
   netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> copy acUplinkRate data.
 * get (* acUplinkRate_val_ptr ).low and (* acUplinkRate_val_ptr ).high from rowreq_ctx->data
 */
    (* acUplinkRate_val_ptr ) = rowreq_ctx->data.acUplinkRate;


    return MFD_SUCCESS;
} /* acUplinkRate_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acDownlinkRate
 * acDownlinkRate is subid 15 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.15
 * Description:
The  ac downlink rate.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * map a value from its original native format to the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-acDownlinkRate.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
acDownlinkRate_map(unsigned long long *mib_acDownlinkRate_val_ptr, unsigned long long raw_acDownlinkRate_val)
{
    netsnmp_assert(NULL != mib_acDownlinkRate_val_ptr);
    
    /*
     * TODO:241:o: |-> Implement acDownlinkRate mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acDownlinkRate_val_ptr) = raw_acDownlinkRate_val;

    return MFD_SUCCESS;
} /* acDownlinkRate_map */

/**
 * Extract the current value of the acDownlinkRate data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acDownlinkRate_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
acDownlinkRate_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acDownlinkRate_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acDownlinkRate_val_ptr );
   
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acDownlinkRate_get","called\n"));
   
   netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> copy acDownlinkRate data.
 * get (* acDownlinkRate_val_ptr ).low and (* acDownlinkRate_val_ptr ).high from rowreq_ctx->data
 */
    (* acDownlinkRate_val_ptr ) = rowreq_ctx->data.acDownlinkRate;


    return MFD_SUCCESS;
} /* acDownlinkRate_get */





int
acBandwidthUsage_map(u_long *mib_acBandwidthUsage_val_ptr, u_long raw_acBandwidthUsage_val)
{
    netsnmp_assert(NULL != mib_acBandwidthUsage_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acBandwidthUsage_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInDiscardPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acBandwidthUsage_val_ptr) = raw_acBandwidthUsage_val;

    return MFD_SUCCESS;
} /* acIfInDiscardPkts_map */

int
acBandwidthUsage_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, u_long * acBandwidthUsage_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acBandwidthUsage_val_ptr );


    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acBandwidthUsage_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the acIfInDiscardPkts data.
 * set (* acIfInDiscardPkts_val_ptr ) from rowreq_ctx->data
 */
    (* acBandwidthUsage_val_ptr ) = rowreq_ctx->data.acBandwidthUsage;

    return MFD_SUCCESS;
} /* acIfInDiscardPkts_get */



int
acDropUsage_map(u_long *mib_acDropUsage_val_ptr, u_long raw_acDropUsage_val)
{
    netsnmp_assert(NULL != mib_acDropUsage_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acDropUsage_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInDiscardPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acDropUsage_val_ptr) = raw_acDropUsage_val;

    return MFD_SUCCESS;
} /* acIfInDiscardPkts_map */

int
acDropUsage_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, u_long * acDropUsage_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acDropUsage_val_ptr );


    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acDropUsage_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the acIfInDiscardPkts data.
 * set (* acIfInDiscardPkts_val_ptr ) from rowreq_ctx->data
 */
    (* acDropUsage_val_ptr ) = rowreq_ctx->data.acDropUsage;

    return MFD_SUCCESS;
} /* acIfInDiscardPkts_get */

int
acIfOutBroadcastPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, u_long * acIfOutBroadcastPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acIfOutBroadcastPkts_val_ptr );


    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acIfOutBroadcastPkts_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the acIfInDiscardPkts data.
 * set (* acIfOutBroadcastPkts_val_ptr ) from rowreq_ctx->data
 */
    (* acIfOutBroadcastPkts_val_ptr ) = rowreq_ctx->data.acIfOutBroadcastPkts;

    return MFD_SUCCESS;
} /* acIfOutBroadcastPkts_get */

int
acUplinkKbyteRate_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, u_long * acUplinkKbyteRate_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acUplinkKbyteRate_val_ptr );


    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acUplinkKbyteRate_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the acIfInDiscardPkts data.
 * set (* acUplinkKbyteRate_val_ptr ) from rowreq_ctx->data
 */
    (* acUplinkKbyteRate_val_ptr ) = rowreq_ctx->data.acUplinkKbyteRate;

    return MFD_SUCCESS;
} /* acUplinkKbyteRate_get */

int
acDownlinkKbyteRate_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, u_long * acDownlinkKbyteRate_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acDownlinkKbyteRate_val_ptr );


    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acDownlinkKbyteRate_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the acIfInDiscardPkts data.
 * set (* acDownlinkKbyteRate_val_ptr ) from rowreq_ctx->data
 */
    (* acDownlinkKbyteRate_val_ptr ) = rowreq_ctx->data.acDownlinkKbyteRate;

    return MFD_SUCCESS;
} /* acDownlinkKbyteRate_get */

int
acipv6IfInReceivesPkts_map(unsigned long long *mib_acipv6IfInReceivesPkts_val_ptr, unsigned long long raw_acipv6IfInReceivesPkts_val)
{
    netsnmp_assert(NULL != mib_acipv6IfInReceivesPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfInReceivesPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acipv6IfInReceivesPkts_val_ptr) = raw_acipv6IfInReceivesPkts_val;

    return MFD_SUCCESS;
}
int
acipv6IfInReceivesPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acipv6IfInReceivesPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acipv6IfInReceivesPkts_val_ptr );
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfInReceivesPkts_get","called\n"));
/*
 * TODO:231:o: |-> copy acipv6IfInReceivesPkts data.
 * get (* acipv6IfInReceivesPkts_val_ptr ).low and (* acipv6IfInReceivesPkts_val_ptr ).high from rowreq_ctx->data
 */
    (* acipv6IfInReceivesPkts_val_ptr ) = rowreq_ctx->data.acipv6IfInReceivesPkts;
    

    return MFD_SUCCESS;
} /* acipv6IfInReceivesPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acipv6IfInHdrErrorsPkts
 * acipv6IfInHdrErrorsPkts is subid 22 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.22
 * Description:
The total number of ipv6 packets the interface ready to throw away.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the acipv6IfInHdrErrorsPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acipv6IfInHdrErrorsPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */

int
acipv6IfInHdrErrorsPkts_map(unsigned long long *mib_acipv6IfInHdrErrorsPkts_val_ptr, unsigned long long raw_acipv6IfInHdrErrorsPkts_val)
{
    netsnmp_assert(NULL != mib_acipv6IfInHdrErrorsPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfInHdrErrorsPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acipv6IfInHdrErrorsPkts_val_ptr) = raw_acipv6IfInHdrErrorsPkts_val;

    return MFD_SUCCESS;
}
int
acipv6IfInHdrErrorsPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acipv6IfInHdrErrorsPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acipv6IfInHdrErrorsPkts_val_ptr );



   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfInHdrErrorsPkts_get","called\n"));
/*
 * TODO:231:o: |-> copy acipv6IfInHdrErrorsPkts data.
 * get (* acipv6IfInHdrErrorsPkts_val_ptr ).low and (* acipv6IfInHdrErrorsPkts_val_ptr ).high from rowreq_ctx->data
 */
    (* acipv6IfInHdrErrorsPkts_val_ptr )= rowreq_ctx->data.acipv6IfInHdrErrorsPkts;
    


    return MFD_SUCCESS;
} /* acipv6IfInHdrErrorsPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acipv6IfInTooBigErrorsPkts
 * acipv6IfInTooBigErrorsPkts is subid 23 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.23
 * Description:
The total number of ipv6 packets those of too big to forward.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the acipv6IfInTooBigErrorsPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acipv6IfInTooBigErrorsPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */

int
acipv6IfInTooBigErrorsPkts_map(unsigned long long *mib_acipv6IfInTooBigErrorsPkts_val_ptr, unsigned long long raw_acipv6IfInTooBigErrorsPkts_val)
{
    netsnmp_assert(NULL != mib_acipv6IfInTooBigErrorsPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfInTooBigErrorsPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acipv6IfInTooBigErrorsPkts_val_ptr) = raw_acipv6IfInTooBigErrorsPkts_val;

    return MFD_SUCCESS;
}
int
acipv6IfInTooBigErrorsPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acipv6IfInTooBigErrorsPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acipv6IfInTooBigErrorsPkts_val_ptr );
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfInTooBigErrorsPkts_get","called\n"));
/*
 * TODO:231:o: |-> copy acipv6IfInTooBigErrorsPkts data.
 * get (* acipv6IfInTooBigErrorsPkts_val_ptr ).low and (* acipv6IfInTooBigErrorsPkts_val_ptr ).high from rowreq_ctx->data
 */
    (* acipv6IfInTooBigErrorsPkts_val_ptr ) = rowreq_ctx->data.acipv6IfInTooBigErrorsPkts;
    


    return MFD_SUCCESS;
} /* acipv6IfInTooBigErrorsPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acipv6IfInNoRoutesPkts
 * acipv6IfInNoRoutesPkts is subid 24 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.24
 * Description:
The total number of ipv6 packets those of no routing and discarded.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the acipv6IfInNoRoutesPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acipv6IfInNoRoutesPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */

int
acipv6IfInNoRoutesPkts_map(unsigned long long *mib_acipv6IfInNoRoutesPkts_val_ptr, unsigned long long raw_acipv6IfInNoRoutesPkts_val)
{
    netsnmp_assert(NULL != mib_acipv6IfInNoRoutesPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfInNoRoutesPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acipv6IfInNoRoutesPkts_val_ptr) = raw_acipv6IfInNoRoutesPkts_val;

    return MFD_SUCCESS;
}
int
acipv6IfInNoRoutesPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acipv6IfInNoRoutesPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acipv6IfInNoRoutesPkts_val_ptr );
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfInNoRoutesPkts_get","called\n"));
/*
 * TODO:231:o: |-> copy acipv6IfInNoRoutesPkts data.
 * get (* acipv6IfInNoRoutesPkts_val_ptr ).low and (* acipv6IfInNoRoutesPkts_val_ptr ).high from rowreq_ctx->data
 */
    (* acipv6IfInNoRoutesPkts_val_ptr )= rowreq_ctx->data.acipv6IfInNoRoutesPkts;
    


    return MFD_SUCCESS;
} /* acipv6IfInNoRoutesPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acipv6IfInAddrErrorsPkts
 * acipv6IfInAddrErrorsPkts is subid 25 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.25
 * Description:
The total number of ipv6 packets due to the input of IPv6 address illegal .
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the acipv6IfInAddrErrorsPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acipv6IfInAddrErrorsPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */

int
acipv6IfInAddrErrorsPkts_map(unsigned long long *mib_acipv6IfInAddrErrorsPkts_val_ptr, unsigned long long raw_acipv6IfInAddrErrorsPkts_val)
{
    netsnmp_assert(NULL != mib_acipv6IfInAddrErrorsPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfInAddrErrorsPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acipv6IfInAddrErrorsPkts_val_ptr) = raw_acipv6IfInAddrErrorsPkts_val;

    return MFD_SUCCESS;
}
int
acipv6IfInAddrErrorsPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acipv6IfInAddrErrorsPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acipv6IfInAddrErrorsPkts_val_ptr );
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfInAddrErrorsPkts_get","called\n"));
/*
 * TODO:231:o: |-> copy acipv6IfInAddrErrorsPkts data.
 * get (* acipv6IfInAddrErrorsPkts_val_ptr ).low and (* acipv6IfInAddrErrorsPkts_val_ptr ).high from rowreq_ctx->data
 */
    (* acipv6IfInAddrErrorsPkts_val_ptr ) = rowreq_ctx->data.acipv6IfInAddrErrorsPkts;
    


    return MFD_SUCCESS;
} /* acipv6IfInAddrErrorsPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acipv6IfInUnknownProtosPkts
 * acipv6IfInUnknownProtosPkts is subid 26 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.26
 * Description:
The total number of ipv6 packets due to unknown or does not support agreement .
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the acipv6IfInUnknownProtosPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acipv6IfInUnknownProtosPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */

int
acipv6IfInUnknownProtosPkts_map(unsigned long long *mib_acipv6IfInUnknownProtosPkts_val_ptr, unsigned long long raw_acipv6IfInUnknownProtosPkts_val)
{
    netsnmp_assert(NULL != mib_acipv6IfInUnknownProtosPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfInUnknownProtosPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acipv6IfInUnknownProtosPkts_val_ptr) = raw_acipv6IfInUnknownProtosPkts_val;

    return MFD_SUCCESS;
}
int
acipv6IfInUnknownProtosPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acipv6IfInUnknownProtosPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acipv6IfInUnknownProtosPkts_val_ptr );
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfInUnknownProtosPkts_get","called\n"));
/*
 * TODO:231:o: |-> copy acipv6IfInUnknownProtosPkts data.
 * get (* acipv6IfInUnknownProtosPkts_val_ptr ).low and (* acipv6IfInUnknownProtosPkts_val_ptr ).high from rowreq_ctx->data
 */
    (* acipv6IfInUnknownProtosPkts_val_ptr ) = rowreq_ctx->data.acipv6IfInUnknownProtosPkts;
    


    return MFD_SUCCESS;
} /* acipv6IfInUnknownProtosPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acipv6IfInTruncatedPkts
 * acipv6IfInTruncatedPkts is subid 27 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.27
 * Description:
The total number of ipv6 packets due to the incomplete data .
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the acipv6IfInTruncatedPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acipv6IfInTruncatedPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */

int
acipv6IfInTruncatedPkts_map(unsigned long long *mib_acipv6IfInTruncatedPkts_val_ptr, unsigned long long raw_acipv6IfInTruncatedPkts_val)
{
    netsnmp_assert(NULL != mib_acipv6IfInTruncatedPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfInTruncatedPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acipv6IfInTruncatedPkts_val_ptr) = raw_acipv6IfInTruncatedPkts_val;

    return MFD_SUCCESS;
}
int
acipv6IfInTruncatedPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acipv6IfInTruncatedPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acipv6IfInTruncatedPkts_val_ptr );
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfInTruncatedPkts_get","called\n"));
/*
 * TODO:231:o: |-> copy acipv6IfInTruncatedPkts data.
 * get (* acipv6IfInTruncatedPkts_val_ptr ).low and (* acipv6IfInTruncatedPkts_val_ptr ).high from rowreq_ctx->data
 */
    (* acipv6IfInTruncatedPkts_val_ptr ) = rowreq_ctx->data.acipv6IfInTruncatedPkts;
    


    return MFD_SUCCESS;
} /* acipv6IfInTruncatedPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acipv6IfInDiscardsPkts
 * acipv6IfInDiscardsPkts is subid 28 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.28
 * Description:
The total number of ipv6 packets unable to continue processing .
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the acipv6IfInDiscardsPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acipv6IfInDiscardsPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */

int
acipv6IfInDiscardsPkts_map(unsigned long long *mib_acipv6IfInDiscardsPkts_val_ptr, unsigned long long raw_acipv6IfInDiscardsPkts_val)
{
    netsnmp_assert(NULL != mib_acipv6IfInDiscardsPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfInDiscardsPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acipv6IfInDiscardsPkts_val_ptr) = raw_acipv6IfInDiscardsPkts_val;

    return MFD_SUCCESS;
}
int
acipv6IfInDiscardsPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acipv6IfInDiscardsPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acipv6IfInDiscardsPkts_val_ptr );
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfInDiscardsPkts_get","called\n"));
/*
 * TODO:231:o: |-> copy acipv6IfInDiscardsPkts data.
 * get (* acipv6IfInDiscardsPkts_val_ptr ).low and (* acipv6IfInDiscardsPkts_val_ptr ).high from rowreq_ctx->data
 */
    (* acipv6IfInDiscardsPkts_val_ptr ) = rowreq_ctx->data.acipv6IfInDiscardsPkts;
    


    return MFD_SUCCESS;
} /* acipv6IfInDiscardsPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acipv6IfInDeliversPkts
 * acipv6IfInDeliversPkts is subid 29 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.29
 * Description:
The total number of ipv6 packets all ipv6 user agreement sent successfully .
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the acipv6IfInDeliversPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acipv6IfInDeliversPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */

int
acipv6IfInDeliversPkts_map(unsigned long long *mib_acipv6IfInDeliversPkts_val_ptr, unsigned long long raw_acipv6IfInDeliversPkts_val)
{
    netsnmp_assert(NULL != mib_acipv6IfInDeliversPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfInDeliversPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acipv6IfInDeliversPkts_val_ptr) = raw_acipv6IfInDeliversPkts_val;

    return MFD_SUCCESS;
}
int
acipv6IfInDeliversPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acipv6IfInDeliversPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acipv6IfInDeliversPkts_val_ptr );
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfInDeliversPkts_get","called\n"));
/*
 * TODO:231:o: |-> copy acipv6IfInDeliversPkts data.
 * get (* acipv6IfInDeliversPkts_val_ptr ).low and (* acipv6IfInDeliversPkts_val_ptr ).high from rowreq_ctx->data
 */
    (* acipv6IfInDeliversPkts_val_ptr ) = rowreq_ctx->data.acipv6IfInDeliversPkts;
    


    return MFD_SUCCESS;
} /* acipv6IfInDeliversPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acipv6IfOutForwDatagramsPkts
 * acipv6IfOutForwDatagramsPkts is subid 30 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.30
 * Description:
The total number of ipv6 packets those received and forwarded to the final node successfully .
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the acipv6IfOutForwDatagramsPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acipv6IfOutForwDatagramsPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */

int
acipv6IfOutForwDatagramsPkts_map(unsigned long long *mib_acipv6IfOutForwDatagramsPkts_val_ptr, unsigned long long raw_acipv6IfOutForwDatagramsPkts_val)
{
    netsnmp_assert(NULL != mib_acipv6IfOutForwDatagramsPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfOutForwDatagramsPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acipv6IfOutForwDatagramsPkts_val_ptr) = raw_acipv6IfOutForwDatagramsPkts_val;

    return MFD_SUCCESS;
}
int
acipv6IfOutForwDatagramsPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acipv6IfOutForwDatagramsPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acipv6IfOutForwDatagramsPkts_val_ptr );
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfOutForwDatagramsPkts_get","called\n"));
/*
 * TODO:231:o: |-> copy acipv6IfOutForwDatagramsPkts data.
 * get (* acipv6IfOutForwDatagramsPkts_val_ptr ).low and (* acipv6IfOutForwDatagramsPkts_val_ptr ).high from rowreq_ctx->data
 */
    (* acipv6IfOutForwDatagramsPkts_val_ptr ) = rowreq_ctx->data.acipv6IfOutForwDatagramsPkts;
    


    return MFD_SUCCESS;
} /* acipv6IfOutForwDatagramsPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acipv6IfOutRequestsPkts
 * acipv6IfOutRequestsPkts is subid 31 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.31
 * Description:
Transport requirements of the local IPv6 all user agreement output message number .
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the acipv6IfOutRequestsPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acipv6IfOutRequestsPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */

int
acipv6IfOutRequestsPkts_map(unsigned long long *mib_acipv6IfOutRequestsPkts_val_ptr, unsigned long long raw_acipv6IfOutRequestsPkts_val)
{
    netsnmp_assert(NULL != mib_acipv6IfOutRequestsPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfOutRequestsPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acipv6IfOutRequestsPkts_val_ptr) = raw_acipv6IfOutRequestsPkts_val;

    return MFD_SUCCESS;
}
int
acipv6IfOutRequestsPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acipv6IfOutRequestsPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acipv6IfOutRequestsPkts_val_ptr );
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfOutRequestsPkts_get","called\n"));
/*
 * TODO:231:o: |-> copy acipv6IfOutRequestsPkts data.
 * get (* acipv6IfOutRequestsPkts_val_ptr ).low and (* acipv6IfOutRequestsPkts_val_ptr ).high from rowreq_ctx->data
 */
    (* acipv6IfOutRequestsPkts_val_ptr ) = rowreq_ctx->data.acipv6IfOutRequestsPkts;
    


    return MFD_SUCCESS;
} /* acipv6IfOutRequestsPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acipv6IfOutDiscardsPkts
 * acipv6IfOutDiscardsPkts is subid 32 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.32
 * Description:
Due to be continue to transmit discarded IPv6 output message number .
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the acipv6IfOutDiscardsPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acipv6IfOutDiscardsPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */

int
acipv6IfOutDiscardsPkts_map(unsigned long long *mib_acipv6IfOutDiscardsPkts_val_ptr, unsigned long long raw_acipv6IfOutDiscardsPkts_val)
{
    netsnmp_assert(NULL != mib_acipv6IfOutDiscardsPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfOutDiscardsPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acipv6IfOutDiscardsPkts_val_ptr) = raw_acipv6IfOutDiscardsPkts_val;

    return MFD_SUCCESS;
}
int
acipv6IfOutDiscardsPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acipv6IfOutDiscardsPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acipv6IfOutDiscardsPkts_val_ptr );
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfOutDiscardsPkts_get","called\n"));
/*
 * TODO:231:o: |-> copy acipv6IfOutDiscardsPkts data.
 * get (* acipv6IfOutDiscardsPkts_val_ptr ).low and (* acipv6IfOutDiscardsPkts_val_ptr ).high from rowreq_ctx->data
 */
    (* acipv6IfOutDiscardsPkts_val_ptr ) = rowreq_ctx->data.acipv6IfOutDiscardsPkts;
    


    return MFD_SUCCESS;
} /* acipv6IfOutDiscardsPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acipv6IfOutFragOKsPkts
 * acipv6IfOutFragOKsPkts is subid 33 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.33
 * Description:
Output interface successful shard of IPv6 output message number .
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the acipv6IfOutFragOKsPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acipv6IfOutFragOKsPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */

int
acipv6IfOutFragOKsPkts_map(unsigned long long *mib_acipv6IfOutFragOKsPkts_val_ptr, unsigned long long raw_acipv6IfOutFragOKsPkts_val)
{
    netsnmp_assert(NULL != mib_acipv6IfOutFragOKsPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfOutFragOKsPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acipv6IfOutFragOKsPkts_val_ptr) = raw_acipv6IfOutFragOKsPkts_val;

    return MFD_SUCCESS;
}
int
acipv6IfOutFragOKsPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acipv6IfOutFragOKsPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acipv6IfOutFragOKsPkts_val_ptr );
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfOutFragOKsPkts_get","called\n"));
/*
 * TODO:231:o: |-> copy acipv6IfOutFragOKsPkts data.
 * get (* acipv6IfOutFragOKsPkts_val_ptr ).low and (* acipv6IfOutFragOKsPkts_val_ptr ).high from rowreq_ctx->data
 */
    (* acipv6IfOutFragOKsPkts_val_ptr ) = rowreq_ctx->data.acipv6IfOutFragOKsPkts;
    


    return MFD_SUCCESS;
} /* acipv6IfOutFragOKsPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acipv6IfOutFragFailsPkts
 * acipv6IfOutFragFailsPkts is subid 34 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.34
 * Description:
Due to the output interface to fragmentation and number of IPv6 packet is discarded .
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the acipv6IfOutFragFailsPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acipv6IfOutFragFailsPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */

int
acipv6IfOutFragFailsPkts_map(unsigned long long *mib_acipv6IfOutFragFailsPkts_val_ptr, unsigned long long raw_acipv6IfOutFragFailsPkts_val)
{
    netsnmp_assert(NULL != mib_acipv6IfOutFragFailsPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfOutFragFailsPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acipv6IfOutFragFailsPkts_val_ptr) = raw_acipv6IfOutFragFailsPkts_val;

    return MFD_SUCCESS;
}
int
acipv6IfOutFragFailsPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acipv6IfOutFragFailsPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acipv6IfOutFragFailsPkts_val_ptr );
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfOutFragFailsPkts_get","called\n"));
/*
 * TODO:231:o: |-> copy acipv6IfOutFragFailsPkts data.
 * get (* acipv6IfOutFragFailsPkts_val_ptr ).low and (* acipv6IfOutFragFailsPkts_val_ptr ).high from rowreq_ctx->data
 */
    (* acipv6IfOutFragFailsPkts_val_ptr ) = rowreq_ctx->data.acipv6IfOutFragFailsPkts;
    


    return MFD_SUCCESS;
} /* acipv6IfOutFragFailsPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acipv6IfOutFragCreatesPkts
 * acipv6IfOutFragCreatesPkts is subid 35 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.35
 * Description:
Output interface based on fragmentation results of IPv6 packet fragmentation .
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the acipv6IfOutFragCreatesPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acipv6IfOutFragCreatesPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */


int
acipv6IfOutFragCreatesPkts_map(unsigned long long *mib_acipv6IfOutFragCreatesPkts_val_ptr, unsigned long long raw_acipv6IfOutFragCreatesPkts_val)
{
    netsnmp_assert(NULL != mib_acipv6IfOutFragCreatesPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfOutFragCreatesPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acipv6IfOutFragCreatesPkts_val_ptr) = raw_acipv6IfOutFragCreatesPkts_val;

    return MFD_SUCCESS;
}
int
acipv6IfOutFragCreatesPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acipv6IfOutFragCreatesPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acipv6IfOutFragCreatesPkts_val_ptr );
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfOutFragCreatesPkts_get","called\n"));
/*
 * TODO:231:o: |-> copy acipv6IfOutFragCreatesPkts data.
 * get (* acipv6IfOutFragCreatesPkts_val_ptr ).low and (* acipv6IfOutFragCreatesPkts_val_ptr ).high from rowreq_ctx->data
 */
    (* acipv6IfOutFragCreatesPkts_val_ptr ) = rowreq_ctx->data.acipv6IfOutFragCreatesPkts;
    


    return MFD_SUCCESS;
} /* acipv6IfOutFragCreatesPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acipv6IfReasmReqdsPkts
 * acipv6IfReasmReqdsPkts is subid 36 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.36
 * Description:
IPv6 subdivision number of interfaces need to restructure .
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the acipv6IfReasmReqdsPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acipv6IfReasmReqdsPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */

int
acipv6IfReasmReqdsPkts_map(unsigned long long *mib_acipv6IfReasmReqdsPkts_val_ptr, unsigned long long raw_acipv6IfReasmReqdsPkts_val)
{
    netsnmp_assert(NULL != mib_acipv6IfReasmReqdsPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfReasmReqdsPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acipv6IfReasmReqdsPkts_val_ptr) = raw_acipv6IfReasmReqdsPkts_val;

    return MFD_SUCCESS;
}
int
acipv6IfReasmReqdsPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acipv6IfReasmReqdsPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acipv6IfReasmReqdsPkts_val_ptr );
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfReasmReqdsPkts_get","called\n"));
/*
 * TODO:231:o: |-> copy acipv6IfReasmReqdsPkts data.
 * get (* acipv6IfReasmReqdsPkts_val_ptr ).low and (* acipv6IfReasmReqdsPkts_val_ptr ).high from rowreq_ctx->data
 */
    (* acipv6IfReasmReqdsPkts_val_ptr ) = rowreq_ctx->data.acipv6IfReasmReqdsPkts;
    


    return MFD_SUCCESS;
} /* acipv6IfReasmReqdsPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acipv6IfReasmOKsPkts
 * acipv6IfReasmOKsPkts is subid 37 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.37
 * Description:
Successful restructuring of IPv6 packet number .
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the acipv6IfReasmOKsPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acipv6IfReasmOKsPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */

int
acipv6IfReasmOKsPkts_map(unsigned long long *mib_acipv6IfReasmOKsPkts_val_ptr, unsigned long long raw_acipv6IfReasmOKsPkts_val)
{
    netsnmp_assert(NULL != mib_acipv6IfReasmOKsPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfReasmOKsPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acipv6IfReasmOKsPkts_val_ptr) = raw_acipv6IfReasmOKsPkts_val;

    return MFD_SUCCESS;
}
int
acipv6IfReasmOKsPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acipv6IfReasmOKsPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acipv6IfReasmOKsPkts_val_ptr );
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfReasmOKsPkts_get","called\n"));
/*
 * TODO:231:o: |-> copy acipv6IfReasmOKsPkts data.
 * get (* acipv6IfReasmOKsPkts_val_ptr ).low and (* acipv6IfReasmOKsPkts_val_ptr ).high from rowreq_ctx->data
 */
    (* acipv6IfReasmOKsPkts_val_ptr ) = rowreq_ctx->data.acipv6IfReasmOKsPkts;
    


    return MFD_SUCCESS;
} /* acipv6IfReasmOKsPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acipv6IfReasmFailsPkts
 * acipv6IfReasmFailsPkts is subid 38 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.38
 * Description:
Due to the failure of fragmentation of IPv6 reorganization algorithm .
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the acipv6IfReasmFailsPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acipv6IfReasmFailsPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */

int
acipv6IfReasmFailsPkts_map(unsigned long long *mib_acipv6IfReasmFailsPkts_val_ptr, unsigned long long raw_acipv6IfReasmFailsPkts_val)
{
    netsnmp_assert(NULL != mib_acipv6IfReasmFailsPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfReasmFailsPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acipv6IfReasmFailsPkts_val_ptr) = raw_acipv6IfReasmFailsPkts_val;

    return MFD_SUCCESS;
}
int
acipv6IfReasmFailsPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acipv6IfReasmFailsPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acipv6IfReasmFailsPkts_val_ptr );
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfReasmFailsPkts_get","called\n"));
/*
 * TODO:231:o: |-> copy acipv6IfReasmFailsPkts data.
 * get (* acipv6IfReasmFailsPkts_val_ptr ).low and (* acipv6IfReasmFailsPkts_val_ptr ).high from rowreq_ctx->data
 */
    (* acipv6IfReasmFailsPkts_val_ptr ) = rowreq_ctx->data.acipv6IfReasmFailsPkts;
    


    return MFD_SUCCESS;
} /* acipv6IfReasmFailsPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acipv6IfInMcastPkts
 * acipv6IfInMcastPkts is subid 39 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.39
 * Description:
Interface receives the IPv6 multicast packets .
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the acipv6IfInMcastPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acipv6IfInMcastPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */

int
acipv6IfInMcastPkts_map(unsigned long long *mib_acipv6IfInMcastPkts_val_ptr, unsigned long long raw_acipv6IfInMcastPkts_val)
{
    netsnmp_assert(NULL != mib_acipv6IfInMcastPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfInMcastPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acipv6IfInMcastPkts_val_ptr) = raw_acipv6IfInMcastPkts_val;

    return MFD_SUCCESS;
}
int
acipv6IfInMcastPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acipv6IfInMcastPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acipv6IfInMcastPkts_val_ptr );
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfInMcastPkts_get","called\n"));
/*
 * TODO:231:o: |-> copy acipv6IfInMcastPkts data.
 * get (* acipv6IfInMcastPkts_val_ptr ).low and (* acipv6IfInMcastPkts_val_ptr ).high from rowreq_ctx->data
 */
    (* acipv6IfInMcastPkts_val_ptr ) = rowreq_ctx->data.acipv6IfInMcastPkts;
    


    return MFD_SUCCESS;
} /* acipv6IfInMcastPkts_get */

/*---------------------------------------------------------------------
 * DOT11-AC-MIB::dot11AcIfCapabilityEntry.acipv6IfOutMcastPkts
 * acipv6IfOutMcastPkts is subid 40 of dot11AcIfCapabilityEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3.1.40
 * Description:
Interface transmit IPv6 multicast packets .
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the acipv6IfOutMcastPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param acipv6IfOutMcastPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */

int
acipv6IfOutMcastPkts_map(unsigned long long *mib_acipv6IfOutMcastPkts_val_ptr, unsigned long long raw_acipv6IfOutMcastPkts_val)
{
    netsnmp_assert(NULL != mib_acipv6IfOutMcastPkts_val_ptr);
    
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfOutMcastPkts_map","called\n"));
    
    /*
     * TODO:241:o: |-> Implement acIfInUcastPkts mapping.
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    (*mib_acipv6IfOutMcastPkts_val_ptr) = raw_acipv6IfOutMcastPkts_val;

    return MFD_SUCCESS;
}
int
acipv6IfOutMcastPkts_get( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx, unsigned long long * acipv6IfOutMcastPkts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != acipv6IfOutMcastPkts_val_ptr );
   DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:acipv6IfOutMcastPkts_get","called\n"));
/*
 * TODO:231:o: |-> copy acipv6IfOutMcastPkts data.
 * get (* acipv6IfOutMcastPkts_val_ptr ).low and (* acipv6IfOutMcastPkts_val_ptr ).high from rowreq_ctx->data
 */
    (* acipv6IfOutMcastPkts_val_ptr ) = rowreq_ctx->data.acipv6IfOutMcastPkts;
    


    return MFD_SUCCESS;
} /* acipv6IfOutMcastPkts_get */

/** @} */
