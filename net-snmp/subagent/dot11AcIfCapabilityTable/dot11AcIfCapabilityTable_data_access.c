/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.12 $ of : mfd-data-access.m2c,v $ 
 *
 * $Id:$
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "dot11AcIfCapabilityTable.h"


#include "dot11AcIfCapabilityTable_data_access.h"
#include <fcntl.h>
#include "../mibs_public.h"
#include "ws_dbus_def.h"
#include "ws_init_dbus.h"
#include "ws_intf.h"
#include "board/board_define.h"
#include "ac_manage_def.h"
#include "ws_snmpd_engine.h"
#include "ws_snmpd_manual.h"
#include "ac_manage_interface.h"


/** @defgroup data_access data_access: Routines to access data
 *
 * These routines are used to locate the data used to satisfy
 * requests.
 * 
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table dot11AcIfCapabilityTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * dot11AcIfCapabilityTable is subid 3 of dot11AcInterface.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.31656.6.1.2.4.3, length: 12
*/

/**
 * initialization for dot11AcIfCapabilityTable data access
 *
 * This function is called during startup to allow you to
 * allocate any resources you need for the data table.
 *
 * @param dot11AcIfCapabilityTable_reg
 *        Pointer to dot11AcIfCapabilityTable_registration
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : unrecoverable error.
 */

static DBusConnection *active_slot_connection = NULL;


#if 0
struct nucastpkts_list{
    unsigned int tx_multicast;
    unsigned int tx_broadcast;

    char ifname[IFNAME_SIZE];

    struct nucastpkts_list *next;
};

static void
free_interface_nucastpkts_list(struct nucastpkts_list **list) {
    if(NULL == list || NULL == *list)
        return ;

    struct nucastpkts_list *tempHead = *list;
    while(tempHead) {
        struct nucastpkts_list *tempNode = tempHead->next;
        free(tempHead);
        tempHead = tempNode;
    }
    *list = NULL;

    return ;
}

static int
get_interface_nucastpkts_list(struct nucastpkts_list **list) {
    if(NULL == list) 
        return -1;

    *list = NULL;
    struct nucastpkts_list *tempHead = NULL;
    
    char buf[512] = { 0 };
    FILE *fp = NULL;
    fp = fopen("/proc/octeon_ethernet_stats", "r");
    if(NULL == fp) {
        return -1;
    }
    
	while(fgets(buf, sizeof(buf), fp) != NULL) {
	
	    fgets(buf, sizeof(buf), fp);        
        char ifname[IFNAME_SIZE] = { 0 };
		sscanf(buf, "%*[^(](%[^)])", ifname);
        
        int i = 0;
        for(i = 0; i < 10; i ++) {
            fgets(buf, sizeof(buf), fp);
        }
        
        unsigned int tx_multicast = 0;
        unsigned int tx_broadcast = 0;
        fgets(buf, sizeof(buf), fp);
		sscanf(buf, "%*[^:]: %lu %*[^:]: %lu", &tx_multicast, &tx_broadcast);

        struct nucastpkts_list *temp_node = (struct nucastpkts_list *)malloc(sizeof(struct nucastpkts_list));
        if(NULL == temp_node){
            free_interface_nucastpkts_list(&tempHead);
            return -1;
        }

        memcpy(temp_node->ifname, ifname, sizeof(temp_node->ifname));
        temp_node->tx_multicast = tx_multicast;
        temp_node->tx_broadcast = tx_broadcast;
        temp_node->next = tempHead;

        tempHead = temp_node;
    }

    fclose(fp);
    *list = tempHead;
    return 0;
}

static DBusConnection *
mib_dbus_get_tipc_connection(unsigned int slot_id)
{  
	if(0 == slot_id || slot_id > SLOT_MAX_NUM)
	{
		syslog(LOG_DEBUG, "mib_dbus_get_tipc_connection fun error: the slot_id is %d\n",slot_id);
		return NULL;
	}
	
	DBusError dbus_error;
	DBusConnection *tempConnection = NULL;
	char temp_dbus_name[60] = { 0 };
	
	dbus_error_init (&dbus_error);
	
	tempConnection = dbus_bus_get_remote(DBUS_BUS_SYSTEM, slot_id, &dbus_error);
	if(NULL == tempConnection)
	{
		dbus_error_free(&dbus_error);
		addresses_shutdown_func();
		syslog(LOG_DEBUG, "The slot %d remote server is not ready.\n", slot_id);
		return NULL;
	}
	
	snprintf(temp_dbus_name, sizeof(temp_dbus_name) - 1, "aw.mib.slot%d", slot_id);
	dbus_bus_request_name(tempConnection, temp_dbus_name, 0, &dbus_error);
	if (dbus_error_is_set(&dbus_error)) 
	{
		syslog(LOG_DEBUG, "request name failed: %s\n", dbus_error.message);
		dbus_error_free(&dbus_error);
		return NULL;
	}
	
	syslog(LOG_DEBUG, "The tipc connection %s of slot %d is OK\n", temp_dbus_name, slot_id);
	return tempConnection;
		
}

void 
mib_close_dbus_connection(DBusConnection **connection)
{
	if(NULL == connection || NULL == *connection || ccgi_dbus_connection == *connection)
		return;

	dbus_connection_close(*connection);
	*connection = NULL;

	return;
}
#endif

static int 
get_product_info(char *filename)
{
	int fd;
	char buff[16] = {0};
	unsigned int data;

	if(NULL == filename) {
		return -1;
	}

    fd = open(filename, O_RDONLY, 0);
    if(fd >= 0) {
        if(read(fd, buff, 16) < 0) {
            snmp_log(LOG_WARNING, "get_product_info: Read error : no value\n");
            close(fd);
            return 0;
        }    
    }
    else {        
        snmp_log(LOG_WARNING, "get_product_info: Open file:%s error!\n", filename);
        return 0;
    }
    
    data = strtoul(buff, NULL, 10);

    close(fd);
    
	return data;
}

static unsigned int 
snmp_get_board_state(void) {
	FILE *fp = NULL;
	char temp_buf[64] = { 0 };
	unsigned int board_on_mask = 0, board_state = 0;

	if(VALID_DBM_FLAG == get_dbm_effective_flag())
	{
		fp = fopen(BOARD_MASK_FILE, "r");
	}
	if(NULL == fp){
		snmp_log(LOG_WARNING, "Open BOARD_MASK_FILE error\n");
		return 0;
	}
	
	if(fscanf(fp, "%u", &board_on_mask) <= 0) {
		fclose(fp);
		snmp_log(LOG_WARNING, "Fscanf BOARD_MASK_FILE error\n");
		return 0;
	}

	snmp_log(LOG_DEBUG, "The broad_on_mask is %d\n", board_on_mask);
	fclose(fp);

	int i = 0;
	for(; i < SLOT_MAX_NUM; i++) {
		if(board_on_mask & (0x1 << i)) {
			fp = NULL;
			unsigned int temp_state = 0;

			if(VALID_DBM_FLAG == get_dbm_effective_flag())
			{
				memset(temp_buf, 0, sizeof(temp_buf));
				sprintf(temp_buf, "/dbm/product/slot/slot%d/board_state", i + 1);
				fp = fopen(temp_buf, "r");
				if(fp) {
					fscanf(fp, "%d", &temp_state);
					fclose(fp);
					
					if(temp_state > 1) {
						board_state |= (0x1 << i);
					}
				}
			}
		}
	}

	return board_state;
}


static manage_message *
snmp_get_slot_interface_info(unsigned int slot_id) {
	manage_message *query = NULL, *reply = NULL;
	manage_session *session = snmp_get_tipc_session();
	if(NULL == session) {
		return NULL;
	}

	manage_tipc_addr_group addr_group;	
	memset(&addr_group, 0, sizeof(manage_tipc_addr_group));
	addr_group.dest.type = MANAGE_TIPC_TYPE;	/*tipc*/
	addr_group.dest.instance = 0x1000 + slot_id;		/*slot id*/
	
	memcpy(&(addr_group.sour), session->local, sizeof(manage_tipc_addr));
	
	query = manage_message_new(AC_MANAGE_TASK_METHOD_INTERFACE_INFO, 
									NULL, 0);
	snmp_log(LOG_DEBUG, "after manage_message_new: slot %d query = %p\n", slot_id, query);
	
	reply = manage_message_send_with_reply_and_block(session, query, -1, &addr_group, sizeof(manage_tipc_addr_group));
	snmp_log(LOG_DEBUG, "after manage_message_send_with_reply_and_block: slot %d reply = %p\n", slot_id, reply);

	MANAGE_FREE(query);
	return reply;
}


static struct if_stats_list *
snmp_search_interface_stats(struct if_stats_list *if_array, unsigned int if_num, const char *ifname) {
	if(NULL == if_array || NULL == ifname) {
		return NULL;
	}
	
	int i = 0;
	for(; i < if_num; i++) {
		if(0 == strcmp(if_array[i].ifname, ifname)) {
			return &if_array[i];
		}
	}

	return NULL;
}


static void
snmp_accumulate_interface_stats(struct if_stats_list *destNode, struct if_stats_list *sourNode) {
    if(NULL == destNode || NULL == sourNode) {
        return ;
    }

    destNode->stats.rx_packets           += sourNode->stats.rx_packets;
    destNode->stats.tx_packets           += sourNode->stats.tx_packets;
    destNode->stats.rx_bytes             += sourNode->stats.rx_bytes;
    destNode->stats.tx_bytes             += sourNode->stats.tx_bytes;
    destNode->stats.rx_errors            += sourNode->stats.rx_errors;
    destNode->stats.tx_errors            += sourNode->stats.tx_errors;
    destNode->stats.rx_dropped           += sourNode->stats.rx_dropped;
    destNode->stats.tx_dropped           += sourNode->stats.tx_dropped;
    destNode->stats.rx_multicast         += sourNode->stats.rx_multicast;
    destNode->stats.tx_multicast         += sourNode->stats.tx_multicast;
    destNode->stats.rx_compressed        += sourNode->stats.rx_compressed;
    destNode->stats.tx_compressed        += sourNode->stats.tx_compressed;
    destNode->stats.collisions           += sourNode->stats.collisions;

    
    /* detailed rx_errors: */
    destNode->stats.rx_length_errors     += sourNode->stats.rx_length_errors;
    destNode->stats.rx_over_errors       += sourNode->stats.rx_over_errors;
    destNode->stats.rx_crc_errors        += sourNode->stats.rx_crc_errors;
    destNode->stats.rx_frame_errors      += sourNode->stats.rx_frame_errors;
    destNode->stats.rx_fifo_errors       += sourNode->stats.rx_fifo_errors;
    destNode->stats.rx_missed_errors     += sourNode->stats.rx_missed_errors;

    
    /* detailed tx_errors */
    destNode->stats.tx_aborted_errors    += sourNode->stats.tx_aborted_errors;
    destNode->stats.tx_carrier_errors    += sourNode->stats.tx_carrier_errors;
    destNode->stats.tx_fifo_errors       += sourNode->stats.tx_fifo_errors;
    destNode->stats.tx_heartbeat_errors  += sourNode->stats.tx_heartbeat_errors;
    destNode->stats.tx_window_errors     += sourNode->stats.tx_window_errors;
    
    return ;
}


int
dot11AcIfCapabilityTable_init_data(dot11AcIfCapabilityTable_registration_ptr dot11AcIfCapabilityTable_reg)
{
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:dot11AcIfCapabilityTable_init_data","called\n"));

    /*
     * TODO:303:o: Initialize dot11AcIfCapabilityTable data.
     */
    /*
    ***************************************************
    ***             START EXAMPLE CODE              ***
    ***---------------------------------------------***/
    /*
     * if you are the sole writer for the file, you could
     * open it here. However, as stated earlier, we are assuming
     * the worst case, which in this case means that the file is
     * written to by someone else, and might not even exist when
     * we start up. So we can't do anything here.
     */
    /*
    ***---------------------------------------------***
    ***              END  EXAMPLE CODE              ***
    ***************************************************/

    return MFD_SUCCESS;
} /* dot11AcIfCapabilityTable_init_data */

/**
 * container-cached overview
 *
 */

/***********************************************************************
 *
 * cache
 *
 ***********************************************************************/
/**
 * container initialization
 *
 * @param container_ptr_ptr A pointer to a container pointer. If you
 *        create a custom container, use this parameter to return it
 *        to the MFD helper. If set to NULL, the MFD helper will
 *        allocate a container for you.
 * @param  cache A pointer to a cache structure. You can set the timeout
 *         and other cache flags using this pointer.
 *
 *  This function is called at startup to allow you to customize certain
 *  aspects of the access method. For the most part, it is for advanced
 *  users. The default code should suffice for most cases. If no custom
 *  container is allocated, the MFD code will create one for your.
 *
 *  This is also the place to set up cache behavior. The default, to
 *  simply set the cache timeout, will work well with the default
 *  container. If you are using a custom container, you may want to
 *  look at the cache helper documentation to see if there are any
 *  flags you want to set.
 *
 * @remark
 *  This would also be a good place to do any initialization needed
 *  for you data source. For example, opening a connection to another
 *  process that will supply the data, opening a database, etc.
 */
void
dot11AcIfCapabilityTable_container_init(netsnmp_container **container_ptr_ptr,
                        netsnmp_cache *cache)
{
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:dot11AcIfCapabilityTable_container_init","called\n"));
    
    if((NULL == cache) || (NULL == container_ptr_ptr)) {
        snmp_log(LOG_ERR,"bad params to dot11AcIfCapabilityTable_container_init\n");
        return;
    }

    /*
     * For advanced users, you can use a custom container. If you
     * do not create one, one will be created for you.
     */
    *container_ptr_ptr = NULL;

    /*
     * TODO:345:A: Set up dot11AcIfCapabilityTable cache properties.
     *
     * Also for advanced users, you can set parameters for the
     * cache. Do not change the magic pointer, as it is used
     * by the MFD helper. To completely disable caching, set
     * cache->enabled to 0.
     */
    cache->timeout = DOT11ACIFCAPABILITYTABLE_CACHE_TIMEOUT; /* seconds */
} /* dot11AcIfCapabilityTable_container_init */

/**
 * load cache data
 *
 * TODO:350:M: Implement dot11AcIfCapabilityTable cache load
 *
 * @param container container to which items should be inserted
 *
 * @retval MFD_SUCCESS              : success.
 * @retval MFD_RESOURCE_UNAVAILABLE : Can't access data source
 * @retval MFD_ERROR                : other error.
 *
 *  This function is called to cache the index(es) (and data, optionally)
 *  for the every row in the data set.
 *
 * @remark
 *  While loading the cache, the only important thing is the indexes.
 *  If access to your data is cheap/fast (e.g. you have a pointer to a
 *  structure in memory), it would make sense to update the data here.
 *  If, however, the accessing the data invovles more work (e.g. parsing
 *  some other existing data, or peforming calculations to derive the data),
 *  then you can limit yourself to setting the indexes and saving any
 *  information you will need later. Then use the saved information in
 *  dot11AcIfCapabilityTable_row_prep() for populating data.
 *
 * @note
 *  If you need consistency between rows (like you want statistics
 *  for each row to be from the same time frame), you should set all
 *  data here.
 *
 */
int
dot11AcIfCapabilityTable_cache_load(netsnmp_container *container)
{
	
	snmp_log(LOG_DEBUG, "enter dot11AcIfCapabilityTable_cache_load\n");
	
    dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx;
    size_t                 count = 0;
    
    /*
     * this example code is based on a data source that is a
     * text file to be read and parsed.
     */
    //FILE *filep;
    //char line[MAX_LINE_SIZE];
    /*
     * temporary storage for index values
     */
        /*
         * ifIndex(1)/INTEGER/ASN_INTEGER/long(long)//l/A/w/e/r/d/h
         */
   long   ifIndex = 0;

    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:dot11AcIfCapabilityTable_cache_load","called\n"));

    /*
    ***************************************************
    ***             START EXAMPLE CODE              ***
    ***---------------------------------------------***/
    /*
     * open our data file.
     */
    //filep = fopen("/etc/dummy.conf", "r");
    //if(NULL ==  filep) {
      //  return MFD_RESOURCE_UNAVAILABLE;
    //}

    /*
    ***---------------------------------------------***
    ***              END  EXAMPLE CODE              ***
    ***************************************************/
    /*
     * TODO:351:M: |-> Load/update data in the dot11AcIfCapabilityTable container.
     * loop over your dot11AcIfCapabilityTable data, allocate a rowreq context,
     * set the index(es) [and data, optionally] and insert into
     * the container.
     */

	
	unsigned int if_num = 0;
	struct if_stats_list *if_stats_array = NULL;

	int i, j;
	unsigned int local_slotid= 0, board_state = 0;

	manage_message *reply= NULL;
	manage_message *reply_array[SLOT_MAX_NUM];

	memset(reply_array, 0, sizeof(reply_array));

	if(VALID_DBM_FLAG == get_dbm_effective_flag())
	{
		local_slotid = get_product_info(PRODUCT_LOCAL_SLOTID);
	}
	if(0 == local_slotid || local_slotid > SLOT_MAX_NUM) {
		snmp_log(LOG_WARNING, "do_sample_interface_flow: get local slot id failed!\n");
		return MFD_SUCCESS;
	}

	reply = snmp_get_slot_interface_info(local_slotid);
	if(reply) {
		if_num = reply->data_length / sizeof(struct if_stats_list);
		if(reply->data_length == if_num * sizeof(struct if_stats_list)) {
			if_stats_array = (void *)reply + sizeof(manage_message);
			reply_array[local_slotid - 1] = reply;
		} else {
			snmp_log(LOG_WARNING, "the packet is error\n");
			SNMP_FREE(reply);
			return MFD_SUCCESS;
		}
	} else{
		snmp_log(LOG_WARNING, "dot11AcIfCapabilityTable_cache_load: interface info get fail\n");
		return MFD_SUCCESS;
	}
	
	board_state = snmp_get_board_state();

	for(i = 0; i < SLOT_MAX_NUM; i++) {
		if(((i + 1) != local_slotid) && (board_state & (0x1 << i))) {
			reply = snmp_get_slot_interface_info(i + 1);
			if(reply) {
				unsigned int temp_num = reply->data_length / sizeof(struct if_stats_list);
				if(reply->data_length == temp_num * sizeof(struct if_stats_list)) {
					struct if_stats_list *temp_array = (void *)reply + sizeof(manage_message);
					for(j = 0; j < temp_num; j++) {
						struct if_stats_list *tempDest = snmp_search_interface_stats(if_stats_array, if_num, temp_array[j].ifname);
						if(NULL == tempDest) {
							continue;
						}
						snmp_accumulate_interface_stats(tempDest, &temp_array[j]);	
						snmp_log(LOG_DEBUG, "temp_array[%d].ifname = %s, tempDest->ifname = %s, tempDest->stats.tx_bytes = %llu", 
										j, temp_array[j].ifname, tempDest->ifname, tempDest->stats.tx_bytes);
					}

					reply_array[i] = reply;
				} else {
					snmp_log(LOG_WARNING, "the packet is error\n");
					SNMP_FREE(reply);
					continue;
				}
			}
		}
	}
	
    int mib_ret = AC_MANAGE_SUCCESS;
    struct mib_acif_stats *acif_array = NULL;
    unsigned int acif_num = 0;
    mib_ret = ac_manage_show_mib_acif_stats(ccgi_dbus_connection, &acif_array, &acif_num);
    snmp_log(LOG_DEBUG, "exit ac_manage_show_mib_acif_stats, mib_ret = %d\n", mib_ret);
        
    int ret = -1;
    struct flow_data_list *alldata = NULL;

    snmp_log(LOG_DEBUG, "enter dbus_get_iface_bandwidth_info\n");
    ret = dbus_get_iface_bandwidth_info(ccgi_dbus_connection, &alldata);
    snmp_log(LOG_DEBUG, "exit dbus_get_iface_bandwidth_info, ret = %d\n", ret);

#if 0
    int ret1 = 0;
    struct nucastpkts_list *listHead = NULL;
    snmp_log(LOG_DEBUG, "enter get_interface_nucastpkts_list\n");
    ret1 = get_interface_nucastpkts_list(&listHead);
    snmp_log(LOG_DEBUG, "exit get_interface_nucastpkts_list, ret = %d\n", ret1);
#endif

#if 0    
    unsigned int if_stats_num = 0;
    struct if_stats_list *if_stats_array = NULL;
    int stats_ret = show_acif_accumulate_stats(active_slot_connection, local_slotid, &if_stats_array, &if_stats_num);
#endif

    if(if_stats_array && if_num) {
        for(i = 0; i < if_num; i++) {
        
#if 0    
	struct if_stats temp = {0};
	
	FILE *fp = NULL;
	
	char buf[1024] = {0};
	char buftemp[50] = {0};
	char name[30] = {0};
	fp = fopen ("/proc/net/dev", "r");
	if (fp == NULL)
	{
		return MFD_RESOURCE_UNAVAILABLE;
	}
	
	fgets (buf, 1024, fp);
	fgets (buf, 1024, fp);
	
	

	while(fgets (buf, 1024, fp) != NULL)
	{
		memset(name, 0 , sizeof(name));
		memset(buftemp, 0, sizeof(buftemp));
		
		sscanf(buf,
		   "%[^:]:%llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu %llu",
		   buftemp,
		   &temp.rx_bytes,
		   &temp.rx_packets,
		   &temp.rx_errors,
		   &temp.rx_dropped,
		   &temp.rx_fifo_errors,
		   &temp.rx_frame_errors,
		   &temp.rx_compressed,
		   &temp.rx_multicast,
		
		   &temp.tx_bytes,
		   &temp.tx_packets,
		   &temp.tx_errors,
		   &temp.tx_dropped,
		   &temp.tx_fifo_errors,
		   &temp.collisions,
		   &temp.tx_carrier_errors,
		   &temp.tx_compressed,
		   &temp.tx_multicast);
		sscanf(buftemp,"%s",name);

		if(strncmp(name,"r",1)==0 
		|| strncmp(name,"pimreg",6)==0 
		|| strncmp(name,"sit0",4)==0)
		{
			continue;
		}
#endif

            if(0 != get_if_index(if_stats_array[i].ifname, &ifIndex)) {
                snmp_log(LOG_WARNING, "get if index error\n");
                continue;
            }
        
            unsigned long rxsample = 0;
            unsigned long txsample = 0;
        
            if(0 == ret && alldata){
                struct flow_data_list *tempz = NULL;
                for(tempz = alldata; NULL != tempz; tempz = tempz->next) {
                    snmp_log(LOG_DEBUG, "(tempz->ltdata.rtdata.index = %d) VS (ifIndex = %d)\n", tempz->ltdata.rtdata.index, ifIndex);
                    if(tempz->ltdata.rtdata.index == ifIndex) {
                        rxsample = tempz->ltdata.rxsample;
                        txsample = tempz->ltdata.txsample;
                        break;
                    }
                }
            }
		
            rowreq_ctx = dot11AcIfCapabilityTable_allocate_rowreq_ctx();
            if (NULL == rowreq_ctx) {
                snmp_log(LOG_ERR, "memory allocation failed\n");
                intflib_memfree(&alldata);
                SNMP_FREE(acif_array);
			for(i = 0; i < SLOT_MAX_NUM; i++) {
				SNMP_FREE(reply_array[i]);
			}               
			//SNMP_FREE(if_stats_array);
                //fclose(fp);			    
                //free_interface_nucastpkts_list(&listHead);
                return MFD_RESOURCE_UNAVAILABLE;
            }
            if(MFD_SUCCESS != dot11AcIfCapabilityTable_indexes_set(rowreq_ctx
                                   , ifIndex
                   )) {
                snmp_log(LOG_ERR,"error setting index while loading "
                         "dot11AcIfCapabilityTable cache.\n");
                dot11AcIfCapabilityTable_release_rowreq_ctx(rowreq_ctx);
                continue;
            }

	        /*
	         * TODO:352:r: |   |-> populate dot11AcIfCapabilityTable data context.
	         * Populate data context here. (optionally, delay until row prep)
	         */
	    /*
	     * TRANSIENT or semi-TRANSIENT data:
	     * copy data or save any info needed to do it in row_prep.
	     */
	    /*
	     * setup/save data for acIfInUcastPkts
	     * acIfInUcastPkts(1)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h
	     */
	    /*
	     * TODO:246:r: |-> Define acIfInUcastPkts mapping.
	     * Map values between raw/native values and MIB values
	     *
	     * Integer based value can usually just do a direct copy.
	     */
	    rowreq_ctx->data.acIfInUcastPkts = if_stats_array[i].stats.rx_packets;	/*单播包*/
	    
	    /*
	     * setup/save data for acIfInNUcastPkts
	     * acIfInNUcastPkts(2)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h
	     */
	    /*
	     * TODO:246:r: |-> Define acIfInNUcastPkts mapping.
	     * Map values between raw/native values and MIB values
	     *
	     * Integer based value can usually just do a direct copy.
	     */
	    //rowreq_ctx->data.acIfInNUcastPkts = tempz->ltdata.rtdata.rx.multicast; /*非单播包*/
	    rowreq_ctx->data.acIfInNUcastPkts = if_stats_array[i].stats.rx_multicast; /*非单播包*/
	    /*
	     * setup/save data for acIfInOctets
	     * acIfInOctets(3)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h
	     */
	    /*
	     * TODO:246:r: |-> Define acIfInOctets mapping.
	     * Map values between raw/native values and MIB values
	     *
	     * Integer based value can usually just do a direct copy.
	     */
	    //rowreq_ctx->data.acIfInOctets = tempz->ltdata.rtdata.rx.bytes;  /*总字节数*/
	    rowreq_ctx->data.acIfInOctets = if_stats_array[i].stats.rx_bytes;  /*总字节数*/
	    /*
	     * setup/save data for acIfInDiscardPkts
	     * acIfInDiscardPkts(4)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
	     */
	    /*
	     * TODO:246:r: |-> Define acIfInDiscardPkts mapping.
	     * Map values between raw/native values and MIB values
	     *
	     * Integer based value can usually just do a direct copy.
	     */
	    //rowreq_ctx->data.acIfInDiscardPkts = tempz->ltdata.rtdata.rx.dropped; /*丢弃包数*/
	    rowreq_ctx->data.acIfInDiscardPkts = if_stats_array[i].stats.rx_dropped; /*丢弃包数*/
	    /*
	     * setup/save data for acIfInErrors
	     * acIfInErrors(5)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
	     */
	    /*
	     * TODO:246:r: |-> Define acIfInErrors mapping.
	     * Map values between raw/native values and MIB values
	     *
	     * Integer based value can usually just do a direct copy.
	     */
	    //rowreq_ctx->data.acIfInErrors = tempz->ltdata.rtdata.rx.errors;  /*错误包数*/
	    rowreq_ctx->data.acIfInErrors = if_stats_array[i].stats.rx_errors;  /*错误包数*/
	    /*
	     * setup/save data for acIfOutUcastPkts
	     * acIfOutUcastPkts(6)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h
	     */
	    /*
	     * TODO:246:r: |-> Define acIfOutUcastPkts mapping.
	     * Map values between raw/native values and MIB values
	     *
	     * Integer based value can usually just do a direct copy.
	     */
	    //rowreq_ctx->data.acIfOutUcastPkts = tempz->ltdata.rtdata.tx.packets;/*单播包*/
	    rowreq_ctx->data.acIfOutUcastPkts = if_stats_array[i].stats.tx_packets;/*单播包*/
	    /*
	     * setup/save data for acIfOutNUcastPkts
	     * acIfOutNUcastPkts(7)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h
	     */
	    /*
	     * TODO:246:r: |-> Define acIfOutNUcastPkts mapping.
	     * Map values between raw/native values and MIB values
	     *
	     * Integer based value can usually just do a direct copy.
	     */
	    //rowreq_ctx->data.acIfOutNUcastPkts = tempz->ltdata.rtdata.tx.multicast;  /*非单播包*/
#if 0	    
        unsigned int acIfOutMulticastPkts = 0;
        if(0 == ret1) {
            struct nucastpkts_list *listNode = NULL;
            for(listNode = listHead; NULL != listNode; listNode = listNode->next) {
                snmp_log(LOG_DEBUG, "listNode->ifname = %s, name = %s\n",listNode->ifname, name);
                if(0 == strcmp(listNode->ifname, name)) {
                    snmp_log(LOG_DEBUG, "listNode->tx_multicast = %d\n",listNode->tx_multicast);
                    acIfOutMulticastPkts = listNode->tx_multicast;
                    break;
                }
            }
        }
#endif        
	    rowreq_ctx->data.acIfOutNUcastPkts = if_stats_array[i].stats.tx_multicast;  /*非单播包*/
		
	    /*
	     * setup/save data for acIfOutOctets
	     * acIfOutOctets(8)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h
	     */
	    /*
	     * TODO:246:r: |-> Define acIfOutOctets mapping.
	     * Map values between raw/native values and MIB values
	     *
	     * Integer based value can usually just do a direct copy.
	     */
	    //rowreq_ctx->data.acIfOutOctets = tempz->ltdata.rtdata.tx.bytes;  /*总字节数*/
	    rowreq_ctx->data.acIfOutOctets = if_stats_array[i].stats.tx_bytes;  /*总字节数*/
	    /*
	     * setup/save data for acIfOutDiscardPkts
	     * acIfOutDiscardPkts(9)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
	     */
	    /*
	     * TODO:246:r: |-> Define acIfOutDiscardPkts mapping.
	     * Map values between raw/native values and MIB values
	     *
	     * Integer based value can usually just do a direct copy.
	     */
	    //rowreq_ctx->data.acIfOutDiscardPkts = tempz->ltdata.rtdata.tx.dropped;  /*丢弃包数*/
	    rowreq_ctx->data.acIfOutDiscardPkts = if_stats_array[i].stats.tx_dropped;  /*丢弃包数*/
	    /*
	     * setup/save data for acIfOutErrors
	     * acIfOutErrors(10)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
	     */
	    /*
	     * TODO:246:r: |-> Define acIfOutErrors mapping.
	     * Map values between raw/native values and MIB values
	     *
	     * Integer based value can usually just do a direct copy.
	     */
	    //rowreq_ctx->data.acIfOutErrors = tempz->ltdata.rtdata.tx.errors;  /*错误包数*/
	    rowreq_ctx->data.acIfOutErrors = if_stats_array[i].stats.tx_errors;  /*错误包数*/
	    /*
	     * setup/save data for acIfUpDwnTimes
	     * acIfUpDwnTimes(11)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
	     */
	    /*
	     * TODO:246:r: |-> Define acIfUpDwnTimes mapping.
	     * Map values between raw/native values and MIB values
	     *
	     * Integer based value can usually just do a direct copy.
	     */
	    rowreq_ctx->data.acIfUpDwnTimes = 0;  /*updown次数*/
	    
	    /*
	     * setup/save data for acIfInMulticastPkts
	     * acIfInMulticastPkts(12)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
	     */
	    /*
	     * TODO:246:r: |-> Define acIfInMulticastPkts mapping.
	     * Map values between raw/native values and MIB values
	     *
	     * Integer based value can usually just do a direct copy.
	     */
	    //rowreq_ctx->data.acIfInMulticastPkts = tempz->ltdata.rtdata.rx.multicast;  /*接收组播包数*/
	    rowreq_ctx->data.acIfInMulticastPkts = if_stats_array[i].stats.rx_multicast;  /*接收组播包数*/
	    
	    /*
	     * setup/save data for acIfOutMulticastPkts
	     * acIfOutMulticastPkts(13)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
	     */
	    /*
	     * TODO:246:r: |-> Define acIfOutMulticastPkts mapping.
	     * Map values between raw/native values and MIB values
	     *
	     * Integer based value can usually just do a direct copy.
	     */
	    //rowreq_ctx->data.acIfOutMulticastPkts = tempz->ltdata.rtdata.tx.multicast;  /*发送组播包数*/
	    rowreq_ctx->data.acIfOutMulticastPkts = if_stats_array[i].stats.tx_multicast;  /*发送组播包数*/
	    /*
	     * setup/save data for acUplinkRate
	     * acUplinkRate(14)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h
	     */
	    /*
	     * TODO:246:r: |-> Define acUplinkRate mapping.
	     * Map values between raw/native values and MIB values
	     *
	     * Integer based value can usually just do a direct copy.
	     */
	    rowreq_ctx->data.acUplinkRate = rxsample;
	    
	    /*
	     * setup/save data for acDownlinkRate
	     * acDownlinkRate(15)/COUNTER64/ASN_COUNTER64/U64(U64)//l/A/w/e/r/d/h
	     */
	    /*
	     * TODO:246:r: |-> Define acDownlinkRate mapping.
	     * Map values between raw/native values and MIB values
	     *
	     * Integer based value can usually just do a direct copy.
	     */
	     
            rowreq_ctx->data.acDownlinkRate = txsample;


            rowreq_ctx->data.acBandwidthUsage = (((rxsample)+(txsample))*8*100)/(1000*1024*1024);

		unsigned long DropUsage = 0;
		unsigned long long total_packets = if_stats_array[i].stats.rx_packets + if_stats_array[i].stats.tx_packets 
									+ if_stats_array[i].stats.rx_dropped + if_stats_array[i].stats.tx_dropped;

            if(total_packets) {
			DropUsage = (if_stats_array[i].stats.rx_dropped + if_stats_array[i].stats.tx_dropped) * 100 / total_packets ;
            }

            rowreq_ctx->data.acDropUsage = DropUsage;

            rowreq_ctx->data.acIfOutBroadcastPkts =  if_stats_array[i].stats.tx_multicast;

            rowreq_ctx->data.acUplinkKbyteRate = rxsample / 1024;

            rowreq_ctx->data.acDownlinkKbyteRate = txsample / 1024;
  
            
            if(AC_MANAGE_SUCCESS == mib_ret && acif_num) {
                int index = 0;
                for(index = 0; index < acif_num; index++) {
                    snmp_log(LOG_DEBUG, "acif_array[%d].ifname %s, name = %s\n", index, acif_array[index].ifname, if_stats_array[i].ifname);
                    if(0 == strcmp(acif_array[index].ifname, if_stats_array[i].ifname)) {
                        MANUAL_SET(rowreq_ctx->data.acIfInNUcastPkts, acif_array[index].acIfInNUcastPkts);
                        MANUAL_SET(rowreq_ctx->data.acIfInDiscardPkts, acif_array[index].acIfInDiscardPkts);
                        MANUAL_SET(rowreq_ctx->data.acIfInErrors, acif_array[index].acIfInErrors);
                        MANUAL_SET(rowreq_ctx->data.acIfInMulticastPkts, acif_array[index].acIfInMulticastPkts);
                        MANUAL_SET(rowreq_ctx->data.acIfOutDiscardPkts, acif_array[index].acIfOutDiscardPkts);
                        MANUAL_SET(rowreq_ctx->data.acIfOutErrors, acif_array[index].acIfOutErrors);
                        MANUAL_SET(rowreq_ctx->data.acIfOutNUcastPkts, acif_array[index].acIfOutNUcastPkts);
                        MANUAL_SET(rowreq_ctx->data.acIfOutMulticastPkts, acif_array[index].acIfOutMulticastPkts);

						total_packets = 0;	
						DropUsage = 0;
						total_packets = rowreq_ctx->data.acIfInDiscardPkts + rowreq_ctx->data.acIfOutDiscardPkts 
															+ if_stats_array[i].stats.rx_packets + if_stats_array[i].stats.tx_packets;
						if(total_packets) {
							DropUsage = (unsigned long long)(rowreq_ctx->data.acIfInDiscardPkts + rowreq_ctx->data.acIfOutDiscardPkts) * 100 / total_packets;
			            }
						MANUAL_SET(rowreq_ctx->data.acDropUsage, DropUsage);
                        break;
                    }
                }
            }
            
	        /*
	         * insert into table container
	         */
            if(CONTAINER_INSERT(container, rowreq_ctx)) {
                dot11AcIfCapabilityTable_release_rowreq_ctx(rowreq_ctx);
            }
            ++count;	   		
        }
    }

	intflib_memfree(&alldata);
	SNMP_FREE(acif_array);
	for(i = 0; i < SLOT_MAX_NUM; i++) {
		SNMP_FREE(reply_array[i]);
	}     
	
    //SNMP_FREE(if_stats_array);
    //fclose(fp);
    //free_interface_nucastpkts_list(&listHead);

    DEBUGMSGT(("verbose:dot11AcIfCapabilityTable:dot11AcIfCapabilityTable_cache_load",
               "inserted %d records\n", count));
	
    snmp_log(LOG_DEBUG, "exit dot11AcIfCapabilityTable_cache_load\n");
    return MFD_SUCCESS;
} /* dot11AcIfCapabilityTable_cache_load */

/**
 * cache clean up
 *
 * @param container container with all current items
 *
 *  This optional callback is called prior to all
 *  item's being removed from the container. If you
 *  need to do any processing before that, do it here.
 *
 * @note
 *  The MFD helper will take care of releasing all the row contexts.
 *
 */
void
dot11AcIfCapabilityTable_cache_free(netsnmp_container *container)
{
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:dot11AcIfCapabilityTable_cache_free","called\n"));

    /*
     * TODO:380:M: Free dot11AcIfCapabilityTable cache.
     */
} /* dot11AcIfCapabilityTable_cache_free */

/**
 * prepare row for processing.
 *
 *  When the agent has located the row for a request, this function is
 *  called to prepare the row for processing. If you fully populated
 *  the data context during the index setup phase, you may not need to
 *  do anything.
 *
 * @param rowreq_ctx pointer to a context.
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 */
int
dot11AcIfCapabilityTable_row_prep( dot11AcIfCapabilityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:dot11AcIfCapabilityTable:dot11AcIfCapabilityTable_row_prep","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:390:o: Prepare row for request.
     * If populating row data was delayed, this is the place to
     * fill in the row for this request.
     */

    return MFD_SUCCESS;
} /* dot11AcIfCapabilityTable_row_prep */

/** @} */
